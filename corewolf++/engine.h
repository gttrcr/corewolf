#pragma once

#include <iostream>
#include <string>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <netdb.h>
#include <sys/uio.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <fstream>
#include <vector>
#include <algorithm>
#include <thread>

namespace corewolf
{
    class engine
    {
        friend std::ostream &operator<<(std::ostream &os, const corewolf::engine *en);
        friend std::ostream &operator<<(std::ostream &os, const corewolf::engine en);

    private:
        const unsigned int _port = 1642;
        const std::string server_ip = "127.0.1.1";
        unsigned int _client_sid;
        std::string _text;
        static corewolf::engine *_instance;
        std::vector<std::string> _defined_functions;
        std::vector<std::string> _valid_names;

        void _valid_name(std::string &name)
        {
            static const unsigned int len = 6;
            static const char alphanum[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
            if (name == "")
            {
                name.clear();
                name.reserve(len);
                for (unsigned int i = 0; i < len; ++i)
                    name += alphanum[rand() % (sizeof(alphanum) - 1)];
            }

            _valid_names.push_back(name);
        }

        engine()
        {
            if (std::system("python3 ./wlserver.py &") < 0)
                ;
            std::this_thread::sleep_for(std::chrono::milliseconds(2000));

            // setup a socket and connection tools
            struct hostent *host = gethostbyname(server_ip.c_str());
            sockaddr_in sendSockAddr;
            bzero((char *)&sendSockAddr, sizeof(sendSockAddr));
            sendSockAddr.sin_family = AF_INET;
            sendSockAddr.sin_addr.s_addr = inet_addr(inet_ntoa(*(struct in_addr *)*host->h_addr_list));

            sendSockAddr.sin_port = htons(_port);
            _client_sid = socket(AF_INET, SOCK_STREAM, 0);
            int status = connect(_client_sid, (sockaddr *)&sendSockAddr, sizeof(sendSockAddr));
            if (status < 0)
                std::cout << "Error connecting to socket!" << std::endl;
            else
                std::cout << "Connected to the server!" << std::endl;
        }

        static std::string _print_vector(const std::vector<std::string> &v)
        {
            std::string ret;
            for (unsigned int i = 0; i < v.size(); i++)
                ret += v[i] + (i == v.size() - 1 ? "" : ",");
            return ret;
        }

    public:
        static corewolf::engine *get()
        {
            if (_instance == nullptr)
                _instance = new corewolf::engine();
            return _instance;
        }

        corewolf::engine *execute(const std::string &input, std::string name = "")
        {
            char msg[131072];
            memset(&msg, 0, sizeof(msg));
            _valid_name(name);
            std::string command = name + "=(" + input + ")";
            strcpy(msg, command.c_str());

            int bytes_read = 0;
            int bytes_written = 0;
            bytes_written += send(_client_sid, (char *)&msg, strlen(msg), 0);
            memset(&msg, 0, sizeof(msg));
            bytes_read += recv(_client_sid, (char *)&msg, sizeof(msg), 0);
            _text = msg;
            return this;
        }

        void define(const std::string &input)
        {
            if (std::find(_defined_functions.begin(), _defined_functions.end(), input) == _defined_functions.end())
                _defined_functions.push_back(input);
            this->execute(input);
        }

        void terminate()
        {
            close(_client_sid);
            _instance = nullptr;
        }

        ///< summary>
        /// returns a filled triangle with angles α and β and side length a, where a is adjacent to one angle only.
        /// https://reference.wolfram.com/language/ref/AASTriangle.html
        ///</summary>
        corewolf::engine *AASTriangle(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AASTriangle[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates an interrupt to abort a computation.
        /// https://reference.wolfram.com/language/ref/Abort.html
        ///</summary>
        corewolf::engine *Abort(const std::string &name = "")
        {
            return this->execute("Abort[]", name);
        }

        ///< summary>
        /// aborts evaluations running in all parallel subkernels.
        /// https://reference.wolfram.com/language/ref/AbortKernels.html
        ///</summary>
        corewolf::engine *AbortKernels(const std::string &name = "")
        {
            return this->execute("AbortKernels[]", name);
        }

        ///< summary>
        /// evaluates expr, saving any aborts until the evaluation is complete.
        /// https://reference.wolfram.com/language/ref/AbortProtect.html
        ///</summary>
        corewolf::engine *AbortProtect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AbortProtect[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the absolute value of the real or complex number z.
        /// https://reference.wolfram.com/language/ref/Abs.html
        ///</summary>
        corewolf::engine *Abs(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Abs[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the list {Abs[z],Arg[z]} of the number z.
        /// https://reference.wolfram.com/language/ref/AbsArg.html
        ///</summary>
        corewolf::engine *AbsArg(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AbsArg[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a plot of Abs[f] colored by Arg[f] as a function of x∈ from xmin to xmax.
        /// https://reference.wolfram.com/language/ref/AbsArgPlot.html
        ///</summary>
        corewolf::engine *AbsArgPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AbsArgPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots several functions.
        /// https://reference.wolfram.com/language/ref/AbsArgPlot.html
        ///</summary>
        corewolf::engine *AbsArgPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AbsArgPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots fi with features defined by the symbolic wrapper w.
        /// https://reference.wolfram.com/language/ref/AbsArgPlot.html
        ///</summary>
        corewolf::engine *AbsArgPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AbsArgPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// takes the variable x to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/AbsArgPlot.html
        ///</summary>
        corewolf::engine *AbsArgPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AbsArgPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the absolute correlation between the vectors v1 and v2.
        /// https://reference.wolfram.com/language/ref/AbsoluteCorrelation.html
        ///</summary>
        corewolf::engine *AbsoluteCorrelation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AbsoluteCorrelation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the absolute correlation matrix for the matrix m.
        /// https://reference.wolfram.com/language/ref/AbsoluteCorrelation.html
        ///</summary>
        corewolf::engine *AbsoluteCorrelation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AbsoluteCorrelation[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the (i,j) absolute correlation for the multivariate symbolic distribution dist.
        /// https://reference.wolfram.com/language/ref/AbsoluteCorrelation.html
        ///</summary>
        corewolf::engine *AbsoluteCorrelation(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AbsoluteCorrelation[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// estimates the absolute correlation function at lags hspec from data.
        /// https://reference.wolfram.com/language/ref/AbsoluteCorrelationFunction.html
        ///</summary>
        corewolf::engine *AbsoluteCorrelationFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AbsoluteCorrelationFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the absolute correlation function at times s and t for the random process proc.
        /// https://reference.wolfram.com/language/ref/AbsoluteCorrelationFunction.html
        ///</summary>
        corewolf::engine *AbsoluteCorrelationFunction(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AbsoluteCorrelationFunction[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the absolute current value of item at a location in the Wolfram System and interface.
        /// https://reference.wolfram.com/language/ref/AbsoluteCurrentValue.html
        ///</summary>
        corewolf::engine *AbsoluteCurrentValue(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AbsoluteCurrentValue[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the absolute current value for the feature of item specified by spec.
        /// https://reference.wolfram.com/language/ref/AbsoluteCurrentValue.html
        ///</summary>
        corewolf::engine *AbsoluteCurrentValue(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AbsoluteCurrentValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the absolute current value of item associated with the const std::string &obj.
        /// https://reference.wolfram.com/language/ref/AbsoluteCurrentValue.html
        ///</summary>
        corewolf::engine *AbsoluteCurrentValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AbsoluteCurrentValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a graphics directive which specifies that lines which follow are to be drawn dashed, with successive segments having absolute lengths d1, d2, … (repeated cyclically).
        /// https://reference.wolfram.com/language/ref/AbsoluteDashing.html
        ///</summary>
        corewolf::engine *AbsoluteDashing(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AbsoluteDashing[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// is equivalent to AbsoluteDashing[{d,d}].
        /// https://reference.wolfram.com/language/ref/AbsoluteDashing.html
        ///</summary>
        corewolf::engine *AbsoluteDashing(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AbsoluteDashing[" + arg0 + "]", name);
        }

        ///< summary>
        /// offsets the dashes by offset.
        /// https://reference.wolfram.com/language/ref/AbsoluteDashing.html
        ///</summary>
        corewolf::engine *AbsoluteDashing(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AbsoluteDashing[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sets the CapForm for individual dashes to capform.
        /// https://reference.wolfram.com/language/ref/AbsoluteDashing.html
        ///</summary>
        corewolf::engine *AbsoluteDashing(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AbsoluteDashing[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the full absolute version of the name for a file in your filesystem.
        /// https://reference.wolfram.com/language/ref/AbsoluteFileName.html
        ///</summary>
        corewolf::engine *AbsoluteFileName(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AbsoluteFileName[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the absolute settings of options specified in an expression such as a graphics object.
        /// https://reference.wolfram.com/language/ref/AbsoluteOptions.html
        ///</summary>
        corewolf::engine *AbsoluteOptions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AbsoluteOptions[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the absolute setting for the option name.
        /// https://reference.wolfram.com/language/ref/AbsoluteOptions.html
        ///</summary>
        corewolf::engine *AbsoluteOptions(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AbsoluteOptions[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the absolute settings for the options namei.
        /// https://reference.wolfram.com/language/ref/AbsoluteOptions.html
        ///</summary>
        corewolf::engine *AbsoluteOptions(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AbsoluteOptions[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is a graphics directive which specifies that points which follow are to be shown if possible as circular regions with absolute diameter d.
        /// https://reference.wolfram.com/language/ref/AbsolutePointSize.html
        ///</summary>
        corewolf::engine *AbsolutePointSize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AbsolutePointSize[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a graphics directive which specifies that lines which follow are to be drawn with absolute thickness d.
        /// https://reference.wolfram.com/language/ref/AbsoluteThickness.html
        ///</summary>
        corewolf::engine *AbsoluteThickness(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AbsoluteThickness[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the total number of seconds since the beginning of January 1, 1900, in your time zone.
        /// https://reference.wolfram.com/language/ref/AbsoluteTime.html
        ///</summary>
        corewolf::engine *AbsoluteTime(const std::string &name = "")
        {
            return this->execute("AbsoluteTime[]", name);
        }

        ///< summary>
        /// gives the absolute time specification corresponding to the given date specification.
        /// https://reference.wolfram.com/language/ref/AbsoluteTime.html
        ///</summary>
        corewolf::engine *AbsoluteTime(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AbsoluteTime[" + arg0 + "]", name);
        }

        ///< summary>
        /// evaluates expr, returning a list of the absolute number of seconds in real time that have elapsed, together with the result obtained.
        /// https://reference.wolfram.com/language/ref/AbsoluteTiming.html
        ///</summary>
        corewolf::engine *AbsoluteTiming(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AbsoluteTiming[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints with all numbers in expr given in standard accounting notation.
        /// https://reference.wolfram.com/language/ref/AccountingForm.html
        ///</summary>
        corewolf::engine *AccountingForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AccountingForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints with numbers given to n‐digit precision.
        /// https://reference.wolfram.com/language/ref/AccountingForm.html
        ///</summary>
        corewolf::engine *AccountingForm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AccountingForm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the successive accumulated totals of elements in list.
        /// https://reference.wolfram.com/language/ref/Accumulate.html
        ///</summary>
        corewolf::engine *Accumulate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Accumulate[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the effective number of digits to the right of the decimal point in the number x.
        /// https://reference.wolfram.com/language/ref/Accuracy.html
        ///</summary>
        corewolf::engine *Accuracy(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Accuracy[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a time or frequency domain absorbing boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/AcousticAbsorbingValue.html
        ///</summary>
        corewolf::engine *AcousticAbsorbingValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AcousticAbsorbingValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a time or frequency domain boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/AcousticAbsorbingValue.html
        ///</summary>
        corewolf::engine *AcousticAbsorbingValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("AcousticAbsorbingValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a time or frequency domain impedance boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/AcousticImpedanceValue.html
        ///</summary>
        corewolf::engine *AcousticImpedanceValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AcousticImpedanceValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a time or frequency domain boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/AcousticImpedanceValue.html
        ///</summary>
        corewolf::engine *AcousticImpedanceValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("AcousticImpedanceValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a time or frequency domain normal velocity boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/AcousticNormalVelocityValue.html
        ///</summary>
        corewolf::engine *AcousticNormalVelocityValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AcousticNormalVelocityValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a time or frequency domain boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/AcousticNormalVelocityValue.html
        ///</summary>
        corewolf::engine *AcousticNormalVelocityValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("AcousticNormalVelocityValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// yields an acoustic PDE term component with variables vars and parameters pars.
        /// https://reference.wolfram.com/language/ref/AcousticPDEComponent.html
        ///</summary>
        corewolf::engine *AcousticPDEComponent(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AcousticPDEComponent[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a time or frequency domain pressure boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/AcousticPressureCondition.html
        ///</summary>
        corewolf::engine *AcousticPressureCondition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AcousticPressureCondition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a time or frequency domain boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/AcousticPressureCondition.html
        ///</summary>
        corewolf::engine *AcousticPressureCondition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("AcousticPressureCondition[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a time or frequency radiation boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/AcousticRadiationValue.html
        ///</summary>
        corewolf::engine *AcousticRadiationValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AcousticRadiationValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a time or frequency domain boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/AcousticRadiationValue.html
        ///</summary>
        corewolf::engine *AcousticRadiationValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("AcousticRadiationValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a time or frequency domain sound hard boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/AcousticSoundHardValue.html
        ///</summary>
        corewolf::engine *AcousticSoundHardValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AcousticSoundHardValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a time or frequency domain boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/AcousticSoundHardValue.html
        ///</summary>
        corewolf::engine *AcousticSoundHardValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("AcousticSoundHardValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a time or frequency domain sound soft boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/AcousticSoundSoftCondition.html
        ///</summary>
        corewolf::engine *AcousticSoundSoftCondition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AcousticSoundSoftCondition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a time or frequency domain boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/AcousticSoundSoftCondition.html
        ///</summary>
        corewolf::engine *AcousticSoundSoftCondition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("AcousticSoundSoftCondition[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an action menu with label name and with items labeled lbli that evaluates the expression acti if the corresponding item is chosen.
        /// https://reference.wolfram.com/language/ref/ActionMenu.html
        ///</summary>
        corewolf::engine *ActionMenu(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ActionMenu[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// replaces all instances of Inactive[f] in expr with f.
        /// https://reference.wolfram.com/language/ref/Activate.html
        ///</summary>
        corewolf::engine *Activate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Activate[" + arg0 + "]", name);
        }

        ///< summary>
        /// replaces only instances of Inactive[f] for which f matches the pattern patt.
        /// https://reference.wolfram.com/language/ref/Activate.html
        ///</summary>
        corewolf::engine *Activate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Activate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an const std::string &representing the result of active classification obtained by using the function f to determine classes for the example configurations confi.
        /// https://reference.wolfram.com/language/ref/ActiveClassification.html
        ///</summary>
        corewolf::engine *ActiveClassification(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ActiveClassification[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates configurations within the region specified by reg.
        /// https://reference.wolfram.com/language/ref/ActiveClassification.html
        ///</summary>
        corewolf::engine *ActiveClassification(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ActiveClassification[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the result of an ActiveClassification process.
        /// https://reference.wolfram.com/language/ref/ActiveClassificationObject.html
        ///</summary>
        corewolf::engine *ActiveClassificationObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ActiveClassificationObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an const std::string &representing the result of active prediction obtained by using the function f to determine values for the example configurations confi.
        /// https://reference.wolfram.com/language/ref/ActivePrediction.html
        ///</summary>
        corewolf::engine *ActivePrediction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ActivePrediction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates configurations within the region specified by reg.
        /// https://reference.wolfram.com/language/ref/ActivePrediction.html
        ///</summary>
        corewolf::engine *ActivePrediction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ActivePrediction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the result of an ActivePrediction process.
        /// https://reference.wolfram.com/language/ref/ActivePredictionObject.html
        ///</summary>
        corewolf::engine *ActivePredictionObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ActivePredictionObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is an acyclic graph and False otherwise.
        /// https://reference.wolfram.com/language/ref/AcyclicGraphQ.html
        ///</summary>
        corewolf::engine *AcyclicGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AcyclicGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// adds x to each side of the equation or inequality rel.
        /// https://reference.wolfram.com/language/ref/AddSides.html
        ///</summary>
        corewolf::engine *AddSides(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AddSides[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// adds the specified content to the existing search index const std::string &obj.
        /// https://reference.wolfram.com/language/ref/AddToSearchIndex.html
        ///</summary>
        corewolf::engine *AddToSearchIndex(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AddToSearchIndex[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// adds all the contenti to obj.
        /// https://reference.wolfram.com/language/ref/AddToSearchIndex.html
        ///</summary>
        corewolf::engine *AddToSearchIndex(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AddToSearchIndex[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// adds the users useri to the permissions group group.
        /// https://reference.wolfram.com/language/ref/AddUsers.html
        ///</summary>
        corewolf::engine *AddUsers(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AddUsers[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the graph with adjacency matrix amat.
        /// https://reference.wolfram.com/language/ref/AdjacencyGraph.html
        ///</summary>
        corewolf::engine *AdjacencyGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AdjacencyGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the graph with vertices vi and adjacency matrix amat.
        /// https://reference.wolfram.com/language/ref/AdjacencyGraph.html
        ///</summary>
        corewolf::engine *AdjacencyGraph(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AdjacencyGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of vertices adjacent to vertex v.
        /// https://reference.wolfram.com/language/ref/AdjacencyList.html
        ///</summary>
        corewolf::engine *AdjacencyList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AdjacencyList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of vertices that are at distance at most d.
        /// https://reference.wolfram.com/language/ref/AdjacencyList.html
        ///</summary>
        corewolf::engine *AdjacencyList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AdjacencyList[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/AdjacencyList.html
        ///</summary>
        corewolf::engine *AdjacencyList(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AdjacencyList[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the vertex–vertex adjacency matrix of the graph g.
        /// https://reference.wolfram.com/language/ref/AdjacencyMatrix.html
        ///</summary>
        corewolf::engine *AdjacencyMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AdjacencyMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/AdjacencyMatrix.html
        ///</summary>
        corewolf::engine *AdjacencyMatrix(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AdjacencyMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives cells of dimension d adjacent to the cell specified by cellspec in the mesh mr.
        /// https://reference.wolfram.com/language/ref/AdjacentMeshCells.html
        ///</summary>
        corewolf::engine *AdjacentMeshCells(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AdjacentMeshCells[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the adjugate of a square matrix m.
        /// https://reference.wolfram.com/language/ref/Adjugate.html
        ///</summary>
        corewolf::engine *Adjugate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Adjugate[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a low-level box construct which displays with the placement of box adjusted using the options given.
        /// https://reference.wolfram.com/language/ref/AdjustmentBox.html
        ///</summary>
        corewolf::engine *AdjustmentBox(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AdjustmentBox[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// adjusts forecast using new observations newdata according to the time series model tproc.
        /// https://reference.wolfram.com/language/ref/AdjustTimeSeriesForecast.html
        ///</summary>
        corewolf::engine *AdjustTimeSeriesForecast(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AdjustTimeSeriesForecast[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the administrative division entity.
        /// https://reference.wolfram.com/language/ref/AdministrativeDivisionData.html
        ///</summary>
        corewolf::engine *AdministrativeDivisionData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AdministrativeDivisionData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified administrative division names.
        /// https://reference.wolfram.com/language/ref/AdministrativeDivisionData.html
        ///</summary>
        corewolf::engine *AdministrativeDivisionData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AdministrativeDivisionData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/AdministrativeDivisionData.html
        ///</summary>
        corewolf::engine *AdministrativeDivisionData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AdministrativeDivisionData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents AffineSpace[{p1,…,pk+1}] extended in the direction w.
        /// https://reference.wolfram.com/language/ref/AffineHalfSpace.html
        ///</summary>
        corewolf::engine *AffineHalfSpace(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AffineHalfSpace[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents AffineSpace[p,{v1,…,vk}] extended in the direction w.
        /// https://reference.wolfram.com/language/ref/AffineHalfSpace.html
        ///</summary>
        corewolf::engine *AffineHalfSpace(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AffineHalfSpace[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the affine space passing through the points pi.
        /// https://reference.wolfram.com/language/ref/AffineSpace.html
        ///</summary>
        corewolf::engine *AffineSpace(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AffineSpace[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the affine space passing through p in the directions vi.
        /// https://reference.wolfram.com/language/ref/AffineSpace.html
        ///</summary>
        corewolf::engine *AffineSpace(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AffineSpace[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents the affine state-space model , .
        /// https://reference.wolfram.com/language/ref/AffineStateSpaceModel.html
        ///</summary>
        corewolf::engine *AffineStateSpaceModel(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AffineStateSpaceModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an affine state-space model corresponding to the system model sys.
        /// https://reference.wolfram.com/language/ref/AffineStateSpaceModel.html
        ///</summary>
        corewolf::engine *AffineStateSpaceModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AffineStateSpaceModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the affine state-space model obtained by Taylor input linearization about the dependent variable xi at xi0 and input uj at uj0 of the differential equations eqns with outputs gi and independent variable t.
        /// https://reference.wolfram.com/language/ref/AffineStateSpaceModel.html
        ///</summary>
        corewolf::engine *AffineStateSpaceModel(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("AffineStateSpaceModel[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// gives a TransformationFunction that represents an affine transform that maps r to m.r.
        /// https://reference.wolfram.com/language/ref/AffineTransform.html
        ///</summary>
        corewolf::engine *AffineTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AffineTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an affine transform that maps r to m.r+v.
        /// https://reference.wolfram.com/language/ref/AffineTransform.html
        ///</summary>
        corewolf::engine *AffineTransform(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AffineTransform[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents an entity class containing a single entity with the property prop whose value is the result of applying the function f to the whole specified entity class.
        /// https://reference.wolfram.com/language/ref/AggregatedEntityClass.html
        ///</summary>
        corewolf::engine *AggregatedEntityClass(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AggregatedEntityClass[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// constructs multiple properties propi obtained by applying fi to class.
        /// https://reference.wolfram.com/language/ref/AggregatedEntityClass.html
        ///</summary>
        corewolf::engine *AggregatedEntityClass(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AggregatedEntityClass[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// forms groups of elements of class according to their values of the property gprop, then generates an entity class with an entity for each of these groups.
        /// https://reference.wolfram.com/language/ref/AggregatedEntityClass.html
        ///</summary>
        corewolf::engine *AggregatedEntityClass(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AggregatedEntityClass[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// forms groups for which the set of values defined by the gspeci is distinct.
        /// https://reference.wolfram.com/language/ref/AggregatedEntityClass.html
        ///</summary>
        corewolf::engine *AggregatedEntityClass(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AggregatedEntityClass[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a layer that aggregates an array of arbitrary rank into a vector, using the function f.
        /// https://reference.wolfram.com/language/ref/AggregationLayer.html
        ///</summary>
        corewolf::engine *AggregationLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AggregationLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// aggregates an array at level n.
        /// https://reference.wolfram.com/language/ref/AggregationLayer.html
        ///</summary>
        corewolf::engine *AggregationLayer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AggregationLayer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// aggregates an array at levels n1,n2,….
        /// https://reference.wolfram.com/language/ref/AggregationLayer.html
        ///</summary>
        corewolf::engine *AggregationLayer(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AggregationLayer[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the aircraft entity.
        /// https://reference.wolfram.com/language/ref/AircraftData.html
        ///</summary>
        corewolf::engine *AircraftData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AircraftData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified aircraft entities.
        /// https://reference.wolfram.com/language/ref/AircraftData.html
        ///</summary>
        corewolf::engine *AircraftData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AircraftData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/AircraftData.html
        ///</summary>
        corewolf::engine *AircraftData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AircraftData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the airport entity.
        /// https://reference.wolfram.com/language/ref/AirportData.html
        ///</summary>
        corewolf::engine *AirportData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AirportData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified airport entities.
        /// https://reference.wolfram.com/language/ref/AirportData.html
        ///</summary>
        corewolf::engine *AirportData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AirportData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/AirportData.html
        ///</summary>
        corewolf::engine *AirportData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AirportData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the most recent measurement for air pressure near the current location.
        /// https://reference.wolfram.com/language/ref/AirPressureData.html
        ///</summary>
        corewolf::engine *AirPressureData(const std::string &name = "")
        {
            return this->execute("AirPressureData[]", name);
        }

        ///< summary>
        /// gives the air pressure value for the specified time near the current location.
        /// https://reference.wolfram.com/language/ref/AirPressureData.html
        ///</summary>
        corewolf::engine *AirPressureData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AirPressureData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value or values for the specified date and location.
        /// https://reference.wolfram.com/language/ref/AirPressureData.html
        ///</summary>
        corewolf::engine *AirPressureData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AirPressureData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives values for all specified locations on the specified dates.
        /// https://reference.wolfram.com/language/ref/AirPressureData.html
        ///</summary>
        corewolf::engine *AirPressureData(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AirPressureData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns the sound attenuation coefficient in moist air for the specified parameters spec for frequency.
        /// https://reference.wolfram.com/language/ref/AirSoundAttenuation.html
        ///</summary>
        corewolf::engine *AirSoundAttenuation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AirSoundAttenuation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the sound attenuation factor for the specified parameters at distance.
        /// https://reference.wolfram.com/language/ref/AirSoundAttenuation.html
        ///</summary>
        corewolf::engine *AirSoundAttenuation(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AirSoundAttenuation[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the sound level at distance given the source sound level sl.
        /// https://reference.wolfram.com/language/ref/AirSoundAttenuation.html
        ///</summary>
        corewolf::engine *AirSoundAttenuation(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("AirSoundAttenuation[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the most recent measurement for air temperature near the current location.
        /// https://reference.wolfram.com/language/ref/AirTemperatureData.html
        ///</summary>
        corewolf::engine *AirTemperatureData(const std::string &name = "")
        {
            return this->execute("AirTemperatureData[]", name);
        }

        ///< summary>
        /// gives the air temperature value for the specified time near the current location.
        /// https://reference.wolfram.com/language/ref/AirTemperatureData.html
        ///</summary>
        corewolf::engine *AirTemperatureData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AirTemperatureData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value or values for the specified date and location.
        /// https://reference.wolfram.com/language/ref/AirTemperatureData.html
        ///</summary>
        corewolf::engine *AirTemperatureData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AirTemperatureData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives values for all specified locations on the specified dates.
        /// https://reference.wolfram.com/language/ref/AirTemperatureData.html
        ///</summary>
        corewolf::engine *AirTemperatureData(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AirTemperatureData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Airy function .
        /// https://reference.wolfram.com/language/ref/AiryAi.html
        ///</summary>
        corewolf::engine *AiryAi(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AiryAi[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the derivative of the Airy function .
        /// https://reference.wolfram.com/language/ref/AiryAiPrime.html
        ///</summary>
        corewolf::engine *AiryAiPrime(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AiryAiPrime[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the k zero of the Airy function .
        /// https://reference.wolfram.com/language/ref/AiryAiZero.html
        ///</summary>
        corewolf::engine *AiryAiZero(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AiryAiZero[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the k zero less than x0.
        /// https://reference.wolfram.com/language/ref/AiryAiZero.html
        ///</summary>
        corewolf::engine *AiryAiZero(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AiryAiZero[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Airy function .
        /// https://reference.wolfram.com/language/ref/AiryBi.html
        ///</summary>
        corewolf::engine *AiryBi(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AiryBi[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the derivative of the Airy function .
        /// https://reference.wolfram.com/language/ref/AiryBiPrime.html
        ///</summary>
        corewolf::engine *AiryBiPrime(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AiryBiPrime[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the k zero of the Airy function .
        /// https://reference.wolfram.com/language/ref/AiryBiZero.html
        ///</summary>
        corewolf::engine *AiryBiZero(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AiryBiZero[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the k zero less than x0.
        /// https://reference.wolfram.com/language/ref/AiryBiZero.html
        ///</summary>
        corewolf::engine *AiryBiZero(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AiryBiZero[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if a is an algebraic integer, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/AlgebraicIntegerQ.html
        ///</summary>
        corewolf::engine *AlgebraicIntegerQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AlgebraicIntegerQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the algebraic number in the field  given by .
        /// https://reference.wolfram.com/language/ref/AlgebraicNumber.html
        ///</summary>
        corewolf::engine *AlgebraicNumber(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AlgebraicNumber[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the smallest positive integer n such that n a is an algebraic integer.
        /// https://reference.wolfram.com/language/ref/AlgebraicNumberDenominator.html
        ///</summary>
        corewolf::engine *AlgebraicNumberDenominator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AlgebraicNumberDenominator[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the norm of the algebraic number a.
        /// https://reference.wolfram.com/language/ref/AlgebraicNumberNorm.html
        ///</summary>
        corewolf::engine *AlgebraicNumberNorm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AlgebraicNumberNorm[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the polynomial in x corresponding to the AlgebraicNumber const std::string &a.
        /// https://reference.wolfram.com/language/ref/AlgebraicNumberPolynomial.html
        ///</summary>
        corewolf::engine *AlgebraicNumberPolynomial(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AlgebraicNumberPolynomial[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the trace of the algebraic number a.
        /// https://reference.wolfram.com/language/ref/AlgebraicNumberTrace.html
        ///</summary>
        corewolf::engine *AlgebraicNumberTrace(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AlgebraicNumberTrace[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if a is an algebraic unit, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/AlgebraicUnitQ.html
        ///</summary>
        corewolf::engine *AlgebraicUnitQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AlgebraicUnitQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if test[ei] is True for all of the ei.
        /// https://reference.wolfram.com/language/ref/AllTrue.html
        ///</summary>
        corewolf::engine *AllTrue(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AllTrue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests parts of expr at level level.
        /// https://reference.wolfram.com/language/ref/AllTrue.html
        ///</summary>
        corewolf::engine *AllTrue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AllTrue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of AllTrue that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/AllTrue.html
        ///</summary>
        corewolf::engine *AllTrue(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AllTrue[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of the lowercase letters a through z in the English alphabet.
        /// https://reference.wolfram.com/language/ref/Alphabet.html
        ///</summary>
        corewolf::engine *Alphabet(const std::string &name = "")
        {
            return this->execute("Alphabet[]", name);
        }

        ///< summary>
        /// gives the alphabet for the language or class type.
        /// https://reference.wolfram.com/language/ref/Alphabet.html
        ///</summary>
        corewolf::engine *Alphabet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Alphabet[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the alphabet defined by prop for the language or class type .
        /// https://reference.wolfram.com/language/ref/Alphabet.html
        ///</summary>
        corewolf::engine *Alphabet(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Alphabet[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives 1 if "string1" appears before "string2" in alphabetical order, -1 if it is after, and 0 if it is identical.
        /// https://reference.wolfram.com/language/ref/AlphabeticOrder.html
        ///</summary>
        corewolf::engine *AlphabeticOrder(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AlphabeticOrder[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses an ordering suitable for the language lang.
        /// https://reference.wolfram.com/language/ref/AlphabeticOrder.html
        ///</summary>
        corewolf::engine *AlphabeticOrder(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AlphabeticOrder[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form that compares strings when applied to "string1", "string2".
        /// https://reference.wolfram.com/language/ref/AlphabeticOrder.html
        ///</summary>
        corewolf::engine *AlphabeticOrder(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AlphabeticOrder[" + arg0 + "]", name);
        }

        ///< summary>
        /// sorts the elements of list into alphabetical order.
        /// https://reference.wolfram.com/language/ref/AlphabeticSort.html
        ///</summary>
        corewolf::engine *AlphabeticSort(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AlphabeticSort[" + arg0 + "]", name);
        }

        ///< summary>
        /// sorts using an ordering suitable for the language lang.
        /// https://reference.wolfram.com/language/ref/AlphabeticSort.html
        ///</summary>
        corewolf::engine *AlphabeticSort(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AlphabeticSort[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the opacity of color.
        /// https://reference.wolfram.com/language/ref/AlphaChannel.html
        ///</summary>
        corewolf::engine *AlphaChannel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AlphaChannel[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the alternating factorial .
        /// https://reference.wolfram.com/language/ref/AlternatingFactorial.html
        ///</summary>
        corewolf::engine *AlternatingFactorial(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AlternatingFactorial[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the alternating group of degree n.
        /// https://reference.wolfram.com/language/ref/AlternatingGroup.html
        ///</summary>
        corewolf::engine *AlternatingGroup(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AlternatingGroup[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a three-dimensional graphics directive that specifies the uniform ambient light of color col to use in coloring 3D surfaces.
        /// https://reference.wolfram.com/language/ref/AmbientLight.html
        ///</summary>
        corewolf::engine *AmbientLight(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AmbientLight[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents possible results derived from an ambiguous semantic interpretation.
        /// https://reference.wolfram.com/language/ref/AmbiguityList.html
        ///</summary>
        corewolf::engine *AmbiguityList(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AmbiguityList[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents possible results from semantic interpretation of an input string.
        /// https://reference.wolfram.com/language/ref/AmbiguityList.html
        ///</summary>
        corewolf::engine *AmbiguityList(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AmbiguityList[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// includes a sequence of associations giving details of the interpretations used to obtain the expri.
        /// https://reference.wolfram.com/language/ref/AmbiguityList.html
        ///</summary>
        corewolf::engine *AmbiguityList(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AmbiguityList[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the anatomical structure entity.
        /// https://reference.wolfram.com/language/ref/AnatomyData.html
        ///</summary>
        corewolf::engine *AnatomyData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AnatomyData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified anatomical structure entities.
        /// https://reference.wolfram.com/language/ref/AnatomyData.html
        ///</summary>
        corewolf::engine *AnatomyData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AnatomyData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/AnatomyData.html
        ///</summary>
        corewolf::engine *AnatomyData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AnatomyData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a three-dimensional graphical image that works with anatomical entities as well as standard 3D graphics primitives and directives.
        /// https://reference.wolfram.com/language/ref/AnatomyPlot3D.html
        ///</summary>
        corewolf::engine *AnatomyPlot3D(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AnatomyPlot3D[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a graphics directive used in AnatomyPlot3D that specifies how anatomy entity‐based graphics objects are to be drawn using the graphics directive or association of directives g.
        /// https://reference.wolfram.com/language/ref/AnatomyStyling.html
        ///</summary>
        corewolf::engine *AnatomyStyling(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AnatomyStyling[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether data is normally distributed using the Anderson–Darling test.
        /// https://reference.wolfram.com/language/ref/AndersonDarlingTest.html
        ///</summary>
        corewolf::engine *AndersonDarlingTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AndersonDarlingTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether data is distributed according to dist using the Anderson–Darling test.
        /// https://reference.wolfram.com/language/ref/AndersonDarlingTest.html
        ///</summary>
        corewolf::engine *AndersonDarlingTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AndersonDarlingTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/AndersonDarlingTest.html
        ///</summary>
        corewolf::engine *AndersonDarlingTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AndersonDarlingTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Anger function .
        /// https://reference.wolfram.com/language/ref/AngerJ.html
        ///</summary>
        corewolf::engine *AngerJ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AngerJ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the associated Anger function .
        /// https://reference.wolfram.com/language/ref/AngerJ.html
        ///</summary>
        corewolf::engine *AngerJ(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AngerJ[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the bisector of the interior angle at p formed by the triangle with vertex points p, q1 and q2.
        /// https://reference.wolfram.com/language/ref/AngleBisector.html
        ///</summary>
        corewolf::engine *AngleBisector(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AngleBisector[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the angle bisector of the specified type.
        /// https://reference.wolfram.com/language/ref/AngleBisector.html
        ///</summary>
        corewolf::engine *AngleBisector(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AngleBisector[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/AngleBracket.html
        ///</summary>
        corewolf::engine *AngleBracket(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AngleBracket[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the list of 2D coordinates corresponding to a path that starts at {0,0}, then takes a series of steps of unit length at successive relative angles θi.
        /// https://reference.wolfram.com/language/ref/AnglePath.html
        ///</summary>
        corewolf::engine *AnglePath(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AnglePath[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// takes successive steps of lengths ri.
        /// https://reference.wolfram.com/language/ref/AnglePath.html
        ///</summary>
        corewolf::engine *AnglePath(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AnglePath[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// starts at angle θ0 with respect to the  axis.
        /// https://reference.wolfram.com/language/ref/AnglePath.html
        ///</summary>
        corewolf::engine *AnglePath(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AnglePath[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// starts at the point {x,y} with initial angle 0 with respect to the  axis.
        /// https://reference.wolfram.com/language/ref/AnglePath.html
        ///</summary>
        corewolf::engine *AnglePath(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AnglePath[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns at each step the data of the form specified by form.
        /// https://reference.wolfram.com/language/ref/AnglePath.html
        ///</summary>
        corewolf::engine *AnglePath(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AnglePath[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the list of 3D coordinates of a path of an const std::string &that starts at {0,0,0}, then takes a series of steps of unit length, each in the direction of the  axis obtained after successive rotation of the const std::string &by the Euler angles αi, βi, γi.
        /// https://reference.wolfram.com/language/ref/AnglePath3D.html
        ///</summary>
        corewolf::engine *AnglePath3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AnglePath3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// takes the successive rotations to be specified by the 3D rotation matrices mati.
        /// https://reference.wolfram.com/language/ref/AnglePath3D.html
        ///</summary>
        corewolf::engine *AnglePath3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AnglePath3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// starts at the point {x0,y0,z0}.
        /// https://reference.wolfram.com/language/ref/AnglePath3D.html
        ///</summary>
        corewolf::engine *AnglePath3D(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AnglePath3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns at each step the data of the form specified by form.
        /// https://reference.wolfram.com/language/ref/AnglePath3D.html
        ///</summary>
        corewolf::engine *AnglePath3D(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AnglePath3D[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the list representing the 2D unit vector at angle θ relative to the  axis.
        /// https://reference.wolfram.com/language/ref/AngleVector.html
        ///</summary>
        corewolf::engine *AngleVector(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AngleVector[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the list representing the 2D vector of length r at angle θ.
        /// https://reference.wolfram.com/language/ref/AngleVector.html
        ///</summary>
        corewolf::engine *AngleVector(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AngleVector[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the result of starting from the point {x,y}, then going a unit distance at angle θ.
        /// https://reference.wolfram.com/language/ref/AngleVector.html
        ///</summary>
        corewolf::engine *AngleVector(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AngleVector[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the result of starting from the point {x,y}, then going distance r at angle θ.
        /// https://reference.wolfram.com/language/ref/AngleVector.html
        ///</summary>
        corewolf::engine *AngleVector(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AngleVector[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// draws a gauge showing value in the range 0 to 1.
        /// https://reference.wolfram.com/language/ref/AngularGauge.html
        ///</summary>
        corewolf::engine *AngularGauge(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AngularGauge[" + arg0 + "]", name);
        }

        ///< summary>
        /// draws a gauge showing value in a range of min to max.
        /// https://reference.wolfram.com/language/ref/AngularGauge.html
        ///</summary>
        corewolf::engine *AngularGauge(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AngularGauge[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// allows value to be set interactively using the gauge.
        /// https://reference.wolfram.com/language/ref/AngularGauge.html
        ///</summary>
        corewolf::engine *AngularGauge(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AngularGauge[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// draws a gauge showing multiple values.
        /// https://reference.wolfram.com/language/ref/AngularGauge.html
        ///</summary>
        corewolf::engine *AngularGauge(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AngularGauge[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates an animation of expr in which u varies continuously from umin to umax.
        /// https://reference.wolfram.com/language/ref/Animate.html
        ///</summary>
        corewolf::engine *Animate(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Animate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes u take on discrete values u1, u2, ….
        /// https://reference.wolfram.com/language/ref/Animate.html
        ///</summary>
        corewolf::engine *Animate(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Animate[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// varies all the variables u, v, ….
        /// https://reference.wolfram.com/language/ref/Animate.html
        ///</summary>
        corewolf::engine *Animate(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Animate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// generates an animation whose frames are the successive imagei.
        /// https://reference.wolfram.com/language/ref/AnimatedImage.html
        ///</summary>
        corewolf::engine *AnimatedImage(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AnimatedImage[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents an animated image from file.
        /// https://reference.wolfram.com/language/ref/AnimatedImage.html
        ///</summary>
        corewolf::engine *AnimatedImage(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AnimatedImage[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a video of fexpr in which u varies from umin to umax.
        /// https://reference.wolfram.com/language/ref/AnimationVideo.html
        ///</summary>
        corewolf::engine *AnimationVideo(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AnimationVideo[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes u take on values u1, u2, ….
        /// https://reference.wolfram.com/language/ref/AnimationVideo.html
        ///</summary>
        corewolf::engine *AnimationVideo(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AnimationVideo[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents an const std::string &that displays with the value of u being continually increased from 0 to 1 with time.
        /// https://reference.wolfram.com/language/ref/Animator.html
        ///</summary>
        corewolf::engine *Animator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Animator[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes u vary from umin to umax.
        /// https://reference.wolfram.com/language/ref/Animator.html
        ///</summary>
        corewolf::engine *Animator(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Animator[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes the value of u increase at a rate of ups units per second.
        /// https://reference.wolfram.com/language/ref/Animator.html
        ///</summary>
        corewolf::engine *Animator(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Animator[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// sets the annotation keyvalue for the const std::string &obj.
        /// https://reference.wolfram.com/language/ref/Annotate.html
        ///</summary>
        corewolf::engine *Annotate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Annotate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sets the annotation for the items in obj specified by itemspec.
        /// https://reference.wolfram.com/language/ref/Annotate.html
        ///</summary>
        corewolf::engine *Annotate(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Annotate[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an expression expr, with annotation data.
        /// https://reference.wolfram.com/language/ref/Annotation.html
        ///</summary>
        corewolf::engine *Annotation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Annotation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies the type of annotation being given.
        /// https://reference.wolfram.com/language/ref/Annotation.html
        ///</summary>
        corewolf::engine *Annotation(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Annotation[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// deletes all annotations of the const std::string &obj.
        /// https://reference.wolfram.com/language/ref/AnnotationDelete.html
        ///</summary>
        corewolf::engine *AnnotationDelete(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AnnotationDelete[" + arg0 + "]", name);
        }

        ///< summary>
        /// deletes all annotations of the items of obj specified by itemspec.
        /// https://reference.wolfram.com/language/ref/AnnotationDelete.html
        ///</summary>
        corewolf::engine *AnnotationDelete(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AnnotationDelete[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// deletes the annotation key specified by spec.
        /// https://reference.wolfram.com/language/ref/AnnotationDelete.html
        ///</summary>
        corewolf::engine *AnnotationDelete(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AnnotationDelete[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// lists all annotation keys available for the const std::string &obj.
        /// https://reference.wolfram.com/language/ref/AnnotationKeys.html
        ///</summary>
        corewolf::engine *AnnotationKeys(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AnnotationKeys[" + arg0 + "]", name);
        }

        ///< summary>
        /// lists all annotation keys available for the items specified by itemspec in obj.
        /// https://reference.wolfram.com/language/ref/AnnotationKeys.html
        ///</summary>
        corewolf::engine *AnnotationKeys(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AnnotationKeys[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the annotation value associated with key for the const std::string &obj.
        /// https://reference.wolfram.com/language/ref/AnnotationValue.html
        ///</summary>
        corewolf::engine *AnnotationValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AnnotationValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the annotation value associated with key for items specified by itemspec in obj.
        /// https://reference.wolfram.com/language/ref/AnnotationValue.html
        ///</summary>
        corewolf::engine *AnnotationValue(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AnnotationValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an annuity of fixed payments p made over t periods.
        /// https://reference.wolfram.com/language/ref/Annuity.html
        ///</summary>
        corewolf::engine *Annuity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Annuity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a series of payments occurring at time intervals q.
        /// https://reference.wolfram.com/language/ref/Annuity.html
        ///</summary>
        corewolf::engine *Annuity(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Annuity[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an annuity with the specified initial and final payments.
        /// https://reference.wolfram.com/language/ref/Annuity.html
        ///</summary>
        corewolf::engine *Annuity(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Annuity[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an annuity due of fixed payments p made over t periods.
        /// https://reference.wolfram.com/language/ref/AnnuityDue.html
        ///</summary>
        corewolf::engine *AnnuityDue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AnnuityDue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a series of payments occurring at time intervals q.
        /// https://reference.wolfram.com/language/ref/AnnuityDue.html
        ///</summary>
        corewolf::engine *AnnuityDue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AnnuityDue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an annuity due with the specified initial and final payments.
        /// https://reference.wolfram.com/language/ref/AnnuityDue.html
        ///</summary>
        corewolf::engine *AnnuityDue(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("AnnuityDue[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an annulus centered at {x,y} with inner radius rinner and outer radius router.
        /// https://reference.wolfram.com/language/ref/Annulus.html
        ///</summary>
        corewolf::engine *Annulus(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Annulus[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an annulus from angle θ1 to θ2.
        /// https://reference.wolfram.com/language/ref/Annulus.html
        ///</summary>
        corewolf::engine *Annulus(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Annulus[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates an AnomalyDetectorFunction[…] based on the examples given.
        /// https://reference.wolfram.com/language/ref/AnomalyDetection.html
        ///</summary>
        corewolf::engine *AnomalyDetection(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AnomalyDetection[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates an anomaly detector based on the given distribution.
        /// https://reference.wolfram.com/language/ref/AnomalyDetection.html
        ///</summary>
        corewolf::engine *AnomalyDetection(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AnomalyDetection[" + arg0 + "]", name);
        }

        ///< summary>
        /// can be used to indicate which examples should be considered anomalous.
        /// https://reference.wolfram.com/language/ref/AnomalyDetection.html
        ///</summary>
        corewolf::engine *AnomalyDetection(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AnomalyDetection[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a function generated by AnomalyDetection for detecting whether data is anomalous or not.
        /// https://reference.wolfram.com/language/ref/AnomalyDetectorFunction.html
        ///</summary>
        corewolf::engine *AnomalyDetectorFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AnomalyDetectorFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the symmetry of an antihermitian matrix.
        /// https://reference.wolfram.com/language/ref/Antihermitian.html
        ///</summary>
        corewolf::engine *Antihermitian(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Antihermitian[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives True if m is explicitly antihermitian, and False otherwise.
        /// https://reference.wolfram.com/language/ref/AntihermitianMatrixQ.html
        ///</summary>
        corewolf::engine *AntihermitianMatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AntihermitianMatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the symmetry of a tensor that is antisymmetric in the slots si.
        /// https://reference.wolfram.com/language/ref/Antisymmetric.html
        ///</summary>
        corewolf::engine *Antisymmetric(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Antisymmetric[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives True if m is explicitly antisymmetric, and False otherwise.
        /// https://reference.wolfram.com/language/ref/AntisymmetricMatrixQ.html
        ///</summary>
        corewolf::engine *AntisymmetricMatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AntisymmetricMatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the antonyms associated with the specified word.
        /// https://reference.wolfram.com/language/ref/Antonyms.html
        ///</summary>
        corewolf::engine *Antonyms(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Antonyms[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a grammar rules pattern const std::string &that represents a sequence of elements matching p1, p2, … in any order.
        /// https://reference.wolfram.com/language/ref/AnyOrder.html
        ///</summary>
        corewolf::engine *AnyOrder(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AnyOrder[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an element in an interpreter or form that accepts any subset of the choices ci.
        /// https://reference.wolfram.com/language/ref/AnySubset.html
        ///</summary>
        corewolf::engine *AnySubset(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AnySubset[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// accepts any subset of the entities in the specified entity class.
        /// https://reference.wolfram.com/language/ref/AnySubset.html
        ///</summary>
        corewolf::engine *AnySubset(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AnySubset[" + arg0 + "]", name);
        }

        ///< summary>
        /// allows at most max choices to be selected.
        /// https://reference.wolfram.com/language/ref/AnySubset.html
        ///</summary>
        corewolf::engine *AnySubset(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AnySubset[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// allows at least min and at most max choices to be selected.
        /// https://reference.wolfram.com/language/ref/AnySubset.html
        ///</summary>
        corewolf::engine *AnySubset(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AnySubset[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if test[ei] is True for any of the ei.
        /// https://reference.wolfram.com/language/ref/AnyTrue.html
        ///</summary>
        corewolf::engine *AnyTrue(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AnyTrue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests parts of expr at level level.
        /// https://reference.wolfram.com/language/ref/AnyTrue.html
        ///</summary>
        corewolf::engine *AnyTrue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AnyTrue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of AnyTrue that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/AnyTrue.html
        ///</summary>
        corewolf::engine *AnyTrue(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AnyTrue[" + arg0 + "]", name);
        }

        ///< summary>
        /// rewrites a rational expression as a sum of terms with minimal denominators.
        /// https://reference.wolfram.com/language/ref/Apart.html
        ///</summary>
        corewolf::engine *Apart(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Apart[" + arg0 + "]", name);
        }

        ///< summary>
        /// treats all variables other than var as constants.
        /// https://reference.wolfram.com/language/ref/Apart.html
        ///</summary>
        corewolf::engine *Apart(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Apart[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// rewrites a rational expression as a sum of terms whose denominators are powers of square-free polynomials.
        /// https://reference.wolfram.com/language/ref/ApartSquareFree.html
        ///</summary>
        corewolf::engine *ApartSquareFree(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ApartSquareFree[" + arg0 + "]", name);
        }

        ///< summary>
        /// treats all variables other than var as constants.
        /// https://reference.wolfram.com/language/ref/ApartSquareFree.html
        ///</summary>
        corewolf::engine *ApartSquareFree(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ApartSquareFree[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an API with parameters namei that evaluates the function fun whenever it is called. The function fun is applied to "name1"val1,"name2"val2,…, where the vali are the settings for the parameters, interpreted as being of types typei.
        /// https://reference.wolfram.com/language/ref/APIFunction.html
        ///</summary>
        corewolf::engine *APIFunction(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("APIFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies that the result from applying fun should be returned in format fmt.
        /// https://reference.wolfram.com/language/ref/APIFunction.html
        ///</summary>
        corewolf::engine *APIFunction(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("APIFunction[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// specifies that the result should be returned as a response of the form rform.
        /// https://reference.wolfram.com/language/ref/APIFunction.html
        ///</summary>
        corewolf::engine *APIFunction(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("APIFunction[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// is the Appell hypergeometric function of two variables .
        /// https://reference.wolfram.com/language/ref/AppellF1.html
        ///</summary>
        corewolf::engine *AppellF1(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("AppellF1[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// gives expr with elem appended.
        /// https://reference.wolfram.com/language/ref/Append.html
        ///</summary>
        corewolf::engine *Append(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Append[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of Append that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/Append.html
        ///</summary>
        corewolf::engine *Append(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Append[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a net layer that takes an input array and appends another array to it.
        /// https://reference.wolfram.com/language/ref/AppendLayer.html
        ///</summary>
        corewolf::engine *AppendLayer(const std::string &name = "")
        {
            return this->execute("AppendLayer[]", name);
        }

        ///< summary>
        /// appends elem to the value of x, and resets x to the result.
        /// https://reference.wolfram.com/language/ref/AppendTo.html
        ///</summary>
        corewolf::engine *AppendTo(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AppendTo[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the formal application of f to g.
        /// https://reference.wolfram.com/language/ref/Application.html
        ///</summary>
        corewolf::engine *Application(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Application[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces the head of expr by f.
        /// https://reference.wolfram.com/language/ref/Apply.html
        ///</summary>
        corewolf::engine *Apply(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Apply[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces heads in parts of expr specified by levelspec.
        /// https://reference.wolfram.com/language/ref/Apply.html
        ///</summary>
        corewolf::engine *Apply(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Apply[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of Apply that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/Apply.html
        ///</summary>
        corewolf::engine *Apply(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Apply[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies the pattern reaction rxn to the list of molecules mols, returning a single list of products.
        /// https://reference.wolfram.com/language/ref/ApplyReaction.html
        ///</summary>
        corewolf::engine *ApplyReaction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ApplyReaction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns up to n lists of products.
        /// https://reference.wolfram.com/language/ref/ApplyReaction.html
        ///</summary>
        corewolf::engine *ApplyReaction(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ApplyReaction[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns a single set of products, using mapi to map the atoms in the i molecule to the i reactant.
        /// https://reference.wolfram.com/language/ref/ApplyReaction.html
        ///</summary>
        corewolf::engine *ApplyReaction(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ApplyReaction[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents an operator form of ApplyReaction that can be applied to a list of molecules.
        /// https://reference.wolfram.com/language/ref/ApplyReaction.html
        ///</summary>
        corewolf::engine *ApplyReaction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ApplyReaction[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies f to each side of the equation or inequality rel.
        /// https://reference.wolfram.com/language/ref/ApplySides.html
        ///</summary>
        corewolf::engine *ApplySides(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ApplySides[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the arc cosine  of the complex number .
        /// https://reference.wolfram.com/language/ref/ArcCos.html
        ///</summary>
        corewolf::engine *ArcCos(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArcCos[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the inverse hyperbolic cosine  of the complex number .
        /// https://reference.wolfram.com/language/ref/ArcCosh.html
        ///</summary>
        corewolf::engine *ArcCosh(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArcCosh[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the arc cotangent  of the complex number .
        /// https://reference.wolfram.com/language/ref/ArcCot.html
        ///</summary>
        corewolf::engine *ArcCot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArcCot[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the inverse hyperbolic cotangent  of the complex number .
        /// https://reference.wolfram.com/language/ref/ArcCoth.html
        ///</summary>
        corewolf::engine *ArcCoth(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArcCoth[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the arc cosecant  of the complex number .
        /// https://reference.wolfram.com/language/ref/ArcCsc.html
        ///</summary>
        corewolf::engine *ArcCsc(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArcCsc[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the inverse hyperbolic cosecant  of the complex number .
        /// https://reference.wolfram.com/language/ref/ArcCsch.html
        ///</summary>
        corewolf::engine *ArcCsch(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArcCsch[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the curvature of the parametrized curve whose Cartesian coordinates xi are functions of t.
        /// https://reference.wolfram.com/language/ref/ArcCurvature.html
        ///</summary>
        corewolf::engine *ArcCurvature(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ArcCurvature[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// interprets the xi as coordinates in the specified coordinate chart.
        /// https://reference.wolfram.com/language/ref/ArcCurvature.html
        ///</summary>
        corewolf::engine *ArcCurvature(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ArcCurvature[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an autoregressive conditionally heteroscedastic process of order q, driven by a standard white noise.
        /// https://reference.wolfram.com/language/ref/ARCHProcess.html
        ///</summary>
        corewolf::engine *ARCHProcess(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ARCHProcess[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an ARCH process with initial data init.
        /// https://reference.wolfram.com/language/ref/ARCHProcess.html
        ///</summary>
        corewolf::engine *ARCHProcess(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ARCHProcess[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the length of the one-dimensional region reg.
        /// https://reference.wolfram.com/language/ref/ArcLength.html
        ///</summary>
        corewolf::engine *ArcLength(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArcLength[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the length of the parametrized curve whose Cartesian coordinates xi are functions of t.
        /// https://reference.wolfram.com/language/ref/ArcLength.html
        ///</summary>
        corewolf::engine *ArcLength(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ArcLength[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// interprets the xi as coordinates in the specified coordinate chart.
        /// https://reference.wolfram.com/language/ref/ArcLength.html
        ///</summary>
        corewolf::engine *ArcLength(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ArcLength[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the arc secant  of the complex number .
        /// https://reference.wolfram.com/language/ref/ArcSec.html
        ///</summary>
        corewolf::engine *ArcSec(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArcSec[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the inverse hyperbolic secant  of the complex number .
        /// https://reference.wolfram.com/language/ref/ArcSech.html
        ///</summary>
        corewolf::engine *ArcSech(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArcSech[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the arc sine  of the complex number .
        /// https://reference.wolfram.com/language/ref/ArcSin.html
        ///</summary>
        corewolf::engine *ArcSin(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArcSin[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the arc sine distribution supported between xmin and xmax.
        /// https://reference.wolfram.com/language/ref/ArcSinDistribution.html
        ///</summary>
        corewolf::engine *ArcSinDistribution(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ArcSinDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the arc sine distribution supported between zero and one.
        /// https://reference.wolfram.com/language/ref/ArcSinDistribution.html
        ///</summary>
        corewolf::engine *ArcSinDistribution(const std::string &name = "")
        {
            return this->execute("ArcSinDistribution[]", name);
        }

        ///< summary>
        /// gives the inverse hyperbolic sine  of the complex number .
        /// https://reference.wolfram.com/language/ref/ArcSinh.html
        ///</summary>
        corewolf::engine *ArcSinh(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArcSinh[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the arc tangent  of the complex number .
        /// https://reference.wolfram.com/language/ref/ArcTan.html
        ///</summary>
        corewolf::engine *ArcTan(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArcTan[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the arc tangent of , taking into account which quadrant the point  is in.
        /// https://reference.wolfram.com/language/ref/ArcTan.html
        ///</summary>
        corewolf::engine *ArcTan(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ArcTan[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the inverse hyperbolic tangent  of the complex number .
        /// https://reference.wolfram.com/language/ref/ArcTanh.html
        ///</summary>
        corewolf::engine *ArcTanh(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArcTanh[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the area of the two-dimensional region reg.
        /// https://reference.wolfram.com/language/ref/Area.html
        ///</summary>
        corewolf::engine *Area(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Area[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the area of the parametrized surface whose Cartesian coordinates xi are functions of s and t.
        /// https://reference.wolfram.com/language/ref/Area.html
        ///</summary>
        corewolf::engine *Area(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Area[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// interprets the xi as coordinates in the specified coordinate chart.
        /// https://reference.wolfram.com/language/ref/Area.html
        ///</summary>
        corewolf::engine *Area(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Area[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the argument of the complex number z.
        /// https://reference.wolfram.com/language/ref/Arg.html
        ///</summary>
        corewolf::engine *Arg(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Arg[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a position xmax at which f is maximized.
        /// https://reference.wolfram.com/language/ref/ArgMax.html
        ///</summary>
        corewolf::engine *ArgMax(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ArgMax[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a position {xmax,ymax,…} at which f is maximized.
        /// https://reference.wolfram.com/language/ref/ArgMax.html
        ///</summary>
        corewolf::engine *ArgMax(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ArgMax[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a position at which f is maximized subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/ArgMax.html
        ///</summary>
        corewolf::engine *ArgMax(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ArgMax[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// constrains variables to the domain dom, typically Reals or Integers.
        /// https://reference.wolfram.com/language/ref/ArgMax.html
        ///</summary>
        corewolf::engine *ArgMax(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ArgMax[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a position xmin at which f is minimized.
        /// https://reference.wolfram.com/language/ref/ArgMin.html
        ///</summary>
        corewolf::engine *ArgMin(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ArgMin[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a position {xmin,ymin,…} at which f is minimized.
        /// https://reference.wolfram.com/language/ref/ArgMin.html
        ///</summary>
        corewolf::engine *ArgMin(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ArgMin[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a position at which f is minimized subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/ArgMin.html
        ///</summary>
        corewolf::engine *ArgMin(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ArgMin[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// constrains variables to the domain dom, typically Reals or Integers.
        /// https://reference.wolfram.com/language/ref/ArgMin.html
        ///</summary>
        corewolf::engine *ArgMin(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ArgMin[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tries to separate args into a list of n positional arguments followed by a list of valid options for f.
        /// https://reference.wolfram.com/language/ref/ArgumentsOptions.html
        ///</summary>
        corewolf::engine *ArgumentsOptions(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ArgumentsOptions[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// requires the number of positional arguments to be between min and max.
        /// https://reference.wolfram.com/language/ref/ArgumentsOptions.html
        ///</summary>
        corewolf::engine *ArgumentsOptions(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ArgumentsOptions[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// modifies the behavior based on the information in the association assoc.
        /// https://reference.wolfram.com/language/ref/ArgumentsOptions.html
        ///</summary>
        corewolf::engine *ArgumentsOptions(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ArgumentsOptions[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an autoregressive integrated moving-average process  such that its  difference is a weakly stationary ARMAProcess[{a1,…,ap},{b1,…,bq},v].
        /// https://reference.wolfram.com/language/ref/ARIMAProcess.html
        ///</summary>
        corewolf::engine *ARIMAProcess(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ARIMAProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a vector ARIMA process (y1(t),… ,yn(t)) such that its (d1,…,dn) difference is a vector weakly stationary ARMAProcess.
        /// https://reference.wolfram.com/language/ref/ARIMAProcess.html
        ///</summary>
        corewolf::engine *ARIMAProcess(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ARIMAProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an ARIMA process with initial data init.
        /// https://reference.wolfram.com/language/ref/ARIMAProcess.html
        ///</summary>
        corewolf::engine *ARIMAProcess(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("ARIMAProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// represents an ARIMA process with a constant c.
        /// https://reference.wolfram.com/language/ref/ARIMAProcess.html
        ///</summary>
        corewolf::engine *ARIMAProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ARIMAProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the arithmetic‐geometric mean of a and b.
        /// https://reference.wolfram.com/language/ref/ArithmeticGeometricMean.html
        ///</summary>
        corewolf::engine *ArithmeticGeometricMean(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ArithmeticGeometricMean[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a weakly stationary autoregressive moving-average process with AR coefficients ai, MA coefficients bj, and normal white noise variance v.
        /// https://reference.wolfram.com/language/ref/ARMAProcess.html
        ///</summary>
        corewolf::engine *ARMAProcess(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ARMAProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an ARMA process with initial data init.
        /// https://reference.wolfram.com/language/ref/ARMAProcess.html
        ///</summary>
        corewolf::engine *ARMAProcess(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ARMAProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an ARMA process with a constant c.
        /// https://reference.wolfram.com/language/ref/ARMAProcess.html
        ///</summary>
        corewolf::engine *ARMAProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ARMAProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an approximate number or quantity with a value around x and an uncertainty δ.
        /// https://reference.wolfram.com/language/ref/Around.html
        ///</summary>
        corewolf::engine *Around(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Around[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a number or quantity with a value around x and asymmetric uncertainties δ-, δ+.
        /// https://reference.wolfram.com/language/ref/Around.html
        ///</summary>
        corewolf::engine *Around(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Around[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives an approximate number or quantity around the mean of the distribution dist, with an uncertainty corresponding to the standard deviation of the distribution.
        /// https://reference.wolfram.com/language/ref/Around.html
        ///</summary>
        corewolf::engine *Around(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Around[" + arg0 + "]", name);
        }

        ///< summary>
        /// propagates uncertainty in expr by replacing all occurrences of si by Around[xi,δi].
        /// https://reference.wolfram.com/language/ref/AroundReplace.html
        ///</summary>
        corewolf::engine *AroundReplace(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AroundReplace[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// propagates uncertainty in expr using a series expansion to order n.
        /// https://reference.wolfram.com/language/ref/AroundReplace.html
        ///</summary>
        corewolf::engine *AroundReplace(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AroundReplace[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a weakly stationary autoregressive process of order p with normal white noise variance v.
        /// https://reference.wolfram.com/language/ref/ARProcess.html
        ///</summary>
        corewolf::engine *ARProcess(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ARProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an AR process with initial data init.
        /// https://reference.wolfram.com/language/ref/ARProcess.html
        ///</summary>
        corewolf::engine *ARProcess(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ARProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an AR process with a constant c.
        /// https://reference.wolfram.com/language/ref/ARProcess.html
        ///</summary>
        corewolf::engine *ARProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ARProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a list of length n, with elements f[i].
        /// https://reference.wolfram.com/language/ref/Array.html
        ///</summary>
        corewolf::engine *Array(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Array[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a list using the index origin r.
        /// https://reference.wolfram.com/language/ref/Array.html
        ///</summary>
        corewolf::engine *Array(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Array[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a list using n values from a to b.
        /// https://reference.wolfram.com/language/ref/Array.html
        ///</summary>
        corewolf::engine *Array(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Array[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates an n1×n2×… array of nested lists, with elements f[i1,i2,…].
        /// https://reference.wolfram.com/language/ref/Array.html
        ///</summary>
        corewolf::engine *Array(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Array[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a list using the index origins ri (default 1).
        /// https://reference.wolfram.com/language/ref/Array.html
        ///</summary>
        corewolf::engine *Array(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Array[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates a list using ni values from ai to bi.
        /// https://reference.wolfram.com/language/ref/Array.html
        ///</summary>
        corewolf::engine *Array(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("Array[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// uses head h, rather than List, for each level of the array.
        /// https://reference.wolfram.com/language/ref/Array.html
        ///</summary>
        corewolf::engine *Array(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Array[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives an array in which all identical elements of array are replaced by an integer index representing the component in which the element lies.
        /// https://reference.wolfram.com/language/ref/ArrayComponents.html
        ///</summary>
        corewolf::engine *ArrayComponents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArrayComponents[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds the identical elements at the specified level in array
        /// https://reference.wolfram.com/language/ref/ArrayComponents.html
        ///</summary>
        corewolf::engine *ArrayComponents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ArrayComponents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses a rule or a list of rules for specifying the labels.
        /// https://reference.wolfram.com/language/ref/ArrayComponents.html
        ///</summary>
        corewolf::engine *ArrayComponents(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ArrayComponents[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the depth to which expr is a full array, with all the parts at a particular level having the same length.
        /// https://reference.wolfram.com/language/ref/ArrayDepth.html
        ///</summary>
        corewolf::engine *ArrayDepth(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArrayDepth[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies f to all range-r blocks in the specified array.
        /// https://reference.wolfram.com/language/ref/ArrayFilter.html
        ///</summary>
        corewolf::engine *ArrayFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ArrayFilter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies f to blocks with ranges r1, r2, … in successive dimensions.
        /// https://reference.wolfram.com/language/ref/ArrayFilter.html
        ///</summary>
        corewolf::engine *ArrayFilter(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ArrayFilter[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// creates a single flattened matrix from a matrix of matrices mi j.
        /// https://reference.wolfram.com/language/ref/ArrayFlatten.html
        ///</summary>
        corewolf::engine *ArrayFlatten(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ArrayFlatten[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// flattens out r pairs of levels in the array a.
        /// https://reference.wolfram.com/language/ref/ArrayFlatten.html
        ///</summary>
        corewolf::engine *ArrayFlatten(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ArrayFlatten[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a mesh region from an array of rank d in which each cell has a geometric dimension d and represents a nonzero value of the array.
        /// https://reference.wolfram.com/language/ref/ArrayMesh.html
        ///</summary>
        corewolf::engine *ArrayMesh(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArrayMesh[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an array with m zeros of padding on every side.
        /// https://reference.wolfram.com/language/ref/ArrayPad.html
        ///</summary>
        corewolf::engine *ArrayPad(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ArrayPad[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the specified padding.
        /// https://reference.wolfram.com/language/ref/ArrayPad.html
        ///</summary>
        corewolf::engine *ArrayPad(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ArrayPad[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// pads with m elements at the beginning and n elements at the end.
        /// https://reference.wolfram.com/language/ref/ArrayPad.html
        ///</summary>
        corewolf::engine *ArrayPad(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ArrayPad[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// pads with mi, ni elements at level i in array.
        /// https://reference.wolfram.com/language/ref/ArrayPad.html
        ///</summary>
        corewolf::engine *ArrayPad(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ArrayPad[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// generates a plot in which the values in an array are shown in a discrete array of squares.
        /// https://reference.wolfram.com/language/ref/ArrayPlot.html
        ///</summary>
        corewolf::engine *ArrayPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArrayPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a plot in which the values in an array are shown in a discrete array of cubes.
        /// https://reference.wolfram.com/language/ref/ArrayPlot3D.html
        ///</summary>
        corewolf::engine *ArrayPlot3D(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArrayPlot3D[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if expr is a full array or a SparseArray object, and gives False otherwise.
        /// https://reference.wolfram.com/language/ref/ArrayQ.html
        ///</summary>
        corewolf::engine *ArrayQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArrayQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// requires expr to be a full array with a depth that matches the pattern patt.
        /// https://reference.wolfram.com/language/ref/ArrayQ.html
        ///</summary>
        corewolf::engine *ArrayQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ArrayQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// requires also that test yield True when applied to each of the array elements in expr.
        /// https://reference.wolfram.com/language/ref/ArrayQ.html
        ///</summary>
        corewolf::engine *ArrayQ(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ArrayQ[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// reduces dimension n of array by applying f.
        /// https://reference.wolfram.com/language/ref/ArrayReduce.html
        ///</summary>
        corewolf::engine *ArrayReduce(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ArrayReduce[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// reduces dimensions n1, n2, etc.
        /// https://reference.wolfram.com/language/ref/ArrayReduce.html
        ///</summary>
        corewolf::engine *ArrayReduce(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ArrayReduce[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// applies f to arrays formed by combining all dimensions nij to make each dimension i.
        /// https://reference.wolfram.com/language/ref/ArrayReduce.html
        ///</summary>
        corewolf::engine *ArrayReduce(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("ArrayReduce[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// resamples array to have dimensions {n1,n2,…}.
        /// https://reference.wolfram.com/language/ref/ArrayResample.html
        ///</summary>
        corewolf::engine *ArrayResample(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ArrayResample[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// resamples array according to the dimension specification dspec.
        /// https://reference.wolfram.com/language/ref/ArrayResample.html
        ///</summary>
        corewolf::engine *ArrayResample(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ArrayResample[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies resampling scheme, either point or bin based.
        /// https://reference.wolfram.com/language/ref/ArrayResample.html
        ///</summary>
        corewolf::engine *ArrayResample(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ArrayResample[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// resamples only the data in the specified subrange {{xmin,xmax},…}.
        /// https://reference.wolfram.com/language/ref/ArrayResample.html
        ///</summary>
        corewolf::engine *ArrayResample(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("ArrayResample[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// arranges the elements of list into a rectangular array with dimensions dims.
        /// https://reference.wolfram.com/language/ref/ArrayReshape.html
        ///</summary>
        corewolf::engine *ArrayReshape(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ArrayReshape[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the specified padding if list does not contain enough elements.
        /// https://reference.wolfram.com/language/ref/ArrayReshape.html
        ///</summary>
        corewolf::engine *ArrayReshape(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ArrayReshape[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the rules {pos1val1,pos2val2,…} specifying elements in a sparse array.
        /// https://reference.wolfram.com/language/ref/ArrayRules.html
        ///</summary>
        corewolf::engine *ArrayRules(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ArrayRules[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the domain of arrays of rank r and dimensions di.
        /// https://reference.wolfram.com/language/ref/Arrays.html
        ///</summary>
        corewolf::engine *Arrays(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Arrays[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the domain of arrays of dimensions di, with components in the domain dom.
        /// https://reference.wolfram.com/language/ref/Arrays.html
        ///</summary>
        corewolf::engine *Arrays(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Arrays[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the subdomain of arrays with dimensions di and symmetry sym.
        /// https://reference.wolfram.com/language/ref/Arrays.html
        ///</summary>
        corewolf::engine *Arrays(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Arrays[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a graphics primitive that represents an arrow from pt1 to pt2.
        /// https://reference.wolfram.com/language/ref/Arrow.html
        ///</summary>
        corewolf::engine *Arrow(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Arrow[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents an arrow with its ends set back from pt1 and pt2 by a distance s.
        /// https://reference.wolfram.com/language/ref/Arrow.html
        ///</summary>
        corewolf::engine *Arrow(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Arrow[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sets back by s1 from pt1 and s2 from pt2.
        /// https://reference.wolfram.com/language/ref/Arrow.html
        ///</summary>
        corewolf::engine *Arrow(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Arrow[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an arrow following the specified curve.
        /// https://reference.wolfram.com/language/ref/Arrow.html
        ///</summary>
        corewolf::engine *Arrow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Arrow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a graphics directive specifying that arrows that follow should have arrowheads with sizes, positions, and forms specified by spec.
        /// https://reference.wolfram.com/language/ref/Arrowheads.html
        ///</summary>
        corewolf::engine *Arrowheads(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Arrowheads[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a filled triangle with angles α and β and side length c, and c is adjacent to both angles.
        /// https://reference.wolfram.com/language/ref/ASATriangle.html
        ///</summary>
        corewolf::engine *ASATriangle(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ASATriangle[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a construct for use inside AskFunction that gives the value associated with key, or interactively asks for it if it is not already known.
        /// https://reference.wolfram.com/language/ref/Ask.html
        ///</summary>
        corewolf::engine *Ask(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Ask[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the values associated with all the keyi, interactively asking for any that are needed.
        /// https://reference.wolfram.com/language/ref/Ask.html
        ///</summary>
        corewolf::engine *Ask(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Ask[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// is a construct for use inside AskFunction that asks for a new value, appends it to the current value associated with "key", and returns the resulting list.
        /// https://reference.wolfram.com/language/ref/AskAppend.html
        ///</summary>
        corewolf::engine *AskAppend(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AskAppend[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a construct for use inside AskFunction that asks for confirmation of the current value associated with "key" and allows this to be either confirmed or changed.
        /// https://reference.wolfram.com/language/ref/AskConfirm.html
        ///</summary>
        corewolf::engine *AskConfirm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AskConfirm[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies the function fun to determine how to ask for confirmation.
        /// https://reference.wolfram.com/language/ref/AskConfirm.html
        ///</summary>
        corewolf::engine *AskConfirm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AskConfirm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a construct for use inside AskFunction that displays the result of evaluating expr in the context of the AskFunction.
        /// https://reference.wolfram.com/language/ref/AskDisplay.html
        ///</summary>
        corewolf::engine *AskDisplay(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AskDisplay[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a construct for use inside AskFunction that gives True if a value is currently associated with key, and False otherwise.
        /// https://reference.wolfram.com/language/ref/AskedQ.html
        ///</summary>
        corewolf::engine *AskedQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AskedQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a construct for use inside AskFunction that gives the value associated with key, or Missing[…] if none has been provided.
        /// https://reference.wolfram.com/language/ref/AskedValue.html
        ///</summary>
        corewolf::engine *AskedValue(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AskedValue[" + arg0 + "]", name);
        }

        ///< summary>
        /// evaluates body, interactively asking for values specified by Ask[…] and related constructs.
        /// https://reference.wolfram.com/language/ref/AskFunction.html
        ///</summary>
        corewolf::engine *AskFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AskFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies how values associated with the keyi should be asked for.
        /// https://reference.wolfram.com/language/ref/AskFunction.html
        ///</summary>
        corewolf::engine *AskFunction(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AskFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a construct for use inside AskFunction that returns an association of all values in the current state of the AskFunction.
        /// https://reference.wolfram.com/language/ref/AskState.html
        ///</summary>
        corewolf::engine *AskState(const std::string &name = "")
        {
            return this->execute("AskState[]", name);
        }

        ///< summary>
        /// is a construct for use inside AskFunction that displays the result of applying fun to the association of the values of all keys encountered so far in the evaluation of the AskFunction.
        /// https://reference.wolfram.com/language/ref/AskTemplateDisplay.html
        ///</summary>
        corewolf::engine *AskTemplateDisplay(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AskTemplateDisplay[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the assertion that test is True. If assertions have been enabled, test is evaluated when the assertion is encountered. If test is not True, then an assertion failure is generated.
        /// https://reference.wolfram.com/language/ref/Assert.html
        ///</summary>
        corewolf::engine *Assert(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Assert[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies a tag that will be used to identify the assertion if it fails.
        /// https://reference.wolfram.com/language/ref/Assert.html
        ///</summary>
        corewolf::engine *Assert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Assert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a tool for assessing whether answers are correct according to the key.
        /// https://reference.wolfram.com/language/ref/AssessmentFunction.html
        ///</summary>
        corewolf::engine *AssessmentFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AssessmentFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the specified answer comparison method.
        /// https://reference.wolfram.com/language/ref/AssessmentFunction.html
        ///</summary>
        corewolf::engine *AssessmentFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AssessmentFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// assesses the specified question within the CloudObject obj.
        /// https://reference.wolfram.com/language/ref/AssessmentFunction.html
        ///</summary>
        corewolf::engine *AssessmentFunction(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AssessmentFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the results of an assessment.
        /// https://reference.wolfram.com/language/ref/AssessmentResultObject.html
        ///</summary>
        corewolf::engine *AssessmentResultObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AssessmentResultObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a collection of many assessments.
        /// https://reference.wolfram.com/language/ref/AssessmentResultObject.html
        ///</summary>
        corewolf::engine *AssessmentResultObject(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AssessmentResultObject[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// changes the association a by adding the key-value pair keyval.
        /// https://reference.wolfram.com/language/ref/AssociateTo.html
        ///</summary>
        corewolf::engine *AssociateTo(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AssociateTo[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// adds all key-value pairs keyivali.
        /// https://reference.wolfram.com/language/ref/AssociateTo.html
        ///</summary>
        corewolf::engine *AssociateTo(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AssociateTo[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// creates the association key1f[key1],key2f[key2],….
        /// https://reference.wolfram.com/language/ref/AssociationMap.html
        ///</summary>
        corewolf::engine *AssociationMap(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AssociationMap[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// creates the association f[key1val1],f[key2val2],….
        /// https://reference.wolfram.com/language/ref/AssociationMap.html
        ///</summary>
        corewolf::engine *AssociationMap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("AssociationMap[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an operator form of AssociationMap that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/AssociationMap.html
        ///</summary>
        corewolf::engine *AssociationMap(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AssociationMap[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if expr is a valid Association object, and False otherwise.
        /// https://reference.wolfram.com/language/ref/AssociationQ.html
        ///</summary>
        corewolf::engine *AssociationQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AssociationQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the association key1val1,key2val2,….
        /// https://reference.wolfram.com/language/ref/AssociationThread.html
        ///</summary>
        corewolf::engine *AssociationThread(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AssociationThread[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// also gives the association key1val1,key2val2,….
        /// https://reference.wolfram.com/language/ref/AssociationThread.html
        ///</summary>
        corewolf::engine *AssociationThread(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AssociationThread[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates expr with assum appended to $Assumptions, so that assum is included in the default assumptions used by functions such as Refine, Simplify, and Integrate.
        /// https://reference.wolfram.com/language/ref/Assuming.html
        ///</summary>
        corewolf::engine *Assuming(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Assuming[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an asymptotic approximation for expr near x0.
        /// https://reference.wolfram.com/language/ref/Asymptotic.html
        ///</summary>
        corewolf::engine *Asymptotic(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Asymptotic[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an asymptotic approximation for expr near x0 to order n.
        /// https://reference.wolfram.com/language/ref/Asymptotic.html
        ///</summary>
        corewolf::engine *Asymptotic(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Asymptotic[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// computes an asymptotic approximation to the differential equation eqn for f[x] centered at x0.
        /// https://reference.wolfram.com/language/ref/AsymptoticDSolveValue.html
        ///</summary>
        corewolf::engine *AsymptoticDSolveValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticDSolveValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes an asymptotic approximation to a system of differential equations.
        /// https://reference.wolfram.com/language/ref/AsymptoticDSolveValue.html
        ///</summary>
        corewolf::engine *AsymptoticDSolveValue(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticDSolveValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes an asymptotic approximation of f[x,ϵ] for the parameter ϵ centered at ϵ0.
        /// https://reference.wolfram.com/language/ref/AsymptoticDSolveValue.html
        ///</summary>
        corewolf::engine *AsymptoticDSolveValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("AsymptoticDSolveValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// computes the asymptotic approximation to order n.
        /// https://reference.wolfram.com/language/ref/AsymptoticDSolveValue.html
        ///</summary>
        corewolf::engine *AsymptoticDSolveValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("AsymptoticDSolveValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// gives conditions for  or  as xx*.
        /// https://reference.wolfram.com/language/ref/AsymptoticEqual.html
        ///</summary>
        corewolf::engine *AsymptoticEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives conditions for  or  as {x1,…,xn}{,…,}.
        /// https://reference.wolfram.com/language/ref/AsymptoticEqual.html
        ///</summary>
        corewolf::engine *AsymptoticEqual(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticEqual[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives conditions for  as xx*.
        /// https://reference.wolfram.com/language/ref/AsymptoticEquivalent.html
        ///</summary>
        corewolf::engine *AsymptoticEquivalent(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticEquivalent[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives conditions for  as {x1,…,xn}{,…,}.
        /// https://reference.wolfram.com/language/ref/AsymptoticEquivalent.html
        ///</summary>
        corewolf::engine *AsymptoticEquivalent(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticEquivalent[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// computes an asymptotic approximation for the expectation of expr centered at a0, under the assumption that x follows the probability distribution dist.
        /// https://reference.wolfram.com/language/ref/AsymptoticExpectation.html
        ///</summary>
        corewolf::engine *AsymptoticExpectation(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticExpectation[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes the asymptotic expectation to order n.
        /// https://reference.wolfram.com/language/ref/AsymptoticExpectation.html
        ///</summary>
        corewolf::engine *AsymptoticExpectation(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticExpectation[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives conditions for  or  as xx*.
        /// https://reference.wolfram.com/language/ref/AsymptoticGreater.html
        ///</summary>
        corewolf::engine *AsymptoticGreater(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticGreater[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives conditions for  or  as .
        /// https://reference.wolfram.com/language/ref/AsymptoticGreater.html
        ///</summary>
        corewolf::engine *AsymptoticGreater(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticGreater[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives conditions for  or  as xx*.
        /// https://reference.wolfram.com/language/ref/AsymptoticGreaterEqual.html
        ///</summary>
        corewolf::engine *AsymptoticGreaterEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticGreaterEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives conditions for  or  as {x1,…,xn}{,…,}.
        /// https://reference.wolfram.com/language/ref/AsymptoticGreaterEqual.html
        ///</summary>
        corewolf::engine *AsymptoticGreaterEqual(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticGreaterEqual[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// computes an asymptotic approximation of the indefinite integral  for x centered at x0.
        /// https://reference.wolfram.com/language/ref/AsymptoticIntegrate.html
        ///</summary>
        corewolf::engine *AsymptoticIntegrate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticIntegrate[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes an asymptotic approximation of the definite integral  for α centered at α0.
        /// https://reference.wolfram.com/language/ref/AsymptoticIntegrate.html
        ///</summary>
        corewolf::engine *AsymptoticIntegrate(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticIntegrate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes the asymptotic approximation to order n.
        /// https://reference.wolfram.com/language/ref/AsymptoticIntegrate.html
        ///</summary>
        corewolf::engine *AsymptoticIntegrate(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticIntegrate[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives conditions for  or  as xx*.
        /// https://reference.wolfram.com/language/ref/AsymptoticLess.html
        ///</summary>
        corewolf::engine *AsymptoticLess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticLess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives conditions for  or  as {x1,…,xn}{,…,}.
        /// https://reference.wolfram.com/language/ref/AsymptoticLess.html
        ///</summary>
        corewolf::engine *AsymptoticLess(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticLess[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives conditions for  or  as xx*.
        /// https://reference.wolfram.com/language/ref/AsymptoticLessEqual.html
        ///</summary>
        corewolf::engine *AsymptoticLessEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticLessEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives conditions for  or  as {x1,…,xn}{,…,}.
        /// https://reference.wolfram.com/language/ref/AsymptoticLessEqual.html
        ///</summary>
        corewolf::engine *AsymptoticLessEqual(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticLessEqual[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the state feedback control law that causes the outputs of the affine system sys to track the reference signals fi with decay rates pj.
        /// https://reference.wolfram.com/language/ref/AsymptoticOutputTracker.html
        ///</summary>
        corewolf::engine *AsymptoticOutputTracker(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticOutputTracker[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// specifies outputs outi and control inputs inj to use.
        /// https://reference.wolfram.com/language/ref/AsymptoticOutputTracker.html
        ///</summary>
        corewolf::engine *AsymptoticOutputTracker(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("AsymptoticOutputTracker[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// computes an asymptotic approximation for the probability of pred centered at a0, under the assumption that x follows the probability distribution dist.
        /// https://reference.wolfram.com/language/ref/AsymptoticProbability.html
        ///</summary>
        corewolf::engine *AsymptoticProbability(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticProbability[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes the asymptotic probability to order n.
        /// https://reference.wolfram.com/language/ref/AsymptoticProbability.html
        ///</summary>
        corewolf::engine *AsymptoticProbability(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticProbability[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// computes an asymptotic approximation of the indefinite product  for x near x0.
        /// https://reference.wolfram.com/language/ref/AsymptoticProduct.html
        ///</summary>
        corewolf::engine *AsymptoticProduct(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticProduct[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes an asymptotic approximation of the definite product  for α near α0.
        /// https://reference.wolfram.com/language/ref/AsymptoticProduct.html
        ///</summary>
        corewolf::engine *AsymptoticProduct(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticProduct[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes the asymptotic approximation to order n.
        /// https://reference.wolfram.com/language/ref/AsymptoticProduct.html
        ///</summary>
        corewolf::engine *AsymptoticProduct(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticProduct[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// computes an asymptotic approximation to the difference equation eqn for f[x] near .
        /// https://reference.wolfram.com/language/ref/AsymptoticRSolveValue.html
        ///</summary>
        corewolf::engine *AsymptoticRSolveValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticRSolveValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes an asymptotic approximation to a system of difference equations.
        /// https://reference.wolfram.com/language/ref/AsymptoticRSolveValue.html
        ///</summary>
        corewolf::engine *AsymptoticRSolveValue(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticRSolveValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes an asymptotic approximation of f[x,ϵ] for the parameter ϵ centered at ϵ0.
        /// https://reference.wolfram.com/language/ref/AsymptoticRSolveValue.html
        ///</summary>
        corewolf::engine *AsymptoticRSolveValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("AsymptoticRSolveValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// computes the asymptotic approximation to order n.
        /// https://reference.wolfram.com/language/ref/AsymptoticRSolveValue.html
        ///</summary>
        corewolf::engine *AsymptoticRSolveValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("AsymptoticRSolveValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// computes asymptotic approximations of solutions y[x] of the equation eqn passing through {a,b}.
        /// https://reference.wolfram.com/language/ref/AsymptoticSolve.html
        ///</summary>
        corewolf::engine *AsymptoticSolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticSolve[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes asymptotic approximations of solutions y[x] of the equation eqn for x near a.
        /// https://reference.wolfram.com/language/ref/AsymptoticSolve.html
        ///</summary>
        corewolf::engine *AsymptoticSolve(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticSolve[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes asymptotic approximations of solutions {y1[x1,x2,…],y2[x1,x2,…],…} of the system of equations eqns.
        /// https://reference.wolfram.com/language/ref/AsymptoticSolve.html
        ///</summary>
        corewolf::engine *AsymptoticSolve(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticSolve[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// computes the asymptotic approximation to order n.
        /// https://reference.wolfram.com/language/ref/AsymptoticSolve.html
        ///</summary>
        corewolf::engine *AsymptoticSolve(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("AsymptoticSolve[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// computes only solutions that are real valued for real argument values.
        /// https://reference.wolfram.com/language/ref/AsymptoticSolve.html
        ///</summary>
        corewolf::engine *AsymptoticSolve(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AsymptoticSolve[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes an asymptotic approximation of the indefinite sum  for x centered at x0.
        /// https://reference.wolfram.com/language/ref/AsymptoticSum.html
        ///</summary>
        corewolf::engine *AsymptoticSum(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticSum[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes an asymptotic approximation of the definite sum  for α centered at α0.
        /// https://reference.wolfram.com/language/ref/AsymptoticSum.html
        ///</summary>
        corewolf::engine *AsymptoticSum(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticSum[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes the asymptotic approximation to order n.
        /// https://reference.wolfram.com/language/ref/AsymptoticSum.html
        ///</summary>
        corewolf::engine *AsymptoticSum(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AsymptoticSum[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents an atom with atomic symbol "sym".
        /// https://reference.wolfram.com/language/ref/Atom.html
        ///</summary>
        corewolf::engine *Atom(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Atom[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an atom with atomic symbol "sym" and specified properties.
        /// https://reference.wolfram.com/language/ref/Atom.html
        ///</summary>
        corewolf::engine *Atom(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Atom[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the number of atoms in the molecule represented by mol.
        /// https://reference.wolfram.com/language/ref/AtomCount.html
        ///</summary>
        corewolf::engine *AtomCount(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AtomCount[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number of atoms in the molecule mol matching the atom pattern patt.
        /// https://reference.wolfram.com/language/ref/AtomCount.html
        ///</summary>
        corewolf::engine *AtomCount(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AtomCount[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of atoms in the molecule represented by mol.
        /// https://reference.wolfram.com/language/ref/AtomList.html
        ///</summary>
        corewolf::engine *AtomList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AtomList[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the list of atoms in the molecule mol matching the atom pattern patt.
        /// https://reference.wolfram.com/language/ref/AtomList.html
        ///</summary>
        corewolf::engine *AtomList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AtomList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value for the specified property of the atoms matching patt.
        /// https://reference.wolfram.com/language/ref/AtomList.html
        ///</summary>
        corewolf::engine *AtomList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AtomList[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields True if expr is an expression which cannot be divided into subexpressions, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/AtomQ.html
        ///</summary>
        corewolf::engine *AtomQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AtomQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes expr a cell attached to the current cell being evaluated.
        /// https://reference.wolfram.com/language/ref/AttachCell.html
        ///</summary>
        corewolf::engine *AttachCell(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AttachCell[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes expr a cell attached to the notebook, cell or box const std::string &obj.
        /// https://reference.wolfram.com/language/ref/AttachCell.html
        ///</summary>
        corewolf::engine *AttachCell(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AttachCell[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies that the attached cell should be at position pos relative to obj.
        /// https://reference.wolfram.com/language/ref/AttachCell.html
        ///</summary>
        corewolf::engine *AttachCell(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AttachCell[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// specifies that the attached cell should be at a distance dist from pos.
        /// https://reference.wolfram.com/language/ref/AttachCell.html
        ///</summary>
        corewolf::engine *AttachCell(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("AttachCell[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// aligns the attached cell so that position opos in expr lies at distance dist from location pos.
        /// https://reference.wolfram.com/language/ref/AttachCell.html
        ///</summary>
        corewolf::engine *AttachCell(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("AttachCell[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// represents a trainable net layer that learns to pay attention to certain portions of its input.
        /// https://reference.wolfram.com/language/ref/AttentionLayer.html
        ///</summary>
        corewolf::engine *AttentionLayer(const std::string &name = "")
        {
            return this->execute("AttentionLayer[]", name);
        }

        ///< summary>
        /// specifies a particular net to give scores for portions of the input.
        /// https://reference.wolfram.com/language/ref/AttentionLayer.html
        ///</summary>
        corewolf::engine *AttentionLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AttentionLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// includes options for weight normalization, masking and other parameters.
        /// https://reference.wolfram.com/language/ref/AttentionLayer.html
        ///</summary>
        corewolf::engine *AttentionLayer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AttentionLayer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of attributes for a symbol.
        /// https://reference.wolfram.com/language/ref/Attributes.html
        ///</summary>
        corewolf::engine *Attributes(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Attributes[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of the attributes for each of the si.
        /// https://reference.wolfram.com/language/ref/Attributes.html
        ///</summary>
        corewolf::engine *Attributes(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Attributes[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents audio stored in the given file.
        /// https://reference.wolfram.com/language/ref/Audio.html
        ///</summary>
        corewolf::engine *Audio(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Audio[" + arg0 + "]", name);
        }

        ///< summary>
        /// multiplies all samples of audio by a factor s.
        /// https://reference.wolfram.com/language/ref/AudioAmplify.html
        ///</summary>
        corewolf::engine *AudioAmplify(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioAmplify[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes the property prop and adds it as an annotation to audio.
        /// https://reference.wolfram.com/language/ref/AudioAnnotate.html
        ///</summary>
        corewolf::engine *AudioAnnotate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioAnnotate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives all annotations associated to audio.
        /// https://reference.wolfram.com/language/ref/AudioAnnotationLookup.html
        ///</summary>
        corewolf::engine *AudioAnnotationLookup(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioAnnotationLookup[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the annotations specified by tags.
        /// https://reference.wolfram.com/language/ref/AudioAnnotationLookup.html
        ///</summary>
        corewolf::engine *AudioAnnotationLookup(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioAnnotationLookup[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// formats each annotation element according to format.
        /// https://reference.wolfram.com/language/ref/AudioAnnotationLookup.html
        ///</summary>
        corewolf::engine *AudioAnnotationLookup(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AudioAnnotationLookup[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies f to non-overlapping partitions of length dur in audio.
        /// https://reference.wolfram.com/language/ref/AudioBlockMap.html
        ///</summary>
        corewolf::engine *AudioBlockMap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AudioBlockMap[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies f to partitions with offset offset in audio.
        /// https://reference.wolfram.com/language/ref/AudioBlockMap.html
        ///</summary>
        corewolf::engine *AudioBlockMap(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AudioBlockMap[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// creates a temporary interactive interface for capturing an audio signal.
        /// https://reference.wolfram.com/language/ref/AudioCapture.html
        ///</summary>
        corewolf::engine *AudioCapture(const std::string &name = "")
        {
            return this->execute("AudioCapture[]", name);
        }

        ///< summary>
        /// captures an audio signal into file.
        /// https://reference.wolfram.com/language/ref/AudioCapture.html
        ///</summary>
        corewolf::engine *AudioCapture(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioCapture[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a multichannel audio const std::string &by combining the sequence of channels in audioi.
        /// https://reference.wolfram.com/language/ref/AudioChannelCombine.html
        ///</summary>
        corewolf::engine *AudioChannelCombine(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AudioChannelCombine[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// mixes channels of audio by averaging and returns a center-panned stereo audio object.
        /// https://reference.wolfram.com/language/ref/AudioChannelMix.html
        ///</summary>
        corewolf::engine *AudioChannelMix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioChannelMix[" + arg0 + "]", name);
        }

        ///< summary>
        /// mixes audio channels into the specified desttype.
        /// https://reference.wolfram.com/language/ref/AudioChannelMix.html
        ///</summary>
        corewolf::engine *AudioChannelMix(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioChannelMix[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the number of channels in the Audio const std::string &audio.
        /// https://reference.wolfram.com/language/ref/AudioChannels.html
        ///</summary>
        corewolf::engine *AudioChannels(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioChannels[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of Audio objects, each of which represents one channel of audio.
        /// https://reference.wolfram.com/language/ref/AudioChannelSeparate.html
        ///</summary>
        corewolf::engine *AudioChannelSeparate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioChannelSeparate[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the specified channel from audio.
        /// https://reference.wolfram.com/language/ref/AudioChannelSeparate.html
        ///</summary>
        corewolf::engine *AudioChannelSeparate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioChannelSeparate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an array of audio samples.
        /// https://reference.wolfram.com/language/ref/AudioData.html
        ///</summary>
        corewolf::engine *AudioData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an array of audio samples converted to the specified "type".
        /// https://reference.wolfram.com/language/ref/AudioData.html
        ///</summary>
        corewolf::engine *AudioData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates audio by adding repeated decaying echos to audio spaced by the specified delay.
        /// https://reference.wolfram.com/language/ref/AudioDelay.html
        ///</summary>
        corewolf::engine *AudioDelay(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioDelay[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the specified feedback as the amount of signal to preserve during each repetition.
        /// https://reference.wolfram.com/language/ref/AudioDelay.html
        ///</summary>
        corewolf::engine *AudioDelay(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AudioDelay[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses mix to control the ratio between original and delayed audio.
        /// https://reference.wolfram.com/language/ref/AudioDelay.html
        ///</summary>
        corewolf::engine *AudioDelay(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("AudioDelay[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// deletes the first t seconds of audio.
        /// https://reference.wolfram.com/language/ref/AudioDelete.html
        ///</summary>
        corewolf::engine *AudioDelete(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioDelete[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// deletes from time t1 to time t2, returning the remaining audio as a single Audio object.
        /// https://reference.wolfram.com/language/ref/AudioDelete.html
        ///</summary>
        corewolf::engine *AudioDelete(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AudioDelete[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns a distance measure between audio1 and audio2.
        /// https://reference.wolfram.com/language/ref/AudioDistance.html
        ///</summary>
        corewolf::engine *AudioDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns audio in which the beginning and end of audio are faded.
        /// https://reference.wolfram.com/language/ref/AudioFade.html
        ///</summary>
        corewolf::engine *AudioFade(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioFade[" + arg0 + "]", name);
        }

        ///< summary>
        /// fades the first and last t seconds of audio.
        /// https://reference.wolfram.com/language/ref/AudioFade.html
        ///</summary>
        corewolf::engine *AudioFade(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioFade[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// fades t1 seconds at the beginning and t2 seconds at the end.
        /// https://reference.wolfram.com/language/ref/AudioFade.html
        ///</summary>
        corewolf::engine *AudioFade(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AudioFade[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives audio by shifting the spectrum of audio by freq.
        /// https://reference.wolfram.com/language/ref/AudioFrequencyShift.html
        ///</summary>
        corewolf::engine *AudioFrequencyShift(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioFrequencyShift[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses mix to control the ratio between the original and shifted audio.
        /// https://reference.wolfram.com/language/ref/AudioFrequencyShift.html
        ///</summary>
        corewolf::engine *AudioFrequencyShift(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AudioFrequencyShift[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates one second of audio of a given model.
        /// https://reference.wolfram.com/language/ref/AudioGenerator.html
        ///</summary>
        corewolf::engine *AudioGenerator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioGenerator[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates t seconds of audio.
        /// https://reference.wolfram.com/language/ref/AudioGenerator.html
        ///</summary>
        corewolf::engine *AudioGenerator(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioGenerator[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates audio samples of the specified "type".
        /// https://reference.wolfram.com/language/ref/AudioGenerator.html
        ///</summary>
        corewolf::engine *AudioGenerator(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AudioGenerator[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields the result of attempting to identify what audio is a recording of.
        /// https://reference.wolfram.com/language/ref/AudioIdentify.html
        ///</summary>
        corewolf::engine *AudioIdentify(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioIdentify[" + arg0 + "]", name);
        }

        ///< summary>
        /// restricts the identification to the specified category.
        /// https://reference.wolfram.com/language/ref/AudioIdentify.html
        ///</summary>
        corewolf::engine *AudioIdentify(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioIdentify[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of up to n possible identifications.
        /// https://reference.wolfram.com/language/ref/AudioIdentify.html
        ///</summary>
        corewolf::engine *AudioIdentify(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AudioIdentify[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the specified property for each identification.
        /// https://reference.wolfram.com/language/ref/AudioIdentify.html
        ///</summary>
        corewolf::engine *AudioIdentify(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("AudioIdentify[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// inserts the audio signal new at time t.
        /// https://reference.wolfram.com/language/ref/AudioInsert.html
        ///</summary>
        corewolf::engine *AudioInsert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioInsert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// inserts multiple audio signals at different positions.
        /// https://reference.wolfram.com/language/ref/AudioInsert.html
        ///</summary>
        corewolf::engine *AudioInsert(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AudioInsert[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives True if audio sounds to be an instance of the const std::string &obj, and gives False otherwise.
        /// https://reference.wolfram.com/language/ref/AudioInstanceQ.html
        ///</summary>
        corewolf::engine *AudioInstanceQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioInstanceQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// assumes that audio is the sound of something in the category cat.
        /// https://reference.wolfram.com/language/ref/AudioInstanceQ.html
        ///</summary>
        corewolf::engine *AudioInstanceQ(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AudioInstanceQ[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns audible intervals of audio.
        /// https://reference.wolfram.com/language/ref/AudioIntervals.html
        ///</summary>
        corewolf::engine *AudioIntervals(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioIntervals[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns intervals of audio for which the criterion crit is satisfied.
        /// https://reference.wolfram.com/language/ref/AudioIntervals.html
        ///</summary>
        corewolf::engine *AudioIntervals(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioIntervals[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns only intervals larger than the given duration mindur.
        /// https://reference.wolfram.com/language/ref/AudioIntervals.html
        ///</summary>
        corewolf::engine *AudioIntervals(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AudioIntervals[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the number of samples in the Audio const std::string &audio.
        /// https://reference.wolfram.com/language/ref/AudioLength.html
        ///</summary>
        corewolf::engine *AudioLength(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioLength[" + arg0 + "]", name);
        }

        ///< summary>
        /// computes the property "prop" locally for partitions of audio.
        /// https://reference.wolfram.com/language/ref/AudioLocalMeasurements.html
        ///</summary>
        corewolf::engine *AudioLocalMeasurements(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioLocalMeasurements[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes several properties "propi".
        /// https://reference.wolfram.com/language/ref/AudioLocalMeasurements.html
        ///</summary>
        corewolf::engine *AudioLocalMeasurements(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AudioLocalMeasurements[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns the measurements in the specified output format.
        /// https://reference.wolfram.com/language/ref/AudioLocalMeasurements.html
        ///</summary>
        corewolf::engine *AudioLocalMeasurements(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AudioLocalMeasurements[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes the loudness of audio according to the EBU momentary definition.
        /// https://reference.wolfram.com/language/ref/AudioLoudness.html
        ///</summary>
        corewolf::engine *AudioLoudness(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioLoudness[" + arg0 + "]", name);
        }

        ///< summary>
        /// computes the loudness according to the definition def.
        /// https://reference.wolfram.com/language/ref/AudioLoudness.html
        ///</summary>
        corewolf::engine *AudioLoudness(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioLoudness[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes the property "prop" for the entire audio.
        /// https://reference.wolfram.com/language/ref/AudioMeasurements.html
        ///</summary>
        corewolf::engine *AudioMeasurements(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioMeasurements[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes several properties "propi".
        /// https://reference.wolfram.com/language/ref/AudioMeasurements.html
        ///</summary>
        corewolf::engine *AudioMeasurements(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AudioMeasurements[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns the values in the specified output format.
        /// https://reference.wolfram.com/language/ref/AudioMeasurements.html
        ///</summary>
        corewolf::engine *AudioMeasurements(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AudioMeasurements[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns measurements for all audioi.
        /// https://reference.wolfram.com/language/ref/AudioMeasurements.html
        ///</summary>
        corewolf::engine *AudioMeasurements(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioMeasurements[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// normalizes audio so that the maximum absolute value of its samples is 1.
        /// https://reference.wolfram.com/language/ref/AudioNormalize.html
        ///</summary>
        corewolf::engine *AudioNormalize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioNormalize[" + arg0 + "]", name);
        }

        ///< summary>
        /// normalizes the audio signal based on the specified model.
        /// https://reference.wolfram.com/language/ref/AudioNormalize.html
        ///</summary>
        corewolf::engine *AudioNormalize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioNormalize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns an audio const std::string &by overlaying all audioi.
        /// https://reference.wolfram.com/language/ref/AudioOverlay.html
        ///</summary>
        corewolf::engine *AudioOverlay(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AudioOverlay[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// adds t seconds of silence to the end of audio.
        /// https://reference.wolfram.com/language/ref/AudioPad.html
        ///</summary>
        corewolf::engine *AudioPad(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioPad[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// adds t1 seconds of silence to the beginning and t2 seconds to the end of audio.
        /// https://reference.wolfram.com/language/ref/AudioPad.html
        ///</summary>
        corewolf::engine *AudioPad(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AudioPad[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// pads using the value or method specified by padding.
        /// https://reference.wolfram.com/language/ref/AudioPad.html
        ///</summary>
        corewolf::engine *AudioPad(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AudioPad[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns a center-panned stereo audio const std::string &from a mono audio.
        /// https://reference.wolfram.com/language/ref/AudioPan.html
        ///</summary>
        corewolf::engine *AudioPan(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioPan[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a stereo audio const std::string &after panning left and right channels using the specified pan.
        /// https://reference.wolfram.com/language/ref/AudioPan.html
        ///</summary>
        corewolf::engine *AudioPan(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioPan[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// partitions an audio const std::string &into non-overlapping segments of duration dur.
        /// https://reference.wolfram.com/language/ref/AudioPartition.html
        ///</summary>
        corewolf::engine *AudioPartition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioPartition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates segments with specified offset.
        /// https://reference.wolfram.com/language/ref/AudioPartition.html
        ///</summary>
        corewolf::engine *AudioPartition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AudioPartition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// pauses the playback of all AudioStream objects.
        /// https://reference.wolfram.com/language/ref/AudioPause.html
        ///</summary>
        corewolf::engine *AudioPause(const std::string &name = "")
        {
            return this->execute("AudioPause[]", name);
        }

        ///< summary>
        /// pauses the playback of the AudioStream const std::string &astream.
        /// https://reference.wolfram.com/language/ref/AudioPause.html
        ///</summary>
        corewolf::engine *AudioPause(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioPause[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies pitch shifting to audio by the ratio r, shifting every frequency  to .
        /// https://reference.wolfram.com/language/ref/AudioPitchShift.html
        ///</summary>
        corewolf::engine *AudioPitchShift(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioPitchShift[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a new AudioStream const std::string &from audio and starts the playback.
        /// https://reference.wolfram.com/language/ref/AudioPlay.html
        ///</summary>
        corewolf::engine *AudioPlay(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioPlay[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots the waveform of audio.
        /// https://reference.wolfram.com/language/ref/AudioPlot.html
        ///</summary>
        corewolf::engine *AudioPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots waveforms of all audioi.
        /// https://reference.wolfram.com/language/ref/AudioPlot.html
        ///</summary>
        corewolf::engine *AudioPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AudioPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if audio has the form of a valid Audio object, and False otherwise.
        /// https://reference.wolfram.com/language/ref/AudioQ.html
        ///</summary>
        corewolf::engine *AudioQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a new AudioStream const std::string &and starts to record from the default input audio device.
        /// https://reference.wolfram.com/language/ref/AudioRecord.html
        ///</summary>
        corewolf::engine *AudioRecord(const std::string &name = "")
        {
            return this->execute("AudioRecord[]", name);
        }

        ///< summary>
        /// records from the input audio device inputdev.
        /// https://reference.wolfram.com/language/ref/AudioRecord.html
        ///</summary>
        corewolf::engine *AudioRecord(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioRecord[" + arg0 + "]", name);
        }

        ///< summary>
        /// replaces the audio signal between t1 and t2 with the new signal new.
        /// https://reference.wolfram.com/language/ref/AudioReplace.html
        ///</summary>
        corewolf::engine *AudioReplace(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioReplace[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces multiple intervals.
        /// https://reference.wolfram.com/language/ref/AudioReplace.html
        ///</summary>
        corewolf::engine *AudioReplace(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AudioReplace[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses the specified fitting method.
        /// https://reference.wolfram.com/language/ref/AudioReplace.html
        ///</summary>
        corewolf::engine *AudioReplace(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AudioReplace[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// resamples audio to have the sample rate of sr.
        /// https://reference.wolfram.com/language/ref/AudioResample.html
        ///</summary>
        corewolf::engine *AudioResample(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioResample[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// adds reverberation to audio.
        /// https://reference.wolfram.com/language/ref/AudioReverb.html
        ///</summary>
        corewolf::engine *AudioReverb(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioReverb[" + arg0 + "]", name);
        }

        ///< summary>
        /// adds reverberation following the room model.
        /// https://reference.wolfram.com/language/ref/AudioReverb.html
        ///</summary>
        corewolf::engine *AudioReverb(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioReverb[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// controls the mix ratio between original and reverberated audio.
        /// https://reference.wolfram.com/language/ref/AudioReverb.html
        ///</summary>
        corewolf::engine *AudioReverb(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AudioReverb[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// reverses audio so that the signal is played backward.
        /// https://reference.wolfram.com/language/ref/AudioReverse.html
        ///</summary>
        corewolf::engine *AudioReverse(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioReverse[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the sample rate of the Audio const std::string &audio.
        /// https://reference.wolfram.com/language/ref/AudioSampleRate.html
        ///</summary>
        corewolf::engine *AudioSampleRate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioSampleRate[" + arg0 + "]", name);
        }

        ///< summary>
        /// transforms audio by applying the function f to its short-time Fourier transform.
        /// https://reference.wolfram.com/language/ref/AudioSpectralMap.html
        ///</summary>
        corewolf::engine *AudioSpectralMap(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioSpectralMap[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies the function f to the list of short-time Fourier transforms of all audioi.
        /// https://reference.wolfram.com/language/ref/AudioSpectralMap.html
        ///</summary>
        corewolf::engine *AudioSpectralMap(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AudioSpectralMap[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns a modified version of audio by applying a time-frequency transformation f to its short-time Fourier transform.
        /// https://reference.wolfram.com/language/ref/AudioSpectralTransformation.html
        ///</summary>
        corewolf::engine *AudioSpectralTransformation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioSpectralTransformation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// splits audio at time t.
        /// https://reference.wolfram.com/language/ref/AudioSplit.html
        ///</summary>
        corewolf::engine *AudioSplit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioSplit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// splits audio at times ti.
        /// https://reference.wolfram.com/language/ref/AudioSplit.html
        ///</summary>
        corewolf::engine *AudioSplit(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AudioSplit[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// stops the playback of all AudioStream objects.
        /// https://reference.wolfram.com/language/ref/AudioStop.html
        ///</summary>
        corewolf::engine *AudioStop(const std::string &name = "")
        {
            return this->execute("AudioStop[]", name);
        }

        ///< summary>
        /// stops the playback of the AudioStream const std::string &astream.
        /// https://reference.wolfram.com/language/ref/AudioStop.html
        ///</summary>
        corewolf::engine *AudioStop(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioStop[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a new AudioStream const std::string &from source.
        /// https://reference.wolfram.com/language/ref/AudioStream.html
        ///</summary>
        corewolf::engine *AudioStream(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioStream[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns all existing streams.
        /// https://reference.wolfram.com/language/ref/AudioStreams.html
        ///</summary>
        corewolf::engine *AudioStreams(const std::string &name = "")
        {
            return this->execute("AudioStreams[]", name);
        }

        ///< summary>
        /// returns all existing streams that originated from audio.
        /// https://reference.wolfram.com/language/ref/AudioStreams.html
        ///</summary>
        corewolf::engine *AudioStreams(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioStreams[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns "prop" for all streams that originated from audio.
        /// https://reference.wolfram.com/language/ref/AudioStreams.html
        ///</summary>
        corewolf::engine *AudioStreams(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioStreams[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies time stretching to audio by the specified factor r.
        /// https://reference.wolfram.com/language/ref/AudioTimeStretch.html
        ///</summary>
        corewolf::engine *AudioTimeStretch(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioTimeStretch[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies the function f to the first audio track of the Video const std::string &video.
        /// https://reference.wolfram.com/language/ref/AudioTrackApply.html
        ///</summary>
        corewolf::engine *AudioTrackApply(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioTrackApply[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// trims silence from the beginning and end of audio.
        /// https://reference.wolfram.com/language/ref/AudioTrim.html
        ///</summary>
        corewolf::engine *AudioTrim(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioTrim[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the first t seconds of audio.
        /// https://reference.wolfram.com/language/ref/AudioTrim.html
        ///</summary>
        corewolf::engine *AudioTrim(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AudioTrim[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns audio starting at time t1 and ending at time t2 of audio.
        /// https://reference.wolfram.com/language/ref/AudioTrim.html
        ///</summary>
        corewolf::engine *AudioTrim(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AudioTrim[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns the data type used to represent samples in the Audio const std::string &audio.
        /// https://reference.wolfram.com/language/ref/AudioType.html
        ///</summary>
        corewolf::engine *AudioType(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AudioType[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the augmented polyhedron poly by replacing each face by a pyramid.
        /// https://reference.wolfram.com/language/ref/AugmentedPolyhedron.html
        ///</summary>
        corewolf::engine *AugmentedPolyhedron(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AugmentedPolyhedron[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the augmented polyhedron with a pyramid of height h.
        /// https://reference.wolfram.com/language/ref/AugmentedPolyhedron.html
        ///</summary>
        corewolf::engine *AugmentedPolyhedron(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AugmentedPolyhedron[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a formal augmented symmetric polynomial with exponents r1, r2, ….
        /// https://reference.wolfram.com/language/ref/AugmentedSymmetricPolynomial.html
        ///</summary>
        corewolf::engine *AugmentedSymmetricPolynomial(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AugmentedSymmetricPolynomial[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a multivariate formal augmented symmetric polynomial with exponent vectors {r11, …, r1n}, {r21, …, r2n}, ….
        /// https://reference.wolfram.com/language/ref/AugmentedSymmetricPolynomial.html
        ///</summary>
        corewolf::engine *AugmentedSymmetricPolynomial(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("AugmentedSymmetricPolynomial[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the augmented symmetric polynomial in data.
        /// https://reference.wolfram.com/language/ref/AugmentedSymmetricPolynomial.html
        ///</summary>
        corewolf::engine *AugmentedSymmetricPolynomial(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AugmentedSymmetricPolynomial[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// initiates a standard dialog for entering username/password authentication information.
        /// https://reference.wolfram.com/language/ref/AuthenticationDialog.html
        ///</summary>
        corewolf::engine *AuthenticationDialog(const std::string &name = "")
        {
            return this->execute("AuthenticationDialog[]", name);
        }

        ///< summary>
        /// initiates an authentication dialog of the specified standard type.
        /// https://reference.wolfram.com/language/ref/AuthenticationDialog.html
        ///</summary>
        corewolf::engine *AuthenticationDialog(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AuthenticationDialog[" + arg0 + "]", name);
        }

        ///< summary>
        /// initiates an authentication dialog that requests values for the specified keys.
        /// https://reference.wolfram.com/language/ref/AuthenticationDialog.html
        ///</summary>
        corewolf::engine *AuthenticationDialog(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AuthenticationDialog[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// applies the function func to the dialog's return value.
        /// https://reference.wolfram.com/language/ref/AuthenticationDialog.html
        ///</summary>
        corewolf::engine *AuthenticationDialog(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AuthenticationDialog[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the stringi that can complete string.
        /// https://reference.wolfram.com/language/ref/Autocomplete.html
        ///</summary>
        corewolf::engine *Autocomplete(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Autocomplete[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// puts the completions in order of decreasing weights wi.
        /// https://reference.wolfram.com/language/ref/Autocomplete.html
        ///</summary>
        corewolf::engine *Autocomplete(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Autocomplete[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the first at most n completions.
        /// https://reference.wolfram.com/language/ref/Autocomplete.html
        ///</summary>
        corewolf::engine *Autocomplete(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Autocomplete[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives an AutocompletionFunction[…] that can be applied to a string.
        /// https://reference.wolfram.com/language/ref/Autocomplete.html
        ///</summary>
        corewolf::engine *Autocomplete(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Autocomplete[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a function to be applied to a string to generate possible completions.
        /// https://reference.wolfram.com/language/ref/AutocompletionFunction.html
        ///</summary>
        corewolf::engine *AutocompletionFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AutocompletionFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the data is autocorrelated.
        /// https://reference.wolfram.com/language/ref/AutocorrelationTest.html
        ///</summary>
        corewolf::engine *AutocorrelationTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AutocorrelationTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the data is autocorrelated up to lag k.
        /// https://reference.wolfram.com/language/ref/AutocorrelationTest.html
        ///</summary>
        corewolf::engine *AutocorrelationTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AutocorrelationTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of "property" for a given model.
        /// https://reference.wolfram.com/language/ref/AutocorrelationTest.html
        ///</summary>
        corewolf::engine *AutocorrelationTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AutocorrelationTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an expression to be reevaluated every hour and made available in the cloud.
        /// https://reference.wolfram.com/language/ref/AutoRefreshed.html
        ///</summary>
        corewolf::engine *AutoRefreshed(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AutoRefreshed[" + arg0 + "]", name);
        }

        ///< summary>
        /// reevaluates at time interval dt.
        /// https://reference.wolfram.com/language/ref/AutoRefreshed.html
        ///</summary>
        corewolf::engine *AutoRefreshed(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AutoRefreshed[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies that the result from evaluating expr should be given in format fmt.
        /// https://reference.wolfram.com/language/ref/AutoRefreshed.html
        ///</summary>
        corewolf::engine *AutoRefreshed(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("AutoRefreshed[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// specifies that the result should be given as a response of the form rform.
        /// https://reference.wolfram.com/language/ref/AutoRefreshed.html
        ///</summary>
        corewolf::engine *AutoRefreshed(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("AutoRefreshed[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents an element of a form that automatically submits the whole form if it is entered.
        /// https://reference.wolfram.com/language/ref/AutoSubmitting.html
        ///</summary>
        corewolf::engine *AutoSubmitting(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AutoSubmitting[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an axiomatic representation of the specified axiomatic theory.
        /// https://reference.wolfram.com/language/ref/AxiomaticTheory.html
        ///</summary>
        corewolf::engine *AxiomaticTheory(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AxiomaticTheory[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses si to represent the operator opi in the theory.
        /// https://reference.wolfram.com/language/ref/AxiomaticTheory.html
        ///</summary>
        corewolf::engine *AxiomaticTheory(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("AxiomaticTheory[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the specified property of an axiomatic theory.
        /// https://reference.wolfram.com/language/ref/AxiomaticTheory.html
        ///</summary>
        corewolf::engine *AxiomaticTheory(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AxiomaticTheory[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a Graphics primitive that represents an axis with a quantitative scale along the path path.
        /// https://reference.wolfram.com/language/ref/AxisObject.html
        ///</summary>
        corewolf::engine *AxisObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("AxisObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the scale specified by scale.
        /// https://reference.wolfram.com/language/ref/AxisObject.html
        ///</summary>
        corewolf::engine *AxisObject(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("AxisObject[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the sporadic simple baby monster group .
        /// https://reference.wolfram.com/language/ref/BabyMonsterGroupB.html
        ///</summary>
        corewolf::engine *BabyMonsterGroupB(const std::string &name = "")
        {
            return this->execute("BabyMonsterGroupB[]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Backslash.html
        ///</summary>
        corewolf::engine *Backslash(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Backslash[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the unit ball centered at the point p.
        /// https://reference.wolfram.com/language/ref/Ball.html
        ///</summary>
        corewolf::engine *Ball(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Ball[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the ball of radius r centered at the point p.
        /// https://reference.wolfram.com/language/ref/Ball.html
        ///</summary>
        corewolf::engine *Ball(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Ball[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a collection of balls of radius r.
        /// https://reference.wolfram.com/language/ref/Ball.html
        ///</summary>
        corewolf::engine *Ball(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Ball[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the sequence of positions on the diagonal band that starts with {i,j} in a sparse array.
        /// https://reference.wolfram.com/language/ref/Band.html
        ///</summary>
        corewolf::engine *Band(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Band[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the positions between {imin,jmin,…} and {imax,jmax,…}.
        /// https://reference.wolfram.com/language/ref/Band.html
        ///</summary>
        corewolf::engine *Band(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Band[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents positions starting with {imin,jmin,…} and then moving with step {di,dj,…}.
        /// https://reference.wolfram.com/language/ref/Band.html
        ///</summary>
        corewolf::engine *Band(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Band[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// applies a bandpass filter with cutoff frequencies ω1 and ω2 to an array of data.
        /// https://reference.wolfram.com/language/ref/BandpassFilter.html
        ///</summary>
        corewolf::engine *BandpassFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BandpassFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses a filter kernel of length n.
        /// https://reference.wolfram.com/language/ref/BandpassFilter.html
        ///</summary>
        corewolf::engine *BandpassFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BandpassFilter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies a smoothing window wfun to the filter kernel.
        /// https://reference.wolfram.com/language/ref/BandpassFilter.html
        ///</summary>
        corewolf::engine *BandpassFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("BandpassFilter[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// applies a bandstop filter with cutoff frequencies ω1 and ω2 to an array of data.
        /// https://reference.wolfram.com/language/ref/BandstopFilter.html
        ///</summary>
        corewolf::engine *BandstopFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BandstopFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses a filter kernel of length n.
        /// https://reference.wolfram.com/language/ref/BandstopFilter.html
        ///</summary>
        corewolf::engine *BandstopFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BandstopFilter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies a smoothing window wfun to the filter kernel.
        /// https://reference.wolfram.com/language/ref/BandstopFilter.html
        ///</summary>
        corewolf::engine *BandstopFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("BandstopFilter[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a Barabasi–Albert graph distribution for n-vertex graphs where a new vertex with k edges is added at each step.
        /// https://reference.wolfram.com/language/ref/BarabasiAlbertGraphDistribution.html
        ///</summary>
        corewolf::engine *BarabasiAlbertGraphDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BarabasiAlbertGraphDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// makes a bar chart with bar lengths y1,  y2, ….
        /// https://reference.wolfram.com/language/ref/BarChart.html
        ///</summary>
        corewolf::engine *BarChart(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BarChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a 3D bar chart with bar lengths y1, y2, … .
        /// https://reference.wolfram.com/language/ref/BarChart3D.html
        ///</summary>
        corewolf::engine *BarChart3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BarChart3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a barcode image of "string" in the specified format.
        /// https://reference.wolfram.com/language/ref/BarcodeImage.html
        ///</summary>
        corewolf::engine *BarcodeImage(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BarcodeImage[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// attempts to generate a barcode image of the specified size.
        /// https://reference.wolfram.com/language/ref/BarcodeImage.html
        ///</summary>
        corewolf::engine *BarcodeImage(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BarcodeImage[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// recognizes a barcode in image and returns it as a string.
        /// https://reference.wolfram.com/language/ref/BarcodeRecognize.html
        ///</summary>
        corewolf::engine *BarcodeRecognize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BarcodeRecognize[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the specified property of the barcode.
        /// https://reference.wolfram.com/language/ref/BarcodeRecognize.html
        ///</summary>
        corewolf::engine *BarcodeRecognize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BarcodeRecognize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// recognizes barcodes of the specified format only.
        /// https://reference.wolfram.com/language/ref/BarcodeRecognize.html
        ///</summary>
        corewolf::engine *BarcodeRecognize(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BarcodeRecognize[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether data follows a MultinormalDistribution using the Baringhaus–Henze test.
        /// https://reference.wolfram.com/language/ref/BaringhausHenzeTest.html
        ///</summary>
        corewolf::engine *BaringhausHenzeTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BaringhausHenzeTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether data follows the distribution with mean vector μ and covariance matrix Σ.
        /// https://reference.wolfram.com/language/ref/BaringhausHenzeTest.html
        ///</summary>
        corewolf::engine *BaringhausHenzeTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BaringhausHenzeTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a legend that identifies colors from the color function cf with an automatic range of values.
        /// https://reference.wolfram.com/language/ref/BarLegend.html
        ///</summary>
        corewolf::engine *BarLegend(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BarLegend[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a legend that identifies colors from the color function cf with the range of values between min and max.
        /// https://reference.wolfram.com/language/ref/BarLegend.html
        ///</summary>
        corewolf::engine *BarLegend(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BarLegend[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a legend that identifies color ranges from the color function cf based on the set of contours contours.
        /// https://reference.wolfram.com/language/ref/BarLegend.html
        ///</summary>
        corewolf::engine *BarLegend(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BarLegend[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Barlow–Proschan importances for all components in the ReliabilityDistribution rdist.
        /// https://reference.wolfram.com/language/ref/BarlowProschanImportance.html
        ///</summary>
        corewolf::engine *BarlowProschanImportance(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BarlowProschanImportance[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Barnes G-function .
        /// https://reference.wolfram.com/language/ref/BarnesG.html
        ///</summary>
        corewolf::engine *BarnesG(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BarnesG[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Bartlett–Hann window function of x.
        /// https://reference.wolfram.com/language/ref/BartlettHannWindow.html
        ///</summary>
        corewolf::engine *BartlettHannWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BartlettHannWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Bartlett window function of x.
        /// https://reference.wolfram.com/language/ref/BartlettWindow.html
        ///</summary>
        corewolf::engine *BartlettWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BartlettWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// decodes the Base64 data contained in a string and returns the result as a byte array.
        /// https://reference.wolfram.com/language/ref/BaseDecode.html
        ///</summary>
        corewolf::engine *BaseDecode(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BaseDecode[" + arg0 + "]", name);
        }

        ///< summary>
        /// decodes using the string using the specified encoding.
        /// https://reference.wolfram.com/language/ref/BaseDecode.html
        ///</summary>
        corewolf::engine *BaseDecode(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BaseDecode[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// encodes the byte array ba as a Base64 string.
        /// https://reference.wolfram.com/language/ref/BaseEncode.html
        ///</summary>
        corewolf::engine *BaseEncode(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BaseEncode[" + arg0 + "]", name);
        }

        ///< summary>
        /// encodes using the specified encoding.
        /// https://reference.wolfram.com/language/ref/BaseEncode.html
        ///</summary>
        corewolf::engine *BaseEncode(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BaseEncode[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// prints with the numbers in expr given in base n.
        /// https://reference.wolfram.com/language/ref/BaseForm.html
        ///</summary>
        corewolf::engine *BaseForm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BaseForm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a trainable recurrent layer that takes a sequence of vectors and produces a sequence of vectors each of size n.
        /// https://reference.wolfram.com/language/ref/BasicRecurrentLayer.html
        ///</summary>
        corewolf::engine *BasicRecurrentLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BasicRecurrentLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// includes options for initial weights and other parameters.
        /// https://reference.wolfram.com/language/ref/BasicRecurrentLayer.html
        ///</summary>
        corewolf::engine *BasicRecurrentLayer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BasicRecurrentLayer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a trainable net layer that normalizes its input data by learning the data mean and variance.
        /// https://reference.wolfram.com/language/ref/BatchNormalizationLayer.html
        ///</summary>
        corewolf::engine *BatchNormalizationLayer(const std::string &name = "")
        {
            return this->execute("BatchNormalizationLayer[]", name);
        }

        ///< summary>
        /// represents the distribution of a mean of n random variables uniformly distributed from 0 to 1.
        /// https://reference.wolfram.com/language/ref/BatesDistribution.html
        ///</summary>
        corewolf::engine *BatesDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BatesDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the distribution of a mean of n random variables uniformly distributed from min to max.
        /// https://reference.wolfram.com/language/ref/BatesDistribution.html
        ///</summary>
        corewolf::engine *BatesDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BatesDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents the Battle–Lemarié wavelet of order 3.
        /// https://reference.wolfram.com/language/ref/BattleLemarieWavelet.html
        ///</summary>
        corewolf::engine *BattleLemarieWavelet(const std::string &name = "")
        {
            return this->execute("BattleLemarieWavelet[]", name);
        }

        ///< summary>
        /// represents the Battle–Lemarié wavelet of order n evaluated on equally spaced interval {-10,10}.
        /// https://reference.wolfram.com/language/ref/BattleLemarieWavelet.html
        ///</summary>
        corewolf::engine *BattleLemarieWavelet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BattleLemarieWavelet[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the Battle–Lemarié wavelet of order n evaluated on equally spaced interval {-lim,lim}.
        /// https://reference.wolfram.com/language/ref/BattleLemarieWavelet.html
        ///</summary>
        corewolf::engine *BattleLemarieWavelet(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BattleLemarieWavelet[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an const std::string &representing the result of Bayesian maximization over the function f over the configurations confi.
        /// https://reference.wolfram.com/language/ref/BayesianMaximization.html
        ///</summary>
        corewolf::engine *BayesianMaximization(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BayesianMaximization[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// maximizes over the region represented by the region specification reg.
        /// https://reference.wolfram.com/language/ref/BayesianMaximization.html
        ///</summary>
        corewolf::engine *BayesianMaximization(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BayesianMaximization[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the result of a Bayesian maximization process.
        /// https://reference.wolfram.com/language/ref/BayesianMaximizationObject.html
        ///</summary>
        corewolf::engine *BayesianMaximizationObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BayesianMaximizationObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the result of a Bayesian minimization process.
        /// https://reference.wolfram.com/language/ref/BayesianMinimizationObject.html
        ///</summary>
        corewolf::engine *BayesianMinimizationObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BayesianMinimizationObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Because.html
        ///</summary>
        corewolf::engine *Because(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Because[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the Beckmann distribution with means μ1 and μ2 and standard deviations σ1 and σ2.
        /// https://reference.wolfram.com/language/ref/BeckmannDistribution.html
        ///</summary>
        corewolf::engine *BeckmannDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("BeckmannDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents the Beckmann distribution with means μ1 and μ2, standard deviations σ1 and σ2, and correlation ρ.
        /// https://reference.wolfram.com/language/ref/BeckmannDistribution.html
        ///</summary>
        corewolf::engine *BeckmannDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("BeckmannDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// generates an audible beep when evaluated.
        /// https://reference.wolfram.com/language/ref/Beep.html
        ///</summary>
        corewolf::engine *Beep(const std::string &name = "")
        {
            return this->execute("Beep[]", name);
        }

        ///< summary>
        /// beeps and populates the Why the Beep dialog with message.
        /// https://reference.wolfram.com/language/ref/Beep.html
        ///</summary>
        corewolf::engine *Beep(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Beep[" + arg0 + "]", name);
        }

        ///< summary>
        /// resets the current context.
        /// https://reference.wolfram.com/language/ref/Begin.html
        ///</summary>
        corewolf::engine *Begin(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Begin[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a WSTP packet that indicates the start of the Dialog subsession referenced by integer.
        /// https://reference.wolfram.com/language/ref/BeginDialogPacket.html
        ///</summary>
        corewolf::engine *BeginDialogPacket(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BeginDialogPacket[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes context` and System` the only active contexts.
        /// https://reference.wolfram.com/language/ref/BeginPackage.html
        ///</summary>
        corewolf::engine *BeginPackage(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BeginPackage[" + arg0 + "]", name);
        }

        ///< summary>
        /// calls Needs on the needi.
        /// https://reference.wolfram.com/language/ref/BeginPackage.html
        ///</summary>
        corewolf::engine *BeginPackage(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BeginPackage[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Bell number .
        /// https://reference.wolfram.com/language/ref/BellB.html
        ///</summary>
        corewolf::engine *BellB(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BellB[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Bell polynomial .
        /// https://reference.wolfram.com/language/ref/BellB.html
        ///</summary>
        corewolf::engine *BellB(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BellB[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the partial Bell polynomial .
        /// https://reference.wolfram.com/language/ref/BellY.html
        ///</summary>
        corewolf::engine *BellY(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("BellY[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the generalized partial Bell polynomial of a matrix m.
        /// https://reference.wolfram.com/language/ref/BellY.html
        ///</summary>
        corewolf::engine *BellY(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BellY[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the generalized Bell polynomial of a matrix m.
        /// https://reference.wolfram.com/language/ref/BellY.html
        ///</summary>
        corewolf::engine *BellY(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BellY[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Benford distribution with base parameter b.
        /// https://reference.wolfram.com/language/ref/BenfordDistribution.html
        ///</summary>
        corewolf::engine *BenfordDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BenfordDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Benini distribution with shape parameters α and β and scale parameter σ.
        /// https://reference.wolfram.com/language/ref/BeniniDistribution.html
        ///</summary>
        corewolf::engine *BeniniDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BeniniDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Benktander distribution of type I with parameters a and b.
        /// https://reference.wolfram.com/language/ref/BenktanderGibratDistribution.html
        ///</summary>
        corewolf::engine *BenktanderGibratDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BenktanderGibratDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Benktander distribution of type II with parameters a and b.
        /// https://reference.wolfram.com/language/ref/BenktanderWeibullDistribution.html
        ///</summary>
        corewolf::engine *BenktanderWeibullDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BenktanderWeibullDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Bernoulli number .
        /// https://reference.wolfram.com/language/ref/BernoulliB.html
        ///</summary>
        corewolf::engine *BernoulliB(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BernoulliB[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Bernoulli polynomial .
        /// https://reference.wolfram.com/language/ref/BernoulliB.html
        ///</summary>
        corewolf::engine *BernoulliB(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BernoulliB[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Bernoulli distribution with probability parameter p.
        /// https://reference.wolfram.com/language/ref/BernoulliDistribution.html
        ///</summary>
        corewolf::engine *BernoulliDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BernoulliDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Bernoulli graph distribution for n-vertex graphs with edge probability p.
        /// https://reference.wolfram.com/language/ref/BernoulliGraphDistribution.html
        ///</summary>
        corewolf::engine *BernoulliGraphDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BernoulliGraphDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Bernoulli process with event probability p.
        /// https://reference.wolfram.com/language/ref/BernoulliProcess.html
        ///</summary>
        corewolf::engine *BernoulliProcess(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BernoulliProcess[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the n Bernstein basis function of degree d at x.
        /// https://reference.wolfram.com/language/ref/BernsteinBasis.html
        ///</summary>
        corewolf::engine *BernsteinBasis(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BernsteinBasis[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// estimates Besag's  function  for point data pdata at radius r.
        /// https://reference.wolfram.com/language/ref/BesagL.html
        ///</summary>
        corewolf::engine *BesagL(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BesagL[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates the function  that can be applied repeatedly to different radii r.
        /// https://reference.wolfram.com/language/ref/BesagL.html
        ///</summary>
        corewolf::engine *BesagL(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BesagL[" + arg0 + "]", name);
        }

        ///< summary>
        /// designs a lowpass Bessel filter of order n and cutoff frequency 1.
        /// https://reference.wolfram.com/language/ref/BesselFilterModel.html
        ///</summary>
        corewolf::engine *BesselFilterModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BesselFilterModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the cutoff frequency ωc.
        /// https://reference.wolfram.com/language/ref/BesselFilterModel.html
        ///</summary>
        corewolf::engine *BesselFilterModel(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BesselFilterModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// expresses the model in terms of the variable var.
        /// https://reference.wolfram.com/language/ref/BesselFilterModel.html
        ///</summary>
        corewolf::engine *BesselFilterModel(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BesselFilterModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the modified Bessel function of the first kind .
        /// https://reference.wolfram.com/language/ref/BesselI.html
        ///</summary>
        corewolf::engine *BesselI(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BesselI[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Bessel function of the first kind .
        /// https://reference.wolfram.com/language/ref/BesselJ.html
        ///</summary>
        corewolf::engine *BesselJ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BesselJ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the k zero of the Bessel function .
        /// https://reference.wolfram.com/language/ref/BesselJZero.html
        ///</summary>
        corewolf::engine *BesselJZero(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BesselJZero[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the k zero greater than x0.
        /// https://reference.wolfram.com/language/ref/BesselJZero.html
        ///</summary>
        corewolf::engine *BesselJZero(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BesselJZero[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the modified Bessel function of the second kind .
        /// https://reference.wolfram.com/language/ref/BesselK.html
        ///</summary>
        corewolf::engine *BesselK(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BesselK[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Bessel function of the second kind .
        /// https://reference.wolfram.com/language/ref/BesselY.html
        ///</summary>
        corewolf::engine *BesselY(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BesselY[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the k zero of the Bessel function of the second kind .
        /// https://reference.wolfram.com/language/ref/BesselYZero.html
        ///</summary>
        corewolf::engine *BesselYZero(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BesselYZero[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the k zero greater than x0.
        /// https://reference.wolfram.com/language/ref/BesselYZero.html
        ///</summary>
        corewolf::engine *BesselYZero(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BesselYZero[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Euler beta function .
        /// https://reference.wolfram.com/language/ref/Beta.html
        ///</summary>
        corewolf::engine *Beta(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Beta[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the incomplete beta function .
        /// https://reference.wolfram.com/language/ref/Beta.html
        ///</summary>
        corewolf::engine *Beta(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Beta[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a beta binomial mixture distribution with beta distribution parameters  and , and  binomial trials.
        /// https://reference.wolfram.com/language/ref/BetaBinomialDistribution.html
        ///</summary>
        corewolf::engine *BetaBinomialDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BetaBinomialDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a continuous beta distribution with shape parameters α and β.
        /// https://reference.wolfram.com/language/ref/BetaDistribution.html
        ///</summary>
        corewolf::engine *BetaDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BetaDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a beta negative binomial mixture distribution with beta distribution parameters α and β and n successful trials.
        /// https://reference.wolfram.com/language/ref/BetaNegativeBinomialDistribution.html
        ///</summary>
        corewolf::engine *BetaNegativeBinomialDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BetaNegativeBinomialDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a beta prime distribution with shape parameters p and q.
        /// https://reference.wolfram.com/language/ref/BetaPrimeDistribution.html
        ///</summary>
        corewolf::engine *BetaPrimeDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BetaPrimeDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a generalized beta prime distribution with scale parameter β.
        /// https://reference.wolfram.com/language/ref/BetaPrimeDistribution.html
        ///</summary>
        corewolf::engine *BetaPrimeDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BetaPrimeDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a generalized beta distribution of the second kind with shape parameter α.
        /// https://reference.wolfram.com/language/ref/BetaPrimeDistribution.html
        ///</summary>
        corewolf::engine *BetaPrimeDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("BetaPrimeDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the regularized incomplete beta function .
        /// https://reference.wolfram.com/language/ref/BetaRegularized.html
        ///</summary>
        corewolf::engine *BetaRegularized(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BetaRegularized[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is equivalent to min≤x≤max.
        /// https://reference.wolfram.com/language/ref/Between.html
        ///</summary>
        corewolf::engine *Between(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Between[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is equivalent to min1≤x≤max1||min2≤x≤max2||….
        /// https://reference.wolfram.com/language/ref/Between.html
        ///</summary>
        corewolf::engine *Between(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Between[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// is an operator form that yields Between[x,range] when applied to an expression x.
        /// https://reference.wolfram.com/language/ref/Between.html
        ///</summary>
        corewolf::engine *Between(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Between[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of betweenness centralities for the vertices in the graph g.
        /// https://reference.wolfram.com/language/ref/BetweennessCentrality.html
        ///</summary>
        corewolf::engine *BetweennessCentrality(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BetweennessCentrality[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/BetweennessCentrality.html
        ///</summary>
        corewolf::engine *BetweennessCentrality(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BetweennessCentrality[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the beveled polyhedron of poly, by beveling each edge.
        /// https://reference.wolfram.com/language/ref/BeveledPolyhedron.html
        ///</summary>
        corewolf::engine *BeveledPolyhedron(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BeveledPolyhedron[" + arg0 + "]", name);
        }

        ///< summary>
        /// bevels the polyhedron poly by a length ratio l at its edges.
        /// https://reference.wolfram.com/language/ref/BeveledPolyhedron.html
        ///</summary>
        corewolf::engine *BeveledPolyhedron(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BeveledPolyhedron[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a graphics primitive that represents a Bézier curve with control points pti.
        /// https://reference.wolfram.com/language/ref/BezierCurve.html
        ///</summary>
        corewolf::engine *BezierCurve(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BezierCurve[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a Bézier function for a curve defined by the control points pti.
        /// https://reference.wolfram.com/language/ref/BezierFunction.html
        ///</summary>
        corewolf::engine *BezierFunction(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BezierFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a Bézier function for a surface or high-dimensional manifold.
        /// https://reference.wolfram.com/language/ref/BezierFunction.html
        ///</summary>
        corewolf::engine *BezierFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BezierFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies a bilateral filter of spatial spread σ and pixel value spread μ to data.
        /// https://reference.wolfram.com/language/ref/BilateralFilter.html
        ///</summary>
        corewolf::engine *BilateralFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BilateralFilter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the bilateral Laplace transform of expr.
        /// https://reference.wolfram.com/language/ref/BilateralLaplaceTransform.html
        ///</summary>
        corewolf::engine *BilateralLaplaceTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BilateralLaplaceTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional bilateral Laplace transform of expr.
        /// https://reference.wolfram.com/language/ref/BilateralLaplaceTransform.html
        ///</summary>
        corewolf::engine *BilateralLaplaceTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("BilateralLaplaceTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the bilateral Z transform of expr.
        /// https://reference.wolfram.com/language/ref/BilateralZTransform.html
        ///</summary>
        corewolf::engine *BilateralZTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BilateralZTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional bilateral Z transform of expr.
        /// https://reference.wolfram.com/language/ref/BilateralZTransform.html
        ///</summary>
        corewolf::engine *BilateralZTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("BilateralZTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// creates a binary image from image by replacing all values above a globally determined threshold with 1 and others with 0.
        /// https://reference.wolfram.com/language/ref/Binarize.html
        ///</summary>
        corewolf::engine *Binarize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Binarize[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a binary image by replacing all values above t with 1 and others with 0.
        /// https://reference.wolfram.com/language/ref/Binarize.html
        ///</summary>
        corewolf::engine *Binarize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Binarize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a binary image by replacing all values in the range t1 through t2 with 1 and others with 0.
        /// https://reference.wolfram.com/language/ref/Binarize.html
        ///</summary>
        corewolf::engine *Binarize(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Binarize[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// recovers an expression from a binary representation generated by BinarySerialize.
        /// https://reference.wolfram.com/language/ref/BinaryDeserialize.html
        ///</summary>
        corewolf::engine *BinaryDeserialize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BinaryDeserialize[" + arg0 + "]", name);
        }

        ///< summary>
        /// wraps h around the expression produced before returning it.
        /// https://reference.wolfram.com/language/ref/BinaryDeserialize.html
        ///</summary>
        corewolf::engine *BinaryDeserialize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BinaryDeserialize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the binary distance between vectors u and v, equal to 0 if they are identical and 1 otherwise.
        /// https://reference.wolfram.com/language/ref/BinaryDistance.html
        ///</summary>
        corewolf::engine *BinaryDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BinaryDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if image has the form of a binary Image or Image3D object, and False otherwise.
        /// https://reference.wolfram.com/language/ref/BinaryImageQ.html
        ///</summary>
        corewolf::engine *BinaryImageQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BinaryImageQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// reads one byte of raw binary data from an input stream, and returns an integer from 0 to 255.
        /// https://reference.wolfram.com/language/ref/BinaryRead.html
        ///</summary>
        corewolf::engine *BinaryRead(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BinaryRead[" + arg0 + "]", name);
        }

        ///< summary>
        /// reads an const std::string &of the specified type.
        /// https://reference.wolfram.com/language/ref/BinaryRead.html
        ///</summary>
        corewolf::engine *BinaryRead(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BinaryRead[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reads a sequence of objects of the specified types.
        /// https://reference.wolfram.com/language/ref/BinaryRead.html
        ///</summary>
        corewolf::engine *BinaryRead(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BinaryRead[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// reads all remaining bytes from a file, and returns them as a list of integers from 0 to 255.
        /// https://reference.wolfram.com/language/ref/BinaryReadList.html
        ///</summary>
        corewolf::engine *BinaryReadList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BinaryReadList[" + arg0 + "]", name);
        }

        ///< summary>
        /// reads objects of the specified type from a file, until the end of the file is reached. The list of objects read is returned.
        /// https://reference.wolfram.com/language/ref/BinaryReadList.html
        ///</summary>
        corewolf::engine *BinaryReadList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BinaryReadList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reads objects with a sequence of types, until the end of the file is reached.
        /// https://reference.wolfram.com/language/ref/BinaryReadList.html
        ///</summary>
        corewolf::engine *BinaryReadList(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BinaryReadList[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// reads only the first n objects of the specified types.
        /// https://reference.wolfram.com/language/ref/BinaryReadList.html
        ///</summary>
        corewolf::engine *BinaryReadList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BinaryReadList[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a binary representation of any expression expr as a ByteArray object.
        /// https://reference.wolfram.com/language/ref/BinarySerialize.html
        ///</summary>
        corewolf::engine *BinarySerialize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BinarySerialize[" + arg0 + "]", name);
        }

        ///< summary>
        /// writes a byte of data, specified as an integer from 0 to 255.
        /// https://reference.wolfram.com/language/ref/BinaryWrite.html
        ///</summary>
        corewolf::engine *BinaryWrite(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BinaryWrite[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// writes a sequence of bytes.
        /// https://reference.wolfram.com/language/ref/BinaryWrite.html
        ///</summary>
        corewolf::engine *BinaryWrite(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BinaryWrite[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// writes an const std::string &of the specified type.
        /// https://reference.wolfram.com/language/ref/BinaryWrite.html
        ///</summary>
        corewolf::engine *BinaryWrite(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BinaryWrite[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// writes a sequence of objects of the specified type.
        /// https://reference.wolfram.com/language/ref/BinaryWrite.html
        ///</summary>
        corewolf::engine *BinaryWrite(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BinaryWrite[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// writes a sequence of objects with a sequence of types.
        /// https://reference.wolfram.com/language/ref/BinaryWrite.html
        ///</summary>
        corewolf::engine *BinaryWrite(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("BinaryWrite[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// counts the number of elements xi whose values lie in successive integer bins.
        /// https://reference.wolfram.com/language/ref/BinCounts.html
        ///</summary>
        corewolf::engine *BinCounts(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BinCounts[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// counts the number of elements xi whose values lie in successive bins of width dx.
        /// https://reference.wolfram.com/language/ref/BinCounts.html
        ///</summary>
        corewolf::engine *BinCounts(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BinCounts[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// counts the number of xi in successive bins of width dx from xmin to xmax.
        /// https://reference.wolfram.com/language/ref/BinCounts.html
        ///</summary>
        corewolf::engine *BinCounts(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BinCounts[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives an array of counts where the first index corresponds to x bins, the second to y, and so on.
        /// https://reference.wolfram.com/language/ref/BinCounts.html
        ///</summary>
        corewolf::engine *BinCounts(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("BinCounts[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// gives lists of the elements xi whose values lie in successive integer bins.
        /// https://reference.wolfram.com/language/ref/BinLists.html
        ///</summary>
        corewolf::engine *BinLists(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BinLists[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives lists of the elements xi whose values lie in successive bins of width dx.
        /// https://reference.wolfram.com/language/ref/BinLists.html
        ///</summary>
        corewolf::engine *BinLists(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BinLists[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives lists of the xi that lie in successive bins of width dx from xmin to xmax.
        /// https://reference.wolfram.com/language/ref/BinLists.html
        ///</summary>
        corewolf::engine *BinLists(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BinLists[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives an array of lists where the first index corresponds to x bins, the second to y, and so on.
        /// https://reference.wolfram.com/language/ref/BinLists.html
        ///</summary>
        corewolf::engine *BinLists(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("BinLists[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// computes a variogram using binned values.
        /// https://reference.wolfram.com/language/ref/BinnedVariogramList.html
        ///</summary>
        corewolf::engine *BinnedVariogramList(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BinnedVariogramList[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// allows binning spec to be specified as given in HistogramList.
        /// https://reference.wolfram.com/language/ref/BinnedVariogramList.html
        ///</summary>
        corewolf::engine *BinnedVariogramList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BinnedVariogramList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the binomial coefficient .
        /// https://reference.wolfram.com/language/ref/Binomial.html
        ///</summary>
        corewolf::engine *Binomial(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Binomial[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a binomial distribution with n trials and success probability p.
        /// https://reference.wolfram.com/language/ref/BinomialDistribution.html
        ///</summary>
        corewolf::engine *BinomialDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BinomialDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a binomial point process with n points in the region reg.
        /// https://reference.wolfram.com/language/ref/BinomialPointProcess.html
        ///</summary>
        corewolf::engine *BinomialPointProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BinomialPointProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a binomial process with event probability p.
        /// https://reference.wolfram.com/language/ref/BinomialProcess.html
        ///</summary>
        corewolf::engine *BinomialProcess(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BinomialProcess[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a bivariate normal distribution with mean {μ1,μ2} and covariance matrix {{σ12,ρ σ1 σ2},{ρ σ1 σ2,σ22}}.
        /// https://reference.wolfram.com/language/ref/BinormalDistribution.html
        ///</summary>
        corewolf::engine *BinormalDistribution(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BinormalDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a bivariate normal distribution with zero mean.
        /// https://reference.wolfram.com/language/ref/BinormalDistribution.html
        ///</summary>
        corewolf::engine *BinormalDistribution(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BinormalDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a bivariate normal distribution with zero mean and covariance matrix {{1,ρ },{ρ,1}}.
        /// https://reference.wolfram.com/language/ref/BinormalDistribution.html
        ///</summary>
        corewolf::engine *BinormalDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BinormalDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a biorthogonal spline wavelet of order 4 and dual order 2.
        /// https://reference.wolfram.com/language/ref/BiorthogonalSplineWavelet.html
        ///</summary>
        corewolf::engine *BiorthogonalSplineWavelet(const std::string &name = "")
        {
            return this->execute("BiorthogonalSplineWavelet[]", name);
        }

        ///< summary>
        /// represents a biorthogonal spline wavelet of order n and dual order m.
        /// https://reference.wolfram.com/language/ref/BiorthogonalSplineWavelet.html
        ///</summary>
        corewolf::engine *BiorthogonalSplineWavelet(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BiorthogonalSplineWavelet[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the biomolecular sequence of the given type corresponding to a string "seq".
        /// https://reference.wolfram.com/language/ref/BioSequence.html
        ///</summary>
        corewolf::engine *BioSequence(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BioSequence[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// infers the type (DNA, protein, etc.) from the sequence.
        /// https://reference.wolfram.com/language/ref/BioSequence.html
        ///</summary>
        corewolf::engine *BioSequence(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BioSequence[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the biomolecular sequence with type corresponding to the given list of chemicals.
        /// https://reference.wolfram.com/language/ref/BioSequence.html
        ///</summary>
        corewolf::engine *BioSequence(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BioSequence[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a biomolecular sequence with the given list of bonds.
        /// https://reference.wolfram.com/language/ref/BioSequence.html
        ///</summary>
        corewolf::engine *BioSequence(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("BioSequence[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a sequence composed of multiple motif sequences with shared primary linkage.
        /// https://reference.wolfram.com/language/ref/BioSequence.html
        ///</summary>
        corewolf::engine *BioSequence(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("BioSequence[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a number of sequences linked only by additional bonds.
        /// https://reference.wolfram.com/language/ref/BioSequence.html
        ///</summary>
        corewolf::engine *BioSequence(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BioSequence[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the generalized back translations of a peptide sequence bioseq.
        /// https://reference.wolfram.com/language/ref/BioSequenceBackTranslateList.html
        ///</summary>
        corewolf::engine *BioSequenceBackTranslateList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BioSequenceBackTranslateList[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the genetic translation table gtt.
        /// https://reference.wolfram.com/language/ref/BioSequenceBackTranslateList.html
        ///</summary>
        corewolf::engine *BioSequenceBackTranslateList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BioSequenceBackTranslateList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// treats the starting amino acid in bioseq according to the specification startspec.
        /// https://reference.wolfram.com/language/ref/BioSequenceBackTranslateList.html
        ///</summary>
        corewolf::engine *BioSequenceBackTranslateList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BioSequenceBackTranslateList[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the biological complement of the sequence bioseq.
        /// https://reference.wolfram.com/language/ref/BioSequenceComplement.html
        ///</summary>
        corewolf::engine *BioSequenceComplement(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BioSequenceComplement[" + arg0 + "]", name);
        }

        ///< summary>
        /// expands the possibly degenerate sequence bioseq into all fully specified corresponding sequences.
        /// https://reference.wolfram.com/language/ref/BioSequenceInstances.html
        ///</summary>
        corewolf::engine *BioSequenceInstances(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BioSequenceInstances[" + arg0 + "]", name);
        }

        ///< summary>
        /// expands the sequence bioseq into at most n fully specified corresponding sequences.
        /// https://reference.wolfram.com/language/ref/BioSequenceInstances.html
        ///</summary>
        corewolf::engine *BioSequenceInstances(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BioSequenceInstances[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the result of applying the modification "mod" to the sequence seq.
        /// https://reference.wolfram.com/language/ref/BioSequenceModify.html
        ///</summary>
        corewolf::engine *BioSequenceModify(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BioSequenceModify[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies the parameters params for "mod".
        /// https://reference.wolfram.com/language/ref/BioSequenceModify.html
        ///</summary>
        corewolf::engine *BioSequenceModify(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BioSequenceModify[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an operator form of BioSequenceModify that can be applied to a biomolecular sequence.
        /// https://reference.wolfram.com/language/ref/BioSequenceModify.html
        ///</summary>
        corewolf::engine *BioSequenceModify(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BioSequenceModify[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a two-dimensional schematic diagram of the biomolecular sequence bioseq.
        /// https://reference.wolfram.com/language/ref/BioSequencePlot.html
        ///</summary>
        corewolf::engine *BioSequencePlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BioSequencePlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if bioseq is a valid BioSequence expression, and False otherwise.
        /// https://reference.wolfram.com/language/ref/BioSequenceQ.html
        ///</summary>
        corewolf::engine *BioSequenceQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BioSequenceQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if bioseq is a valid BioSequence expression matching a specification spec, and False otherwise.
        /// https://reference.wolfram.com/language/ref/BioSequenceQ.html
        ///</summary>
        corewolf::engine *BioSequenceQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BioSequenceQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// biologically complements and reverses the sequence bioseq.
        /// https://reference.wolfram.com/language/ref/BioSequenceReverseComplement.html
        ///</summary>
        corewolf::engine *BioSequenceReverseComplement(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BioSequenceReverseComplement[" + arg0 + "]", name);
        }

        ///< summary>
        /// transcribes DNA into RNA or inverts the transcription of RNA back to DNA for the sequence bioseq.
        /// https://reference.wolfram.com/language/ref/BioSequenceTranscribe.html
        ///</summary>
        corewolf::engine *BioSequenceTranscribe(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BioSequenceTranscribe[" + arg0 + "]", name);
        }

        ///< summary>
        /// translates a DNA or RNA sequence bioseq to a peptide sequence.
        /// https://reference.wolfram.com/language/ref/BioSequenceTranslate.html
        ///</summary>
        corewolf::engine *BioSequenceTranslate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BioSequenceTranslate[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the genetic translation table gtt.
        /// https://reference.wolfram.com/language/ref/BioSequenceTranslate.html
        ///</summary>
        corewolf::engine *BioSequenceTranslate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BioSequenceTranslate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// treats start codons in bioseq according to the specification startspec.
        /// https://reference.wolfram.com/language/ref/BioSequenceTranslate.html
        ///</summary>
        corewolf::engine *BioSequenceTranslate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BioSequenceTranslate[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is a bipartite graph and False otherwise.
        /// https://reference.wolfram.com/language/ref/BipartiteGraphQ.html
        ///</summary>
        corewolf::engine *BipartiteGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BipartiteGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a lowpass biquadratic filter using the characteristic frequency ω and the quality factor q.
        /// https://reference.wolfram.com/language/ref/BiquadraticFilterModel.html
        ///</summary>
        corewolf::engine *BiquadraticFilterModel(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BiquadraticFilterModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// expresses the model in terms of the variable var.
        /// https://reference.wolfram.com/language/ref/BiquadraticFilterModel.html
        ///</summary>
        corewolf::engine *BiquadraticFilterModel(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BiquadraticFilterModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Birnbaum importances for all components in the ReliabilityDistribution rdist at time t.
        /// https://reference.wolfram.com/language/ref/BirnbaumImportance.html
        ///</summary>
        corewolf::engine *BirnbaumImportance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BirnbaumImportance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the Birnbaum–Saunders distribution with shape parameter α and scale parameter λ.
        /// https://reference.wolfram.com/language/ref/BirnbaumSaundersDistribution.html
        ///</summary>
        corewolf::engine *BirnbaumSaundersDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BirnbaumSaundersDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the bitwise AND of the integers ni.
        /// https://reference.wolfram.com/language/ref/BitAnd.html
        ///</summary>
        corewolf::engine *BitAnd(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BitAnd[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// sets to 0 the bit corresponding to the coefficient of  in the integer n.
        /// https://reference.wolfram.com/language/ref/BitClear.html
        ///</summary>
        corewolf::engine *BitClear(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BitClear[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gets the bit corresponding to the coefficient of  in the integer n.
        /// https://reference.wolfram.com/language/ref/BitGet.html
        ///</summary>
        corewolf::engine *BitGet(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BitGet[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the number of binary bits necessary to represent the integer n.
        /// https://reference.wolfram.com/language/ref/BitLength.html
        ///</summary>
        corewolf::engine *BitLength(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BitLength[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the bitwise NOT of the integer n.
        /// https://reference.wolfram.com/language/ref/BitNot.html
        ///</summary>
        corewolf::engine *BitNot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BitNot[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the bitwise OR of the integers ni.
        /// https://reference.wolfram.com/language/ref/BitOr.html
        ///</summary>
        corewolf::engine *BitOr(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BitOr[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// sets to 1 the bit corresponding to the coefficient of  in the integer n.
        /// https://reference.wolfram.com/language/ref/BitSet.html
        ///</summary>
        corewolf::engine *BitSet(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BitSet[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// shifts the binary bits in the integer n to the left by k places, padding with zeros on the right.
        /// https://reference.wolfram.com/language/ref/BitShiftLeft.html
        ///</summary>
        corewolf::engine *BitShiftLeft(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BitShiftLeft[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// shifts one bit to the left.
        /// https://reference.wolfram.com/language/ref/BitShiftLeft.html
        ///</summary>
        corewolf::engine *BitShiftLeft(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BitShiftLeft[" + arg0 + "]", name);
        }

        ///< summary>
        /// shifts the binary bits in the integer n to the right by k places, dropping bits that are shifted past the unit's position on the right.
        /// https://reference.wolfram.com/language/ref/BitShiftRight.html
        ///</summary>
        corewolf::engine *BitShiftRight(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BitShiftRight[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// shifts one bit to the right.
        /// https://reference.wolfram.com/language/ref/BitShiftRight.html
        ///</summary>
        corewolf::engine *BitShiftRight(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BitShiftRight[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the bitwise XOR of the integers ni.
        /// https://reference.wolfram.com/language/ref/BitXor.html
        ///</summary>
        corewolf::engine *BitXor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BitXor[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the biweight location estimator of the elements in list.
        /// https://reference.wolfram.com/language/ref/BiweightLocation.html
        ///</summary>
        corewolf::engine *BiweightLocation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BiweightLocation[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the biweight location estimator with scaling parameter c.
        /// https://reference.wolfram.com/language/ref/BiweightLocation.html
        ///</summary>
        corewolf::engine *BiweightLocation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BiweightLocation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the biweight midvariance of the elements in list.
        /// https://reference.wolfram.com/language/ref/BiweightMidvariance.html
        ///</summary>
        corewolf::engine *BiweightMidvariance(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BiweightMidvariance[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the biweight midvariance with scaling parameter c.
        /// https://reference.wolfram.com/language/ref/BiweightMidvariance.html
        ///</summary>
        corewolf::engine *BiweightMidvariance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BiweightMidvariance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Blackman–Harris window function of x.
        /// https://reference.wolfram.com/language/ref/BlackmanHarrisWindow.html
        ///</summary>
        corewolf::engine *BlackmanHarrisWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlackmanHarrisWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Blackman–Nuttall window function of x.
        /// https://reference.wolfram.com/language/ref/BlackmanNuttallWindow.html
        ///</summary>
        corewolf::engine *BlackmanNuttallWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlackmanNuttallWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Blackman window function of x.
        /// https://reference.wolfram.com/language/ref/BlackmanWindow.html
        ///</summary>
        corewolf::engine *BlackmanWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlackmanWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a pattern const std::string &that can stand for any Wolfram Language expression.
        /// https://reference.wolfram.com/language/ref/Blank.html
        ///</summary>
        corewolf::engine *Blank(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Blank[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a pattern const std::string &that can stand for any sequence of zero or more Wolfram Language expressions.
        /// https://reference.wolfram.com/language/ref/BlankNullSequence.html
        ///</summary>
        corewolf::engine *BlankNullSequence(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlankNullSequence[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a pattern const std::string &that can stand for any sequence of one or more Wolfram Language expressions.
        /// https://reference.wolfram.com/language/ref/BlankSequence.html
        ///</summary>
        corewolf::engine *BlankSequence(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlankSequence[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a color obtained by blending a fraction  of color col1 and  of color col2.
        /// https://reference.wolfram.com/language/ref/Blend.html
        ///</summary>
        corewolf::engine *Blend(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Blend[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// interpolates to give coli when x=xi.
        /// https://reference.wolfram.com/language/ref/Blend.html
        ///</summary>
        corewolf::engine *Blend(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Blend[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// blends all the coli, using fraction ui of color coli.
        /// https://reference.wolfram.com/language/ref/Blend.html
        ///</summary>
        corewolf::engine *Blend(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Blend[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// specifies that expr is to be evaluated with local values for the symbols x, y, ….
        /// https://reference.wolfram.com/language/ref/Block.html
        ///</summary>
        corewolf::engine *Block(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Block[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives available information connected with the specified address on the default blockchain.
        /// https://reference.wolfram.com/language/ref/BlockchainAddressData.html
        ///</summary>
        corewolf::engine *BlockchainAddressData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlockchainAddressData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the specified property of the blockchain address.
        /// https://reference.wolfram.com/language/ref/BlockchainAddressData.html
        ///</summary>
        corewolf::engine *BlockchainAddressData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BlockchainAddressData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives information about the block with the specified hash on the blockchain specified by $BlockchainBase.
        /// https://reference.wolfram.com/language/ref/BlockchainBlockData.html
        ///</summary>
        corewolf::engine *BlockchainBlockData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlockchainBlockData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the specified property of the block.
        /// https://reference.wolfram.com/language/ref/BlockchainBlockData.html
        ///</summary>
        corewolf::engine *BlockchainBlockData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BlockchainBlockData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gets the result obtained from a Wolfram expression contract at blockchain address caddr.
        /// https://reference.wolfram.com/language/ref/BlockchainContractValue.html
        ///</summary>
        corewolf::engine *BlockchainContractValue(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlockchainContractValue[" + arg0 + "]", name);
        }

        ///< summary>
        /// gets the property prop of the result obtained from a Wolfram expression contract with address caddr.
        /// https://reference.wolfram.com/language/ref/BlockchainContractValue.html
        ///</summary>
        corewolf::engine *BlockchainContractValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BlockchainContractValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives information about the blockchain specified by $BlockchainBase.
        /// https://reference.wolfram.com/language/ref/BlockchainData.html
        ///</summary>
        corewolf::engine *BlockchainData(const std::string &name = "")
        {
            return this->execute("BlockchainData[]", name);
        }

        ///< summary>
        /// gives the value of the specified property of the blockchain.
        /// https://reference.wolfram.com/language/ref/BlockchainData.html
        ///</summary>
        corewolf::engine *BlockchainData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlockchainData[" + arg0 + "]", name);
        }

        ///< summary>
        /// retrieves data from the Wolfram blockchain for the transaction with the specified ID.
        /// https://reference.wolfram.com/language/ref/BlockchainGet.html
        ///</summary>
        corewolf::engine *BlockchainGet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlockchainGet[" + arg0 + "]", name);
        }

        ///< summary>
        /// encodes a private or public key in the specified blockchain format.
        /// https://reference.wolfram.com/language/ref/BlockchainKeyEncode.html
        ///</summary>
        corewolf::engine *BlockchainKeyEncode(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BlockchainKeyEncode[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// adds expr to the Wolfram blockchain.
        /// https://reference.wolfram.com/language/ref/BlockchainPut.html
        ///</summary>
        corewolf::engine *BlockchainPut(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlockchainPut[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives information about the use of tokens with the specified name on a blockchain.
        /// https://reference.wolfram.com/language/ref/BlockchainTokenData.html
        ///</summary>
        corewolf::engine *BlockchainTokenData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlockchainTokenData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the specified property of token usage.
        /// https://reference.wolfram.com/language/ref/BlockchainTokenData.html
        ///</summary>
        corewolf::engine *BlockchainTokenData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BlockchainTokenData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a blockchain transaction built from the components in the association assoc.
        /// https://reference.wolfram.com/language/ref/BlockchainTransaction.html
        ///</summary>
        corewolf::engine *BlockchainTransaction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlockchainTransaction[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives information about the blockchain transaction with ID txid on the blockchain specified by $BlockchainBase.
        /// https://reference.wolfram.com/language/ref/BlockchainTransactionData.html
        ///</summary>
        corewolf::engine *BlockchainTransactionData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlockchainTransactionData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the specified property of the transaction.
        /// https://reference.wolfram.com/language/ref/BlockchainTransactionData.html
        ///</summary>
        corewolf::engine *BlockchainTransactionData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BlockchainTransactionData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// digitally signs a blockchain transaction using the specified private key.
        /// https://reference.wolfram.com/language/ref/BlockchainTransactionSign.html
        ///</summary>
        corewolf::engine *BlockchainTransactionSign(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BlockchainTransactionSign[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// digitally signs a transaction using all the keys keyi.
        /// https://reference.wolfram.com/language/ref/BlockchainTransactionSign.html
        ///</summary>
        corewolf::engine *BlockchainTransactionSign(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BlockchainTransactionSign[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// submits the transaction specified in the BlockchainTransaction const std::string &obj to a blockchain.
        /// https://reference.wolfram.com/language/ref/BlockchainTransactionSubmit.html
        ///</summary>
        corewolf::engine *BlockchainTransactionSubmit(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlockchainTransactionSubmit[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the block diagonal matrix with diagonal blocks di as a structured array.
        /// https://reference.wolfram.com/language/ref/BlockDiagonalMatrix.html
        ///</summary>
        corewolf::engine *BlockDiagonalMatrix(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BlockDiagonalMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// converts the block diagonal matrix mat to a structured array.
        /// https://reference.wolfram.com/language/ref/BlockDiagonalMatrix.html
        ///</summary>
        corewolf::engine *BlockDiagonalMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlockDiagonalMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the block lower triangular matrix lmat as a structured array.
        /// https://reference.wolfram.com/language/ref/BlockLowerTriangularMatrix.html
        ///</summary>
        corewolf::engine *BlockLowerTriangularMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlockLowerTriangularMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies f to non-overlapping sublists of length n in list.
        /// https://reference.wolfram.com/language/ref/BlockMap.html
        ///</summary>
        corewolf::engine *BlockMap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BlockMap[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies f to sublists with offset d in list.
        /// https://reference.wolfram.com/language/ref/BlockMap.html
        ///</summary>
        corewolf::engine *BlockMap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("BlockMap[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// applies f to blocks of size n1×n2×….
        /// https://reference.wolfram.com/language/ref/BlockMap.html
        ///</summary>
        corewolf::engine *BlockMap(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("BlockMap[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// evaluates expr with all pseudorandom generators localized, so that uses of SeedRandom, RandomInteger, and related functions within the evaluation of expr do not affect subsequent pseudorandom sequences.
        /// https://reference.wolfram.com/language/ref/BlockRandom.html
        ///</summary>
        corewolf::engine *BlockRandom(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlockRandom[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the block upper triangular matrix umat as a structured array.
        /// https://reference.wolfram.com/language/ref/BlockUpperTriangularMatrix.html
        ///</summary>
        corewolf::engine *BlockUpperTriangularMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlockUpperTriangularMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives Blomqvist's medial correlation coefficient β for the vectors v1 and v2.
        /// https://reference.wolfram.com/language/ref/BlomqvistBeta.html
        ///</summary>
        corewolf::engine *BlomqvistBeta(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BlomqvistBeta[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives Blomqvist's medial correlation coefficient β for the matrix m.
        /// https://reference.wolfram.com/language/ref/BlomqvistBeta.html
        ///</summary>
        corewolf::engine *BlomqvistBeta(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BlomqvistBeta[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the (i,j) medial correlation coefficient for the multivariate symbolic distribution dist.
        /// https://reference.wolfram.com/language/ref/BlomqvistBeta.html
        ///</summary>
        corewolf::engine *BlomqvistBeta(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BlomqvistBeta[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether the vectors v1 and v2 are independent.
        /// https://reference.wolfram.com/language/ref/BlomqvistBetaTest.html
        ///</summary>
        corewolf::engine *BlomqvistBetaTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BlomqvistBetaTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a blurred version of image.
        /// https://reference.wolfram.com/language/ref/Blur.html
        ///</summary>
        corewolf::engine *Blur(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Blur[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a version of image blurred over pixel radius r.
        /// https://reference.wolfram.com/language/ref/Blur.html
        ///</summary>
        corewolf::engine *Blur(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Blur[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a Bode plot of a linear time-invariant system lsys.
        /// https://reference.wolfram.com/language/ref/BodePlot.html
        ///</summary>
        corewolf::engine *BodePlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BodePlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots for the frequency range ωmin to ωmax.
        /// https://reference.wolfram.com/language/ref/BodePlot.html
        ///</summary>
        corewolf::engine *BodePlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BodePlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a Bohman window function of x.
        /// https://reference.wolfram.com/language/ref/BohmanWindow.html
        ///</summary>
        corewolf::engine *BohmanWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BohmanWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a single chemical bond between atoms with indices idi and idj.
        /// https://reference.wolfram.com/language/ref/Bond.html
        ///</summary>
        corewolf::engine *Bond(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Bond[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a chemical bond of the specified type.
        /// https://reference.wolfram.com/language/ref/Bond.html
        ///</summary>
        corewolf::engine *Bond(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Bond[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the number of bonds in the molecule mol.
        /// https://reference.wolfram.com/language/ref/BondCount.html
        ///</summary>
        corewolf::engine *BondCount(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BondCount[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number of bonds in the molecule mol matching the bond pattern patt.
        /// https://reference.wolfram.com/language/ref/BondCount.html
        ///</summary>
        corewolf::engine *BondCount(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BondCount[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of bonds in the molecule mol.
        /// https://reference.wolfram.com/language/ref/BondList.html
        ///</summary>
        corewolf::engine *BondList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BondList[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the list of bonds in the molecule mol matching the atom pattern patt.
        /// https://reference.wolfram.com/language/ref/BondList.html
        ///</summary>
        corewolf::engine *BondList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BondList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value for the specified property of the bonds matching patt.
        /// https://reference.wolfram.com/language/ref/BondList.html
        ///</summary>
        corewolf::engine *BondList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BondList[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives True if bond is a bond in the molecule m, and False otherwise.
        /// https://reference.wolfram.com/language/ref/BondQ.html
        ///</summary>
        corewolf::engine *BondQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BondQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields 1 if expr is True and 0 if it is False.
        /// https://reference.wolfram.com/language/ref/Boole.html
        ///</summary>
        corewolf::engine *Boole(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Boole[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Boolean function of n variables that gives True if k consecutive variables are True.
        /// https://reference.wolfram.com/language/ref/BooleanConsecutiveFunction.html
        ///</summary>
        corewolf::engine *BooleanConsecutiveFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BooleanConsecutiveFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// treats the variable list as cyclic.
        /// https://reference.wolfram.com/language/ref/BooleanConsecutiveFunction.html
        ///</summary>
        corewolf::engine *BooleanConsecutiveFunction(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BooleanConsecutiveFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Boolean function of n1 n2 ⋯ nd variables that gives True if all variables in a  block of the  variable array are True.
        /// https://reference.wolfram.com/language/ref/BooleanConsecutiveFunction.html
        ///</summary>
        corewolf::engine *BooleanConsecutiveFunction(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BooleanConsecutiveFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// treats the i level of the variable array as cyclic if ci is True.
        /// https://reference.wolfram.com/language/ref/BooleanConsecutiveFunction.html
        ///</summary>
        corewolf::engine *BooleanConsecutiveFunction(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("BooleanConsecutiveFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Boolean expression in variables ai corresponding to the Boolean consecutive function specified by spec.
        /// https://reference.wolfram.com/language/ref/BooleanConsecutiveFunction.html
        ///</summary>
        corewolf::engine *BooleanConsecutiveFunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BooleanConsecutiveFunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Boolean expression in the form specified by form.
        /// https://reference.wolfram.com/language/ref/BooleanConsecutiveFunction.html
        ///</summary>
        corewolf::engine *BooleanConsecutiveFunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BooleanConsecutiveFunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// converts the Boolean expression expr to disjunctive normal form.
        /// https://reference.wolfram.com/language/ref/BooleanConvert.html
        ///</summary>
        corewolf::engine *BooleanConvert(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BooleanConvert[" + arg0 + "]", name);
        }

        ///< summary>
        /// converts the Boolean expression expr to the specified form.
        /// https://reference.wolfram.com/language/ref/BooleanConvert.html
        ///</summary>
        corewolf::engine *BooleanConvert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BooleanConvert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds an expression in the specified form that is equivalent to expr when cond is true.
        /// https://reference.wolfram.com/language/ref/BooleanConvert.html
        ///</summary>
        corewolf::engine *BooleanConvert(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BooleanConvert[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Boolean function of n variables that gives True if at most kmax variables are True.
        /// https://reference.wolfram.com/language/ref/BooleanCountingFunction.html
        ///</summary>
        corewolf::engine *BooleanCountingFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BooleanCountingFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a function of n variables that gives True if exactly k variables are True.
        /// https://reference.wolfram.com/language/ref/BooleanCountingFunction.html
        ///</summary>
        corewolf::engine *BooleanCountingFunction(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BooleanCountingFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Boolean expression in variables ai corresponding to the Boolean counting function specified by spec.
        /// https://reference.wolfram.com/language/ref/BooleanCountingFunction.html
        ///</summary>
        corewolf::engine *BooleanCountingFunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BooleanCountingFunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Boolean expression in the form specified by form.
        /// https://reference.wolfram.com/language/ref/BooleanCountingFunction.html
        ///</summary>
        corewolf::engine *BooleanCountingFunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BooleanCountingFunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the k Boolean function in n variables.
        /// https://reference.wolfram.com/language/ref/BooleanFunction.html
        ///</summary>
        corewolf::engine *BooleanFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BooleanFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the Boolean function corresponding to the specified vector of truth values.
        /// https://reference.wolfram.com/language/ref/BooleanFunction.html
        ///</summary>
        corewolf::engine *BooleanFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BooleanFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the Boolean function defined by the specified mapping from inputs to outputs.
        /// https://reference.wolfram.com/language/ref/BooleanFunction.html
        ///</summary>
        corewolf::engine *BooleanFunction(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BooleanFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Boolean expression in variables ai corresponding to the Boolean function specified by spec.
        /// https://reference.wolfram.com/language/ref/BooleanFunction.html
        ///</summary>
        corewolf::engine *BooleanFunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BooleanFunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Boolean expression in the form specified by form.
        /// https://reference.wolfram.com/language/ref/BooleanFunction.html
        ///</summary>
        corewolf::engine *BooleanFunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BooleanFunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Boolean graph defined by the Boolean function bfunc on the graphs g1, …, gn.
        /// https://reference.wolfram.com/language/ref/BooleanGraph.html
        ///</summary>
        corewolf::engine *BooleanGraph(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("BooleanGraph[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents the k maxterm in n variables.
        /// https://reference.wolfram.com/language/ref/BooleanMaxterms.html
        ///</summary>
        corewolf::engine *BooleanMaxterms(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BooleanMaxterms[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the conjunction of the maxterms ki.
        /// https://reference.wolfram.com/language/ref/BooleanMaxterms.html
        ///</summary>
        corewolf::engine *BooleanMaxterms(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BooleanMaxterms[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the conjunction of maxterms given by the exponent vectors ui, vi, ….
        /// https://reference.wolfram.com/language/ref/BooleanMaxterms.html
        ///</summary>
        corewolf::engine *BooleanMaxterms(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BooleanMaxterms[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Boolean expression in variables ai corresponding to the maxterms function specified by spec.
        /// https://reference.wolfram.com/language/ref/BooleanMaxterms.html
        ///</summary>
        corewolf::engine *BooleanMaxterms(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BooleanMaxterms[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Boolean expression in the form specified by form.
        /// https://reference.wolfram.com/language/ref/BooleanMaxterms.html
        ///</summary>
        corewolf::engine *BooleanMaxterms(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BooleanMaxterms[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds a minimal-length disjunctive normal form representation of expr.
        /// https://reference.wolfram.com/language/ref/BooleanMinimize.html
        ///</summary>
        corewolf::engine *BooleanMinimize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BooleanMinimize[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds a minimal-length representation for expr in the specified form.
        /// https://reference.wolfram.com/language/ref/BooleanMinimize.html
        ///</summary>
        corewolf::engine *BooleanMinimize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BooleanMinimize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a minimal-length expression in the specified form that is equivalent to expr when cond is true.
        /// https://reference.wolfram.com/language/ref/BooleanMinimize.html
        ///</summary>
        corewolf::engine *BooleanMinimize(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BooleanMinimize[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the k minterm in n variables.
        /// https://reference.wolfram.com/language/ref/BooleanMinterms.html
        ///</summary>
        corewolf::engine *BooleanMinterms(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BooleanMinterms[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the disjunction of the minterms ki.
        /// https://reference.wolfram.com/language/ref/BooleanMinterms.html
        ///</summary>
        corewolf::engine *BooleanMinterms(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BooleanMinterms[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the disjunction of minterms given by the exponent vectors ui, vi, ….
        /// https://reference.wolfram.com/language/ref/BooleanMinterms.html
        ///</summary>
        corewolf::engine *BooleanMinterms(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BooleanMinterms[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Boolean expression in variables ai corresponding to the minterms function specified by spec.
        /// https://reference.wolfram.com/language/ref/BooleanMinterms.html
        ///</summary>
        corewolf::engine *BooleanMinterms(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BooleanMinterms[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Boolean expression in the form specified by form.
        /// https://reference.wolfram.com/language/ref/BooleanMinterms.html
        ///</summary>
        corewolf::engine *BooleanMinterms(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BooleanMinterms[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns True if expr is either True or False.
        /// https://reference.wolfram.com/language/ref/BooleanQ.html
        ///</summary>
        corewolf::engine *BooleanQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BooleanQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the Boolean combination bfunc of regions reg1, reg2, ….
        /// https://reference.wolfram.com/language/ref/BooleanRegion.html
        ///</summary>
        corewolf::engine *BooleanRegion(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BooleanRegion[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of truth values for all possible combinations of variable values supplied to the Boolean function bf.
        /// https://reference.wolfram.com/language/ref/BooleanTable.html
        ///</summary>
        corewolf::engine *BooleanTable(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BooleanTable[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of the truth values of the Boolean expression expr for all possible combinations of values of the ai.
        /// https://reference.wolfram.com/language/ref/BooleanTable.html
        ///</summary>
        corewolf::engine *BooleanTable(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BooleanTable[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a nested table of truth values of expr with the outermost level giving possible combinations of the ai.
        /// https://reference.wolfram.com/language/ref/BooleanTable.html
        ///</summary>
        corewolf::engine *BooleanTable(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("BooleanTable[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives a list of the Boolean variables in the Boolean expression expr.
        /// https://reference.wolfram.com/language/ref/BooleanVariables.html
        ///</summary>
        corewolf::engine *BooleanVariables(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BooleanVariables[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the pixel width of uniform borders of image in the form {{left,right},{bottom,top}}.
        /// https://reference.wolfram.com/language/ref/BorderDimensions.html
        ///</summary>
        corewolf::engine *BorderDimensions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BorderDimensions[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds borders whose pixels vary by an amount less than t.
        /// https://reference.wolfram.com/language/ref/BorderDimensions.html
        ///</summary>
        corewolf::engine *BorderDimensions(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BorderDimensions[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Borel–Tanner distribution with shape parameters α and n.
        /// https://reference.wolfram.com/language/ref/BorelTannerDistribution.html
        ///</summary>
        corewolf::engine *BorelTannerDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BorelTannerDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the morphological bottom-hat transform of image with respect to structuring element ker.
        /// https://reference.wolfram.com/language/ref/BottomHatTransform.html
        ///</summary>
        corewolf::engine *BottomHatTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BottomHatTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// discretizes a 2D or 3D graphic g into a BoundaryMeshRegion.
        /// https://reference.wolfram.com/language/ref/BoundaryDiscretizeGraphics.html
        ///</summary>
        corewolf::engine *BoundaryDiscretizeGraphics(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BoundaryDiscretizeGraphics[" + arg0 + "]", name);
        }

        ///< summary>
        /// discretizes only the elements in g that match the pattern patt.
        /// https://reference.wolfram.com/language/ref/BoundaryDiscretizeGraphics.html
        ///</summary>
        corewolf::engine *BoundaryDiscretizeGraphics(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BoundaryDiscretizeGraphics[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// discretizes the region reg into a BoundaryMeshRegion.
        /// https://reference.wolfram.com/language/ref/BoundaryDiscretizeRegion.html
        ///</summary>
        corewolf::engine *BoundaryDiscretizeRegion(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BoundaryDiscretizeRegion[" + arg0 + "]", name);
        }

        ///< summary>
        /// restricts to the bounds .
        /// https://reference.wolfram.com/language/ref/BoundaryDiscretizeRegion.html
        ///</summary>
        corewolf::engine *BoundaryDiscretizeRegion(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BoundaryDiscretizeRegion[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a BoundaryMeshRegion from a MeshRegion mreg.
        /// https://reference.wolfram.com/language/ref/BoundaryMesh.html
        ///</summary>
        corewolf::engine *BoundaryMesh(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BoundaryMesh[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields a mesh with boundary cells bcellj, where coordinates given as integer i are taken to be pi, where the cells together represent a closed curve, surface, etc.
        /// https://reference.wolfram.com/language/ref/BoundaryMeshRegion.html
        ///</summary>
        corewolf::engine *BoundaryMeshRegion(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BoundaryMeshRegion[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields a mesh with cell properties defined by the symbolic wrapper wi.
        /// https://reference.wolfram.com/language/ref/BoundaryMeshRegion.html
        ///</summary>
        corewolf::engine *BoundaryMeshRegion(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BoundaryMeshRegion[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields a mesh from multiple boundaries boundaryi.
        /// https://reference.wolfram.com/language/ref/BoundaryMeshRegion.html
        ///</summary>
        corewolf::engine *BoundaryMeshRegion(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("BoundaryMeshRegion[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// yields True if the region reg is a valid BoundaryMeshRegion const std::string &and False otherwise.
        /// https://reference.wolfram.com/language/ref/BoundaryMeshRegionQ.html
        ///</summary>
        corewolf::engine *BoundaryMeshRegionQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BoundaryMeshRegionQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if reg is a bounded region and False otherwise.
        /// https://reference.wolfram.com/language/ref/BoundedRegionQ.html
        ///</summary>
        corewolf::engine *BoundedRegionQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BoundedRegionQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the minimal axis-aligned bounding box for the points pt1, pt2, ….
        /// https://reference.wolfram.com/language/ref/BoundingRegion.html
        ///</summary>
        corewolf::engine *BoundingRegion(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BoundingRegion[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a bounding region of type form.
        /// https://reference.wolfram.com/language/ref/BoundingRegion.html
        ///</summary>
        corewolf::engine *BoundingRegion(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BoundingRegion[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a bounding region for the region reg.
        /// https://reference.wolfram.com/language/ref/BoundingRegion.html
        ///</summary>
        corewolf::engine *BoundingRegion(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BoundingRegion[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a low-level representation of the contents of a typesetting cell.
        /// https://reference.wolfram.com/language/ref/BoxData.html
        ///</summary>
        corewolf::engine *BoxData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BoxData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a  matrix of s.
        /// https://reference.wolfram.com/language/ref/BoxMatrix.html
        ///</summary>
        corewolf::engine *BoxMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BoxMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a  block of s centered in a w×w matrix of s.
        /// https://reference.wolfram.com/language/ref/BoxMatrix.html
        ///</summary>
        corewolf::engine *BoxMatrix(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BoxMatrix[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a  array of s.
        /// https://reference.wolfram.com/language/ref/BoxMatrix.html
        ///</summary>
        corewolf::engine *BoxMatrix(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BoxMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is an const std::string &that represents a box structure in an open notebook in the front end.
        /// https://reference.wolfram.com/language/ref/BoxObject.html
        ///</summary>
        corewolf::engine *BoxObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BoxObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes a box‐and‐whisker chart for the values xi.
        /// https://reference.wolfram.com/language/ref/BoxWhiskerChart.html
        ///</summary>
        corewolf::engine *BoxWhiskerChart(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BoxWhiskerChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a chart with box‐and‐whisker symbol specification bwspec.
        /// https://reference.wolfram.com/language/ref/BoxWhiskerChart.html
        ///</summary>
        corewolf::engine *BoxWhiskerChart(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BoxWhiskerChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as x,y,….
        /// https://reference.wolfram.com/language/ref/BracketingBar.html
        ///</summary>
        corewolf::engine *BracketingBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BracketingBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Bray–Curtis distance between vectors u and v.
        /// https://reference.wolfram.com/language/ref/BrayCurtisDistance.html
        ///</summary>
        corewolf::engine *BrayCurtisDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BrayCurtisDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// performs a breadth-first scan (bfs) of the graph g starting at the vertex s and evaluates fi whenever "eventi" occurs.
        /// https://reference.wolfram.com/language/ref/BreadthFirstScan.html
        ///</summary>
        corewolf::engine *BreadthFirstScan(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("BreadthFirstScan[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// performs a breadth-first scan of the whole graph g.
        /// https://reference.wolfram.com/language/ref/BreadthFirstScan.html
        ///</summary>
        corewolf::engine *BreadthFirstScan(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BreadthFirstScan[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/BreadthFirstScan.html
        ///</summary>
        corewolf::engine *BreadthFirstScan(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BreadthFirstScan[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// exits the nearest enclosing Do, For, or While.
        /// https://reference.wolfram.com/language/ref/Break.html
        ///</summary>
        corewolf::engine *Break(const std::string &name = "")
        {
            return this->execute("Break[]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the bridge entity.
        /// https://reference.wolfram.com/language/ref/BridgeData.html
        ///</summary>
        corewolf::engine *BridgeData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BridgeData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified bridge entities.
        /// https://reference.wolfram.com/language/ref/BridgeData.html
        ///</summary>
        corewolf::engine *BridgeData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BridgeData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/BridgeData.html
        ///</summary>
        corewolf::engine *BridgeData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BridgeData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// adjusts the brightness across image, correcting uneven illumination.
        /// https://reference.wolfram.com/language/ref/BrightnessEqualize.html
        ///</summary>
        corewolf::engine *BrightnessEqualize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BrightnessEqualize[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the correction model given by flatfield, which models the variation in brightness across image.
        /// https://reference.wolfram.com/language/ref/BrightnessEqualize.html
        ///</summary>
        corewolf::engine *BrightnessEqualize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BrightnessEqualize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the dark environment model given by darkfield.
        /// https://reference.wolfram.com/language/ref/BrightnessEqualize.html
        ///</summary>
        corewolf::engine *BrightnessEqualize(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BrightnessEqualize[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the broadcast station entity.
        /// https://reference.wolfram.com/language/ref/BroadcastStationData.html
        ///</summary>
        corewolf::engine *BroadcastStationData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BroadcastStationData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified broadcast station entities.
        /// https://reference.wolfram.com/language/ref/BroadcastStationData.html
        ///</summary>
        corewolf::engine *BroadcastStationData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BroadcastStationData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/BroadcastStationData.html
        ///</summary>
        corewolf::engine *BroadcastStationData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BroadcastStationData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether the variance of data is 1.
        /// https://reference.wolfram.com/language/ref/BrownForsytheTest.html
        ///</summary>
        corewolf::engine *BrownForsytheTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BrownForsytheTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the variances of data1, data2, … are equal.
        /// https://reference.wolfram.com/language/ref/BrownForsytheTest.html
        ///</summary>
        corewolf::engine *BrownForsytheTest(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BrownForsytheTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/BrownForsytheTest.html
        ///</summary>
        corewolf::engine *BrownForsytheTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BrownForsytheTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the Brownian bridge process from value a at time t1 to value b at time t2 with volatility σ.
        /// https://reference.wolfram.com/language/ref/BrownianBridgeProcess.html
        ///</summary>
        corewolf::engine *BrownianBridgeProcess(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("BrownianBridgeProcess[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents the standard Brownian bridge process from value a at time t1 to value b at time t2.
        /// https://reference.wolfram.com/language/ref/BrownianBridgeProcess.html
        ///</summary>
        corewolf::engine *BrownianBridgeProcess(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BrownianBridgeProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents the standard Brownian bridge process pinned at 0 at times t1 and t2.
        /// https://reference.wolfram.com/language/ref/BrownianBridgeProcess.html
        ///</summary>
        corewolf::engine *BrownianBridgeProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BrownianBridgeProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the standard Brownian bridge process pinned at 0 at time 0 and at time 1.
        /// https://reference.wolfram.com/language/ref/BrownianBridgeProcess.html
        ///</summary>
        corewolf::engine *BrownianBridgeProcess(const std::string &name = "")
        {
            return this->execute("BrownianBridgeProcess[]", name);
        }

        ///< summary>
        /// gives the zeroth uniform B-spline basis function of degree d at x.
        /// https://reference.wolfram.com/language/ref/BSplineBasis.html
        ///</summary>
        corewolf::engine *BSplineBasis(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BSplineBasis[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the n uniform B-spline basis function of degree d.
        /// https://reference.wolfram.com/language/ref/BSplineBasis.html
        ///</summary>
        corewolf::engine *BSplineBasis(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BSplineBasis[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the n non-uniform B-spline basis function of degree d with knots at positions ui.
        /// https://reference.wolfram.com/language/ref/BSplineBasis.html
        ///</summary>
        corewolf::engine *BSplineBasis(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("BSplineBasis[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// is a graphics primitive that represents a nonuniform rational B-spline curve with control points pti.
        /// https://reference.wolfram.com/language/ref/BSplineCurve.html
        ///</summary>
        corewolf::engine *BSplineCurve(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BSplineCurve[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a B-spline function for a curve defined by the control points pti.
        /// https://reference.wolfram.com/language/ref/BSplineFunction.html
        ///</summary>
        corewolf::engine *BSplineFunction(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BSplineFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a B-spline function for a surface or high-dimensional manifold.
        /// https://reference.wolfram.com/language/ref/BSplineFunction.html
        ///</summary>
        corewolf::engine *BSplineFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BSplineFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a graphics primitive that represents a nonuniform rational B-spline surface defined by an array of  control points.
        /// https://reference.wolfram.com/language/ref/BSplineSurface.html
        ///</summary>
        corewolf::engine *BSplineSurface(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BSplineSurface[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes a bubble chart with bubbles at positions {xi,yi} with sizes zi.
        /// https://reference.wolfram.com/language/ref/BubbleChart.html
        ///</summary>
        corewolf::engine *BubbleChart(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BubbleChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a bubble chart with bubble features defined by the symbolic wrappers wk.
        /// https://reference.wolfram.com/language/ref/BubbleChart.html
        ///</summary>
        corewolf::engine *BubbleChart(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("BubbleChart[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// makes a bubble chart from multiple datasets datai.
        /// https://reference.wolfram.com/language/ref/BubbleChart.html
        ///</summary>
        corewolf::engine *BubbleChart(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BubbleChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a 3D bubble chart with bubbles at positions {xi,yi,zi} with sizes ui.
        /// https://reference.wolfram.com/language/ref/BubbleChart3D.html
        ///</summary>
        corewolf::engine *BubbleChart3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("BubbleChart3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a 3D bubble chart with bubble features defined by the symbolic wrappers wk.
        /// https://reference.wolfram.com/language/ref/BubbleChart3D.html
        ///</summary>
        corewolf::engine *BubbleChart3D(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("BubbleChart3D[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// makes a 3D bubble chart from multiple datasets datai.
        /// https://reference.wolfram.com/language/ref/BubbleChart3D.html
        ///</summary>
        corewolf::engine *BubbleChart3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("BubbleChart3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the buckyball graph.
        /// https://reference.wolfram.com/language/ref/BuckyballGraph.html
        ///</summary>
        corewolf::engine *BuckyballGraph(const std::string &name = "")
        {
            return this->execute("BuckyballGraph[]", name);
        }

        ///< summary>
        /// gives the order‐n buckyball graph.
        /// https://reference.wolfram.com/language/ref/BuckyballGraph.html
        ///</summary>
        corewolf::engine *BuckyballGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BuckyballGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the order‐n buckyball graph of class "class".
        /// https://reference.wolfram.com/language/ref/BuckyballGraph.html
        ///</summary>
        corewolf::engine *BuckyballGraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BuckyballGraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the building entity.
        /// https://reference.wolfram.com/language/ref/BuildingData.html
        ///</summary>
        corewolf::engine *BuildingData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BuildingData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified building entities.
        /// https://reference.wolfram.com/language/ref/BuildingData.html
        ///</summary>
        corewolf::engine *BuildingData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BuildingData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/BuildingData.html
        ///</summary>
        corewolf::engine *BuildingData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BuildingData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// draws a bullet gauge showing value and reference in a range of min to max.
        /// https://reference.wolfram.com/language/ref/BulletGauge.html
        ///</summary>
        corewolf::engine *BulletGauge(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("BulletGauge[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// draws a bullet gauge with multiple values v1, v2, ….
        /// https://reference.wolfram.com/language/ref/BulletGauge.html
        ///</summary>
        corewolf::engine *BulletGauge(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("BulletGauge[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// draws a bullet gauge with multiple references r1, r2, ….
        /// https://reference.wolfram.com/language/ref/BulletGauge.html
        ///</summary>
        corewolf::engine *BulletGauge(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("BulletGauge[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns True if the date is a business day and returns False otherwise.
        /// https://reference.wolfram.com/language/ref/BusinessDayQ.html
        ///</summary>
        corewolf::engine *BusinessDayQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("BusinessDayQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the order-n butterfly graph.
        /// https://reference.wolfram.com/language/ref/ButterflyGraph.html
        ///</summary>
        corewolf::engine *ButterflyGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ButterflyGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the base-b order-n butterfly graph.
        /// https://reference.wolfram.com/language/ref/ButterflyGraph.html
        ///</summary>
        corewolf::engine *ButterflyGraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ButterflyGraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a lowpass Butterworth filter of order n and cutoff frequency of 1.
        /// https://reference.wolfram.com/language/ref/ButterworthFilterModel.html
        ///</summary>
        corewolf::engine *ButterworthFilterModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ButterworthFilterModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the cutoff frequency ωc.
        /// https://reference.wolfram.com/language/ref/ButterworthFilterModel.html
        ///</summary>
        corewolf::engine *ButterworthFilterModel(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ButterworthFilterModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// expresses the model in terms of the variable var.
        /// https://reference.wolfram.com/language/ref/ButterworthFilterModel.html
        ///</summary>
        corewolf::engine *ButterworthFilterModel(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ButterworthFilterModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a button that is labeled with label, and evaluates action whenever it is clicked.
        /// https://reference.wolfram.com/language/ref/Button.html
        ///</summary>
        corewolf::engine *Button(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Button[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a bar of buttons with labels lbli that perform actions acti when pressed.
        /// https://reference.wolfram.com/language/ref/ButtonBar.html
        ///</summary>
        corewolf::engine *ButtonBar(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ButtonBar[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// is a low-level box construct that represents a button in a notebook expression.
        /// https://reference.wolfram.com/language/ref/ButtonBox.html
        ///</summary>
        corewolf::engine *ButtonBox(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ButtonBox[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the notebook, if any, that contains the button which initiated the current evaluation.
        /// https://reference.wolfram.com/language/ref/ButtonNotebook.html
        ///</summary>
        corewolf::engine *ButtonNotebook(const std::string &name = "")
        {
            return this->execute("ButtonNotebook[]", name);
        }

        ///< summary>
        /// constructs a ByteArray const std::string &containing the byte values bi.
        /// https://reference.wolfram.com/language/ref/ByteArray.html
        ///</summary>
        corewolf::engine *ByteArray(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ByteArray[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// constructs a ByteArray const std::string &by extracting byte values from a Base64-encoded string.
        /// https://reference.wolfram.com/language/ref/ByteArray.html
        ///</summary>
        corewolf::engine *ByteArray(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ByteArray[" + arg0 + "]", name);
        }

        ///< summary>
        /// attempts to determine what ImportByteArray format could be used to import the ByteArray const std::string &ba.
        /// https://reference.wolfram.com/language/ref/ByteArrayFormat.html
        ///</summary>
        corewolf::engine *ByteArrayFormat(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ByteArrayFormat[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if the ByteArray const std::string &ba might be imported as format "fmt" and gives False otherwise.
        /// https://reference.wolfram.com/language/ref/ByteArrayFormatQ.html
        ///</summary>
        corewolf::engine *ByteArrayFormatQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ByteArrayFormatQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if ba might be imported as one of "fmti".
        /// https://reference.wolfram.com/language/ref/ByteArrayFormatQ.html
        ///</summary>
        corewolf::engine *ByteArrayFormatQ(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ByteArrayFormatQ[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives True if expr is a valid ByteArray object, and False otherwise.
        /// https://reference.wolfram.com/language/ref/ByteArrayQ.html
        ///</summary>
        corewolf::engine *ByteArrayQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ByteArrayQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a string by decoding the data in the byte array ba, assuming UTF-8 encoding.
        /// https://reference.wolfram.com/language/ref/ByteArrayToString.html
        ///</summary>
        corewolf::engine *ByteArrayToString(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ByteArrayToString[" + arg0 + "]", name);
        }

        ///< summary>
        /// interprets the data in the specified character encoding.
        /// https://reference.wolfram.com/language/ref/ByteArrayToString.html
        ///</summary>
        corewolf::engine *ByteArrayToString(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ByteArrayToString[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the number of bytes used internally by the Wolfram System to store expr.
        /// https://reference.wolfram.com/language/ref/ByteCount.html
        ///</summary>
        corewolf::engine *ByteCount(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ByteCount[" + arg0 + "]", name);
        }

        ///< summary>
        /// is the default form for the i  parameter or constant generated in representing the results of various symbolic computations.
        /// https://reference.wolfram.com/language/ref/C.html
        ///</summary>
        corewolf::engine *C(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("C[" + arg0 + "]", name);
        }

        ///< summary>
        /// converts the date const std::string &date to the specified calendar type calendar.
        /// https://reference.wolfram.com/language/ref/CalendarConvert.html
        ///</summary>
        corewolf::engine *CalendarConvert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CalendarConvert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts to the default calendar type.
        /// https://reference.wolfram.com/language/ref/CalendarConvert.html
        ///</summary>
        corewolf::engine *CalendarConvert(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CalendarConvert[" + arg0 + "]", name);
        }

        ///< summary>
        /// converts date1 through daten to the specified calendar.
        /// https://reference.wolfram.com/language/ref/CalendarConvert.html
        ///</summary>
        corewolf::engine *CalendarConvert(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CalendarConvert[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the default parameters associated with the date calendar cal.
        /// https://reference.wolfram.com/language/ref/CalendarData.html
        ///</summary>
        corewolf::engine *CalendarData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CalendarData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified parameter param for calendar cal.
        /// https://reference.wolfram.com/language/ref/CalendarData.html
        ///</summary>
        corewolf::engine *CalendarData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CalendarData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays expr in a plot as a callout pointing to data.
        /// https://reference.wolfram.com/language/ref/Callout.html
        ///</summary>
        corewolf::engine *Callout(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Callout[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays a callout with expr at a position specified by pos.
        /// https://reference.wolfram.com/language/ref/Callout.html
        ///</summary>
        corewolf::engine *Callout(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Callout[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays a callout anchored at a position specified by apos.
        /// https://reference.wolfram.com/language/ref/Callout.html
        ///</summary>
        corewolf::engine *Callout(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Callout[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// is a WSTP packet encapsulating a request to invoke the external function numbered integer with the arguments contained in list.
        /// https://reference.wolfram.com/language/ref/CallPacket.html
        ///</summary>
        corewolf::engine *CallPacket(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CallPacket[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Canberra distance between vectors u and v.
        /// https://reference.wolfram.com/language/ref/CanberraDistance.html
        ///</summary>
        corewolf::engine *CanberraDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CanberraDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// cancels out common factors in the numerator and denominator of expr.
        /// https://reference.wolfram.com/language/ref/Cancel.html
        ///</summary>
        corewolf::engine *Cancel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Cancel[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Cancel button in a dialog that closes the dialog window when clicked.
        /// https://reference.wolfram.com/language/ref/CancelButton.html
        ///</summary>
        corewolf::engine *CancelButton(const std::string &name = "")
        {
            return this->execute("CancelButton[]", name);
        }

        ///< summary>
        /// represents a button labeled Cancel that evaluates action when clicked.
        /// https://reference.wolfram.com/language/ref/CancelButton.html
        ///</summary>
        corewolf::engine *CancelButton(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CancelButton[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses label as the label for the button.
        /// https://reference.wolfram.com/language/ref/CancelButton.html
        ///</summary>
        corewolf::engine *CancelButton(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CancelButton[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// makes a chart with candles representing open, high, low, and close prices for each date.
        /// https://reference.wolfram.com/language/ref/CandlestickChart.html
        ///</summary>
        corewolf::engine *CandlestickChart(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CandlestickChart[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a candlestick chart for the financial entity "name" over the date range daterange.
        /// https://reference.wolfram.com/language/ref/CandlestickChart.html
        ///</summary>
        corewolf::engine *CandlestickChart(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CandlestickChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a canonical form of the graph g.
        /// https://reference.wolfram.com/language/ref/CanonicalGraph.html
        ///</summary>
        corewolf::engine *CanonicalGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CanonicalGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph.
        /// https://reference.wolfram.com/language/ref/CanonicalGraph.html
        ///</summary>
        corewolf::engine *CanonicalGraph(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CanonicalGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a canonical representation of the polygon poly with shared coordinates and with inner and outer boundaries.
        /// https://reference.wolfram.com/language/ref/CanonicalizePolygon.html
        ///</summary>
        corewolf::engine *CanonicalizePolygon(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CanonicalizePolygon[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a canonical representation of poly with the specified filter.
        /// https://reference.wolfram.com/language/ref/CanonicalizePolygon.html
        ///</summary>
        corewolf::engine *CanonicalizePolygon(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CanonicalizePolygon[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a canonical representation of the polyhedron poly with shared coordinates and with inner and outer boundaries.
        /// https://reference.wolfram.com/language/ref/CanonicalizePolyhedron.html
        ///</summary>
        corewolf::engine *CanonicalizePolyhedron(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CanonicalizePolyhedron[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a canonical representation of the region reg.
        /// https://reference.wolfram.com/language/ref/CanonicalizeRegion.html
        ///</summary>
        corewolf::engine *CanonicalizeRegion(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CanonicalizeRegion[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the canonical name for the entity specified by entity.
        /// https://reference.wolfram.com/language/ref/CanonicalName.html
        ///</summary>
        corewolf::engine *CanonicalName(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CanonicalName[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the canonical name for entity1 through entityn.
        /// https://reference.wolfram.com/language/ref/CanonicalName.html
        ///</summary>
        corewolf::engine *CanonicalName(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CanonicalName[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the canonical time warping (CTW) correspondence between sequences s1 and s2.
        /// https://reference.wolfram.com/language/ref/CanonicalWarpingCorrespondence.html
        ///</summary>
        corewolf::engine *CanonicalWarpingCorrespondence(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CanonicalWarpingCorrespondence[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses warp as initial warping correspondence.
        /// https://reference.wolfram.com/language/ref/CanonicalWarpingCorrespondence.html
        ///</summary>
        corewolf::engine *CanonicalWarpingCorrespondence(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CanonicalWarpingCorrespondence[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses a window win for local search.
        /// https://reference.wolfram.com/language/ref/CanonicalWarpingCorrespondence.html
        ///</summary>
        corewolf::engine *CanonicalWarpingCorrespondence(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("CanonicalWarpingCorrespondence[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the canonical time warping (CTW) distance between sequences s1 and s2.
        /// https://reference.wolfram.com/language/ref/CanonicalWarpingDistance.html
        ///</summary>
        corewolf::engine *CanonicalWarpingDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CanonicalWarpingDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses init as the initial correspondence between the two sequences.
        /// https://reference.wolfram.com/language/ref/CanonicalWarpingDistance.html
        ///</summary>
        corewolf::engine *CanonicalWarpingDistance(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CanonicalWarpingDistance[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses a window win for local search.
        /// https://reference.wolfram.com/language/ref/CanonicalWarpingDistance.html
        ///</summary>
        corewolf::engine *CanonicalWarpingDistance(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("CanonicalWarpingDistance[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives a mesh region representing the n-step Cantor set.
        /// https://reference.wolfram.com/language/ref/CantorMesh.html
        ///</summary>
        corewolf::engine *CantorMesh(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CantorMesh[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the n-step Cantor set in dimension d.
        /// https://reference.wolfram.com/language/ref/CantorMesh.html
        ///</summary>
        corewolf::engine *CantorMesh(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CantorMesh[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Cantor staircase function .
        /// https://reference.wolfram.com/language/ref/CantorStaircase.html
        ///</summary>
        corewolf::engine *CantorStaircase(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CantorStaircase[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an empty canvas in the current notebook in which you can do free-form drawing.
        /// https://reference.wolfram.com/language/ref/Canvas.html
        ///</summary>
        corewolf::engine *Canvas(const std::string &name = "")
        {
            return this->execute("Canvas[]", name);
        }

        ///< summary>
        /// represents a canvas that initially contains the specified 2D graphic.
        /// https://reference.wolfram.com/language/ref/Canvas.html
        ///</summary>
        corewolf::engine *Canvas(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Canvas[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as x⌢y⌢….
        /// https://reference.wolfram.com/language/ref/Cap.html
        ///</summary>
        corewolf::engine *Cap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Cap[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a graphics primitive that specifies what type of caps should be used at the ends of lines, tubes, and related primitives.
        /// https://reference.wolfram.com/language/ref/CapForm.html
        ///</summary>
        corewolf::engine *CapForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CapForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as x.
        /// https://reference.wolfram.com/language/ref/CapitalDifferentialD.html
        ///</summary>
        corewolf::engine *CapitalDifferentialD(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CapitalDifferentialD[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields a string in which the first character has been made uppercase.
        /// https://reference.wolfram.com/language/ref/Capitalize.html
        ///</summary>
        corewolf::engine *Capitalize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Capitalize[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a string capitalized using the specified capitalization scheme.
        /// https://reference.wolfram.com/language/ref/Capitalize.html
        ///</summary>
        corewolf::engine *Capitalize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Capitalize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the filled capsule between points {xi,yi,zi} and radius r.
        /// https://reference.wolfram.com/language/ref/CapsuleShape.html
        ///</summary>
        corewolf::engine *CapsuleShape(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CapsuleShape[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Caputo fractional differintegral  of the function .
        /// https://reference.wolfram.com/language/ref/CaputoD.html
        ///</summary>
        corewolf::engine *CaputoD(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CaputoD[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// Carleman linearizes the nonlinear state-space model sys according to spec.
        /// https://reference.wolfram.com/language/ref/CarlemanLinearize.html
        ///</summary>
        corewolf::engine *CarlemanLinearize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CarlemanLinearize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Carlson's elliptic integral .
        /// https://reference.wolfram.com/language/ref/CarlsonRC.html
        ///</summary>
        corewolf::engine *CarlsonRC(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CarlsonRC[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Carlson's elliptic integral .
        /// https://reference.wolfram.com/language/ref/CarlsonRD.html
        ///</summary>
        corewolf::engine *CarlsonRD(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CarlsonRD[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Carlson's elliptic integral .
        /// https://reference.wolfram.com/language/ref/CarlsonRE.html
        ///</summary>
        corewolf::engine *CarlsonRE(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CarlsonRE[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Carlson's elliptic integral .
        /// https://reference.wolfram.com/language/ref/CarlsonRF.html
        ///</summary>
        corewolf::engine *CarlsonRF(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CarlsonRF[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Carlson's elliptic integral .
        /// https://reference.wolfram.com/language/ref/CarlsonRG.html
        ///</summary>
        corewolf::engine *CarlsonRG(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CarlsonRG[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives Carlson's elliptic integral .
        /// https://reference.wolfram.com/language/ref/CarlsonRJ.html
        ///</summary>
        corewolf::engine *CarlsonRJ(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("CarlsonRJ[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the Carlson's elliptic integral .
        /// https://reference.wolfram.com/language/ref/CarlsonRK.html
        ///</summary>
        corewolf::engine *CarlsonRK(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CarlsonRK[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives Carlson's elliptic integral .
        /// https://reference.wolfram.com/language/ref/CarlsonRM.html
        ///</summary>
        corewolf::engine *CarlsonRM(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CarlsonRM[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Carmichael function .
        /// https://reference.wolfram.com/language/ref/CarmichaelLambda.html
        ///</summary>
        corewolf::engine *CarmichaelLambda(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CarmichaelLambda[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of the ei that match the pattern.
        /// https://reference.wolfram.com/language/ref/Cases.html
        ///</summary>
        corewolf::engine *Cases(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Cases[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of all parts of expr on levels specified by levelspec that match the pattern.
        /// https://reference.wolfram.com/language/ref/Cases.html
        ///</summary>
        corewolf::engine *Cases(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Cases[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the first n parts in expr that match the pattern.
        /// https://reference.wolfram.com/language/ref/Cases.html
        ///</summary>
        corewolf::engine *Cases(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Cases[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an operator form of Cases that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/Cases.html
        ///</summary>
        corewolf::engine *Cases(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Cases[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a string pattern that requires matching typographical case, even with the overall option setting IgnoreCase->True.
        /// https://reference.wolfram.com/language/ref/CaseSensitive.html
        ///</summary>
        corewolf::engine *CaseSensitive(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CaseSensitive[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a series of cash flows occurring at unit time intervals.
        /// https://reference.wolfram.com/language/ref/Cashflow.html
        ///</summary>
        corewolf::engine *Cashflow(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Cashflow[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents cash flows occurring at time intervals q.
        /// https://reference.wolfram.com/language/ref/Cashflow.html
        ///</summary>
        corewolf::engine *Cashflow(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Cashflow[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents cash flows occurring at the specified times.
        /// https://reference.wolfram.com/language/ref/Cashflow.html
        ///</summary>
        corewolf::engine *Cashflow(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Cashflow[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Casoratian determinant for the sequences y1, y2, … depending on n.
        /// https://reference.wolfram.com/language/ref/Casoratian.html
        ///</summary>
        corewolf::engine *Casoratian(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Casoratian[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Casoratian determinant for the basis of the solutions of the linear difference equation eqn involving y[n+m].
        /// https://reference.wolfram.com/language/ref/Casoratian.html
        ///</summary>
        corewolf::engine *Casoratian(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Casoratian[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Casoratian determinant for the system of linear difference equations eqns.
        /// https://reference.wolfram.com/language/ref/Casoratian.html
        ///</summary>
        corewolf::engine *Casoratian(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Casoratian[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// converts val to the type type, for use in compiled code.
        /// https://reference.wolfram.com/language/ref/Cast.html
        ///</summary>
        corewolf::engine *Cast(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Cast[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reinterprets the bits representing val as having the type type.
        /// https://reference.wolfram.com/language/ref/Cast.html
        ///</summary>
        corewolf::engine *Cast(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Cast[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the n Catalan number .
        /// https://reference.wolfram.com/language/ref/CatalanNumber.html
        ///</summary>
        corewolf::engine *CatalanNumber(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CatalanNumber[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the argument of the first Throw generated in the evaluation of expr.
        /// https://reference.wolfram.com/language/ref/Catch.html
        ///</summary>
        corewolf::engine *Catch(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Catch[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns value from the first Throw[value,tag] for which form matches tag.
        /// https://reference.wolfram.com/language/ref/Catch.html
        ///</summary>
        corewolf::engine *Catch(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Catch[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns f[value,tag].
        /// https://reference.wolfram.com/language/ref/Catch.html
        ///</summary>
        corewolf::engine *Catch(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Catch[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a uniform categorical distribution over classes c1, c2, etc.
        /// https://reference.wolfram.com/language/ref/CategoricalDistribution.html
        ///</summary>
        corewolf::engine *CategoricalDistribution(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CategoricalDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a categorical distribution over classes ci with weights wi.
        /// https://reference.wolfram.com/language/ref/CategoricalDistribution.html
        ///</summary>
        corewolf::engine *CategoricalDistribution(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CategoricalDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses the array weights to define probabilities over each element of the domain.
        /// https://reference.wolfram.com/language/ref/CategoricalDistribution.html
        ///</summary>
        corewolf::engine *CategoricalDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CategoricalDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields a single list with all elements from the listi in order.
        /// https://reference.wolfram.com/language/ref/Catenate.html
        ///</summary>
        corewolf::engine *Catenate(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Catenate[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a net layer that takes a list of input arrays and catenates them.
        /// https://reference.wolfram.com/language/ref/CatenateLayer.html
        ///</summary>
        corewolf::engine *CatenateLayer(const std::string &name = "")
        {
            return this->execute("CatenateLayer[]", name);
        }

        ///< summary>
        /// represents a net layer that takes a list of input arrays and catenates them at level n.
        /// https://reference.wolfram.com/language/ref/CatenateLayer.html
        ///</summary>
        corewolf::engine *CatenateLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CatenateLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Cauchy distribution with location parameter a and scale parameter b.
        /// https://reference.wolfram.com/language/ref/CauchyDistribution.html
        ///</summary>
        corewolf::engine *CauchyDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CauchyDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Cauchy distribution with location parameter 0 and scale parameter 1.
        /// https://reference.wolfram.com/language/ref/CauchyDistribution.html
        ///</summary>
        corewolf::engine *CauchyDistribution(const std::string &name = "")
        {
            return this->execute("CauchyDistribution[]", name);
        }

        ///< summary>
        /// represents a Cauchy cluster point process with density μ, cluster mean λ and scale parameter b in .
        /// https://reference.wolfram.com/language/ref/CauchyPointProcess.html
        ///</summary>
        corewolf::engine *CauchyPointProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("CauchyPointProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a Cauchy window function of x.
        /// https://reference.wolfram.com/language/ref/CauchyWindow.html
        ///</summary>
        corewolf::engine *CauchyWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CauchyWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the parameter α.
        /// https://reference.wolfram.com/language/ref/CauchyWindow.html
        ///</summary>
        corewolf::engine *CauchyWindow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CauchyWindow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a Cayley graph representation of group.
        /// https://reference.wolfram.com/language/ref/CayleyGraph.html
        ///</summary>
        corewolf::engine *CayleyGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CayleyGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the cumulative distribution function for the distribution dist evaluated at x.
        /// https://reference.wolfram.com/language/ref/CDF.html
        ///</summary>
        corewolf::engine *CDF(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CDF[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the multivariate cumulative distribution function for the distribution dist evaluated at {x1,x2,…}.
        /// https://reference.wolfram.com/language/ref/CDF.html
        ///</summary>
        corewolf::engine *CDF(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CDF[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the CDF as a pure function.
        /// https://reference.wolfram.com/language/ref/CDF.html
        ///</summary>
        corewolf::engine *CDF(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CDF[" + arg0 + "]", name);
        }

        ///< summary>
        /// deploys expr in a form that can be played by Wolfram Player.
        /// https://reference.wolfram.com/language/ref/CDFDeploy.html
        ///</summary>
        corewolf::engine *CDFDeploy(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CDFDeploy[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Cohen–Daubechies–Feauveau wavelet of type "9/7".
        /// https://reference.wolfram.com/language/ref/CDFWavelet.html
        ///</summary>
        corewolf::engine *CDFWavelet(const std::string &name = "")
        {
            return this->execute("CDFWavelet[]", name);
        }

        ///< summary>
        /// represents a Cohen–Daubechies–Feauveau wavelet of type "type".
        /// https://reference.wolfram.com/language/ref/CDFWavelet.html
        ///</summary>
        corewolf::engine *CDFWavelet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CDFWavelet[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the smallest integer greater than or equal to x.
        /// https://reference.wolfram.com/language/ref/Ceiling.html
        ///</summary>
        corewolf::engine *Ceiling(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Ceiling[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the smallest multiple of a greater than or equal to x.
        /// https://reference.wolfram.com/language/ref/Ceiling.html
        ///</summary>
        corewolf::engine *Ceiling(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Ceiling[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is the low-level representation of a cell inside a Wolfram System notebook.
        /// https://reference.wolfram.com/language/ref/Cell.html
        ///</summary>
        corewolf::engine *Cell(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Cell[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a cell in the specified style.
        /// https://reference.wolfram.com/language/ref/Cell.html
        ///</summary>
        corewolf::engine *Cell(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Cell[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a cell with multiple styles applied to it.
        /// https://reference.wolfram.com/language/ref/Cell.html
        ///</summary>
        corewolf::engine *Cell(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Cell[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives an open group of cells that can appear in a Wolfram System notebook.
        /// https://reference.wolfram.com/language/ref/CellGroup.html
        ///</summary>
        corewolf::engine *CellGroup(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CellGroup[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a cell group in which only the first cell is open.
        /// https://reference.wolfram.com/language/ref/CellGroup.html
        ///</summary>
        corewolf::engine *CellGroup(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CellGroup[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a cell group in which cells i1, i2, …  are open.
        /// https://reference.wolfram.com/language/ref/CellGroup.html
        ///</summary>
        corewolf::engine *CellGroup(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CellGroup[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is a low-level construct that represents an open group of cells in a notebook.
        /// https://reference.wolfram.com/language/ref/CellGroupData.html
        ///</summary>
        corewolf::engine *CellGroupData(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CellGroupData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a cell group that is open or closed according to the value of status.
        /// https://reference.wolfram.com/language/ref/CellGroupData.html
        ///</summary>
        corewolf::engine *CellGroupData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CellGroupData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a cell group with cells at positions i1, i2, … open.
        /// https://reference.wolfram.com/language/ref/CellGroupData.html
        ///</summary>
        corewolf::engine *CellGroupData(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CellGroupData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is an const std::string &that represents a cell in an open notebook in the front end.
        /// https://reference.wolfram.com/language/ref/CellObject.html
        ///</summary>
        corewolf::engine *CellObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CellObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// inserts expr as a complete cell in the current notebook just below the cell being evaluated.
        /// https://reference.wolfram.com/language/ref/CellPrint.html
        ///</summary>
        corewolf::engine *CellPrint(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CellPrint[" + arg0 + "]", name);
        }

        ///< summary>
        /// inserts a sequence of cells.
        /// https://reference.wolfram.com/language/ref/CellPrint.html
        ///</summary>
        corewolf::engine *CellPrint(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CellPrint[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns a list of CellObject expressions corresponding to cells in the current notebook.
        /// https://reference.wolfram.com/language/ref/Cells.html
        ///</summary>
        corewolf::engine *Cells(const std::string &name = "")
        {
            return this->execute("Cells[]", name);
        }

        ///< summary>
        /// returns the list of CellObject expressions in obj.
        /// https://reference.wolfram.com/language/ref/Cells.html
        ///</summary>
        corewolf::engine *Cells(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Cells[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a list representing the evolution of the cellular automaton with the specified rule from initial condition init for t steps.
        /// https://reference.wolfram.com/language/ref/CellularAutomaton.html
        ///</summary>
        corewolf::engine *CellularAutomaton(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CellularAutomaton[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the result of evolving init for one step.
        /// https://reference.wolfram.com/language/ref/CellularAutomaton.html
        ///</summary>
        corewolf::engine *CellularAutomaton(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CellularAutomaton[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives only those parts of the evolution specified by tspec, xspec, etc.
        /// https://reference.wolfram.com/language/ref/CellularAutomaton.html
        ///</summary>
        corewolf::engine *CellularAutomaton(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("CellularAutomaton[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// is an operator form of CellularAutomaton that represents one step of evolution.
        /// https://reference.wolfram.com/language/ref/CellularAutomaton.html
        ///</summary>
        corewolf::engine *CellularAutomaton(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CellularAutomaton[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the distribution of values that come from dist and are censored to be between xmin and xmax.
        /// https://reference.wolfram.com/language/ref/CensoredDistribution.html
        ///</summary>
        corewolf::engine *CensoredDistribution(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CensoredDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the distribution of values that come from the multivariate distribution dist and are censored to be between xmin and xmax, ymin and ymax, etc.
        /// https://reference.wolfram.com/language/ref/CensoredDistribution.html
        ///</summary>
        corewolf::engine *CensoredDistribution(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CensoredDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a censored event time t with censoring c.
        /// https://reference.wolfram.com/language/ref/Censoring.html
        ///</summary>
        corewolf::engine *Censoring(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Censoring[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a vector of censored event times ti with censoring c.
        /// https://reference.wolfram.com/language/ref/Censoring.html
        ///</summary>
        corewolf::engine *Censoring(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Censoring[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a vector of event times ti with corresponding censoring ci.
        /// https://reference.wolfram.com/language/ref/Censoring.html
        ///</summary>
        corewolf::engine *Censoring(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Censoring[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// creates a list of length n with the elements of a at the center and zeros elsewhere.
        /// https://reference.wolfram.com/language/ref/CenterArray.html
        ///</summary>
        corewolf::engine *CenterArray(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CenterArray[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates an n1×n2×… array with the array a at the center and zeros elsewhere.
        /// https://reference.wolfram.com/language/ref/CenterArray.html
        ///</summary>
        corewolf::engine *CenterArray(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CenterArray[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses pad instead of zero for the background.
        /// https://reference.wolfram.com/language/ref/CenterArray.html
        ///</summary>
        corewolf::engine *CenterArray(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CenterArray[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// creates an array with a single 1 at the center and zeros elsewhere.
        /// https://reference.wolfram.com/language/ref/CenterArray.html
        ///</summary>
        corewolf::engine *CenterArray(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CenterArray[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/CenterDot.html
        ///</summary>
        corewolf::engine *CenterDot(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CenterDot[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// for real numbers x and dx gives a centered interval that contains the real interval .
        /// https://reference.wolfram.com/language/ref/CenteredInterval.html
        ///</summary>
        corewolf::engine *CenteredInterval(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CenteredInterval[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// for an approximate number c gives a centered interval that contains all values within the error bounds of c.
        /// https://reference.wolfram.com/language/ref/CenteredInterval.html
        ///</summary>
        corewolf::engine *CenteredInterval(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CenteredInterval[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the central feature of the elements .
        /// https://reference.wolfram.com/language/ref/CentralFeature.html
        ///</summary>
        corewolf::engine *CentralFeature(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CentralFeature[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the central feature for several different forms of data.
        /// https://reference.wolfram.com/language/ref/CentralFeature.html
        ///</summary>
        corewolf::engine *CentralFeature(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CentralFeature[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the r central moment of the elements in list with respect to their mean.
        /// https://reference.wolfram.com/language/ref/CentralMoment.html
        ///</summary>
        corewolf::engine *CentralMoment(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CentralMoment[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the r formal central moment.
        /// https://reference.wolfram.com/language/ref/CentralMoment.html
        ///</summary>
        corewolf::engine *CentralMoment(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CentralMoment[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the central moment-generating function for the distribution dist as a function of the variable t.
        /// https://reference.wolfram.com/language/ref/CentralMomentGeneratingFunction.html
        ///</summary>
        corewolf::engine *CentralMomentGeneratingFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CentralMomentGeneratingFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the central moment-generating function for the multivariate distribution dist as a function of the variables t1, t2, ….
        /// https://reference.wolfram.com/language/ref/CentralMomentGeneratingFunction.html
        ///</summary>
        corewolf::engine *CentralMomentGeneratingFunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CentralMomentGeneratingFunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots the array of power cepstra computed on each partition of data.
        /// https://reference.wolfram.com/language/ref/Cepstrogram.html
        ///</summary>
        corewolf::engine *Cepstrogram(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Cepstrogram[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses partitions of length n.
        /// https://reference.wolfram.com/language/ref/Cepstrogram.html
        ///</summary>
        corewolf::engine *Cepstrogram(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Cepstrogram[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses partitions with offset d.
        /// https://reference.wolfram.com/language/ref/Cepstrogram.html
        ///</summary>
        corewolf::engine *Cepstrogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Cepstrogram[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies a smoothing window wfun to each partition.
        /// https://reference.wolfram.com/language/ref/Cepstrogram.html
        ///</summary>
        corewolf::engine *Cepstrogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Cepstrogram[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// pads partitions with zeros to length m prior to the computation of the transform.
        /// https://reference.wolfram.com/language/ref/Cepstrogram.html
        ///</summary>
        corewolf::engine *Cepstrogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("Cepstrogram[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// computes an array of cepstra on data.
        /// https://reference.wolfram.com/language/ref/CepstrogramArray.html
        ///</summary>
        corewolf::engine *CepstrogramArray(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CepstrogramArray[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses partitions of length n.
        /// https://reference.wolfram.com/language/ref/CepstrogramArray.html
        ///</summary>
        corewolf::engine *CepstrogramArray(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CepstrogramArray[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses partitions with offset d.
        /// https://reference.wolfram.com/language/ref/CepstrogramArray.html
        ///</summary>
        corewolf::engine *CepstrogramArray(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CepstrogramArray[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies a smoothing window wfun to each partition.
        /// https://reference.wolfram.com/language/ref/CepstrogramArray.html
        ///</summary>
        corewolf::engine *CepstrogramArray(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("CepstrogramArray[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// pads partitions with zeros to length m prior to the computation of the transform.
        /// https://reference.wolfram.com/language/ref/CepstrogramArray.html
        ///</summary>
        corewolf::engine *CepstrogramArray(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("CepstrogramArray[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// computes the power cepstrum of data.
        /// https://reference.wolfram.com/language/ref/CepstrumArray.html
        ///</summary>
        corewolf::engine *CepstrumArray(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CepstrumArray[" + arg0 + "]", name);
        }

        ///< summary>
        /// computes the specified type of cepstrum of data.
        /// https://reference.wolfram.com/language/ref/CepstrumArray.html
        ///</summary>
        corewolf::engine *CepstrumArray(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CepstrumArray[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// prints as a C language version of expr.
        /// https://reference.wolfram.com/language/ref/CForm.html
        ///</summary>
        corewolf::engine *CForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the base-b Champernowne number .
        /// https://reference.wolfram.com/language/ref/ChampernowneNumber.html
        ///</summary>
        corewolf::engine *ChampernowneNumber(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ChampernowneNumber[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the base-10 Champernowne number.
        /// https://reference.wolfram.com/language/ref/ChampernowneNumber.html
        ///</summary>
        corewolf::engine *ChampernowneNumber(const std::string &name = "")
        {
            return this->execute("ChampernowneNumber[]", name);
        }

        ///< summary>
        /// starts listening on the specified channel.
        /// https://reference.wolfram.com/language/ref/ChannelListen.html
        ///</summary>
        corewolf::engine *ChannelListen(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ChannelListen[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies func to the association corresponding to each message received on the channel.
        /// https://reference.wolfram.com/language/ref/ChannelListen.html
        ///</summary>
        corewolf::engine *ChannelListen(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ChannelListen[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a channel listener created by ChannelListen.
        /// https://reference.wolfram.com/language/ref/ChannelListener.html
        ///</summary>
        corewolf::engine *ChannelListener(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ChannelListener[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of currently active channel listeners.
        /// https://reference.wolfram.com/language/ref/ChannelListeners.html
        ///</summary>
        corewolf::engine *ChannelListeners(const std::string &name = "")
        {
            return this->execute("ChannelListeners[]", name);
        }

        ///< summary>
        /// gives a new anonymous channel specification.
        /// https://reference.wolfram.com/language/ref/ChannelObject.html
        ///</summary>
        corewolf::engine *ChannelObject(const std::string &name = "")
        {
            return this->execute("ChannelObject[]", name);
        }

        ///< summary>
        /// represents a channel specified by a given URL.
        /// https://reference.wolfram.com/language/ref/ChannelObject.html
        ///</summary>
        corewolf::engine *ChannelObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ChannelObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a channel receiver function that applies fun to any channel message it receives.
        /// https://reference.wolfram.com/language/ref/ChannelReceiverFunction.html
        ///</summary>
        corewolf::engine *ChannelReceiverFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ChannelReceiverFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// sends the specified message msg to the specified channel.
        /// https://reference.wolfram.com/language/ref/ChannelSend.html
        ///</summary>
        corewolf::engine *ChannelSend(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ChannelSend[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of users currently subscribed to the specified channel.
        /// https://reference.wolfram.com/language/ref/ChannelSubscribers.html
        ///</summary>
        corewolf::engine *ChannelSubscribers(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ChannelSubscribers[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of subscribed users for each of the channels channeli.
        /// https://reference.wolfram.com/language/ref/ChannelSubscribers.html
        ///</summary>
        corewolf::engine *ChannelSubscribers(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ChannelSubscribers[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// finds a two-level segmentation of image by computing optimal contours around regions of consistent intensity in image.
        /// https://reference.wolfram.com/language/ref/ChanVeseBinarize.html
        ///</summary>
        corewolf::engine *ChanVeseBinarize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ChanVeseBinarize[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses marker to create an initial contour.
        /// https://reference.wolfram.com/language/ref/ChanVeseBinarize.html
        ///</summary>
        corewolf::engine *ChanVeseBinarize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ChanVeseBinarize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specify the Chan–Vese weights μ, ν, λ1, and λ2.
        /// https://reference.wolfram.com/language/ref/ChanVeseBinarize.html
        ///</summary>
        corewolf::engine *ChanVeseBinarize(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ChanVeseBinarize[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives an association whose keys are the distinct characters in string, and whose values give the number of times those characters appear in string.
        /// https://reference.wolfram.com/language/ref/CharacterCounts.html
        ///</summary>
        corewolf::engine *CharacterCounts(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CharacterCounts[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives counts of the distinct n-grams consisting of runs of n characters in string.
        /// https://reference.wolfram.com/language/ref/CharacterCounts.html
        ///</summary>
        corewolf::engine *CharacterCounts(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CharacterCounts[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the characteristic function for the distribution dist as a function of the variable t.
        /// https://reference.wolfram.com/language/ref/CharacteristicFunction.html
        ///</summary>
        corewolf::engine *CharacteristicFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CharacteristicFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the characteristic function for the multivariate distribution dist as a function of the variables t1, t2, ….
        /// https://reference.wolfram.com/language/ref/CharacteristicFunction.html
        ///</summary>
        corewolf::engine *CharacteristicFunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CharacteristicFunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the characteristic polynomial for the matrix m.
        /// https://reference.wolfram.com/language/ref/CharacteristicPolynomial.html
        ///</summary>
        corewolf::engine *CharacteristicPolynomial(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CharacteristicPolynomial[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the generalized characteristic polynomial with respect to a.
        /// https://reference.wolfram.com/language/ref/CharacteristicPolynomial.html
        ///</summary>
        corewolf::engine *CharacteristicPolynomial(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CharacteristicPolynomial[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the name of the character c.
        /// https://reference.wolfram.com/language/ref/CharacterName.html
        ///</summary>
        corewolf::engine *CharacterName(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CharacterName[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a name of the specified type.
        /// https://reference.wolfram.com/language/ref/CharacterName.html
        ///</summary>
        corewolf::engine *CharacterName(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CharacterName[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts the characters in text to the specified normalization form.
        /// https://reference.wolfram.com/language/ref/CharacterNormalize.html
        ///</summary>
        corewolf::engine *CharacterNormalize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CharacterNormalize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields a list of the characters in the range from "c1" to "c2".
        /// https://reference.wolfram.com/language/ref/CharacterRange.html
        ///</summary>
        corewolf::engine *CharacterRange(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CharacterRange[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the characters in a string.
        /// https://reference.wolfram.com/language/ref/Characters.html
        ///</summary>
        corewolf::engine *Characters(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Characters[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a lowpass Chebyshev type 1 filter of order n.
        /// https://reference.wolfram.com/language/ref/Chebyshev1FilterModel.html
        ///</summary>
        corewolf::engine *Chebyshev1FilterModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Chebyshev1FilterModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the cutoff frequency ωc.
        /// https://reference.wolfram.com/language/ref/Chebyshev1FilterModel.html
        ///</summary>
        corewolf::engine *Chebyshev1FilterModel(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Chebyshev1FilterModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// expresses the model in terms of the variable var.
        /// https://reference.wolfram.com/language/ref/Chebyshev1FilterModel.html
        ///</summary>
        corewolf::engine *Chebyshev1FilterModel(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Chebyshev1FilterModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a lowpass Chebyshev type 2 filter of order n.
        /// https://reference.wolfram.com/language/ref/Chebyshev2FilterModel.html
        ///</summary>
        corewolf::engine *Chebyshev2FilterModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Chebyshev2FilterModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the cutoff frequency ωc.
        /// https://reference.wolfram.com/language/ref/Chebyshev2FilterModel.html
        ///</summary>
        corewolf::engine *Chebyshev2FilterModel(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Chebyshev2FilterModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// expresses the model in terms of the variable var.
        /// https://reference.wolfram.com/language/ref/Chebyshev2FilterModel.html
        ///</summary>
        corewolf::engine *Chebyshev2FilterModel(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Chebyshev2FilterModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Chebyshev polynomial of the first kind .
        /// https://reference.wolfram.com/language/ref/ChebyshevT.html
        ///</summary>
        corewolf::engine *ChebyshevT(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ChebyshevT[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Chebyshev polynomial of the second kind .
        /// https://reference.wolfram.com/language/ref/ChebyshevU.html
        ///</summary>
        corewolf::engine *ChebyshevU(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ChebyshevU[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates expr, and returns the result, unless messages were generated, in which case it evaluates and returns failexpr.
        /// https://reference.wolfram.com/language/ref/Check.html
        ///</summary>
        corewolf::engine *Check(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Check[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// checks only for the specified messages.
        /// https://reference.wolfram.com/language/ref/Check.html
        ///</summary>
        corewolf::engine *Check(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Check[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// checks only for messages in the named message group.
        /// https://reference.wolfram.com/language/ref/Check.html
        ///</summary>
        corewolf::engine *Check(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Check[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// evaluates expr, returning failexpr if an abort occurs.
        /// https://reference.wolfram.com/language/ref/CheckAbort.html
        ///</summary>
        corewolf::engine *CheckAbort(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CheckAbort[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if args consists of exactly n positional arguments followed by valid options for f, and False otherwise.
        /// https://reference.wolfram.com/language/ref/CheckArguments.html
        ///</summary>
        corewolf::engine *CheckArguments(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CheckArguments[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// requires the number of positional arguments to be between min and max.
        /// https://reference.wolfram.com/language/ref/CheckArguments.html
        ///</summary>
        corewolf::engine *CheckArguments(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CheckArguments[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// modifies the behavior based on the information in the association assoc.
        /// https://reference.wolfram.com/language/ref/CheckArguments.html
        ///</summary>
        corewolf::engine *CheckArguments(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CheckArguments[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a checkbox with setting x, displayed as  when x is True and  when x is False.
        /// https://reference.wolfram.com/language/ref/Checkbox.html
        ///</summary>
        corewolf::engine *Checkbox(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Checkbox[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a checkbox that toggles between values val1 and val2 and displays as  and , respectively.
        /// https://reference.wolfram.com/language/ref/Checkbox.html
        ///</summary>
        corewolf::engine *Checkbox(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Checkbox[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a checkbox bar with setting x and with checkboxes for values vali to include in the list x.
        /// https://reference.wolfram.com/language/ref/CheckboxBar.html
        ///</summary>
        corewolf::engine *CheckboxBar(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CheckboxBar[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// converts the quantity in the specified instance cheminst to targetunit.
        /// https://reference.wolfram.com/language/ref/ChemicalConvert.html
        ///</summary>
        corewolf::engine *ChemicalConvert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ChemicalConvert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts to SI base units.
        /// https://reference.wolfram.com/language/ref/ChemicalConvert.html
        ///</summary>
        corewolf::engine *ChemicalConvert(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ChemicalConvert[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the chemical "name".
        /// https://reference.wolfram.com/language/ref/ChemicalData.html
        ///</summary>
        corewolf::engine *ChemicalData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ChemicalData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a structure diagram for the chemical with the specified name.
        /// https://reference.wolfram.com/language/ref/ChemicalData.html
        ///</summary>
        corewolf::engine *ChemicalData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ChemicalData[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a chemical species with ni atoms of the element elemi.
        /// https://reference.wolfram.com/language/ref/ChemicalFormula.html
        ///</summary>
        corewolf::engine *ChemicalFormula(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ChemicalFormula[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the chemical formula corresponding to the given input.
        /// https://reference.wolfram.com/language/ref/ChemicalFormula.html
        ///</summary>
        corewolf::engine *ChemicalFormula(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ChemicalFormula[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a chemical whose qualifiers quali have values of vali.
        /// https://reference.wolfram.com/language/ref/ChemicalInstance.html
        ///</summary>
        corewolf::engine *ChemicalInstance(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ChemicalInstance[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a chemical quantified by quantity.
        /// https://reference.wolfram.com/language/ref/ChemicalInstance.html
        ///</summary>
        corewolf::engine *ChemicalInstance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ChemicalInstance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a chemical reaction between the given reactants and products.
        /// https://reference.wolfram.com/language/ref/ChemicalReaction.html
        ///</summary>
        corewolf::engine *ChemicalReaction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ChemicalReaction[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the chessboard, Chebyshev, or sup norm distance between vectors u and v.
        /// https://reference.wolfram.com/language/ref/ChessboardDistance.html
        ///</summary>
        corewolf::engine *ChessboardDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ChessboardDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a  distribution with ν degrees of freedom.
        /// https://reference.wolfram.com/language/ref/ChiDistribution.html
        ///</summary>
        corewolf::engine *ChiDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ChiDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the smallest  with  that satisfies all the integer congruences .
        /// https://reference.wolfram.com/language/ref/ChineseRemainder.html
        ///</summary>
        corewolf::engine *ChineseRemainder(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ChineseRemainder[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the smallest  with  that satisfies all the integer congruences .
        /// https://reference.wolfram.com/language/ref/ChineseRemainder.html
        ///</summary>
        corewolf::engine *ChineseRemainder(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ChineseRemainder[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a  distribution with ν degrees of freedom.
        /// https://reference.wolfram.com/language/ref/ChiSquareDistribution.html
        ///</summary>
        corewolf::engine *ChiSquareDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ChiSquareDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a pair of OK and Cancel buttons that close a dialog.
        /// https://reference.wolfram.com/language/ref/ChoiceButtons.html
        ///</summary>
        corewolf::engine *ChoiceButtons(const std::string &name = "")
        {
            return this->execute("ChoiceButtons[]", name);
        }

        ///< summary>
        /// represents OK and Cancel buttons that evaluate the corresponding acti when clicked.
        /// https://reference.wolfram.com/language/ref/ChoiceButtons.html
        ///</summary>
        corewolf::engine *ChoiceButtons(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ChoiceButtons[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// uses the lbli to label the buttons.
        /// https://reference.wolfram.com/language/ref/ChoiceButtons.html
        ///</summary>
        corewolf::engine *ChoiceButtons(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ChoiceButtons[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// puts up a standard choice dialog that displays expr together with OK and Cancel buttons, and returns True if OK is clicked and False if Cancel is clicked.
        /// https://reference.wolfram.com/language/ref/ChoiceDialog.html
        ///</summary>
        corewolf::engine *ChoiceDialog(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ChoiceDialog[" + arg0 + "]", name);
        }

        ///< summary>
        /// includes buttons with labels lbli, and returns the corresponding vali for the button clicked.
        /// https://reference.wolfram.com/language/ref/ChoiceDialog.html
        ///</summary>
        corewolf::engine *ChoiceDialog(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ChoiceDialog[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Cholesky decomposition of a matrix m.
        /// https://reference.wolfram.com/language/ref/CholeskyDecomposition.html
        ///</summary>
        corewolf::engine *CholeskyDecomposition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CholeskyDecomposition[" + arg0 + "]", name);
        }

        ///< summary>
        /// replaces approximate real numbers in expr that are close to zero by the exact integer 0.
        /// https://reference.wolfram.com/language/ref/Chop.html
        ///</summary>
        corewolf::engine *Chop(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Chop[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots a 2D slice of the color space colspace.
        /// https://reference.wolfram.com/language/ref/ChromaticityPlot.html
        ///</summary>
        corewolf::engine *ChromaticityPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ChromaticityPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots multiple colors and color spaces.
        /// https://reference.wolfram.com/language/ref/ChromaticityPlot.html
        ///</summary>
        corewolf::engine *ChromaticityPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ChromaticityPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// uses the reference color space refcolspace.
        /// https://reference.wolfram.com/language/ref/ChromaticityPlot.html
        ///</summary>
        corewolf::engine *ChromaticityPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ChromaticityPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a 3D gamut of the color space colspace.
        /// https://reference.wolfram.com/language/ref/ChromaticityPlot3D.html
        ///</summary>
        corewolf::engine *ChromaticityPlot3D(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ChromaticityPlot3D[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots multiple colors, color spaces and images.
        /// https://reference.wolfram.com/language/ref/ChromaticityPlot3D.html
        ///</summary>
        corewolf::engine *ChromaticityPlot3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ChromaticityPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// uses the reference color space refcolspace.
        /// https://reference.wolfram.com/language/ref/ChromaticityPlot3D.html
        ///</summary>
        corewolf::engine *ChromaticityPlot3D(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ChromaticityPlot3D[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the chromatic polynomial of the graph g.
        /// https://reference.wolfram.com/language/ref/ChromaticPolynomial.html
        ///</summary>
        corewolf::engine *ChromaticPolynomial(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ChromaticPolynomial[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/ChromaticPolynomial.html
        ///</summary>
        corewolf::engine *ChromaticPolynomial(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ChromaticPolynomial[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a circle of radius r centered at {x,y}.
        /// https://reference.wolfram.com/language/ref/Circle.html
        ///</summary>
        corewolf::engine *Circle(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Circle[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a circle of radius 1.
        /// https://reference.wolfram.com/language/ref/Circle.html
        ///</summary>
        corewolf::engine *Circle(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Circle[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives an axis-aligned ellipse with semiaxes lengths rx and ry.
        /// https://reference.wolfram.com/language/ref/Circle.html
        ///</summary>
        corewolf::engine *Circle(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Circle[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a circular or ellipse arc from angle θ1 to θ2.
        /// https://reference.wolfram.com/language/ref/Circle.html
        ///</summary>
        corewolf::engine *Circle(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Circle[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/CircleDot.html
        ///</summary>
        corewolf::engine *CircleDot(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CircleDot[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/CircleMinus.html
        ///</summary>
        corewolf::engine *CircleMinus(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CircleMinus[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/CirclePlus.html
        ///</summary>
        corewolf::engine *CirclePlus(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CirclePlus[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the positions of n points equally spaced around the unit circle.
        /// https://reference.wolfram.com/language/ref/CirclePoints.html
        ///</summary>
        corewolf::engine *CirclePoints(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CirclePoints[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the positions of n points equally spaced around a circle of radius r.
        /// https://reference.wolfram.com/language/ref/CirclePoints.html
        ///</summary>
        corewolf::engine *CirclePoints(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CirclePoints[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// starts at angle θ1 with respect to the  axis.
        /// https://reference.wolfram.com/language/ref/CirclePoints.html
        ///</summary>
        corewolf::engine *CirclePoints(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CirclePoints[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// centers the circle at {x,y}.
        /// https://reference.wolfram.com/language/ref/CirclePoints.html
        ///</summary>
        corewolf::engine *CirclePoints(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CirclePoints[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a circle passing through the points pi.
        /// https://reference.wolfram.com/language/ref/CircleThrough.html
        ///</summary>
        corewolf::engine *CircleThrough(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CircleThrough[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a circle with center q.
        /// https://reference.wolfram.com/language/ref/CircleThrough.html
        ///</summary>
        corewolf::engine *CircleThrough(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CircleThrough[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a circle with radius r.
        /// https://reference.wolfram.com/language/ref/CircleThrough.html
        ///</summary>
        corewolf::engine *CircleThrough(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CircleThrough[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/CircleTimes.html
        ///</summary>
        corewolf::engine *CircleTimes(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CircleTimes[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/CircleTimes.html
        ///</summary>
        corewolf::engine *CircleTimes(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CircleTimes[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the circulant graph  with n vertices and jump j.
        /// https://reference.wolfram.com/language/ref/CirculantGraph.html
        ///</summary>
        corewolf::engine *CirculantGraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CirculantGraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the circulant graph  with n vertices and jumps j1, j2, ….
        /// https://reference.wolfram.com/language/ref/CirculantGraph.html
        ///</summary>
        corewolf::engine *CirculantGraph(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CirculantGraph[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a circular arc passing through the points pi.
        /// https://reference.wolfram.com/language/ref/CircularArcThrough.html
        ///</summary>
        corewolf::engine *CircularArcThrough(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CircularArcThrough[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a circular arc with center q.
        /// https://reference.wolfram.com/language/ref/CircularArcThrough.html
        ///</summary>
        corewolf::engine *CircularArcThrough(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CircularArcThrough[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a circular arc with radius r.
        /// https://reference.wolfram.com/language/ref/CircularArcThrough.html
        ///</summary>
        corewolf::engine *CircularArcThrough(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CircularArcThrough[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a circular orthogonal matrix distribution with matrix dimensions {n,n}.
        /// https://reference.wolfram.com/language/ref/CircularOrthogonalMatrixDistribution.html
        ///</summary>
        corewolf::engine *CircularOrthogonalMatrixDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CircularOrthogonalMatrixDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a circular quaternion matrix distribution with matrix dimensions {2 n,2 n} over the field of complex numbers.
        /// https://reference.wolfram.com/language/ref/CircularQuaternionMatrixDistribution.html
        ///</summary>
        corewolf::engine *CircularQuaternionMatrixDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CircularQuaternionMatrixDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a circular real matrix distribution with matrix dimensions {n,n}.
        /// https://reference.wolfram.com/language/ref/CircularRealMatrixDistribution.html
        ///</summary>
        corewolf::engine *CircularRealMatrixDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CircularRealMatrixDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a circular symplectic matrix distribution with matrix dimensions {2 n,2 n} over the field of complex numbers.
        /// https://reference.wolfram.com/language/ref/CircularSymplecticMatrixDistribution.html
        ///</summary>
        corewolf::engine *CircularSymplecticMatrixDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CircularSymplecticMatrixDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a circular unitary matrix distribution with matrix dimensions {n,n}.
        /// https://reference.wolfram.com/language/ref/CircularUnitaryMatrixDistribution.html
        ///</summary>
        corewolf::engine *CircularUnitaryMatrixDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CircularUnitaryMatrixDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the sphere that circumscribes the points pi in .
        /// https://reference.wolfram.com/language/ref/Circumsphere.html
        ///</summary>
        corewolf::engine *Circumsphere(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Circumsphere[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the circumsphere of a polyhedron or polygon poly.
        /// https://reference.wolfram.com/language/ref/Circumsphere.html
        ///</summary>
        corewolf::engine *Circumsphere(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Circumsphere[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the city with the specified name.
        /// https://reference.wolfram.com/language/ref/CityData.html
        ///</summary>
        corewolf::engine *CityData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CityData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the full specifications of cities whose names are consistent with name.
        /// https://reference.wolfram.com/language/ref/CityData.html
        ///</summary>
        corewolf::engine *CityData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CityData[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a function generated by Classify that classifies data into classes.
        /// https://reference.wolfram.com/language/ref/ClassifierFunction.html
        ///</summary>
        corewolf::engine *ClassifierFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ClassifierFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives measurements associated with property prop when classifier is evaluated on testset.
        /// https://reference.wolfram.com/language/ref/ClassifierMeasurements.html
        ///</summary>
        corewolf::engine *ClassifierMeasurements(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ClassifierMeasurements[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields a measurement report that can be applied to any property.
        /// https://reference.wolfram.com/language/ref/ClassifierMeasurements.html
        ///</summary>
        corewolf::engine *ClassifierMeasurements(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ClassifierMeasurements[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives properties prop1, prop2, etc.
        /// https://reference.wolfram.com/language/ref/ClassifierMeasurements.html
        ///</summary>
        corewolf::engine *ClassifierMeasurements(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ClassifierMeasurements[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an const std::string &generated by ClassifierMeasurements that can be applied to properties.
        /// https://reference.wolfram.com/language/ref/ClassifierMeasurementsObject.html
        ///</summary>
        corewolf::engine *ClassifierMeasurementsObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ClassifierMeasurementsObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a ClassifierFunction[…] based on the examples and classes given.
        /// https://reference.wolfram.com/language/ref/Classify.html
        ///</summary>
        corewolf::engine *Classify(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Classify[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a ClassifierFunction[…] based on an association of classes with their examples.
        /// https://reference.wolfram.com/language/ref/Classify.html
        ///</summary>
        corewolf::engine *Classify(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Classify[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// attempts to classify data using a classifier function deduced from the training set given.
        /// https://reference.wolfram.com/language/ref/Classify.html
        ///</summary>
        corewolf::engine *Classify(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Classify[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// clears values and definitions for the symboli.
        /// https://reference.wolfram.com/language/ref/Clear.html
        ///</summary>
        corewolf::engine *Clear(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Clear[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// clears all values, definitions, attributes, messages, and defaults associated with symbols.
        /// https://reference.wolfram.com/language/ref/ClearAll.html
        ///</summary>
        corewolf::engine *ClearAll(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ClearAll[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// removes attr from the list of attributes of the symbol symbol.
        /// https://reference.wolfram.com/language/ref/ClearAttributes.html
        ///</summary>
        corewolf::engine *ClearAttributes(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ClearAttributes[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// removes several attributes at a time.
        /// https://reference.wolfram.com/language/ref/ClearAttributes.html
        ///</summary>
        corewolf::engine *ClearAttributes(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ClearAttributes[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// removes attributes from several symbols at a time.
        /// https://reference.wolfram.com/language/ref/ClearAttributes.html
        ///</summary>
        corewolf::engine *ClearAttributes(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ClearAttributes[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// clears all persistent and session cookies associated with the specified domain.
        /// https://reference.wolfram.com/language/ref/ClearCookies.html
        ///</summary>
        corewolf::engine *ClearCookies(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ClearCookies[" + arg0 + "]", name);
        }

        ///< summary>
        /// clears permissions for the specified class of users for the cloud const std::string &obj.
        /// https://reference.wolfram.com/language/ref/ClearPermissions.html
        ///</summary>
        corewolf::engine *ClearPermissions(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ClearPermissions[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// clears permissions for the cloud const std::string &corresponding to the current document.
        /// https://reference.wolfram.com/language/ref/ClearPermissions.html
        ///</summary>
        corewolf::engine *ClearPermissions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ClearPermissions[" + arg0 + "]", name);
        }

        ///< summary>
        /// clears internal system caches of stored results.
        /// https://reference.wolfram.com/language/ref/ClearSystemCache.html
        ///</summary>
        corewolf::engine *ClearSystemCache(const std::string &name = "")
        {
            return this->execute("ClearSystemCache[]", name);
        }

        ///< summary>
        /// clears only caches of the specified type.
        /// https://reference.wolfram.com/language/ref/ClearSystemCache.html
        ///</summary>
        corewolf::engine *ClearSystemCache(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ClearSystemCache[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Clebsch–Gordan coefficient for the decomposition of  in terms of .
        /// https://reference.wolfram.com/language/ref/ClebschGordan.html
        ///</summary>
        corewolf::engine *ClebschGordan(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ClebschGordan[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a clickable pane that displays as image and applies func to the  coordinates of each click within the pane.
        /// https://reference.wolfram.com/language/ref/ClickPane.html
        ///</summary>
        corewolf::engine *ClickPane(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ClickPane[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies the range of coordinates to use.
        /// https://reference.wolfram.com/language/ref/ClickPane.html
        ///</summary>
        corewolf::engine *ClickPane(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ClickPane[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a button that copies expr whenever it is clicked.
        /// https://reference.wolfram.com/language/ref/ClickToCopy.html
        ///</summary>
        corewolf::engine *ClickToCopy(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ClickToCopy[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays with label on the button.
        /// https://reference.wolfram.com/language/ref/ClickToCopy.html
        ///</summary>
        corewolf::engine *ClickToCopy(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ClickToCopy[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives x clipped to be between  and .
        /// https://reference.wolfram.com/language/ref/Clip.html
        ///</summary>
        corewolf::engine *Clip(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Clip[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives x for min≤x≤max, min for x<min and max for x>max.
        /// https://reference.wolfram.com/language/ref/Clip.html
        ///</summary>
        corewolf::engine *Clip(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Clip[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives vmin for x<min and vmax for x>max.
        /// https://reference.wolfram.com/language/ref/Clip.html
        ///</summary>
        corewolf::engine *Clip(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Clip[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a clock variable whose value cycles continuously from 0 to 1 once per second when it appears inside a dynamically updated const std::string &such as a Dynamic.
        /// https://reference.wolfram.com/language/ref/Clock.html
        ///</summary>
        corewolf::engine *Clock(const std::string &name = "")
        {
            return this->execute("Clock[]", name);
        }

        ///< summary>
        /// cycles from 0 to t every t seconds.
        /// https://reference.wolfram.com/language/ref/Clock.html
        ///</summary>
        corewolf::engine *Clock(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Clock[" + arg0 + "]", name);
        }

        ///< summary>
        /// cycles from 0 to vmax every t seconds.
        /// https://reference.wolfram.com/language/ref/Clock.html
        ///</summary>
        corewolf::engine *Clock(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Clock[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// cycles through the range vmin to vmax every t seconds.
        /// https://reference.wolfram.com/language/ref/Clock.html
        ///</summary>
        corewolf::engine *Clock(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Clock[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// cycles through the range vmin to vmax over the course of vmax-vmin seconds.
        /// https://reference.wolfram.com/language/ref/Clock.html
        ///</summary>
        corewolf::engine *Clock(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Clock[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// goes through the cycle only n times, then always yields only the maximum value.
        /// https://reference.wolfram.com/language/ref/Clock.html
        ///</summary>
        corewolf::engine *Clock(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Clock[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// draws an analog clock face showing the local time with hours, minutes, and seconds.
        /// https://reference.wolfram.com/language/ref/ClockGauge.html
        ///</summary>
        corewolf::engine *ClockGauge(const std::string &name = "")
        {
            return this->execute("ClockGauge[]", name);
        }

        ///< summary>
        /// draws an analog clock face showing the time corresponding to an AbsoluteTime, DateObject, or TimeObject specification.
        /// https://reference.wolfram.com/language/ref/ClockGauge.html
        ///</summary>
        corewolf::engine *ClockGauge(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ClockGauge[" + arg0 + "]", name);
        }

        ///< summary>
        /// draws an analog clock face showing hour h, minute m, and seconds s.
        /// https://reference.wolfram.com/language/ref/ClockGauge.html
        ///</summary>
        corewolf::engine *ClockGauge(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ClockGauge[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// closes a stream or socket.
        /// https://reference.wolfram.com/language/ref/Close.html
        ///</summary>
        corewolf::engine *Close(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Close[" + arg0 + "]", name);
        }

        ///< summary>
        /// terminates all parallel kernels from the list Kernels[].
        /// https://reference.wolfram.com/language/ref/CloseKernels.html
        ///</summary>
        corewolf::engine *CloseKernels(const std::string &name = "")
        {
            return this->execute("CloseKernels[]", name);
        }

        ///< summary>
        /// terminates the kernel k.
        /// https://reference.wolfram.com/language/ref/CloseKernels.html
        ///</summary>
        corewolf::engine *CloseKernels(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloseKernels[" + arg0 + "]", name);
        }

        ///< summary>
        /// terminates the kernels k1, k2, ….
        /// https://reference.wolfram.com/language/ref/CloseKernels.html
        ///</summary>
        corewolf::engine *CloseKernels(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CloseKernels[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of closeness centralities for the vertices in the graph g.
        /// https://reference.wolfram.com/language/ref/ClosenessCentrality.html
        ///</summary>
        corewolf::engine *ClosenessCentrality(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ClosenessCentrality[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/ClosenessCentrality.html
        ///</summary>
        corewolf::engine *ClosenessCentrality(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ClosenessCentrality[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the morphological closing of image with respect to the structuring element ker.
        /// https://reference.wolfram.com/language/ref/Closing.html
        ///</summary>
        corewolf::engine *Closing(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Closing[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives data associated with the cloud account currently being used.
        /// https://reference.wolfram.com/language/ref/CloudAccountData.html
        ///</summary>
        corewolf::engine *CloudAccountData(const std::string &name = "")
        {
            return this->execute("CloudAccountData[]", name);
        }

        ///< summary>
        /// gives the property prop associated with the cloud account being used.
        /// https://reference.wolfram.com/language/ref/CloudAccountData.html
        ///</summary>
        corewolf::engine *CloudAccountData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudAccountData[" + arg0 + "]", name);
        }

        ///< summary>
        /// authenticates to the Wolfram Cloud using the specified cloud user ID and password.
        /// https://reference.wolfram.com/language/ref/CloudConnect.html
        ///</summary>
        corewolf::engine *CloudConnect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CloudConnect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// shows a dialog to input the password.
        /// https://reference.wolfram.com/language/ref/CloudConnect.html
        ///</summary>
        corewolf::engine *CloudConnect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudConnect[" + arg0 + "]", name);
        }

        ///< summary>
        /// shows a dialog to input both the cloud user ID and the password.
        /// https://reference.wolfram.com/language/ref/CloudConnect.html
        ///</summary>
        corewolf::engine *CloudConnect(const std::string &name = "")
        {
            return this->execute("CloudConnect[]", name);
        }

        ///< summary>
        /// deploys expr to a new anonymous cloud object.
        /// https://reference.wolfram.com/language/ref/CloudDeploy.html
        ///</summary>
        corewolf::engine *CloudDeploy(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudDeploy[" + arg0 + "]", name);
        }

        ///< summary>
        /// deploys expr to a cloud const std::string &at the specified location relative to the user's current cloud directory.
        /// https://reference.wolfram.com/language/ref/CloudDeploy.html
        ///</summary>
        corewolf::engine *CloudDeploy(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CloudDeploy[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a CloudObject representing the current working directory used for cloud objects.
        /// https://reference.wolfram.com/language/ref/CloudDirectory.html
        ///</summary>
        corewolf::engine *CloudDirectory(const std::string &name = "")
        {
            return this->execute("CloudDirectory[]", name);
        }

        ///< summary>
        /// disconnects a non-cloud instance of the Wolfram Language from the Wolfram Cloud.
        /// https://reference.wolfram.com/language/ref/CloudDisconnect.html
        ///</summary>
        corewolf::engine *CloudDisconnect(const std::string &name = "")
        {
            return this->execute("CloudDisconnect[]", name);
        }

        ///< summary>
        /// evaluates expr in the cloud and returns the result.
        /// https://reference.wolfram.com/language/ref/CloudEvaluate.html
        ///</summary>
        corewolf::engine *CloudEvaluate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudEvaluate[" + arg0 + "]", name);
        }

        ///< summary>
        /// wraps the head h around the result before returning it.
        /// https://reference.wolfram.com/language/ref/CloudEvaluate.html
        ///</summary>
        corewolf::engine *CloudEvaluate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CloudEvaluate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// exports expr to a new anonymous cloud const std::string &in the specified format.
        /// https://reference.wolfram.com/language/ref/CloudExport.html
        ///</summary>
        corewolf::engine *CloudExport(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CloudExport[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// exports to a cloud const std::string &at a given URI.
        /// https://reference.wolfram.com/language/ref/CloudExport.html
        ///</summary>
        corewolf::engine *CloudExport(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CloudExport[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an expression whose value is persistently stored in the cloud.
        /// https://reference.wolfram.com/language/ref/CloudExpression.html
        ///</summary>
        corewolf::engine *CloudExpression(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudExpression[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a cloud expression with a given URI.
        /// https://reference.wolfram.com/language/ref/CloudExpression.html
        ///</summary>
        corewolf::engine *CloudExpression(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CloudExpression[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the part of a cloud expression specified by the parti.
        /// https://reference.wolfram.com/language/ref/CloudExpression.html
        ///</summary>
        corewolf::engine *CloudExpression(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("CloudExpression[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives a list of named cloud expressions owned by you.
        /// https://reference.wolfram.com/language/ref/CloudExpressions.html
        ///</summary>
        corewolf::engine *CloudExpressions(const std::string &name = "")
        {
            return this->execute("CloudExpressions[]", name);
        }

        ///< summary>
        /// gives a list of anonymous cloud expressions owned by you.
        /// https://reference.wolfram.com/language/ref/CloudExpressions.html
        ///</summary>
        corewolf::engine *CloudExpressions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudExpressions[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a pure function that evaluates fun[args] in the cloud.
        /// https://reference.wolfram.com/language/ref/CloudFunction.html
        ///</summary>
        corewolf::engine *CloudFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// wraps the head h around the result of the function before returning it.
        /// https://reference.wolfram.com/language/ref/CloudFunction.html
        ///</summary>
        corewolf::engine *CloudFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CloudFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reads in a cloud const std::string &at a given URI, evaluating each expression in it and returning the last one.
        /// https://reference.wolfram.com/language/ref/CloudGet.html
        ///</summary>
        corewolf::engine *CloudGet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudGet[" + arg0 + "]", name);
        }

        ///< summary>
        /// imports from a cloud const std::string &at a given URI.
        /// https://reference.wolfram.com/language/ref/CloudImport.html
        ///</summary>
        corewolf::engine *CloudImport(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudImport[" + arg0 + "]", name);
        }

        ///< summary>
        /// imports the specified elements of a cloud object.
        /// https://reference.wolfram.com/language/ref/CloudImport.html
        ///</summary>
        corewolf::engine *CloudImport(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CloudImport[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives summary logging data for all your cloud objects.
        /// https://reference.wolfram.com/language/ref/CloudLoggingData.html
        ///</summary>
        corewolf::engine *CloudLoggingData(const std::string &name = "")
        {
            return this->execute("CloudLoggingData[]", name);
        }

        ///< summary>
        /// gives summary logging data for all your cloud objects of a particular category.
        /// https://reference.wolfram.com/language/ref/CloudLoggingData.html
        ///</summary>
        corewolf::engine *CloudLoggingData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudLoggingData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives aggregated summary logging data for all the objects obji.
        /// https://reference.wolfram.com/language/ref/CloudLoggingData.html
        ///</summary>
        corewolf::engine *CloudLoggingData(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CloudLoggingData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives summary logging data for the specified period.
        /// https://reference.wolfram.com/language/ref/CloudLoggingData.html
        ///</summary>
        corewolf::engine *CloudLoggingData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CloudLoggingData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives logging data elements specified by elems.
        /// https://reference.wolfram.com/language/ref/CloudLoggingData.html
        ///</summary>
        corewolf::engine *CloudLoggingData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CloudLoggingData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a new anonymous cloud object.
        /// https://reference.wolfram.com/language/ref/CloudObject.html
        ///</summary>
        corewolf::engine *CloudObject(const std::string &name = "")
        {
            return this->execute("CloudObject[]", name);
        }

        ///< summary>
        /// represents a cloud const std::string &with a given URI.
        /// https://reference.wolfram.com/language/ref/CloudObject.html
        ///</summary>
        corewolf::engine *CloudObject(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CloudObject[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a cloud const std::string &of a given user with a given path.
        /// https://reference.wolfram.com/language/ref/CloudObject.html
        ///</summary>
        corewolf::engine *CloudObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of cloud objects in your current cloud directory.
        /// https://reference.wolfram.com/language/ref/CloudObjects.html
        ///</summary>
        corewolf::engine *CloudObjects(const std::string &name = "")
        {
            return this->execute("CloudObjects[]", name);
        }

        ///< summary>
        /// gives a list of cloud objects in the cloud directory dir.
        /// https://reference.wolfram.com/language/ref/CloudObjects.html
        ///</summary>
        corewolf::engine *CloudObjects(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudObjects[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of cloud objects of the specified type in the cloud directory dir.
        /// https://reference.wolfram.com/language/ref/CloudObjects.html
        ///</summary>
        corewolf::engine *CloudObjects(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CloudObjects[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// makes a public copy in the cloud of the current document.
        /// https://reference.wolfram.com/language/ref/CloudPublish.html
        ///</summary>
        corewolf::engine *CloudPublish(const std::string &name = "")
        {
            return this->execute("CloudPublish[]", name);
        }

        ///< summary>
        /// makes a public copy of the cloud const std::string &obj.
        /// https://reference.wolfram.com/language/ref/CloudPublish.html
        ///</summary>
        corewolf::engine *CloudPublish(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudPublish[" + arg0 + "]", name);
        }

        ///< summary>
        /// publishes to the specified location relative to the user's current cloud directory.
        /// https://reference.wolfram.com/language/ref/CloudPublish.html
        ///</summary>
        corewolf::engine *CloudPublish(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CloudPublish[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// writes expr to a new anonymous cloud object.
        /// https://reference.wolfram.com/language/ref/CloudPut.html
        ///</summary>
        corewolf::engine *CloudPut(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudPut[" + arg0 + "]", name);
        }

        ///< summary>
        /// writes expr to a cloud const std::string &at a given URI.
        /// https://reference.wolfram.com/language/ref/CloudPut.html
        ///</summary>
        corewolf::engine *CloudPut(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CloudPut[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// saves definitions associated with the specified symbol to a new anonymous cloud object.
        /// https://reference.wolfram.com/language/ref/CloudSave.html
        ///</summary>
        corewolf::engine *CloudSave(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudSave[" + arg0 + "]", name);
        }

        ///< summary>
        /// saves definitions associated with several objects.
        /// https://reference.wolfram.com/language/ref/CloudSave.html
        ///</summary>
        corewolf::engine *CloudSave(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CloudSave[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// appends definitions associated with symspec to the cloud const std::string &at the given URI.
        /// https://reference.wolfram.com/language/ref/CloudSave.html
        ///</summary>
        corewolf::engine *CloudSave(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CloudSave[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// shares the current cloud document with the specified user.
        /// https://reference.wolfram.com/language/ref/CloudShare.html
        ///</summary>
        corewolf::engine *CloudShare(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudShare[" + arg0 + "]", name);
        }

        ///< summary>
        /// shares the current document with all the users useri.
        /// https://reference.wolfram.com/language/ref/CloudShare.html
        ///</summary>
        corewolf::engine *CloudShare(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CloudShare[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// shares the cloud const std::string &obj with the specified users.
        /// https://reference.wolfram.com/language/ref/CloudShare.html
        ///</summary>
        corewolf::engine *CloudShare(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CloudShare[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// submits expr for immediate asynchronous cloud evaluation.
        /// https://reference.wolfram.com/language/ref/CloudSubmit.html
        ///</summary>
        corewolf::engine *CloudSubmit(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudSubmit[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a symbol whose value is persistently stored in the cloud.
        /// https://reference.wolfram.com/language/ref/CloudSymbol.html
        ///</summary>
        corewolf::engine *CloudSymbol(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudSymbol[" + arg0 + "]", name);
        }

        ///< summary>
        /// cancels sharing of the cloud const std::string &obj with everyone.
        /// https://reference.wolfram.com/language/ref/CloudUnshare.html
        ///</summary>
        corewolf::engine *CloudUnshare(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CloudUnshare[" + arg0 + "]", name);
        }

        ///< summary>
        /// cancels sharing with the specified list of users.
        /// https://reference.wolfram.com/language/ref/CloudUnshare.html
        ///</summary>
        corewolf::engine *CloudUnshare(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CloudUnshare[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a ClassifierFunction[…] by partitioning data into clusters of similar elements.
        /// https://reference.wolfram.com/language/ref/ClusterClassify.html
        ///</summary>
        corewolf::engine *ClusterClassify(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ClusterClassify[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a ClassifierFunction[…] with n clusters.
        /// https://reference.wolfram.com/language/ref/ClusterClassify.html
        ///</summary>
        corewolf::engine *ClusterClassify(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ClusterClassify[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an array in which each element at the lowest level of array is replaced by an integer index representing the cluster in which the element lies.
        /// https://reference.wolfram.com/language/ref/ClusteringComponents.html
        ///</summary>
        corewolf::engine *ClusteringComponents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ClusteringComponents[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds n clusters.
        /// https://reference.wolfram.com/language/ref/ClusteringComponents.html
        ///</summary>
        corewolf::engine *ClusteringComponents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ClusteringComponents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds clusters at the specified level in array.
        /// https://reference.wolfram.com/language/ref/ClusteringComponents.html
        ///</summary>
        corewolf::engine *ClusteringComponents(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ClusteringComponents[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// constructs a weighted tree from the hierarchical clustering of the elements e1, e2, ….
        /// https://reference.wolfram.com/language/ref/ClusteringTree.html
        ///</summary>
        corewolf::engine *ClusteringTree(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ClusteringTree[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents ei using labels labeli in the constructed graph.
        /// https://reference.wolfram.com/language/ref/ClusteringTree.html
        ///</summary>
        corewolf::engine *ClusteringTree(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ClusteringTree[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a color in the CMYK color space with cyan, magenta, yellow and black components.
        /// https://reference.wolfram.com/language/ref/CMYKColor.html
        ///</summary>
        corewolf::engine *CMYKColor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("CMYKColor[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// specifies opacity a.
        /// https://reference.wolfram.com/language/ref/CMYKColor.html
        ///</summary>
        corewolf::engine *CMYKColor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("CMYKColor[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// returns a color from an HTML color name etc.
        /// https://reference.wolfram.com/language/ref/CMYKColor.html
        ///</summary>
        corewolf::engine *CMYKColor(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CMYKColor[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the coefficient of form in the polynomial expr.
        /// https://reference.wolfram.com/language/ref/Coefficient.html
        ///</summary>
        corewolf::engine *Coefficient(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Coefficient[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the coefficient of form^n in expr.
        /// https://reference.wolfram.com/language/ref/Coefficient.html
        ///</summary>
        corewolf::engine *Coefficient(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Coefficient[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the arrays of coefficients of the variables vars in the polynomials polys.
        /// https://reference.wolfram.com/language/ref/CoefficientArrays.html
        ///</summary>
        corewolf::engine *CoefficientArrays(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CoefficientArrays[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of coefficients of powers of var in poly, starting with power 0.
        /// https://reference.wolfram.com/language/ref/CoefficientList.html
        ///</summary>
        corewolf::engine *CoefficientList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CoefficientList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an array of coefficients of the vari.
        /// https://reference.wolfram.com/language/ref/CoefficientList.html
        ///</summary>
        corewolf::engine *CoefficientList(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CoefficientList[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives an array of dimensions {dim1,dim2,…}, truncating or padding with zeros as needed.
        /// https://reference.wolfram.com/language/ref/CoefficientList.html
        ///</summary>
        corewolf::engine *CoefficientList(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("CoefficientList[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the list {{e11,e12,…}c1,{e21,…}c2,…} of exponent vectors and coefficients for the monomials in poly with respect to the xi.
        /// https://reference.wolfram.com/language/ref/CoefficientRules.html
        ///</summary>
        corewolf::engine *CoefficientRules(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CoefficientRules[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the result with the monomial ordering specified by order.
        /// https://reference.wolfram.com/language/ref/CoefficientRules.html
        ///</summary>
        corewolf::engine *CoefficientRules(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CoefficientRules[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Coiflet wavelet of order 2.
        /// https://reference.wolfram.com/language/ref/CoifletWavelet.html
        ///</summary>
        corewolf::engine *CoifletWavelet(const std::string &name = "")
        {
            return this->execute("CoifletWavelet[]", name);
        }

        ///< summary>
        /// represents a Coiflet wavelet of order n.
        /// https://reference.wolfram.com/language/ref/CoifletWavelet.html
        ///</summary>
        corewolf::engine *CoifletWavelet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CoifletWavelet[" + arg0 + "]", name);
        }

        ///< summary>
        /// collects together terms involving the same powers of objects matching x.
        /// https://reference.wolfram.com/language/ref/Collect.html
        ///</summary>
        corewolf::engine *Collect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Collect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// successively collects together terms that involve the same powers of objects matching x1, then x2, ….
        /// https://reference.wolfram.com/language/ref/Collect.html
        ///</summary>
        corewolf::engine *Collect(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Collect[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// applies h to the expression that forms the coefficient of each term obtained.
        /// https://reference.wolfram.com/language/ref/Collect.html
        ///</summary>
        corewolf::engine *Collect(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Collect[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether the points p1,p2,p3,…,pn are collinear.
        /// https://reference.wolfram.com/language/ref/CollinearPoints.html
        ///</summary>
        corewolf::engine *CollinearPoints(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CollinearPoints[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Colon.html
        ///</summary>
        corewolf::engine *Colon(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Colon[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// adjusts the colors in image to achieve a balance that simulates the effect of neutral lighting.
        /// https://reference.wolfram.com/language/ref/ColorBalance.html
        ///</summary>
        corewolf::engine *ColorBalance(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ColorBalance[" + arg0 + "]", name);
        }

        ///< summary>
        /// adjusts colors in image so that the reference color specified by ref is mapped to white.
        /// https://reference.wolfram.com/language/ref/ColorBalance.html
        ///</summary>
        corewolf::engine *ColorBalance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ColorBalance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a multichannel image by combining the sequence of channels in the imagei.
        /// https://reference.wolfram.com/language/ref/ColorCombine.html
        ///</summary>
        corewolf::engine *ColorCombine(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ColorCombine[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// combines images that represent the color components specified by colorspace.
        /// https://reference.wolfram.com/language/ref/ColorCombine.html
        ///</summary>
        corewolf::engine *ColorCombine(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ColorCombine[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts the color space of a color to the specified color space colspace.
        /// https://reference.wolfram.com/language/ref/ColorConvert.html
        ///</summary>
        corewolf::engine *ColorConvert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ColorConvert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts the color space of a list of colors and images.
        /// https://reference.wolfram.com/language/ref/ColorConvert.html
        ///</summary>
        corewolf::engine *ColorConvert(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ColorConvert[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a function that generates colors in the named color scheme when applied to parameter values.
        /// https://reference.wolfram.com/language/ref/ColorData.html
        ///</summary>
        corewolf::engine *ColorData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ColorData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the specified property of a color scheme.
        /// https://reference.wolfram.com/language/ref/ColorData.html
        ///</summary>
        corewolf::engine *ColorData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ColorData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of named collections of color schemes.
        /// https://reference.wolfram.com/language/ref/ColorData.html
        ///</summary>
        corewolf::engine *ColorData(const std::string &name = "")
        {
            return this->execute("ColorData[]", name);
        }

        ///< summary>
        /// returns a mask image representing regions in image with colors within the specified color region.
        /// https://reference.wolfram.com/language/ref/ColorDetect.html
        ///</summary>
        corewolf::engine *ColorDetect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ColorDetect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the approximate perceptual distance between color directives c1 and c2.
        /// https://reference.wolfram.com/language/ref/ColorDistance.html
        ///</summary>
        corewolf::engine *ColorDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ColorDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates an image from an integer matrix m, using colors for positive integers and black for non-positive integers.
        /// https://reference.wolfram.com/language/ref/Colorize.html
        ///</summary>
        corewolf::engine *Colorize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Colorize[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the negative of a color.
        /// https://reference.wolfram.com/language/ref/ColorNegate.html
        ///</summary>
        corewolf::engine *ColorNegate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ColorNegate[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of negative images or colors.
        /// https://reference.wolfram.com/language/ref/ColorNegate.html
        ///</summary>
        corewolf::engine *ColorNegate(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ColorNegate[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents an ICC color profile that can convert between the independent color space "ics" and the device-dependent color space "device".
        /// https://reference.wolfram.com/language/ref/ColorProfileData.html
        ///</summary>
        corewolf::engine *ColorProfileData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ColorProfileData[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// yields True if color is a valid color directive and False otherwise.
        /// https://reference.wolfram.com/language/ref/ColorQ.html
        ///</summary>
        corewolf::engine *ColorQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ColorQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an approximation to image by quantizing to distinct colors.
        /// https://reference.wolfram.com/language/ref/ColorQuantize.html
        ///</summary>
        corewolf::engine *ColorQuantize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ColorQuantize[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses at most n distinct colors.
        /// https://reference.wolfram.com/language/ref/ColorQuantize.html
        ///</summary>
        corewolf::engine *ColorQuantize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ColorQuantize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an image using only the n specified colors coli.
        /// https://reference.wolfram.com/language/ref/ColorQuantize.html
        ///</summary>
        corewolf::engine *ColorQuantize(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ColorQuantize[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds regions in image whose pixel values are similar to color and replaces them with transparent pixels.
        /// https://reference.wolfram.com/language/ref/ColorReplace.html
        ///</summary>
        corewolf::engine *ColorReplace(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ColorReplace[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces all pixels whose values are within a distance d from color.
        /// https://reference.wolfram.com/language/ref/ColorReplace.html
        ///</summary>
        corewolf::engine *ColorReplace(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ColorReplace[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// does multiple color replacements.
        /// https://reference.wolfram.com/language/ref/ColorReplace.html
        ///</summary>
        corewolf::engine *ColorReplace(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ColorReplace[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of single-channel images corresponding to each of the color channels in image.
        /// https://reference.wolfram.com/language/ref/ColorSeparate.html
        ///</summary>
        corewolf::engine *ColorSeparate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ColorSeparate[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of images corresponding to the components of colorspace.
        /// https://reference.wolfram.com/language/ref/ColorSeparate.html
        ///</summary>
        corewolf::engine *ColorSeparate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ColorSeparate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a color setter which displays as a swatch of the specified color and when clicked brings up a system color picker dialog.
        /// https://reference.wolfram.com/language/ref/ColorSetter.html
        ///</summary>
        corewolf::engine *ColorSetter(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ColorSetter[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a color setter with initial color gray.
        /// https://reference.wolfram.com/language/ref/ColorSetter.html
        ///</summary>
        corewolf::engine *ColorSetter(const std::string &name = "")
        {
            return this->execute("ColorSetter[]", name);
        }

        ///< summary>
        /// represents a color slider currently set to the color corresponding to color.
        /// https://reference.wolfram.com/language/ref/ColorSlider.html
        ///</summary>
        corewolf::engine *ColorSlider(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ColorSlider[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a color slider with an initial gray color.
        /// https://reference.wolfram.com/language/ref/ColorSlider.html
        ///</summary>
        corewolf::engine *ColorSlider(const std::string &name = "")
        {
            return this->execute("ColorSlider[]", name);
        }

        ///< summary>
        /// represents a region around color.
        /// https://reference.wolfram.com/language/ref/ColorsNear.html
        ///</summary>
        corewolf::engine *ColorsNear(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ColorsNear[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a region with maximum distance d around color.
        /// https://reference.wolfram.com/language/ref/ColorsNear.html
        ///</summary>
        corewolf::engine *ColorsNear(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ColorsNear[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the specified color distance function dfun.
        /// https://reference.wolfram.com/language/ref/ColorsNear.html
        ///</summary>
        corewolf::engine *ColorsNear(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ColorsNear[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies a tone mapping to color values in image so as to make variations of luminance visible even in small intervals of the dynamic range.
        /// https://reference.wolfram.com/language/ref/ColorToneMapping.html
        ///</summary>
        corewolf::engine *ColorToneMapping(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ColorToneMapping[" + arg0 + "]", name);
        }

        ///< summary>
        /// maps colors by compressing the overall range of luminance values by a factor c.
        /// https://reference.wolfram.com/language/ref/ColorToneMapping.html
        ///</summary>
        corewolf::engine *ColorToneMapping(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ColorToneMapping[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// takes the specified range of colors and compresses their overall luminance values by a factor c.
        /// https://reference.wolfram.com/language/ref/ColorToneMapping.html
        ///</summary>
        corewolf::engine *ColorToneMapping(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ColorToneMapping[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses different compression factors ci for different ranges rangei.
        /// https://reference.wolfram.com/language/ref/ColorToneMapping.html
        ///</summary>
        corewolf::engine *ColorToneMapping(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ColorToneMapping[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses the color compensation factor s to correct for saturation distortion introduced during tone mapping.
        /// https://reference.wolfram.com/language/ref/ColorToneMapping.html
        ///</summary>
        corewolf::engine *ColorToneMapping(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ColorToneMapping[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is an const std::string &that formats with the expri arranged in a column, with expr1 above expr2, etc.
        /// https://reference.wolfram.com/language/ref/Column.html
        ///</summary>
        corewolf::engine *Column(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Column[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// aligns each element horizontally in the specified way.
        /// https://reference.wolfram.com/language/ref/Column.html
        ///</summary>
        corewolf::engine *Column(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Column[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// leaves the specified number of x-heights of spacing between successive elements.
        /// https://reference.wolfram.com/language/ref/Column.html
        ///</summary>
        corewolf::engine *Column(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Column[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a class of entities obtained by combining the properties of those pairs of entities from class1 and class2 for which the value of the property prop is the same for the two entities in the pair.
        /// https://reference.wolfram.com/language/ref/CombinedEntityClass.html
        ///</summary>
        corewolf::engine *CombinedEntityClass(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CombinedEntityClass[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// combines pairs of entities for which all the property specifications pspeck agree.
        /// https://reference.wolfram.com/language/ref/CombinedEntityClass.html
        ///</summary>
        corewolf::engine *CombinedEntityClass(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("CombinedEntityClass[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses "jspec" to determine when to allow entities with missing properties to be included.
        /// https://reference.wolfram.com/language/ref/CombinedEntityClass.html
        ///</summary>
        corewolf::engine *CombinedEntityClass(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("CombinedEntityClass[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the comet entity.
        /// https://reference.wolfram.com/language/ref/CometData.html
        ///</summary>
        corewolf::engine *CometData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CometData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified comet entities.
        /// https://reference.wolfram.com/language/ref/CometData.html
        ///</summary>
        corewolf::engine *CometData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CometData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/CometData.html
        ///</summary>
        corewolf::engine *CometData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CometData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of the elements that are the most common in list.
        /// https://reference.wolfram.com/language/ref/Commonest.html
        ///</summary>
        corewolf::engine *Commonest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Commonest[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of the n most common elements in list.
        /// https://reference.wolfram.com/language/ref/Commonest.html
        ///</summary>
        corewolf::engine *Commonest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Commonest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// filters data by replacing every value with the most common value in its range-r neighborhood.
        /// https://reference.wolfram.com/language/ref/CommonestFilter.html
        ///</summary>
        corewolf::engine *CommonestFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CommonestFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses ri for filtering the dimension in data.
        /// https://reference.wolfram.com/language/ref/CommonestFilter.html
        ///</summary>
        corewolf::engine *CommonestFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CommonestFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the common name for the entity specified by entity.
        /// https://reference.wolfram.com/language/ref/CommonName.html
        ///</summary>
        corewolf::engine *CommonName(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CommonName[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the common name for entity1 through entityn.
        /// https://reference.wolfram.com/language/ref/CommonName.html
        ///</summary>
        corewolf::engine *CommonName(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CommonName[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// converts quantity1 through quantityn to common units across compatible dimensions.
        /// https://reference.wolfram.com/language/ref/CommonUnits.html
        ///</summary>
        corewolf::engine *CommonUnits(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CommonUnits[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a plot showing the community structure of the graph g.
        /// https://reference.wolfram.com/language/ref/CommunityGraphPlot.html
        ///</summary>
        corewolf::engine *CommunityGraphPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CommunityGraphPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a plot for the graph g with communities {vi1,vi2,…}, ….
        /// https://reference.wolfram.com/language/ref/CommunityGraphPlot.html
        ///</summary>
        corewolf::engine *CommunityGraphPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CommunityGraphPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a plot with highlighting features defined by the symbol wrappers wj.
        /// https://reference.wolfram.com/language/ref/CommunityGraphPlot.html
        ///</summary>
        corewolf::engine *CommunityGraphPlot(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CommunityGraphPlot[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a plot for a graph in which vertex vik is connected to vertex vjk.
        /// https://reference.wolfram.com/language/ref/CommunityGraphPlot.html
        ///</summary>
        corewolf::engine *CommunityGraphPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CommunityGraphPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a plot for a graph represented by the adjacency matrix m.
        /// https://reference.wolfram.com/language/ref/CommunityGraphPlot.html
        ///</summary>
        corewolf::engine *CommunityGraphPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CommunityGraphPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the company entity.
        /// https://reference.wolfram.com/language/ref/CompanyData.html
        ///</summary>
        corewolf::engine *CompanyData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CompanyData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified company entities.
        /// https://reference.wolfram.com/language/ref/CompanyData.html
        ///</summary>
        corewolf::engine *CompanyData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CompanyData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/CompanyData.html
        ///</summary>
        corewolf::engine *CompanyData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CompanyData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns True if quantity1 and quantity2 have compatible units, and False otherwise.
        /// https://reference.wolfram.com/language/ref/CompatibleUnitQ.html
        ///</summary>
        corewolf::engine *CompatibleUnitQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CompatibleUnitQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a compiled function that evaluates expr assuming numerical values of the xi.
        /// https://reference.wolfram.com/language/ref/Compile.html
        ///</summary>
        corewolf::engine *Compile(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Compile[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// assumes that subexpressions in expr that match pi are of types that match pti.
        /// https://reference.wolfram.com/language/ref/Compile.html
        ///</summary>
        corewolf::engine *Compile(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Compile[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// is a function created by FunctionCompile that contains compiled code that is run when the CompiledCodeFunction is applied to suitable arguments.
        /// https://reference.wolfram.com/language/ref/CompiledCodeFunction.html
        ///</summary>
        corewolf::engine *CompiledCodeFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CompiledCodeFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a type for expressions of the form h[x1,x2,…,xn], suitable for use in compiled code.
        /// https://reference.wolfram.com/language/ref/CompiledExpressionDeclaration.html
        ///</summary>
        corewolf::engine *CompiledExpressionDeclaration(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CompiledExpressionDeclaration[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a type for expressions of the form h[x1,x2,…,xn], with xi having the type ti.
        /// https://reference.wolfram.com/language/ref/CompiledExpressionDeclaration.html
        ///</summary>
        corewolf::engine *CompiledExpressionDeclaration(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CompiledExpressionDeclaration[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// asserts the condition cond on the type parameters.
        /// https://reference.wolfram.com/language/ref/CompiledExpressionDeclaration.html
        ///</summary>
        corewolf::engine *CompiledExpressionDeclaration(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("CompiledExpressionDeclaration[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents compiled code for evaluating a compiled function.
        /// https://reference.wolfram.com/language/ref/CompiledFunction.html
        ///</summary>
        corewolf::engine *CompiledFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CompiledFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a net layer whose computation is defined by the compilable function func.
        /// https://reference.wolfram.com/language/ref/CompiledLayer.html
        ///</summary>
        corewolf::engine *CompiledLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CompiledLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies a gradient propagating function allowing the layer to be used in NetTrain.
        /// https://reference.wolfram.com/language/ref/CompiledLayer.html
        ///</summary>
        corewolf::engine *CompiledLayer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CompiledLayer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a function that, if defined in a compiler environment, is automatically called by the Wolfram Compiler.
        /// https://reference.wolfram.com/language/ref/CompilerCallback.html
        ///</summary>
        corewolf::engine *CompilerCallback(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CompilerCallback[" + arg0 + "]", name);
        }

        ///< summary>
        /// appends declarations to $CompilerEnvironment.
        /// https://reference.wolfram.com/language/ref/CompilerEnvironmentAppendTo.html
        ///</summary>
        corewolf::engine *CompilerEnvironmentAppendTo(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CompilerEnvironmentAppendTo[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// appends declarations to CompilerEnvironmentObject env.
        /// https://reference.wolfram.com/language/ref/CompilerEnvironmentAppendTo.html
        ///</summary>
        corewolf::engine *CompilerEnvironmentAppendTo(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CompilerEnvironmentAppendTo[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the elements in eall that are not in any of the ei.
        /// https://reference.wolfram.com/language/ref/Complement.html
        ///</summary>
        corewolf::engine *Complement(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Complement[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an entity class containing all the entities in classall that are not in any of the classi.
        /// https://reference.wolfram.com/language/ref/ComplementedEntityClass.html
        ///</summary>
        corewolf::engine *ComplementedEntityClass(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ComplementedEntityClass[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the complete graph with n vertices .
        /// https://reference.wolfram.com/language/ref/CompleteGraph.html
        ///</summary>
        corewolf::engine *CompleteGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CompleteGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the complete k-partite graph with n1+n2+⋯+nk vertices .
        /// https://reference.wolfram.com/language/ref/CompleteGraph.html
        ///</summary>
        corewolf::engine *CompleteGraph(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CompleteGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is a complete graph, and False otherwise.
        /// https://reference.wolfram.com/language/ref/CompleteGraphQ.html
        ///</summary>
        corewolf::engine *CompleteGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CompleteGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if the subgraph induced by vlist is a complete graph, and False otherwise.
        /// https://reference.wolfram.com/language/ref/CompleteGraphQ.html
        ///</summary>
        corewolf::engine *CompleteGraphQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CompleteGraphQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a complete integral u for the first-order partial differential equation pde, with independent variables {x1,…,xn}.
        /// https://reference.wolfram.com/language/ref/CompleteIntegral.html
        ///</summary>
        corewolf::engine *CompleteIntegral(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("CompleteIntegral[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the complete binary tree with n levels.
        /// https://reference.wolfram.com/language/ref/CompleteKaryTree.html
        ///</summary>
        corewolf::engine *CompleteKaryTree(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CompleteKaryTree[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the complete k-ary tree with n levels.
        /// https://reference.wolfram.com/language/ref/CompleteKaryTree.html
        ///</summary>
        corewolf::engine *CompleteKaryTree(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CompleteKaryTree[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a plot in which complex values zij in an array array are shown in a discrete array of squares with Arg[zij] indicated by color and Abs[zij] by shading.
        /// https://reference.wolfram.com/language/ref/ComplexArrayPlot.html
        ///</summary>
        corewolf::engine *ComplexArrayPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ComplexArrayPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a filled contour plot of f as a function of z.
        /// https://reference.wolfram.com/language/ref/ComplexContourPlot.html
        ///</summary>
        corewolf::engine *ComplexContourPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ComplexContourPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates contour lines for f1, f2, ….
        /// https://reference.wolfram.com/language/ref/ComplexContourPlot.html
        ///</summary>
        corewolf::engine *ComplexContourPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ComplexContourPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// expands expr assuming that all variables are real.
        /// https://reference.wolfram.com/language/ref/ComplexExpand.html
        ///</summary>
        corewolf::engine *ComplexExpand(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ComplexExpand[" + arg0 + "]", name);
        }

        ///< summary>
        /// expands expr assuming that variables matching any of the xi are complex.
        /// https://reference.wolfram.com/language/ref/ComplexExpand.html
        ///</summary>
        corewolf::engine *ComplexExpand(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ComplexExpand[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots complex numbers z1, z2, … as points in the complex plane.
        /// https://reference.wolfram.com/language/ref/ComplexListPlot.html
        ///</summary>
        corewolf::engine *ComplexListPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ComplexListPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a plot of Arg[f] over the complex rectangle with corners zmin and zmax.
        /// https://reference.wolfram.com/language/ref/ComplexPlot.html
        ///</summary>
        corewolf::engine *ComplexPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ComplexPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a 3D plot of Abs[f] colored by Arg[f] over the complex rectangle with corners zmin and zmax.
        /// https://reference.wolfram.com/language/ref/ComplexPlot3D.html
        ///</summary>
        corewolf::engine *ComplexPlot3D(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ComplexPlot3D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a plot showing the region in the complex plane for which pred is True.
        /// https://reference.wolfram.com/language/ref/ComplexRegionPlot.html
        ///</summary>
        corewolf::engine *ComplexRegionPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ComplexRegionPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots regions given by the multiple predicates predi.
        /// https://reference.wolfram.com/language/ref/ComplexRegionPlot.html
        ///</summary>
        corewolf::engine *ComplexRegionPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ComplexRegionPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a streamline plot of the vector field {Re[f],Im[f]} over the complex rectangle with corners zmin and zmax.
        /// https://reference.wolfram.com/language/ref/ComplexStreamPlot.html
        ///</summary>
        corewolf::engine *ComplexStreamPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ComplexStreamPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a vector plot of the vector field {Re[f],Im[f]} over the complex rectangle with corners zmin and zmax.
        /// https://reference.wolfram.com/language/ref/ComplexVectorPlot.html
        ///</summary>
        corewolf::engine *ComplexVectorPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ComplexVectorPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots several vector fields.
        /// https://reference.wolfram.com/language/ref/ComplexVectorPlot.html
        ///</summary>
        corewolf::engine *ComplexVectorPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ComplexVectorPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// computes the property "prop" for components of image indicated by the label matrix lmat.
        /// https://reference.wolfram.com/language/ref/ComponentMeasurements.html
        ///</summary>
        corewolf::engine *ComponentMeasurements(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ComponentMeasurements[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes the property "prop" for connected components of image.
        /// https://reference.wolfram.com/language/ref/ComponentMeasurements.html
        ///</summary>
        corewolf::engine *ComponentMeasurements(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ComponentMeasurements[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// only returns measurements for components that satisfy the criterion crit.
        /// https://reference.wolfram.com/language/ref/ComponentMeasurements.html
        ///</summary>
        corewolf::engine *ComponentMeasurements(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ComponentMeasurements[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// formats the result according to the output specification format.
        /// https://reference.wolfram.com/language/ref/ComponentMeasurements.html
        ///</summary>
        corewolf::engine *ComponentMeasurements(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ComponentMeasurements[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// generates a list of the form {x,f1[x],f2[f1[x]],…}.
        /// https://reference.wolfram.com/language/ref/ComposeList.html
        ///</summary>
        corewolf::engine *ComposeList(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ComposeList[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// composes several power series.
        /// https://reference.wolfram.com/language/ref/ComposeSeries.html
        ///</summary>
        corewolf::engine *ComposeSeries(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ComposeSeries[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields True if n is a composite number, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/CompositeQ.html
        ///</summary>
        corewolf::engine *CompositeQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CompositeQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a composition of the functions f1, f2, f3, ….
        /// https://reference.wolfram.com/language/ref/Composition.html
        ///</summary>
        corewolf::engine *Composition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Composition[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a form or interpreter specification for a list of fields or inputs that gives a list of results.
        /// https://reference.wolfram.com/language/ref/CompoundElement.html
        ///</summary>
        corewolf::engine *CompoundElement(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CompoundElement[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a form or interpreter specification that gives an association of results.
        /// https://reference.wolfram.com/language/ref/CompoundElement.html
        ///</summary>
        corewolf::engine *CompoundElement(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CompoundElement[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a compound Poisson distribution with rate parameter λ and jump size distribution dist.
        /// https://reference.wolfram.com/language/ref/CompoundPoissonDistribution.html
        ///</summary>
        corewolf::engine *CompoundPoissonDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CompoundPoissonDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a compound Poisson process with rate parameter λ and jump size distribution jdist.
        /// https://reference.wolfram.com/language/ref/CompoundPoissonProcess.html
        ///</summary>
        corewolf::engine *CompoundPoissonProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CompoundPoissonProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a compound renewal process with renewal-time distribution rdist and jump size distribution jdist.
        /// https://reference.wolfram.com/language/ref/CompoundRenewalProcess.html
        ///</summary>
        corewolf::engine *CompoundRenewalProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CompoundRenewalProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a compressed representation of expr as a string.
        /// https://reference.wolfram.com/language/ref/Compress.html
        ///</summary>
        corewolf::engine *Compress(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Compress[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the concave hull mesh from the points p1,p2,….
        /// https://reference.wolfram.com/language/ref/ConcaveHullMesh.html
        ///</summary>
        corewolf::engine *ConcaveHullMesh(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ConcaveHullMesh[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the concave hull mesh of the specified parameter α.
        /// https://reference.wolfram.com/language/ref/ConcaveHullMesh.html
        ///</summary>
        corewolf::engine *ConcaveHullMesh(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConcaveHullMesh[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the concave hull mesh of cells of dimension d.
        /// https://reference.wolfram.com/language/ref/ConcaveHullMesh.html
        ///</summary>
        corewolf::engine *ConcaveHullMesh(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ConcaveHullMesh[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a symbolic construct that represents the expression expr when the condition cond is True.
        /// https://reference.wolfram.com/language/ref/ConditionalExpression.html
        ///</summary>
        corewolf::engine *ConditionalExpression(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConditionalExpression[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// or exprcond represents expr conditioned by the predicate cond.
        /// https://reference.wolfram.com/language/ref/Conditioned.html
        ///</summary>
        corewolf::engine *Conditioned(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Conditioned[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a cone with a base of radius r centered at (x1,y1,z1) and a tip at (x2,y2,z2).
        /// https://reference.wolfram.com/language/ref/Cone.html
        ///</summary>
        corewolf::engine *Cone(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Cone[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a cone with a base of radius 1.
        /// https://reference.wolfram.com/language/ref/Cone.html
        ///</summary>
        corewolf::engine *Cone(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Cone[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// confirms that expr is not considered a failure, otherwise throwing an error to the nearest surrounding Enclose.
        /// https://reference.wolfram.com/language/ref/Confirm.html
        ///</summary>
        corewolf::engine *Confirm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Confirm[" + arg0 + "]", name);
        }

        ///< summary>
        /// evaluates info and includes its value in the thrown error if expr is not confirmed.
        /// https://reference.wolfram.com/language/ref/Confirm.html
        ///</summary>
        corewolf::engine *Confirm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Confirm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the specified tag for any thrown errors.
        /// https://reference.wolfram.com/language/ref/Confirm.html
        ///</summary>
        corewolf::engine *Confirm(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Confirm[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// confirms that test is True, otherwise throwing an error to the nearest surrounding Enclose.
        /// https://reference.wolfram.com/language/ref/ConfirmAssert.html
        ///</summary>
        corewolf::engine *ConfirmAssert(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ConfirmAssert[" + arg0 + "]", name);
        }

        ///< summary>
        /// evaluates info and includes its value in the thrown error if test is not True.
        /// https://reference.wolfram.com/language/ref/ConfirmAssert.html
        ///</summary>
        corewolf::engine *ConfirmAssert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConfirmAssert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the specified tag for any thrown errors.
        /// https://reference.wolfram.com/language/ref/ConfirmAssert.html
        ///</summary>
        corewolf::engine *ConfirmAssert(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ConfirmAssert[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// confirms that f[expr] returns True, otherwise throwing an error to the nearest surrounding Enclose.
        /// https://reference.wolfram.com/language/ref/ConfirmBy.html
        ///</summary>
        corewolf::engine *ConfirmBy(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConfirmBy[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates info and includes its value in the thrown error if expr is not confirmed.
        /// https://reference.wolfram.com/language/ref/ConfirmBy.html
        ///</summary>
        corewolf::engine *ConfirmBy(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ConfirmBy[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses the specified tag for any thrown errors.
        /// https://reference.wolfram.com/language/ref/ConfirmBy.html
        ///</summary>
        corewolf::engine *ConfirmBy(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ConfirmBy[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// confirms that expr matches the pattern form, otherwise throwing an error to the nearest surrounding Enclose.
        /// https://reference.wolfram.com/language/ref/ConfirmMatch.html
        ///</summary>
        corewolf::engine *ConfirmMatch(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConfirmMatch[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates info and includes its value in the thrown error if expr is not confirmed.
        /// https://reference.wolfram.com/language/ref/ConfirmMatch.html
        ///</summary>
        corewolf::engine *ConfirmMatch(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ConfirmMatch[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses the specified tag for any thrown errors.
        /// https://reference.wolfram.com/language/ref/ConfirmMatch.html
        ///</summary>
        corewolf::engine *ConfirmMatch(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ConfirmMatch[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// confirms that no messages are generated during the evaluation of expr, otherwise quieting them and throwing an error to the nearest surrounding Enclose.
        /// https://reference.wolfram.com/language/ref/ConfirmQuiet.html
        ///</summary>
        corewolf::engine *ConfirmQuiet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ConfirmQuiet[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests only for the specified message.
        /// https://reference.wolfram.com/language/ref/ConfirmQuiet.html
        ///</summary>
        corewolf::engine *ConfirmQuiet(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConfirmQuiet[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests only for the specified list of messages.
        /// https://reference.wolfram.com/language/ref/ConfirmQuiet.html
        ///</summary>
        corewolf::engine *ConfirmQuiet(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ConfirmQuiet[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates info and includes its value in the thrown error if expr is not confirmed.
        /// https://reference.wolfram.com/language/ref/ConfirmQuiet.html
        ///</summary>
        corewolf::engine *ConfirmQuiet(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ConfirmQuiet[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses the specified tag for any thrown errors.
        /// https://reference.wolfram.com/language/ref/ConfirmQuiet.html
        ///</summary>
        corewolf::engine *ConfirmQuiet(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ConfirmQuiet[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// returns a list of audio objects where all audioi are made to have conforming properties, including duration, data type, and number of channels.
        /// https://reference.wolfram.com/language/ref/ConformAudio.html
        ///</summary>
        corewolf::engine *ConformAudio(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ConformAudio[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns all audio objects of the specified spec.
        /// https://reference.wolfram.com/language/ref/ConformAudio.html
        ///</summary>
        corewolf::engine *ConformAudio(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConformAudio[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a list of images where all imagei are made to have conforming properties, including dimensions, data type, color space, and interleaving.
        /// https://reference.wolfram.com/language/ref/ConformImages.html
        ///</summary>
        corewolf::engine *ConformImages(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ConformImages[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns all images of the specified spec.
        /// https://reference.wolfram.com/language/ref/ConformImages.html
        ///</summary>
        corewolf::engine *ConformImages(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConformImages[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// resizes images using the specified fitting method.
        /// https://reference.wolfram.com/language/ref/ConformImages.html
        ///</summary>
        corewolf::engine *ConformImages(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ConformImages[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Congruent.html
        ///</summary>
        corewolf::engine *Congruent(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Congruent[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a two-dimensional graphics directive specifying that faces of polygons and other filled graphics objects are to be drawn using a progressive transition between colors coli along a circle.
        /// https://reference.wolfram.com/language/ref/ConicGradientFilling.html
        ///</summary>
        corewolf::engine *ConicGradientFilling(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ConicGradientFilling[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// rotates from the center point {x,y}.
        /// https://reference.wolfram.com/language/ref/ConicGradientFilling.html
        ///</summary>
        corewolf::engine *ConicGradientFilling(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ConicGradientFilling[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents the m-dimensional affine hull region passing through points pi.
        /// https://reference.wolfram.com/language/ref/ConicHullRegion.html
        ///</summary>
        corewolf::engine *ConicHullRegion(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ConicHullRegion[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the m-dimensional affine hull region passing through the point p and parallel to vi.
        /// https://reference.wolfram.com/language/ref/ConicHullRegion.html
        ///</summary>
        corewolf::engine *ConicHullRegion(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ConicHullRegion[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents the m-dimensional affine hull plus the conic hull generated by the vectors wj.
        /// https://reference.wolfram.com/language/ref/ConicHullRegion.html
        ///</summary>
        corewolf::engine *ConicHullRegion(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ConicHullRegion[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents the m-dimensional affine hull plus the conic hull generated by the vectors wj.
        /// https://reference.wolfram.com/language/ref/ConicHullRegion.html
        ///</summary>
        corewolf::engine *ConicHullRegion(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ConicHullRegion[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// finds values of variables vars that minimize the linear objective f subject to conic constraints cons.
        /// https://reference.wolfram.com/language/ref/ConicOptimization.html
        ///</summary>
        corewolf::engine *ConicOptimization(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ConicOptimization[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// specifies what solution property "prop" should be returned.
        /// https://reference.wolfram.com/language/ref/ConicOptimization.html
        ///</summary>
        corewolf::engine *ConicOptimization(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConicOptimization[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// or z gives the complex conjugate of the complex number z.
        /// https://reference.wolfram.com/language/ref/Conjugate.html
        ///</summary>
        corewolf::engine *Conjugate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Conjugate[" + arg0 + "]", name);
        }

        ///< summary>
        /// or  gives the conjugate transpose of .
        /// https://reference.wolfram.com/language/ref/ConjugateTranspose.html
        ///</summary>
        corewolf::engine *ConjugateTranspose(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ConjugateTranspose[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the conjunction of expr over all choices of the Boolean variables ai.
        /// https://reference.wolfram.com/language/ref/Conjunction.html
        ///</summary>
        corewolf::engine *Conjunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Conjunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the connected components of the graph g.
        /// https://reference.wolfram.com/language/ref/ConnectedComponents.html
        ///</summary>
        corewolf::engine *ConnectedComponents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ConnectedComponents[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the connected components that include at least one of the vertices v1, v2, … .
        /// https://reference.wolfram.com/language/ref/ConnectedComponents.html
        ///</summary>
        corewolf::engine *ConnectedComponents(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ConnectedComponents[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the connected components that include a vertex that matches the pattern patt.
        /// https://reference.wolfram.com/language/ref/ConnectedComponents.html
        ///</summary>
        corewolf::engine *ConnectedComponents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConnectedComponents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/ConnectedComponents.html
        ///</summary>
        corewolf::engine *ConnectedComponents(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConnectedComponents[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the connected components of the graph g.
        /// https://reference.wolfram.com/language/ref/ConnectedGraphComponents.html
        ///</summary>
        corewolf::engine *ConnectedGraphComponents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ConnectedGraphComponents[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the connected components that include at least one of the vertices v1, v2, … .
        /// https://reference.wolfram.com/language/ref/ConnectedGraphComponents.html
        ///</summary>
        corewolf::engine *ConnectedGraphComponents(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ConnectedGraphComponents[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the connected components that include a vertex that matches the pattern patt.
        /// https://reference.wolfram.com/language/ref/ConnectedGraphComponents.html
        ///</summary>
        corewolf::engine *ConnectedGraphComponents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConnectedGraphComponents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/ConnectedGraphComponents.html
        ///</summary>
        corewolf::engine *ConnectedGraphComponents(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConnectedGraphComponents[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is connected, and False otherwise.
        /// https://reference.wolfram.com/language/ref/ConnectedGraphQ.html
        ///</summary>
        corewolf::engine *ConnectedGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ConnectedGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list {c1,c2,…} of disjoint path connected meshed regions.
        /// https://reference.wolfram.com/language/ref/ConnectedMeshComponents.html
        ///</summary>
        corewolf::engine *ConnectedMeshComponents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ConnectedMeshComponents[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the connected components of the molecule mol.
        /// https://reference.wolfram.com/language/ref/ConnectedMoleculeComponents.html
        ///</summary>
        corewolf::engine *ConnectedMoleculeComponents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ConnectedMoleculeComponents[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if the atoms in mol form are connected by bonds, and False otherwise.
        /// https://reference.wolfram.com/language/ref/ConnectedMoleculeQ.html
        ///</summary>
        corewolf::engine *ConnectedMoleculeQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ConnectedMoleculeQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// connects a CompiledFunction cf with the library callback manager with name mname.
        /// https://reference.wolfram.com/language/ref/ConnectLibraryCallbackFunction.html
        ///</summary>
        corewolf::engine *ConnectLibraryCallbackFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConnectLibraryCallbackFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a system model by connecting connector "a" of component "c1" with connector "b" of component "c2" etc.
        /// https://reference.wolfram.com/language/ref/ConnectSystemModelComponents.html
        ///</summary>
        corewolf::engine *ConnectSystemModelComponents(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ConnectSystemModelComponents[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// connects the system model model with a controller according to the controller data controller.
        /// https://reference.wolfram.com/language/ref/ConnectSystemModelController.html
        ///</summary>
        corewolf::engine *ConnectSystemModelController(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConnectSystemModelController[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Connes window function of x.
        /// https://reference.wolfram.com/language/ref/ConnesWindow.html
        ///</summary>
        corewolf::engine *ConnesWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ConnesWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the parameter α.
        /// https://reference.wolfram.com/language/ref/ConnesWindow.html
        ///</summary>
        corewolf::engine *ConnesWindow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConnesWindow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether the variances of data1, data2, … are equal.
        /// https://reference.wolfram.com/language/ref/ConoverTest.html
        ///</summary>
        corewolf::engine *ConoverTest(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ConoverTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// tests a dispersion measure against .
        /// https://reference.wolfram.com/language/ref/ConoverTest.html
        ///</summary>
        corewolf::engine *ConoverTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ConoverTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/ConoverTest.html
        ///</summary>
        corewolf::engine *ConoverTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConoverTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a conservative convection term  with conservative convection coefficient  and model variables vars.
        /// https://reference.wolfram.com/language/ref/ConservativeConvectionPDETerm.html
        ///</summary>
        corewolf::engine *ConservativeConvectionPDETerm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConservativeConvectionPDETerm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses model parameters pars.
        /// https://reference.wolfram.com/language/ref/ConservativeConvectionPDETerm.html
        ///</summary>
        corewolf::engine *ConservativeConvectionPDETerm(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ConservativeConvectionPDETerm[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a list of n copies of the element c.
        /// https://reference.wolfram.com/language/ref/ConstantArray.html
        ///</summary>
        corewolf::engine *ConstantArray(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConstantArray[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates an  array of nested lists containing copies of the element c.
        /// https://reference.wolfram.com/language/ref/ConstantArray.html
        ///</summary>
        corewolf::engine *ConstantArray(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ConstantArray[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives an image of the specified size with constant pixel values of val.
        /// https://reference.wolfram.com/language/ref/ConstantImage.html
        ///</summary>
        corewolf::engine *ConstantImage(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConstantImage[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an image converted to the specified type.
        /// https://reference.wolfram.com/language/ref/ConstantImage.html
        ///</summary>
        corewolf::engine *ConstantImage(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ConstantImage[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives True if the reg is a constant region and False otherwise.
        /// https://reference.wolfram.com/language/ref/ConstantRegionQ.html
        ///</summary>
        corewolf::engine *ConstantRegionQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ConstantRegionQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the constellation entity.
        /// https://reference.wolfram.com/language/ref/ConstellationData.html
        ///</summary>
        corewolf::engine *ConstellationData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConstellationData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified constellation entities.
        /// https://reference.wolfram.com/language/ref/ConstellationData.html
        ///</summary>
        corewolf::engine *ConstellationData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConstellationData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/ConstellationData.html
        ///</summary>
        corewolf::engine *ConstellationData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ConstellationData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives f[x].
        /// https://reference.wolfram.com/language/ref/Construct.html
        ///</summary>
        corewolf::engine *Construct(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Construct[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives f[x1,…,xn].
        /// https://reference.wolfram.com/language/ref/Construct.html
        ///</summary>
        corewolf::engine *Construct(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Construct[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an const std::string &of type outer containing objects of type inner.
        /// https://reference.wolfram.com/language/ref/Containing.html
        ///</summary>
        corewolf::engine *Containing(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Containing[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if e1 contains all of the elements of e2.
        /// https://reference.wolfram.com/language/ref/ContainsAll.html
        ///</summary>
        corewolf::engine *ContainsAll(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ContainsAll[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is an operator form that yields True when the const std::string &to which it is applied contains all of the elements of e2.
        /// https://reference.wolfram.com/language/ref/ContainsAll.html
        ///</summary>
        corewolf::engine *ContainsAll(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ContainsAll[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if e1 contains any of the elements of e2.
        /// https://reference.wolfram.com/language/ref/ContainsAny.html
        ///</summary>
        corewolf::engine *ContainsAny(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ContainsAny[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is an operator form that yields True when the const std::string &to which it is applied contains any of the elements in e2.
        /// https://reference.wolfram.com/language/ref/ContainsAny.html
        ///</summary>
        corewolf::engine *ContainsAny(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ContainsAny[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if e1 contains exactly the same elements as e2.
        /// https://reference.wolfram.com/language/ref/ContainsExactly.html
        ///</summary>
        corewolf::engine *ContainsExactly(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ContainsExactly[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is an operator form that yields True when the const std::string &to which it is applied contains exactly the same elements as e2.
        /// https://reference.wolfram.com/language/ref/ContainsExactly.html
        ///</summary>
        corewolf::engine *ContainsExactly(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ContainsExactly[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if e1 contains none of the elements in e2.
        /// https://reference.wolfram.com/language/ref/ContainsNone.html
        ///</summary>
        corewolf::engine *ContainsNone(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ContainsNone[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is an operator form that yields True when the const std::string &to which it is applied contains none of the elements of e2.
        /// https://reference.wolfram.com/language/ref/ContainsNone.html
        ///</summary>
        corewolf::engine *ContainsNone(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ContainsNone[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if e1 contains only elements that appear in e2.
        /// https://reference.wolfram.com/language/ref/ContainsOnly.html
        ///</summary>
        corewolf::engine *ContainsOnly(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ContainsOnly[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is an operator form that yields True when the const std::string &to which it is applied contains only elements that appear in e2.
        /// https://reference.wolfram.com/language/ref/ContainsOnly.html
        ///</summary>
        corewolf::engine *ContainsOnly(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ContainsOnly[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a function generated by TrainImageContentDetector or TrainTextContentDetector that localizes and classifies contents in a piece of text or an image.
        /// https://reference.wolfram.com/language/ref/ContentDetectorFunction.html
        ///</summary>
        corewolf::engine *ContentDetectorFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ContentDetectorFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a content const std::string &whose content is string.
        /// https://reference.wolfram.com/language/ref/ContentObject.html
        ///</summary>
        corewolf::engine *ContentObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ContentObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a content const std::string &with a sequence of fields with names namei and values vali.
        /// https://reference.wolfram.com/language/ref/ContentObject.html
        ///</summary>
        corewolf::engine *ContentObject(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ContentObject[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the current context.
        /// https://reference.wolfram.com/language/ref/Context.html
        ///</summary>
        corewolf::engine *Context(const std::string &name = "")
        {
            return this->execute("Context[]", name);
        }

        ///< summary>
        /// gives the context in which a symbol appears.
        /// https://reference.wolfram.com/language/ref/Context.html
        ///</summary>
        corewolf::engine *Context(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Context[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of all contexts.
        /// https://reference.wolfram.com/language/ref/Contexts.html
        ///</summary>
        corewolf::engine *Contexts(const std::string &name = "")
        {
            return this->execute("Contexts[]", name);
        }

        ///< summary>
        /// gives a list of the contexts that match the string.
        /// https://reference.wolfram.com/language/ref/Contexts.html
        ///</summary>
        corewolf::engine *Contexts(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Contexts[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the string specifying the file name that is by convention associated with a particular context.
        /// https://reference.wolfram.com/language/ref/ContextToFileName.html
        ///</summary>
        corewolf::engine *ContextToFileName(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ContextToFileName[" + arg0 + "]", name);
        }

        ///< summary>
        /// exits to the nearest enclosing Do, For, or While in a procedural program.
        /// https://reference.wolfram.com/language/ref/Continue.html
        ///</summary>
        corewolf::engine *Continue(const std::string &name = "")
        {
            return this->execute("Continue[]", name);
        }

        ///< summary>
        /// generates a list of the first n terms in the continued fraction representation of x.
        /// https://reference.wolfram.com/language/ref/ContinuedFraction.html
        ///</summary>
        corewolf::engine *ContinuedFraction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ContinuedFraction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a list of all terms that can be obtained given the precision of x.
        /// https://reference.wolfram.com/language/ref/ContinuedFraction.html
        ///</summary>
        corewolf::engine *ContinuedFraction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ContinuedFraction[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the continued fraction .
        /// https://reference.wolfram.com/language/ref/ContinuedFractionK.html
        ///</summary>
        corewolf::engine *ContinuedFractionK(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ContinuedFractionK[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents the continued fraction .
        /// https://reference.wolfram.com/language/ref/ContinuedFractionK.html
        ///</summary>
        corewolf::engine *ContinuedFractionK(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ContinuedFractionK[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a continuous-time finite-state Markov process with transition rate matrix q and initial state i0.
        /// https://reference.wolfram.com/language/ref/ContinuousMarkovProcess.html
        ///</summary>
        corewolf::engine *ContinuousMarkovProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ContinuousMarkovProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Markov process with transition matrix m and transition rates μ.
        /// https://reference.wolfram.com/language/ref/ContinuousMarkovProcess.html
        ///</summary>
        corewolf::engine *ContinuousMarkovProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ContinuousMarkovProcess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a task in which expr is continuously reevaluated.
        /// https://reference.wolfram.com/language/ref/ContinuousTask.html
        ///</summary>
        corewolf::engine *ContinuousTask(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ContinuousTask[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a task in which expr is continuously reevaluated until the time specified by end.
        /// https://reference.wolfram.com/language/ref/ContinuousTask.html
        ///</summary>
        corewolf::engine *ContinuousTask(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ContinuousTask[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if lsys is a continuous-time systems model, and False otherwise.
        /// https://reference.wolfram.com/language/ref/ContinuousTimeModelQ.html
        ///</summary>
        corewolf::engine *ContinuousTimeModelQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ContinuousTimeModelQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields a continuous wavelet data const std::string &with wavelet coefficients coefi corresponding to octave and voice {octi,voci} and wavelet wave.
        /// https://reference.wolfram.com/language/ref/ContinuousWaveletData.html
        ///</summary>
        corewolf::engine *ContinuousWaveletData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ContinuousWaveletData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the continuous wavelet transform of a list of values xi.
        /// https://reference.wolfram.com/language/ref/ContinuousWaveletTransform.html
        ///</summary>
        corewolf::engine *ContinuousWaveletTransform(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ContinuousWaveletTransform[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the continuous wavelet transform using the wavelet wave.
        /// https://reference.wolfram.com/language/ref/ContinuousWaveletTransform.html
        ///</summary>
        corewolf::engine *ContinuousWaveletTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ContinuousWaveletTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the continuous wavelet transform using noct octaves with nvoc voices per octave.
        /// https://reference.wolfram.com/language/ref/ContinuousWaveletTransform.html
        ///</summary>
        corewolf::engine *ContinuousWaveletTransform(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ContinuousWaveletTransform[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives a binary image in which white pixels correspond to the zeros and zero crossings in image.
        /// https://reference.wolfram.com/language/ref/ContourDetect.html
        ///</summary>
        corewolf::engine *ContourDetect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ContourDetect[" + arg0 + "]", name);
        }

        ///< summary>
        /// treats values in image that are smaller in absolute value than delta as zero.
        /// https://reference.wolfram.com/language/ref/ContourDetect.html
        ///</summary>
        corewolf::engine *ContourDetect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ContourDetect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a contour plot of f as a function of x and y.
        /// https://reference.wolfram.com/language/ref/ContourPlot.html
        ///</summary>
        corewolf::engine *ContourPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ContourPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// plots several contour lines.
        /// https://reference.wolfram.com/language/ref/ContourPlot.html
        ///</summary>
        corewolf::engine *ContourPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ContourPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// takes the variables {x,y} to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/ContourPlot.html
        ///</summary>
        corewolf::engine *ContourPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ContourPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// produces a three-dimensional contour plot of f as a function of x, y, and z.
        /// https://reference.wolfram.com/language/ref/ContourPlot3D.html
        ///</summary>
        corewolf::engine *ContourPlot3D(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("ContourPlot3D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// takes the variables {x,y,z} to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/ContourPlot3D.html
        ///</summary>
        corewolf::engine *ContourPlot3D(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ContourPlot3D[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the contraharmonic mean of the values in list.
        /// https://reference.wolfram.com/language/ref/ContraharmonicMean.html
        ///</summary>
        corewolf::engine *ContraharmonicMean(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ContraharmonicMean[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the order p Lehmer contraharmonic mean.
        /// https://reference.wolfram.com/language/ref/ContraharmonicMean.html
        ///</summary>
        corewolf::engine *ContraharmonicMean(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ContraharmonicMean[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a loss layer that computes a loss based on a distance metric and a target that specifies whether the distance should be minimized or maximized.
        /// https://reference.wolfram.com/language/ref/ContrastiveLossLayer.html
        ///</summary>
        corewolf::engine *ContrastiveLossLayer(const std::string &name = "")
        {
            return this->execute("ContrastiveLossLayer[]", name);
        }

        ///< summary>
        /// specifies a distance above which the loss is zero for True targets.
        /// https://reference.wolfram.com/language/ref/ContrastiveLossLayer.html
        ///</summary>
        corewolf::engine *ContrastiveLossLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ContrastiveLossLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an interactive control for the variable u in the domain dom, with the type of control chosen to be appropriate for the domain specified.
        /// https://reference.wolfram.com/language/ref/Control.html
        ///</summary>
        corewolf::engine *Control(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Control[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates to act if a control that affects act is actively being used, and to norm otherwise.
        /// https://reference.wolfram.com/language/ref/ControlActive.html
        ///</summary>
        corewolf::engine *ControlActive(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ControlActive[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the controllability Gramian of the state-space model ssm.
        /// https://reference.wolfram.com/language/ref/ControllabilityGramian.html
        ///</summary>
        corewolf::engine *ControllabilityGramian(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ControllabilityGramian[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the controllability matrix of the state-space model ssm.
        /// https://reference.wolfram.com/language/ref/ControllabilityMatrix.html
        ///</summary>
        corewolf::engine *ControllabilityMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ControllabilityMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields the controllable subsystem of the state-space model sys.
        /// https://reference.wolfram.com/language/ref/ControllableDecomposition.html
        ///</summary>
        corewolf::engine *ControllableDecomposition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ControllableDecomposition[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies the new state variables zi.
        /// https://reference.wolfram.com/language/ref/ControllableDecomposition.html
        ///</summary>
        corewolf::engine *ControllableDecomposition(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ControllableDecomposition[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if the state-space model sys is controllable, and False otherwise.
        /// https://reference.wolfram.com/language/ref/ControllableModelQ.html
        ///</summary>
        corewolf::engine *ControllableModelQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ControllableModelQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if the subsystem sub is controllable.
        /// https://reference.wolfram.com/language/ref/ControllableModelQ.html
        ///</summary>
        corewolf::engine *ControllableModelQ(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ControllableModelQ[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives dynamically updated information on currently connected controller devices.
        /// https://reference.wolfram.com/language/ref/ControllerInformation.html
        ///</summary>
        corewolf::engine *ControllerInformation(const std::string &name = "")
        {
            return this->execute("ControllerInformation[]", name);
        }

        ///< summary>
        /// generates a version of expr set up to allow interactive manipulation of the value of u using an external controller device.
        /// https://reference.wolfram.com/language/ref/ControllerManipulate.html
        ///</summary>
        corewolf::engine *ControllerManipulate(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ControllerManipulate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// allows u to take on discrete values u1, u2, ….
        /// https://reference.wolfram.com/language/ref/ControllerManipulate.html
        ///</summary>
        corewolf::engine *ControllerManipulate(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ControllerManipulate[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// allows each of the u, v, … to be manipulated by the external controller device.
        /// https://reference.wolfram.com/language/ref/ControllerManipulate.html
        ///</summary>
        corewolf::engine *ControllerManipulate(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ControllerManipulate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// links the parameters to the specified controllers on the external controller device.
        /// https://reference.wolfram.com/language/ref/ControllerManipulate.html
        ///</summary>
        corewolf::engine *ControllerManipulate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ControllerManipulate[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the state of the control c for the first connected controller device on which it is supported.
        /// https://reference.wolfram.com/language/ref/ControllerState.html
        ///</summary>
        corewolf::engine *ControllerState(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ControllerState[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the states of several controls.
        /// https://reference.wolfram.com/language/ref/ControllerState.html
        ///</summary>
        corewolf::engine *ControllerState(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ControllerState[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the state of control c for controller devices with the specified identifier.
        /// https://reference.wolfram.com/language/ref/ControllerState.html
        ///</summary>
        corewolf::engine *ControllerState(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ControllerState[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the states of several controls for several controller devices.
        /// https://reference.wolfram.com/language/ref/ControllerState.html
        ///</summary>
        corewolf::engine *ControllerState(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ControllerState[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a convection term  with convection coefficient  and model variables vars.
        /// https://reference.wolfram.com/language/ref/ConvectionPDETerm.html
        ///</summary>
        corewolf::engine *ConvectionPDETerm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConvectionPDETerm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses model parameters pars.
        /// https://reference.wolfram.com/language/ref/ConvectionPDETerm.html
        ///</summary>
        corewolf::engine *ConvectionPDETerm(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ConvectionPDETerm[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of the convergents corresponding to the continued fraction terms list.
        /// https://reference.wolfram.com/language/ref/Convergents.html
        ///</summary>
        corewolf::engine *Convergents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Convergents[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the first n convergents for a number x.
        /// https://reference.wolfram.com/language/ref/Convergents.html
        ///</summary>
        corewolf::engine *Convergents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Convergents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a BoundaryMeshRegion representing the convex hull from the points p1, p2, ….
        /// https://reference.wolfram.com/language/ref/ConvexHullMesh.html
        ///</summary>
        corewolf::engine *ConvexHullMesh(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ConvexHullMesh[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the convex hull of the mesh region mreg.
        /// https://reference.wolfram.com/language/ref/ConvexHullMesh.html
        ///</summary>
        corewolf::engine *ConvexHullMesh(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ConvexHullMesh[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the convex hull from the points p1, p2, ….
        /// https://reference.wolfram.com/language/ref/ConvexHullRegion.html
        ///</summary>
        corewolf::engine *ConvexHullRegion(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ConvexHullRegion[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the convex hull of the region reg.
        /// https://reference.wolfram.com/language/ref/ConvexHullRegion.html
        ///</summary>
        corewolf::engine *ConvexHullRegion(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ConvexHullRegion[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds values of variables vars that minimize the convex objective function f subject to convex constraints cons.
        /// https://reference.wolfram.com/language/ref/ConvexOptimization.html
        ///</summary>
        corewolf::engine *ConvexOptimization(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ConvexOptimization[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// specifies what solution property "prop" should be returned.
        /// https://reference.wolfram.com/language/ref/ConvexOptimization.html
        ///</summary>
        corewolf::engine *ConvexOptimization(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConvexOptimization[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if the polygon poly is convex, and False otherwise.
        /// https://reference.wolfram.com/language/ref/ConvexPolygonQ.html
        ///</summary>
        corewolf::engine *ConvexPolygonQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ConvexPolygonQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if the polyhedron poly is convex, and False otherwise.
        /// https://reference.wolfram.com/language/ref/ConvexPolyhedronQ.html
        ///</summary>
        corewolf::engine *ConvexPolyhedronQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ConvexPolyhedronQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if reg is a convex region and False otherwise.
        /// https://reference.wolfram.com/language/ref/ConvexRegionQ.html
        ///</summary>
        corewolf::engine *ConvexRegionQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ConvexRegionQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a trainable convolutional net layer having n output channels and using kernels of size s to compute the convolution.
        /// https://reference.wolfram.com/language/ref/ConvolutionLayer.html
        ///</summary>
        corewolf::engine *ConvolutionLayer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ConvolutionLayer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a layer performing one-dimensional convolutions with kernels of size s.
        /// https://reference.wolfram.com/language/ref/ConvolutionLayer.html
        ///</summary>
        corewolf::engine *ConvolutionLayer(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ConvolutionLayer[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// includes options for padding and other parameters.
        /// https://reference.wolfram.com/language/ref/ConvolutionLayer.html
        ///</summary>
        corewolf::engine *ConvolutionLayer(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ConvolutionLayer[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the convolution with respect to x of the expressions f and g.
        /// https://reference.wolfram.com/language/ref/Convolve.html
        ///</summary>
        corewolf::engine *Convolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Convolve[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional convolution.
        /// https://reference.wolfram.com/language/ref/Convolve.html
        ///</summary>
        corewolf::engine *Convolve(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("Convolve[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// represents the sporadic simple Conway group Co1.
        /// https://reference.wolfram.com/language/ref/ConwayGroupCo1.html
        ///</summary>
        corewolf::engine *ConwayGroupCo1(const std::string &name = "")
        {
            return this->execute("ConwayGroupCo1[]", name);
        }

        ///< summary>
        /// represents the sporadic simple Conway group Co2.
        /// https://reference.wolfram.com/language/ref/ConwayGroupCo2.html
        ///</summary>
        corewolf::engine *ConwayGroupCo2(const std::string &name = "")
        {
            return this->execute("ConwayGroupCo2[]", name);
        }

        ///< summary>
        /// represents the sporadic simple Conway group Co3.
        /// https://reference.wolfram.com/language/ref/ConwayGroupCo3.html
        ///</summary>
        corewolf::engine *ConwayGroupCo3(const std::string &name = "")
        {
            return this->execute("ConwayGroupCo3[]", name);
        }

        ///< summary>
        /// gives the corners {{xmin,ymin,…},{xmax,ymax,…}} of the bounding box of the region defined by coords.
        /// https://reference.wolfram.com/language/ref/CoordinateBoundingBox.html
        ///</summary>
        corewolf::engine *CoordinateBoundingBox(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CoordinateBoundingBox[" + arg0 + "]", name);
        }

        ///< summary>
        /// pads the region by δ in each direction.
        /// https://reference.wolfram.com/language/ref/CoordinateBoundingBox.html
        ///</summary>
        corewolf::engine *CoordinateBoundingBox(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CoordinateBoundingBox[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// pads by p1, p2, … in successive dimensions.
        /// https://reference.wolfram.com/language/ref/CoordinateBoundingBox.html
        ///</summary>
        corewolf::engine *CoordinateBoundingBox(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CoordinateBoundingBox[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives {{xmin-p1min,ymin-p2min,…},{xmax+p1max,ymax+p2max,…},…}
        /// https://reference.wolfram.com/language/ref/CoordinateBoundingBox.html
        ///</summary>
        corewolf::engine *CoordinateBoundingBox(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("CoordinateBoundingBox[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates an array of {x,y,…} coordinates with integer steps in each dimension.
        /// https://reference.wolfram.com/language/ref/CoordinateBoundingBoxArray.html
        ///</summary>
        corewolf::engine *CoordinateBoundingBoxArray(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CoordinateBoundingBoxArray[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses step d in each dimension.
        /// https://reference.wolfram.com/language/ref/CoordinateBoundingBoxArray.html
        ///</summary>
        corewolf::engine *CoordinateBoundingBoxArray(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CoordinateBoundingBoxArray[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies offsets to use for each coordinate point.
        /// https://reference.wolfram.com/language/ref/CoordinateBoundingBoxArray.html
        ///</summary>
        corewolf::engine *CoordinateBoundingBoxArray(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CoordinateBoundingBoxArray[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// expands the array by k elements in every direction.
        /// https://reference.wolfram.com/language/ref/CoordinateBoundingBoxArray.html
        ///</summary>
        corewolf::engine *CoordinateBoundingBoxArray(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("CoordinateBoundingBoxArray[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives a list {{xmin,xmax},{ymin,ymax},…} of the bounds in each dimension of the region defined by coords.
        /// https://reference.wolfram.com/language/ref/CoordinateBounds.html
        ///</summary>
        corewolf::engine *CoordinateBounds(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CoordinateBounds[" + arg0 + "]", name);
        }

        ///< summary>
        /// pads the ranges of coordinates by ±δ in each dimension.
        /// https://reference.wolfram.com/language/ref/CoordinateBounds.html
        ///</summary>
        corewolf::engine *CoordinateBounds(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CoordinateBounds[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// pads by p1, p2, … in successive dimensions.
        /// https://reference.wolfram.com/language/ref/CoordinateBounds.html
        ///</summary>
        corewolf::engine *CoordinateBounds(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CoordinateBounds[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives {{xmin-p1min,xmax+p1max},{ymin-p2min,ymax+p2max},…}
        /// https://reference.wolfram.com/language/ref/CoordinateBounds.html
        ///</summary>
        corewolf::engine *CoordinateBounds(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("CoordinateBounds[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates an array of {x,y,…} coordinates with integer steps in each dimension.
        /// https://reference.wolfram.com/language/ref/CoordinateBoundsArray.html
        ///</summary>
        corewolf::engine *CoordinateBoundsArray(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CoordinateBoundsArray[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses step d in each dimension.
        /// https://reference.wolfram.com/language/ref/CoordinateBoundsArray.html
        ///</summary>
        corewolf::engine *CoordinateBoundsArray(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CoordinateBoundsArray[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies offsets to use for each coordinate point.
        /// https://reference.wolfram.com/language/ref/CoordinateBoundsArray.html
        ///</summary>
        corewolf::engine *CoordinateBoundsArray(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CoordinateBoundsArray[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// expands the array by k elements in every direction.
        /// https://reference.wolfram.com/language/ref/CoordinateBoundsArray.html
        ///</summary>
        corewolf::engine *CoordinateBoundsArray(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("CoordinateBoundsArray[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for chart.
        /// https://reference.wolfram.com/language/ref/CoordinateChartData.html
        ///</summary>
        corewolf::engine *CoordinateChartData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CoordinateChartData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for chart evaluated at the point {x1,x2,…,xn}.
        /// https://reference.wolfram.com/language/ref/CoordinateChartData.html
        ///</summary>
        corewolf::engine *CoordinateChartData(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("CoordinateChartData[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// performs the coordinate transformation t on the point pt.
        /// https://reference.wolfram.com/language/ref/CoordinateTransform.html
        ///</summary>
        corewolf::engine *CoordinateTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CoordinateTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// transforms several points.
        /// https://reference.wolfram.com/language/ref/CoordinateTransform.html
        ///</summary>
        corewolf::engine *CoordinateTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CoordinateTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the coordinate transformation t.
        /// https://reference.wolfram.com/language/ref/CoordinateTransformData.html
        ///</summary>
        corewolf::engine *CoordinateTransformData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CoordinateTransformData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the property evaluated at the point {x1,x2,…,xn}.
        /// https://reference.wolfram.com/language/ref/CoordinateTransformData.html
        ///</summary>
        corewolf::engine *CoordinateTransformData(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("CoordinateTransformData[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// tests whether the points p1,p2,p3,p4,…,pn are coplanar.
        /// https://reference.wolfram.com/language/ref/CoplanarPoints.html
        ///</summary>
        corewolf::engine *CoplanarPoints(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CoplanarPoints[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if n1 and n2 are relatively prime, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/CoprimeQ.html
        ///</summary>
        corewolf::engine *CoprimeQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CoprimeQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if all pairs of the ni are relatively prime, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/CoprimeQ.html
        ///</summary>
        corewolf::engine *CoprimeQ(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CoprimeQ[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Coproduct.html
        ///</summary>
        corewolf::engine *Coproduct(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Coproduct[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a copula distribution with kernel distribution ker and marginal distributions dist1, dist2, … .
        /// https://reference.wolfram.com/language/ref/CopulaDistribution.html
        ///</summary>
        corewolf::engine *CopulaDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CopulaDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// creates a copy of a databin.
        /// https://reference.wolfram.com/language/ref/CopyDatabin.html
        ///</summary>
        corewolf::engine *CopyDatabin(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CopyDatabin[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a copy with the specified options.
        /// https://reference.wolfram.com/language/ref/CopyDatabin.html
        ///</summary>
        corewolf::engine *CopyDatabin(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CopyDatabin[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// copies the directory dir1 to dir2.
        /// https://reference.wolfram.com/language/ref/CopyDirectory.html
        ///</summary>
        corewolf::engine *CopyDirectory(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CopyDirectory[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// copies from the local, remote or cloud file file1 to the local, remote or cloud file file2.
        /// https://reference.wolfram.com/language/ref/CopyFile.html
        ///</summary>
        corewolf::engine *CopyFile(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CopyFile[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces the contents of the clipboard with expr.
        /// https://reference.wolfram.com/language/ref/CopyToClipboard.html
        ///</summary>
        corewolf::engine *CopyToClipboard(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CopyToClipboard[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields the core-nilpotent decomposition of a square matrix m.
        /// https://reference.wolfram.com/language/ref/CoreNilpotentDecomposition.html
        ///</summary>
        corewolf::engine *CoreNilpotentDecomposition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CoreNilpotentDecomposition[" + arg0 + "]", name);
        }

        ///< summary>
        /// computes a measure for the presence of a corner for each pixel in image and returns the result as an intensity image.
        /// https://reference.wolfram.com/language/ref/CornerFilter.html
        ///</summary>
        corewolf::engine *CornerFilter(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CornerFilter[" + arg0 + "]", name);
        }

        ///< summary>
        /// detects corners at a pixel range r.
        /// https://reference.wolfram.com/language/ref/CornerFilter.html
        ///</summary>
        corewolf::engine *CornerFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CornerFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the correlation between the vectors v1 and v2.
        /// https://reference.wolfram.com/language/ref/Correlation.html
        ///</summary>
        corewolf::engine *Correlation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Correlation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the sample correlation matrix for observations in matrix m.
        /// https://reference.wolfram.com/language/ref/Correlation.html
        ///</summary>
        corewolf::engine *Correlation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Correlation[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the (i,j) correlation for the multivariate symbolic distribution dist.
        /// https://reference.wolfram.com/language/ref/Correlation.html
        ///</summary>
        corewolf::engine *Correlation(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Correlation[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the correlation coefficient distance between vectors u and v.
        /// https://reference.wolfram.com/language/ref/CorrelationDistance.html
        ///</summary>
        corewolf::engine *CorrelationDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CorrelationDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// estimates the correlation function at lags hspec from data.
        /// https://reference.wolfram.com/language/ref/CorrelationFunction.html
        ///</summary>
        corewolf::engine *CorrelationFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CorrelationFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the correlation function at times s and t for the random process proc.
        /// https://reference.wolfram.com/language/ref/CorrelationFunction.html
        ///</summary>
        corewolf::engine *CorrelationFunction(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CorrelationFunction[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether the correlation coefficient for a bivariate population is zero.
        /// https://reference.wolfram.com/language/ref/CorrelationTest.html
        ///</summary>
        corewolf::engine *CorrelationTest(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CorrelationTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// tests whether the correlation coefficient is ρ0.
        /// https://reference.wolfram.com/language/ref/CorrelationTest.html
        ///</summary>
        corewolf::engine *CorrelationTest(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CorrelationTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether the correlation coefficients for two populations are equal.
        /// https://reference.wolfram.com/language/ref/CorrelationTest.html
        ///</summary>
        corewolf::engine *CorrelationTest(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("CorrelationTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/CorrelationTest.html
        ///</summary>
        corewolf::engine *CorrelationTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CorrelationTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the cosine of z.
        /// https://reference.wolfram.com/language/ref/Cos.html
        ///</summary>
        corewolf::engine *Cos(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Cos[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the hyperbolic cosine of z.
        /// https://reference.wolfram.com/language/ref/Cosh.html
        ///</summary>
        corewolf::engine *Cosh(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Cosh[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the hyperbolic cosine integral .
        /// https://reference.wolfram.com/language/ref/CoshIntegral.html
        ///</summary>
        corewolf::engine *CoshIntegral(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CoshIntegral[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the angular cosine distance between vectors u and v.
        /// https://reference.wolfram.com/language/ref/CosineDistance.html
        ///</summary>
        corewolf::engine *CosineDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CosineDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a cosine window function of x.
        /// https://reference.wolfram.com/language/ref/CosineWindow.html
        ///</summary>
        corewolf::engine *CosineWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CosineWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the exponent α.
        /// https://reference.wolfram.com/language/ref/CosineWindow.html
        ///</summary>
        corewolf::engine *CosineWindow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CosineWindow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the cosine integral function .
        /// https://reference.wolfram.com/language/ref/CosIntegral.html
        ///</summary>
        corewolf::engine *CosIntegral(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CosIntegral[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the cotangent of z.
        /// https://reference.wolfram.com/language/ref/Cot.html
        ///</summary>
        corewolf::engine *Cot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Cot[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the hyperbolic cotangent of z.
        /// https://reference.wolfram.com/language/ref/Coth.html
        ///</summary>
        corewolf::engine *Coth(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Coth[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the regular Coulomb wavefunction .
        /// https://reference.wolfram.com/language/ref/CoulombF.html
        ///</summary>
        corewolf::engine *CoulombF(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CoulombF[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the irregular Coulomb wavefunction .
        /// https://reference.wolfram.com/language/ref/CoulombG.html
        ///</summary>
        corewolf::engine *CoulombG(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CoulombG[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the outgoing irregular Coulomb wavefunction .
        /// https://reference.wolfram.com/language/ref/CoulombH1.html
        ///</summary>
        corewolf::engine *CoulombH1(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CoulombH1[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the incoming irregular Coulomb wavefunction .
        /// https://reference.wolfram.com/language/ref/CoulombH2.html
        ///</summary>
        corewolf::engine *CoulombH2(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CoulombH2[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the number of elements in list that match pattern.
        /// https://reference.wolfram.com/language/ref/Count.html
        ///</summary>
        corewolf::engine *Count(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Count[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the total number of subexpressions matching pattern that appear at the levels in expr specified by levelspec.
        /// https://reference.wolfram.com/language/ref/Count.html
        ///</summary>
        corewolf::engine *Count(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Count[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of Count that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/Count.html
        ///</summary>
        corewolf::engine *Count(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Count[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number of distinct elements that appear in list.
        /// https://reference.wolfram.com/language/ref/CountDistinct.html
        ///</summary>
        corewolf::engine *CountDistinct(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CountDistinct[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number of distinct values of f[ei] that occur.
        /// https://reference.wolfram.com/language/ref/CountDistinctBy.html
        ///</summary>
        corewolf::engine *CountDistinctBy(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CountDistinctBy[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of CountDistinctBy that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/CountDistinctBy.html
        ///</summary>
        corewolf::engine *CountDistinctBy(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CountDistinctBy[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number of real roots of the univariate function f in x.
        /// https://reference.wolfram.com/language/ref/CountRoots.html
        ///</summary>
        corewolf::engine *CountRoots(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CountRoots[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the number of roots between a and b.
        /// https://reference.wolfram.com/language/ref/CountRoots.html
        ///</summary>
        corewolf::engine *CountRoots(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CountRoots[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the country, country-like entity, or group of countries specified by "tag".
        /// https://reference.wolfram.com/language/ref/CountryData.html
        ///</summary>
        corewolf::engine *CountryData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CountryData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives time series for certain economic and other properties.
        /// https://reference.wolfram.com/language/ref/CountryData.html
        ///</summary>
        corewolf::engine *CountryData(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CountryData[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives an association whose keys are the distinct elements of list, and whose values give the number of times those elements appear in list.
        /// https://reference.wolfram.com/language/ref/Counts.html
        ///</summary>
        corewolf::engine *Counts(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Counts[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an association whose keys are the distinct values of the f[ei], and whose values give the number of times these f[ei] values appear.
        /// https://reference.wolfram.com/language/ref/CountsBy.html
        ///</summary>
        corewolf::engine *CountsBy(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CountsBy[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of CountsBy that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/CountsBy.html
        ///</summary>
        corewolf::engine *CountsBy(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CountsBy[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the covariance between the vectors v1 and v2.
        /// https://reference.wolfram.com/language/ref/Covariance.html
        ///</summary>
        corewolf::engine *Covariance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Covariance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the sample covariance matrix for observations in matrix m.
        /// https://reference.wolfram.com/language/ref/Covariance.html
        ///</summary>
        corewolf::engine *Covariance(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Covariance[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the (i,j) covariance for the multivariate symbolic distribution dist.
        /// https://reference.wolfram.com/language/ref/Covariance.html
        ///</summary>
        corewolf::engine *Covariance(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Covariance[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// estimates the covariance function at lags hspec from data.
        /// https://reference.wolfram.com/language/ref/CovarianceFunction.html
        ///</summary>
        corewolf::engine *CovarianceFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CovarianceFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the covariance function at times s and t for the random process proc.
        /// https://reference.wolfram.com/language/ref/CovarianceFunction.html
        ///</summary>
        corewolf::engine *CovarianceFunction(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CovarianceFunction[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represent an m-phase Coxian distribution with phase probabilities αi and rates λi.
        /// https://reference.wolfram.com/language/ref/CoxianDistribution.html
        ///</summary>
        corewolf::engine *CoxianDistribution(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CoxianDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a Cox–Ingersoll–Ross process with long‐term mean μ, volatility σ, speed of adjustment θ, and initial condition x0.
        /// https://reference.wolfram.com/language/ref/CoxIngersollRossProcess.html
        ///</summary>
        corewolf::engine *CoxIngersollRossProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("CoxIngersollRossProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents the symbolic proportional hazards model obtained from CoxModelFit.
        /// https://reference.wolfram.com/language/ref/CoxModel.html
        ///</summary>
        corewolf::engine *CoxModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CoxModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// constructs a model of the baseline hazard  for events times ei.
        /// https://reference.wolfram.com/language/ref/CoxModelFit.html
        ///</summary>
        corewolf::engine *CoxModelFit(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CoxModelFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// constructs a Cox model of the form , where the fi depend on the xk.
        /// https://reference.wolfram.com/language/ref/CoxModelFit.html
        ///</summary>
        corewolf::engine *CoxModelFit(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::vector<std::string> &arg4, const std::vector<std::string> &arg5, const std::string &name = "")
        {
            return this->execute("CoxModelFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg5) + "}" + "]", name);
        }

        ///< summary>
        /// tests whether data is normally distributed using the Cramér–von Mises test.
        /// https://reference.wolfram.com/language/ref/CramerVonMisesTest.html
        ///</summary>
        corewolf::engine *CramerVonMisesTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CramerVonMisesTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether data is distributed according to dist using the Cramér–von Mises test.
        /// https://reference.wolfram.com/language/ref/CramerVonMisesTest.html
        ///</summary>
        corewolf::engine *CramerVonMisesTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CramerVonMisesTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/CramerVonMisesTest.html
        ///</summary>
        corewolf::engine *CramerVonMisesTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CramerVonMisesTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// creates a compressed archive in the current directory from source.
        /// https://reference.wolfram.com/language/ref/CreateArchive.html
        ///</summary>
        corewolf::engine *CreateArchive(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreateArchive[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a compressed archive in the directory or file specified by path.
        /// https://reference.wolfram.com/language/ref/CreateArchive.html
        ///</summary>
        corewolf::engine *CreateArchive(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CreateArchive[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a new channel for channel communication, with a generated name.
        /// https://reference.wolfram.com/language/ref/CreateChannel.html
        ///</summary>
        corewolf::engine *CreateChannel(const std::string &name = "")
        {
            return this->execute("CreateChannel[]", name);
        }

        ///< summary>
        /// creates a channel with the specified path relative to the home area of the currently authenticated user.
        /// https://reference.wolfram.com/language/ref/CreateChannel.html
        ///</summary>
        corewolf::engine *CreateChannel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreateChannel[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a new anonymous cloud expression that stores the specified initial value.
        /// https://reference.wolfram.com/language/ref/CreateCloudExpression.html
        ///</summary>
        corewolf::engine *CreateCloudExpression(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreateCloudExpression[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a new cloud expression with the specified name.
        /// https://reference.wolfram.com/language/ref/CreateCloudExpression.html
        ///</summary>
        corewolf::engine *CreateCloudExpression(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CreateCloudExpression[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a compiler environment that can be used in FunctionCompile and related functions.
        /// https://reference.wolfram.com/language/ref/CreateCompilerEnvironment.html
        ///</summary>
        corewolf::engine *CreateCompilerEnvironment(const std::string &name = "")
        {
            return this->execute("CreateCompilerEnvironment[]", name);
        }

        ///< summary>
        /// creates a databin in the Wolfram Data Drop and returns the corresponding Databin object.
        /// https://reference.wolfram.com/language/ref/CreateDatabin.html
        ///</summary>
        corewolf::engine *CreateDatabin(const std::string &name = "")
        {
            return this->execute("CreateDatabin[]", name);
        }

        ///< summary>
        /// creates a databin with the specified options.
        /// https://reference.wolfram.com/language/ref/CreateDatabin.html
        ///</summary>
        corewolf::engine *CreateDatabin(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreateDatabin[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a data structure with the specified type.
        /// https://reference.wolfram.com/language/ref/CreateDataStructure.html
        ///</summary>
        corewolf::engine *CreateDataStructure(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("CreateDataStructure[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// creates a SystemModel generating a signal of values vi.
        /// https://reference.wolfram.com/language/ref/CreateDataSystemModel.html
        ///</summary>
        corewolf::engine *CreateDataSystemModel(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CreateDataSystemModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// creates a model for the TimeSeries or InterpolatingFunction obj.
        /// https://reference.wolfram.com/language/ref/CreateDataSystemModel.html
        ///</summary>
        corewolf::engine *CreateDataSystemModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreateDataSystemModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a model with samples from the function fun between tmin and tmax.
        /// https://reference.wolfram.com/language/ref/CreateDataSystemModel.html
        ///</summary>
        corewolf::engine *CreateDataSystemModel(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CreateDataSystemModel[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// creates a model with data specification "dspec".
        /// https://reference.wolfram.com/language/ref/CreateDataSystemModel.html
        ///</summary>
        corewolf::engine *CreateDataSystemModel(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CreateDataSystemModel[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a dialog notebook containing expr and opens it in the front end.
        /// https://reference.wolfram.com/language/ref/CreateDialog.html
        ///</summary>
        corewolf::engine *CreateDialog(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreateDialog[" + arg0 + "]", name);
        }

        ///< summary>
        /// replaces the notebook represented by the notebook const std::string &obj with the one obtained from expr.
        /// https://reference.wolfram.com/language/ref/CreateDialog.html
        ///</summary>
        corewolf::engine *CreateDialog(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CreateDialog[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a directory with name dir.
        /// https://reference.wolfram.com/language/ref/CreateDirectory.html
        ///</summary>
        corewolf::engine *CreateDirectory(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreateDirectory[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a directory in the default area for temporary directories on your computer system.
        /// https://reference.wolfram.com/language/ref/CreateDirectory.html
        ///</summary>
        corewolf::engine *CreateDirectory(const std::string &name = "")
        {
            return this->execute("CreateDirectory[]", name);
        }

        ///< summary>
        /// creates an empty document notebook and opens it in the front end.
        /// https://reference.wolfram.com/language/ref/CreateDocument.html
        ///</summary>
        corewolf::engine *CreateDocument(const std::string &name = "")
        {
            return this->execute("CreateDocument[]", name);
        }

        ///< summary>
        /// creates and opens a document notebook containing the expression expr.
        /// https://reference.wolfram.com/language/ref/CreateDocument.html
        ///</summary>
        corewolf::engine *CreateDocument(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreateDocument[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates and opens a document notebook consisting of a sequence of cells containing the expri.
        /// https://reference.wolfram.com/language/ref/CreateDocument.html
        ///</summary>
        corewolf::engine *CreateDocument(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CreateDocument[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// replaces the notebook represented by the notebook const std::string &obj with the one obtained from expr.
        /// https://reference.wolfram.com/language/ref/CreateDocument.html
        ///</summary>
        corewolf::engine *CreateDocument(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CreateDocument[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a file with name file.
        /// https://reference.wolfram.com/language/ref/CreateFile.html
        ///</summary>
        corewolf::engine *CreateFile(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreateFile[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a file in the default area for temporary files on your computer system.
        /// https://reference.wolfram.com/language/ref/CreateFile.html
        ///</summary>
        corewolf::engine *CreateFile(const std::string &name = "")
        {
            return this->execute("CreateFile[]", name);
        }

        ///< summary>
        /// creates an on-demand license entitlement using settings.
        /// https://reference.wolfram.com/language/ref/CreateLicenseEntitlement.html
        ///</summary>
        corewolf::engine *CreateLicenseEntitlement(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreateLicenseEntitlement[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates an on-demand license entitlement using the default settings.
        /// https://reference.wolfram.com/language/ref/CreateLicenseEntitlement.html
        ///</summary>
        corewolf::engine *CreateLicenseEntitlement(const std::string &name = "")
        {
            return this->execute("CreateLicenseEntitlement[]", name);
        }

        ///< summary>
        /// creates a managed library expression by applying f to a positive integer ID associated with a registered manager with name mname.
        /// https://reference.wolfram.com/language/ref/CreateManagedLibraryExpression.html
        ///</summary>
        corewolf::engine *CreateManagedLibraryExpression(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CreateManagedLibraryExpression[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a generic empty notebook and opens it in the front end.
        /// https://reference.wolfram.com/language/ref/CreateNotebook.html
        ///</summary>
        corewolf::engine *CreateNotebook(const std::string &name = "")
        {
            return this->execute("CreateNotebook[]", name);
        }

        ///< summary>
        /// creates an empty notebook of the specified type and opens it in the front end.
        /// https://reference.wolfram.com/language/ref/CreateNotebook.html
        ///</summary>
        corewolf::engine *CreateNotebook(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreateNotebook[" + arg0 + "]", name);
        }

        ///< summary>
        /// replaces the notebook represented by the notebook const std::string &obj by a version converted to be of the specified type.
        /// https://reference.wolfram.com/language/ref/CreateNotebook.html
        ///</summary>
        corewolf::engine *CreateNotebook(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CreateNotebook[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a paclet archive file from source.
        /// https://reference.wolfram.com/language/ref/CreatePacletArchive.html
        ///</summary>
        corewolf::engine *CreatePacletArchive(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreatePacletArchive[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a paclet archive file from source and places it in destdir.
        /// https://reference.wolfram.com/language/ref/CreatePacletArchive.html
        ///</summary>
        corewolf::engine *CreatePacletArchive(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CreatePacletArchive[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a palette notebook containing expr, and opens it in the front end.
        /// https://reference.wolfram.com/language/ref/CreatePalette.html
        ///</summary>
        corewolf::engine *CreatePalette(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreatePalette[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates and opens a palette notebook consisting of a sequence of cells containing the expri.
        /// https://reference.wolfram.com/language/ref/CreatePalette.html
        ///</summary>
        corewolf::engine *CreatePalette(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CreatePalette[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// replaces the notebook represented by the notebook const std::string &obj with the one obtained from expr.
        /// https://reference.wolfram.com/language/ref/CreatePalette.html
        ///</summary>
        corewolf::engine *CreatePalette(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CreatePalette[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a permissions group with the specified name.
        /// https://reference.wolfram.com/language/ref/CreatePermissionsGroup.html
        ///</summary>
        corewolf::engine *CreatePermissionsGroup(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreatePermissionsGroup[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a permissions group consisting of the specified initial users.
        /// https://reference.wolfram.com/language/ref/CreatePermissionsGroup.html
        ///</summary>
        corewolf::engine *CreatePermissionsGroup(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CreatePermissionsGroup[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// creates a search index from all files in the directory dir and its subdirectories.
        /// https://reference.wolfram.com/language/ref/CreateSearchIndex.html
        ///</summary>
        corewolf::engine *CreateSearchIndex(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreateSearchIndex[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a search index from all sources sourcei.
        /// https://reference.wolfram.com/language/ref/CreateSearchIndex.html
        ///</summary>
        corewolf::engine *CreateSearchIndex(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CreateSearchIndex[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the search index the specified name.
        /// https://reference.wolfram.com/language/ref/CreateSearchIndex.html
        ///</summary>
        corewolf::engine *CreateSearchIndex(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CreateSearchIndex[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates an empty search index, which can be added to with AddToSearchIndex.
        /// https://reference.wolfram.com/language/ref/CreateSearchIndex.html
        ///</summary>
        corewolf::engine *CreateSearchIndex(const std::string &name = "")
        {
            return this->execute("CreateSearchIndex[]", name);
        }

        ///< summary>
        /// creates a Modelica SystemModel from the systems model sys.
        /// https://reference.wolfram.com/language/ref/CreateSystemModel.html
        ///</summary>
        corewolf::engine *CreateSystemModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreateSystemModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a model for the system equations eqns with independent variable t.
        /// https://reference.wolfram.com/language/ref/CreateSystemModel.html
        ///</summary>
        corewolf::engine *CreateSystemModel(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CreateSystemModel[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates an instance of a type in compiled code.
        /// https://reference.wolfram.com/language/ref/CreateTypeInstance.html
        ///</summary>
        corewolf::engine *CreateTypeInstance(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("CreateTypeInstance[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// creates a random, universally unique UUID string.
        /// https://reference.wolfram.com/language/ref/CreateUUID.html
        ///</summary>
        corewolf::engine *CreateUUID(const std::string &name = "")
        {
            return this->execute("CreateUUID[]", name);
        }

        ///< summary>
        /// appends a UUID string to the specified base string.
        /// https://reference.wolfram.com/language/ref/CreateUUID.html
        ///</summary>
        corewolf::engine *CreateUUID(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreateUUID[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates an empty window in the front end.
        /// https://reference.wolfram.com/language/ref/CreateWindow.html
        ///</summary>
        corewolf::engine *CreateWindow(const std::string &name = "")
        {
            return this->execute("CreateWindow[]", name);
        }

        ///< summary>
        /// creates a window displaying the notebook expression expr, and opens it in the front end.
        /// https://reference.wolfram.com/language/ref/CreateWindow.html
        ///</summary>
        corewolf::engine *CreateWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CreateWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// replaces the notebook represented by the notebook const std::string &obj with the one obtained from expr.
        /// https://reference.wolfram.com/language/ref/CreateWindow.html
        ///</summary>
        corewolf::engine *CreateWindow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CreateWindow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the criticality failure importances for all components in the ReliabilityDistribution rdist at time t.
        /// https://reference.wolfram.com/language/ref/CriticalityFailureImportance.html
        ///</summary>
        corewolf::engine *CriticalityFailureImportance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CriticalityFailureImportance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the criticality success importances for all components in the ReliabilityDistribution rdist at time t.
        /// https://reference.wolfram.com/language/ref/CriticalitySuccessImportance.html
        ///</summary>
        corewolf::engine *CriticalitySuccessImportance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CriticalitySuccessImportance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// locks the variable var with respect to parallel computation, evaluates expr, then releases var.
        /// https://reference.wolfram.com/language/ref/CriticalSection.html
        ///</summary>
        corewolf::engine *CriticalSection(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CriticalSection[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// locks all variables vari simultaneously.
        /// https://reference.wolfram.com/language/ref/CriticalSection.html
        ///</summary>
        corewolf::engine *CriticalSection(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CriticalSection[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the vector cross product of a and b.
        /// https://reference.wolfram.com/language/ref/Cross.html
        ///</summary>
        corewolf::engine *Cross(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Cross[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a net layer that computes the cross-entropy loss by comparing input class probability vectors with indices representing the target class.
        /// https://reference.wolfram.com/language/ref/CrossEntropyLossLayer.html
        ///</summary>
        corewolf::engine *CrossEntropyLossLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CrossEntropyLossLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a count of the number of times a ray starting from the point p crosses the closed curve contour.
        /// https://reference.wolfram.com/language/ref/CrossingCount.html
        ///</summary>
        corewolf::engine *CrossingCount(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CrossingCount[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a binary image in which white pixels correspond to the zero crossings in image.
        /// https://reference.wolfram.com/language/ref/CrossingDetect.html
        ///</summary>
        corewolf::engine *CrossingDetect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CrossingDetect[" + arg0 + "]", name);
        }

        ///< summary>
        /// treats values in image that are smaller in absolute value than delta as zero.
        /// https://reference.wolfram.com/language/ref/CrossingDetect.html
        ///</summary>
        corewolf::engine *CrossingDetect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CrossingDetect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a Polygon representing all points for which a ray from the point in any direction in the plane crosses the line segments {p1,p2},…,{pn-1,pn},{pn,p1} an odd number of times.
        /// https://reference.wolfram.com/language/ref/CrossingPolygon.html
        ///</summary>
        corewolf::engine *CrossingPolygon(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CrossingPolygon[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a Polygon from the line segments {p11,p12},…,{p21,p22},….
        /// https://reference.wolfram.com/language/ref/CrossingPolygon.html
        ///</summary>
        corewolf::engine *CrossingPolygon(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CrossingPolygon[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a matrix whose elements are 1 in a centered cross-shaped region that extends r positions along each index direction, and are 0 otherwise.
        /// https://reference.wolfram.com/language/ref/CrossMatrix.html
        ///</summary>
        corewolf::engine *CrossMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CrossMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a w×w matrix containing a cross-shaped region of 1s.
        /// https://reference.wolfram.com/language/ref/CrossMatrix.html
        ///</summary>
        corewolf::engine *CrossMatrix(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CrossMatrix[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields an array whose elements are 1 in a centered cross-shaped region that extends ri positions in the i index direction.
        /// https://reference.wolfram.com/language/ref/CrossMatrix.html
        ///</summary>
        corewolf::engine *CrossMatrix(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CrossMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the cosecant of z.
        /// https://reference.wolfram.com/language/ref/Csc.html
        ///</summary>
        corewolf::engine *Csc(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Csc[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the hyperbolic cosecant of z.
        /// https://reference.wolfram.com/language/ref/Csch.html
        ///</summary>
        corewolf::engine *Csch(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Csch[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the solid region corresponding to the Boolean combination "op" of regions reg1,reg2,….
        /// https://reference.wolfram.com/language/ref/CSGRegion.html
        ///</summary>
        corewolf::engine *CSGRegion(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CSGRegion[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if the region reg is a valid CSGRegion const std::string &and False otherwise.
        /// https://reference.wolfram.com/language/ref/CSGRegionQ.html
        ///</summary>
        corewolf::engine *CSGRegionQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CSGRegionQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the tree expression representing the CSG region reg.
        /// https://reference.wolfram.com/language/ref/CSGRegionTree.html
        ///</summary>
        corewolf::engine *CSGRegionTree(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CSGRegionTree[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a net layer that computes the connectionist temporal classification loss by comparing a sequence of class probability vectors with a sequence of indices representing the target classes.
        /// https://reference.wolfram.com/language/ref/CTCLossLayer.html
        ///</summary>
        corewolf::engine *CTCLossLayer(const std::string &name = "")
        {
            return this->execute("CTCLossLayer[]", name);
        }

        ///< summary>
        /// represents a regular cube centered at the origin with unit edge length.
        /// https://reference.wolfram.com/language/ref/Cube.html
        ///</summary>
        corewolf::engine *Cube(const std::string &name = "")
        {
            return this->execute("Cube[]", name);
        }

        ///< summary>
        /// represents a cube with edge length l.
        /// https://reference.wolfram.com/language/ref/Cube.html
        ///</summary>
        corewolf::engine *Cube(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Cube[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a cube rotated by an angle θ with respect to the z axis and angle ϕ with respect to the y axis.
        /// https://reference.wolfram.com/language/ref/Cube.html
        ///</summary>
        corewolf::engine *Cube(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Cube[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the real-valued cube root of x.
        /// https://reference.wolfram.com/language/ref/CubeRoot.html
        ///</summary>
        corewolf::engine *CubeRoot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CubeRoot[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a unit hypercube with its lower corner at pmin.
        /// https://reference.wolfram.com/language/ref/Cuboid.html
        ///</summary>
        corewolf::engine *Cuboid(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Cuboid[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an axis-aligned filled cuboid with lower corner pmin and upper corner pmax.
        /// https://reference.wolfram.com/language/ref/Cuboid.html
        ///</summary>
        corewolf::engine *Cuboid(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Cuboid[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the r cumulant of the distribution dist.
        /// https://reference.wolfram.com/language/ref/Cumulant.html
        ///</summary>
        corewolf::engine *Cumulant(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Cumulant[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the r formal cumulant.
        /// https://reference.wolfram.com/language/ref/Cumulant.html
        ///</summary>
        corewolf::engine *Cumulant(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Cumulant[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the cumulant-generating function for the distribution dist as a function of the variable t.
        /// https://reference.wolfram.com/language/ref/CumulantGeneratingFunction.html
        ///</summary>
        corewolf::engine *CumulantGeneratingFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CumulantGeneratingFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the cumulant-generating function for the multivariate distribution dist as a function of the variables t1, t2, … .
        /// https://reference.wolfram.com/language/ref/CumulantGeneratingFunction.html
        ///</summary>
        corewolf::engine *CumulantGeneratingFunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CumulantGeneratingFunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots the cumulative impact of the value of each feature in data on the result of model.
        /// https://reference.wolfram.com/language/ref/CumulativeFeatureImpactPlot.html
        ///</summary>
        corewolf::engine *CumulativeFeatureImpactPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CumulativeFeatureImpactPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// estimates the feature impacts using synthetic data.
        /// https://reference.wolfram.com/language/ref/CumulativeFeatureImpactPlot.html
        ///</summary>
        corewolf::engine *CumulativeFeatureImpactPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CumulativeFeatureImpactPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as x⌣y⌣….
        /// https://reference.wolfram.com/language/ref/Cup.html
        ///</summary>
        corewolf::engine *Cup(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Cup[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x≍y≍….
        /// https://reference.wolfram.com/language/ref/CupCap.html
        ///</summary>
        corewolf::engine *CupCap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CupCap[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the curl .
        /// https://reference.wolfram.com/language/ref/Curl.html
        ///</summary>
        corewolf::engine *Curl(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Curl[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the curl of the ××…× array f with respect to the -dimensional vector {x1,…,xn}.
        /// https://reference.wolfram.com/language/ref/Curl.html
        ///</summary>
        corewolf::engine *Curl(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Curl[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the curl in the coordinates chart.
        /// https://reference.wolfram.com/language/ref/Curl.html
        ///</summary>
        corewolf::engine *Curl(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Curl[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// attempts to convert the specified currency quantity to the specified target currency.
        /// https://reference.wolfram.com/language/ref/CurrencyConvert.html
        ///</summary>
        corewolf::engine *CurrencyConvert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CurrencyConvert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts to the target currency for the historical date specification.
        /// https://reference.wolfram.com/language/ref/CurrencyConvert.html
        ///</summary>
        corewolf::engine *CurrencyConvert(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CurrencyConvert[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the current date of the specified granularity type gran.
        /// https://reference.wolfram.com/language/ref/CurrentDate.html
        ///</summary>
        corewolf::engine *CurrentDate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CurrentDate[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the date of the given granularity that includes the specified date.
        /// https://reference.wolfram.com/language/ref/CurrentDate.html
        ///</summary>
        corewolf::engine *CurrentDate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CurrentDate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the instant corresponding to the current date.
        /// https://reference.wolfram.com/language/ref/CurrentDate.html
        ///</summary>
        corewolf::engine *CurrentDate(const std::string &name = "")
        {
            return this->execute("CurrentDate[]", name);
        }

        ///< summary>
        /// returns the current image captured from a connected camera.
        /// https://reference.wolfram.com/language/ref/CurrentImage.html
        ///</summary>
        corewolf::engine *CurrentImage(const std::string &name = "")
        {
            return this->execute("CurrentImage[]", name);
        }

        ///< summary>
        /// returns n sequential image frames as a list.
        /// https://reference.wolfram.com/language/ref/CurrentImage.html
        ///</summary>
        corewolf::engine *CurrentImage(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CurrentImage[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns an image captured from the portion of the notebook nb that appears on your screen.
        /// https://reference.wolfram.com/language/ref/CurrentNotebookImage.html
        ///</summary>
        corewolf::engine *CurrentNotebookImage(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CurrentNotebookImage[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns an image captured from the notebook in which the function is evaluated.
        /// https://reference.wolfram.com/language/ref/CurrentNotebookImage.html
        ///</summary>
        corewolf::engine *CurrentNotebookImage(const std::string &name = "")
        {
            return this->execute("CurrentNotebookImage[]", name);
        }

        ///< summary>
        /// returns an image captured from all current display screens on your computer.
        /// https://reference.wolfram.com/language/ref/CurrentScreenImage.html
        ///</summary>
        corewolf::engine *CurrentScreenImage(const std::string &name = "")
        {
            return this->execute("CurrentScreenImage[]", name);
        }

        ///< summary>
        /// returns an image captured from display screen n.
        /// https://reference.wolfram.com/language/ref/CurrentScreenImage.html
        ///</summary>
        corewolf::engine *CurrentScreenImage(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CurrentScreenImage[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the specified rectangle from the image of all current display screens.
        /// https://reference.wolfram.com/language/ref/CurrentScreenImage.html
        ///</summary>
        corewolf::engine *CurrentScreenImage(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CurrentScreenImage[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the current value of item at a location in the Wolfram System and interface.
        /// https://reference.wolfram.com/language/ref/CurrentValue.html
        ///</summary>
        corewolf::engine *CurrentValue(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CurrentValue[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the current value for the feature of item specified by spec.
        /// https://reference.wolfram.com/language/ref/CurrentValue.html
        ///</summary>
        corewolf::engine *CurrentValue(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("CurrentValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the current value of item associated with the const std::string &obj.
        /// https://reference.wolfram.com/language/ref/CurrentValue.html
        ///</summary>
        corewolf::engine *CurrentValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CurrentValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of the function f of n arguments so that CurryApplied[f,n][x1]…[xn] is equivalent to f[x1,…,xn].
        /// https://reference.wolfram.com/language/ref/CurryApplied.html
        ///</summary>
        corewolf::engine *CurryApplied(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CurryApplied[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of CurryApplied that can be applied to a function to represent an operator form with n arguments.
        /// https://reference.wolfram.com/language/ref/CurryApplied.html
        ///</summary>
        corewolf::engine *CurryApplied(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CurryApplied[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an operator form of the function f of n arguments so that CurryApplied[f,{i1,…,in}][x1]…[xn] is equivalent to f[xi1,…,xin].
        /// https://reference.wolfram.com/language/ref/CurryApplied.html
        ///</summary>
        corewolf::engine *CurryApplied(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CurryApplied[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// applies a mean curvature flow filter to image.
        /// https://reference.wolfram.com/language/ref/CurvatureFlowFilter.html
        ///</summary>
        corewolf::engine *CurvatureFlowFilter(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CurvatureFlowFilter[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies the amount of curvature flow time t to be applied.
        /// https://reference.wolfram.com/language/ref/CurvatureFlowFilter.html
        ///</summary>
        corewolf::engine *CurvatureFlowFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("CurvatureFlowFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies the curvature flow with a modified conductance term parametrized by k.
        /// https://reference.wolfram.com/language/ref/CurvatureFlowFilter.html
        ///</summary>
        corewolf::engine *CurvatureFlowFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CurvatureFlowFilter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the cycle graph with n vertices .
        /// https://reference.wolfram.com/language/ref/CycleGraph.html
        ///</summary>
        corewolf::engine *CycleGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CycleGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// constructs the cycle index monomial of the permutation perm in the variables xi.
        /// https://reference.wolfram.com/language/ref/CycleIndexPolynomial.html
        ///</summary>
        corewolf::engine *CycleIndexPolynomial(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CycleIndexPolynomial[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a permutation with disjoint cycles cyci.
        /// https://reference.wolfram.com/language/ref/Cycles.html
        ///</summary>
        corewolf::engine *Cycles(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Cycles[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the cyclic group of degree n.
        /// https://reference.wolfram.com/language/ref/CyclicGroup.html
        ///</summary>
        corewolf::engine *CyclicGroup(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("CyclicGroup[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the n cyclotomic polynomial in x.
        /// https://reference.wolfram.com/language/ref/Cyclotomic.html
        ///</summary>
        corewolf::engine *Cyclotomic(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Cyclotomic[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a cylinder of radius r around the line from (x1,y1,z1) to (x2,y2,z2).
        /// https://reference.wolfram.com/language/ref/Cylinder.html
        ///</summary>
        corewolf::engine *Cylinder(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Cylinder[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a cylinder of radius 1.
        /// https://reference.wolfram.com/language/ref/Cylinder.html
        ///</summary>
        corewolf::engine *Cylinder(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Cylinder[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds a decomposition of the region represented by the statement expr into cylindrical parts whose directions correspond to the successive xi.
        /// https://reference.wolfram.com/language/ref/CylindricalDecomposition.html
        ///</summary>
        corewolf::engine *CylindricalDecomposition(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("CylindricalDecomposition[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds a decomposition of the result of applying the topological operation op to the region represented by the statement expr.
        /// https://reference.wolfram.com/language/ref/CylindricalDecomposition.html
        ///</summary>
        corewolf::engine *CylindricalDecomposition(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CylindricalDecomposition[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a cylindrical algebraic formula in x1,x2,….
        /// https://reference.wolfram.com/language/ref/CylindricalDecompositionFunction.html
        ///</summary>
        corewolf::engine *CylindricalDecompositionFunction(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("CylindricalDecompositionFunction[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the partial derivative .
        /// https://reference.wolfram.com/language/ref/D.html
        ///</summary>
        corewolf::engine *D(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("D[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the multiple derivative .
        /// https://reference.wolfram.com/language/ref/D.html
        ///</summary>
        corewolf::engine *D(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the partial derivative .
        /// https://reference.wolfram.com/language/ref/D.html
        ///</summary>
        corewolf::engine *D(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("D[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the multiple partial derivative .
        /// https://reference.wolfram.com/language/ref/D.html
        ///</summary>
        corewolf::engine *D(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a Dagum distribution with shape parameters p and a and scale parameter b.
        /// https://reference.wolfram.com/language/ref/DagumDistribution.html
        ///</summary>
        corewolf::engine *DagumDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DagumDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the dam entity.
        /// https://reference.wolfram.com/language/ref/DamData.html
        ///</summary>
        corewolf::engine *DamData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DamData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified dam entities.
        /// https://reference.wolfram.com/language/ref/DamData.html
        ///</summary>
        corewolf::engine *DamData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DamData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/DamData.html
        ///</summary>
        corewolf::engine *DamData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DamData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Damerau–Levenshtein distance between strings, vectors or biomolecular sequences u and v.
        /// https://reference.wolfram.com/language/ref/DamerauLevenshteinDistance.html
        ///</summary>
        corewolf::engine *DamerauLevenshteinDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DamerauLevenshteinDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a darker version of the specified color.
        /// https://reference.wolfram.com/language/ref/Darker.html
        ///</summary>
        corewolf::engine *Darker(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Darker[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a version of the specified color darkened by a fraction f.
        /// https://reference.wolfram.com/language/ref/Darker.html
        ///</summary>
        corewolf::engine *Darker(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Darker[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a two-dimensional graphics directive specifying that lines that follow are to be drawn dashed, with successive segments of lengths r1, r2, … (repeated cyclically). The ri are given as a fraction of the total width of the graph.
        /// https://reference.wolfram.com/language/ref/Dashing.html
        ///</summary>
        corewolf::engine *Dashing(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Dashing[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// is equivalent to Dashing[{r,r}].
        /// https://reference.wolfram.com/language/ref/Dashing.html
        ///</summary>
        corewolf::engine *Dashing(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Dashing[" + arg0 + "]", name);
        }

        ///< summary>
        /// offsets the dashes by offset.
        /// https://reference.wolfram.com/language/ref/Dashing.html
        ///</summary>
        corewolf::engine *Dashing(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Dashing[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sets the CapForm for individual dashes to capform.
        /// https://reference.wolfram.com/language/ref/Dashing.html
        ///</summary>
        corewolf::engine *Dashing(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Dashing[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// activates a connection to the database db.
        /// https://reference.wolfram.com/language/ref/DatabaseConnect.html
        ///</summary>
        corewolf::engine *DatabaseConnect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DatabaseConnect[" + arg0 + "]", name);
        }

        ///< summary>
        /// deactivates a connection to the database db.
        /// https://reference.wolfram.com/language/ref/DatabaseDisconnect.html
        ///</summary>
        corewolf::engine *DatabaseDisconnect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DatabaseDisconnect[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a reference to a local file-based SQL database.
        /// https://reference.wolfram.com/language/ref/DatabaseReference.html
        ///</summary>
        corewolf::engine *DatabaseReference(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DatabaseReference[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a databin in the Wolfram Data Drop.
        /// https://reference.wolfram.com/language/ref/Databin.html
        ///</summary>
        corewolf::engine *Databin(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Databin[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the first n entries in a databin.
        /// https://reference.wolfram.com/language/ref/Databin.html
        ///</summary>
        corewolf::engine *Databin(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Databin[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents entries m through n in a databin, with negative numbers counting from the end.
        /// https://reference.wolfram.com/language/ref/Databin.html
        ///</summary>
        corewolf::engine *Databin(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Databin[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents only elements with keys keyi within each entry in a databin.
        /// https://reference.wolfram.com/language/ref/Databin.html
        ///</summary>
        corewolf::engine *Databin(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Databin[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// adds the specified data to a databin.
        /// https://reference.wolfram.com/language/ref/DatabinAdd.html
        ///</summary>
        corewolf::engine *DatabinAdd(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DatabinAdd[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of databins associated with the currently connected user.
        /// https://reference.wolfram.com/language/ref/Databins.html
        ///</summary>
        corewolf::engine *Databins(const std::string &name = "")
        {
            return this->execute("Databins[]", name);
        }

        ///< summary>
        /// submits the specified data to be added to the databin bin asynchronously.
        /// https://reference.wolfram.com/language/ref/DatabinSubmit.html
        ///</summary>
        corewolf::engine *DatabinSubmit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DatabinSubmit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// bulk uploads all the entries entryi to a databin.
        /// https://reference.wolfram.com/language/ref/DatabinUpload.html
        ///</summary>
        corewolf::engine *DatabinUpload(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DatabinUpload[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// bulk uploads all entries in an event series to a databin.
        /// https://reference.wolfram.com/language/ref/DatabinUpload.html
        ///</summary>
        corewolf::engine *DatabinUpload(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DatabinUpload[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a probability distribution of type ddist, estimated from a set of data.
        /// https://reference.wolfram.com/language/ref/DataDistribution.html
        ///</summary>
        corewolf::engine *DataDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DataDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a structured dataset based on a hierarchy of lists and associations.
        /// https://reference.wolfram.com/language/ref/Dataset.html
        ///</summary>
        corewolf::engine *Dataset(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Dataset[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a data structure.
        /// https://reference.wolfram.com/language/ref/DataStructure.html
        ///</summary>
        corewolf::engine *DataStructure(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DataStructure[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if ds is a valid data structure and False otherwise.
        /// https://reference.wolfram.com/language/ref/DataStructureQ.html
        ///</summary>
        corewolf::engine *DataStructureQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DataStructureQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if ds is a valid data structure of the specified type and False otherwise.
        /// https://reference.wolfram.com/language/ref/DataStructureQ.html
        ///</summary>
        corewolf::engine *DataStructureQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DataStructureQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the earliest and latest of the datei.
        /// https://reference.wolfram.com/language/ref/DateBounds.html
        ///</summary>
        corewolf::engine *DateBounds(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DateBounds[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the first and last dates in the time series tseries.
        /// https://reference.wolfram.com/language/ref/DateBounds.html
        ///</summary>
        corewolf::engine *DateBounds(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DateBounds[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the endpoints of interval in the specified granularity gran.
        /// https://reference.wolfram.com/language/ref/DateBounds.html
        ///</summary>
        corewolf::engine *DateBounds(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DateBounds[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the const std::string &obj associated with a particular year.
        /// https://reference.wolfram.com/language/ref/Dated.html
        ///</summary>
        corewolf::engine *Dated(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Dated[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the number of days from date1 to date2.
        /// https://reference.wolfram.com/language/ref/DateDifference.html
        ///</summary>
        corewolf::engine *DateDifference(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DateDifference[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the difference between date1 and date2 in the specified unit.
        /// https://reference.wolfram.com/language/ref/DateDifference.html
        ///</summary>
        corewolf::engine *DateDifference(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DateDifference[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the difference as a list with elements corresponding to the successive "uniti".
        /// https://reference.wolfram.com/language/ref/DateDifference.html
        ///</summary>
        corewolf::engine *DateDifference(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("DateDifference[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents the specified unit at a specific date.
        /// https://reference.wolfram.com/language/ref/DatedUnit.html
        ///</summary>
        corewolf::engine *DatedUnit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DatedUnit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// plots a histogram of the dates datei.
        /// https://reference.wolfram.com/language/ref/DateHistogram.html
        ///</summary>
        corewolf::engine *DateHistogram(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DateHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots a histogram with bin width specification bspec.
        /// https://reference.wolfram.com/language/ref/DateHistogram.html
        ///</summary>
        corewolf::engine *DateHistogram(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DateHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// plots a histogram with bin heights computed according to the specification hspec.
        /// https://reference.wolfram.com/language/ref/DateHistogram.html
        ///</summary>
        corewolf::engine *DateHistogram(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DateHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the continuous interval of time between start and end.
        /// https://reference.wolfram.com/language/ref/DateInterval.html
        ///</summary>
        corewolf::engine *DateInterval(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DateInterval[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents an interval of dates with calendar granularity gran.
        /// https://reference.wolfram.com/language/ref/DateInterval.html
        ///</summary>
        corewolf::engine *DateInterval(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DateInterval[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the union of intervals start1 to end1, start2 to end2, ….
        /// https://reference.wolfram.com/language/ref/DateInterval.html
        ///</summary>
        corewolf::engine *DateInterval(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DateInterval[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the date interval from the initial to final instants of the granular date const std::string &gdate.
        /// https://reference.wolfram.com/language/ref/DateInterval.html
        ///</summary>
        corewolf::engine *DateInterval(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DateInterval[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the current local date and time in the form {year,month,day,hour,minute,second}.
        /// https://reference.wolfram.com/language/ref/DateList.html
        ///</summary>
        corewolf::engine *DateList(const std::string &name = "")
        {
            return this->execute("DateList[]", name);
        }

        ///< summary>
        /// gives a date list corresponding to the given date specification.
        /// https://reference.wolfram.com/language/ref/DateList.html
        ///</summary>
        corewolf::engine *DateList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DateList[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes a log plot with values vi at a sequence of dates.
        /// https://reference.wolfram.com/language/ref/DateListLogPlot.html
        ///</summary>
        corewolf::engine *DateListLogPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DateListLogPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a log plot with dates at equal intervals specified by datespec.
        /// https://reference.wolfram.com/language/ref/DateListLogPlot.html
        ///</summary>
        corewolf::engine *DateListLogPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DateListLogPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// plots the time series tseries.
        /// https://reference.wolfram.com/language/ref/DateListLogPlot.html
        ///</summary>
        corewolf::engine *DateListLogPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DateListLogPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots data from all the datai.
        /// https://reference.wolfram.com/language/ref/DateListLogPlot.html
        ///</summary>
        corewolf::engine *DateListLogPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DateListLogPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots points with values vi at a sequence of dates.
        /// https://reference.wolfram.com/language/ref/DateListPlot.html
        ///</summary>
        corewolf::engine *DateListPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("DateListPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// plots points with dates at equal intervals specified by datespec.
        /// https://reference.wolfram.com/language/ref/DateListPlot.html
        ///</summary>
        corewolf::engine *DateListPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DateListPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// plots the time series tseries.
        /// https://reference.wolfram.com/language/ref/DateListPlot.html
        ///</summary>
        corewolf::engine *DateListPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DateListPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots data from all the datai.
        /// https://reference.wolfram.com/language/ref/DateListPlot.html
        ///</summary>
        corewolf::engine *DateListPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DateListPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots the values vi in steps at a sequence of dates.
        /// https://reference.wolfram.com/language/ref/DateListStepPlot.html
        ///</summary>
        corewolf::engine *DateListStepPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DateListStepPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots the values vi in steps with dates at equal intervals specified by datespec.
        /// https://reference.wolfram.com/language/ref/DateListStepPlot.html
        ///</summary>
        corewolf::engine *DateListStepPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DateListStepPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// plots the time series tseries.
        /// https://reference.wolfram.com/language/ref/DateListStepPlot.html
        ///</summary>
        corewolf::engine *DateListStepPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DateListStepPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots data from all the datai.
        /// https://reference.wolfram.com/language/ref/DateListStepPlot.html
        ///</summary>
        corewolf::engine *DateListStepPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DateListStepPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots using steps specified by step.
        /// https://reference.wolfram.com/language/ref/DateListStepPlot.html
        ///</summary>
        corewolf::engine *DateListStepPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DateListStepPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the current local date.
        /// https://reference.wolfram.com/language/ref/DateObject.html
        ///</summary>
        corewolf::engine *DateObject(const std::string &name = "")
        {
            return this->execute("DateObject[]", name);
        }

        ///< summary>
        /// gives a date const std::string &corresponding to the given date specification.
        /// https://reference.wolfram.com/language/ref/DateObject.html
        ///</summary>
        corewolf::engine *DateObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DateObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the date const std::string &of calendar granularity gran that includes the reference date rdate.
        /// https://reference.wolfram.com/language/ref/DateObject.html
        ///</summary>
        corewolf::engine *DateObject(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DateObject[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if expr is a DateObject with valid arguments, and False otherwise.
        /// https://reference.wolfram.com/language/ref/DateObjectQ.html
        ///</summary>
        corewolf::engine *DateObjectQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DateObjectQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if the calendar dates date1 and date2 overlap, and False otherwise.
        /// https://reference.wolfram.com/language/ref/DateOverlapsQ.html
        ///</summary>
        corewolf::engine *DateOverlapsQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DateOverlapsQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the characters of a date with elements of type "ei" in StringExpression.
        /// https://reference.wolfram.com/language/ref/DatePattern.html
        ///</summary>
        corewolf::engine *DatePattern(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DatePattern[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// allows separators that match the string expression sep.
        /// https://reference.wolfram.com/language/ref/DatePattern.html
        ///</summary>
        corewolf::engine *DatePattern(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DatePattern[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the date n days after date.
        /// https://reference.wolfram.com/language/ref/DatePlus.html
        ///</summary>
        corewolf::engine *DatePlus(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DatePlus[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the date n calendar steps after date.
        /// https://reference.wolfram.com/language/ref/DatePlus.html
        ///</summary>
        corewolf::engine *DatePlus(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DatePlus[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a date offset by ni steps of each specified size.
        /// https://reference.wolfram.com/language/ref/DatePlus.html
        ///</summary>
        corewolf::engine *DatePlus(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("DatePlus[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the date n days after the current date.
        /// https://reference.wolfram.com/language/ref/DatePlus.html
        ///</summary>
        corewolf::engine *DatePlus(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DatePlus[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives all dates in the range from date1 to date2.
        /// https://reference.wolfram.com/language/ref/DateRange.html
        ///</summary>
        corewolf::engine *DateRange(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DateRange[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the dates in the range from date1 to date2 that are increment apart.
        /// https://reference.wolfram.com/language/ref/DateRange.html
        ///</summary>
        corewolf::engine *DateRange(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DateRange[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the canonical mapping of continuous dates and times to a quantitative scale.
        /// https://reference.wolfram.com/language/ref/DateScale.html
        ///</summary>
        corewolf::engine *DateScale(const std::string &name = "")
        {
            return this->execute("DateScale[]", name);
        }

        ///< summary>
        /// picks out all dates datei of a list for which crit[datei] is True.
        /// https://reference.wolfram.com/language/ref/DateSelect.html
        ///</summary>
        corewolf::engine *DateSelect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DateSelect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of DateSelect that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/DateSelect.html
        ///</summary>
        corewolf::engine *DateSelect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DateSelect[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a string representing the complete current local date and time.
        /// https://reference.wolfram.com/language/ref/DateString.html
        ///</summary>
        corewolf::engine *DateString(const std::string &name = "")
        {
            return this->execute("DateString[]", name);
        }

        ///< summary>
        /// gives a string corresponding to the given date specification.
        /// https://reference.wolfram.com/language/ref/DateString.html
        ///</summary>
        corewolf::engine *DateString(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DateString[" + arg0 + "]", name);
        }

        ///< summary>
        /// concatenates the specified elements in the order given.
        /// https://reference.wolfram.com/language/ref/DateString.html
        ///</summary>
        corewolf::engine *DateString(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DateString[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives elements specified by the date format fmt for the date or time specification date.
        /// https://reference.wolfram.com/language/ref/DateString.html
        ///</summary>
        corewolf::engine *DateString(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DateString[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified element of the current date and time.
        /// https://reference.wolfram.com/language/ref/DateValue.html
        ///</summary>
        corewolf::engine *DateValue(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DateValue[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of the specified elements of the current date and time.
        /// https://reference.wolfram.com/language/ref/DateValue.html
        ///</summary>
        corewolf::engine *DateValue(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DateValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the specified element of the specified date.
        /// https://reference.wolfram.com/language/ref/DateValue.html
        ///</summary>
        corewolf::engine *DateValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DateValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the result in the specified form.
        /// https://reference.wolfram.com/language/ref/DateValue.html
        ///</summary>
        corewolf::engine *DateValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DateValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns True if the calendar date date2 is entirely contained within date1, and False otherwise.
        /// https://reference.wolfram.com/language/ref/DateWithinQ.html
        ///</summary>
        corewolf::engine *DateWithinQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DateWithinQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Daubechies wavelet of order 2.
        /// https://reference.wolfram.com/language/ref/DaubechiesWavelet.html
        ///</summary>
        corewolf::engine *DaubechiesWavelet(const std::string &name = "")
        {
            return this->execute("DaubechiesWavelet[]", name);
        }

        ///< summary>
        /// represents a Daubechies wavelet of order n.
        /// https://reference.wolfram.com/language/ref/DaubechiesWavelet.html
        ///</summary>
        corewolf::engine *DaubechiesWavelet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DaubechiesWavelet[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Davis distribution with scale parameter b, shape parameter n, and location parameter μ.
        /// https://reference.wolfram.com/language/ref/DavisDistribution.html
        ///</summary>
        corewolf::engine *DavisDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DavisDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Dawson integral .
        /// https://reference.wolfram.com/language/ref/DawsonF.html
        ///</summary>
        corewolf::engine *DawsonF(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DawsonF[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number of days from date1 to date2.
        /// https://reference.wolfram.com/language/ref/DayCount.html
        ///</summary>
        corewolf::engine *DayCount(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DayCount[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the number of days of the specified daytype from date1 to date2.
        /// https://reference.wolfram.com/language/ref/DayCount.html
        ///</summary>
        corewolf::engine *DayCount(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DayCount[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a two-dimensional GeoGraphics primitive that represents the half of the Earth that is currently in daylight.
        /// https://reference.wolfram.com/language/ref/DayHemisphere.html
        ///</summary>
        corewolf::engine *DayHemisphere(const std::string &name = "")
        {
            return this->execute("DayHemisphere[]", name);
        }

        ///< summary>
        /// represents the daylight half of the Earth for the specified date.
        /// https://reference.wolfram.com/language/ref/DayHemisphere.html
        ///</summary>
        corewolf::engine *DayHemisphere(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DayHemisphere[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if it is currently daylight from the user's location.
        /// https://reference.wolfram.com/language/ref/DaylightQ.html
        ///</summary>
        corewolf::engine *DaylightQ(const std::string &name = "")
        {
            return this->execute("DaylightQ[]", name);
        }

        ///< summary>
        /// gives True if it is daylight from the user's location on the specified datespec.
        /// https://reference.wolfram.com/language/ref/DaylightQ.html
        ///</summary>
        corewolf::engine *DaylightQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DaylightQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if it is daylight from the specified locationspec on the specified datespec.
        /// https://reference.wolfram.com/language/ref/DaylightQ.html
        ///</summary>
        corewolf::engine *DaylightQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DaylightQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if it is daylight from the specified locations and dates.
        /// https://reference.wolfram.com/language/ref/DaylightQ.html
        ///</summary>
        corewolf::engine *DaylightQ(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DaylightQ[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives True if it is daylight from the specified locationspec on the specified datespec taking inclusionspec into account.
        /// https://reference.wolfram.com/language/ref/DaylightQ.html
        ///</summary>
        corewolf::engine *DaylightQ(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DaylightQ[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns True if the date matches the daytype specification and returns False otherwise.
        /// https://reference.wolfram.com/language/ref/DayMatchQ.html
        ///</summary>
        corewolf::engine *DayMatchQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DayMatchQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the current day of the week.
        /// https://reference.wolfram.com/language/ref/DayName.html
        ///</summary>
        corewolf::engine *DayName(const std::string &name = "")
        {
            return this->execute("DayName[]", name);
        }

        ///< summary>
        /// gives the day of the week for the given date.
        /// https://reference.wolfram.com/language/ref/DayName.html
        ///</summary>
        corewolf::engine *DayName(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DayName[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a one-dimensional GeoGraphics primitive that represents the separation line between the halves of the Earth currently in daytime and nighttime.
        /// https://reference.wolfram.com/language/ref/DayNightTerminator.html
        ///</summary>
        corewolf::engine *DayNightTerminator(const std::string &name = "")
        {
            return this->execute("DayNightTerminator[]", name);
        }

        ///< summary>
        /// represents the separation line between day and night for the specified date.
        /// https://reference.wolfram.com/language/ref/DayNightTerminator.html
        ///</summary>
        corewolf::engine *DayNightTerminator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DayNightTerminator[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the date n days away from date.
        /// https://reference.wolfram.com/language/ref/DayPlus.html
        ///</summary>
        corewolf::engine *DayPlus(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DayPlus[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the date that is n days of daytype away from date.
        /// https://reference.wolfram.com/language/ref/DayPlus.html
        ///</summary>
        corewolf::engine *DayPlus(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DayPlus[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the dates in the range from date1 to date2.
        /// https://reference.wolfram.com/language/ref/DayRange.html
        ///</summary>
        corewolf::engine *DayRange(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DayRange[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the dates in the range from date1 to date2 that are of the specified daytype.
        /// https://reference.wolfram.com/language/ref/DayRange.html
        ///</summary>
        corewolf::engine *DayRange(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DayRange[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// rounds date to the nearest day of daytype, using the next-day rounding convention.
        /// https://reference.wolfram.com/language/ref/DayRound.html
        ///</summary>
        corewolf::engine *DayRound(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DayRound[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// rounds date to the nearest day of daytype, using rounding.
        /// https://reference.wolfram.com/language/ref/DayRound.html
        ///</summary>
        corewolf::engine *DayRound(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DayRound[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the n-dimensional De Bruijn graph with m symbols.
        /// https://reference.wolfram.com/language/ref/DeBruijnGraph.html
        ///</summary>
        corewolf::engine *DeBruijnGraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeBruijnGraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the De Bruijn graph with connectivity given by type.
        /// https://reference.wolfram.com/language/ref/DeBruijnGraph.html
        ///</summary>
        corewolf::engine *DeBruijnGraph(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DeBruijnGraph[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a de Bruijn sequence on the elements in list taken n at a time.
        /// https://reference.wolfram.com/language/ref/DeBruijnSequence.html
        ///</summary>
        corewolf::engine *DeBruijnSequence(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeBruijnSequence[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields a string in which the first character has been made lowercase.
        /// https://reference.wolfram.com/language/ref/Decapitalize.html
        ///</summary>
        corewolf::engine *Decapitalize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Decapitalize[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints with approximate real numbers in expr always given in decimal form, without scientific notation.
        /// https://reference.wolfram.com/language/ref/DecimalForm.html
        ///</summary>
        corewolf::engine *DecimalForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DecimalForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints with approximate real numbers given in decimal form to n-digit precision.
        /// https://reference.wolfram.com/language/ref/DecimalForm.html
        ///</summary>
        corewolf::engine *DecimalForm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DecimalForm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// prints with approximate real numbers having n digits, with f digits to the right of the decimal point.
        /// https://reference.wolfram.com/language/ref/DecimalForm.html
        ///</summary>
        corewolf::engine *DecimalForm(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DecimalForm[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// declares that Needs["context`"] should automatically be executed if a symbol with any of the specified names is ever used.
        /// https://reference.wolfram.com/language/ref/DeclarePackage.html
        ///</summary>
        corewolf::engine *DeclarePackage(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DeclarePackage[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// decomposes a polynomial, if possible, into a composition of simpler polynomials.
        /// https://reference.wolfram.com/language/ref/Decompose.html
        ///</summary>
        corewolf::engine *Decompose(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Decompose[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a trainable deconvolutional net layer having n output channels and using kernels of size sz to compute the deconvolution.
        /// https://reference.wolfram.com/language/ref/DeconvolutionLayer.html
        ///</summary>
        corewolf::engine *DeconvolutionLayer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeconvolutionLayer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a layer performing one-dimensional deconvolutions with kernels of size s.
        /// https://reference.wolfram.com/language/ref/DeconvolutionLayer.html
        ///</summary>
        corewolf::engine *DeconvolutionLayer(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DeconvolutionLayer[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// includes options for initial kernels and other parameters.
        /// https://reference.wolfram.com/language/ref/DeconvolutionLayer.html
        ///</summary>
        corewolf::engine *DeconvolutionLayer(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DeconvolutionLayer[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// attempts to decrypt the encrypted const std::string &enc using the specified password.
        /// https://reference.wolfram.com/language/ref/Decrypt.html
        ///</summary>
        corewolf::engine *Decrypt(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Decrypt[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// interactively requests a password with which to try to decrypt obj.
        /// https://reference.wolfram.com/language/ref/Decrypt.html
        ///</summary>
        corewolf::engine *Decrypt(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Decrypt[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a decrypted version of a file, using the specified password.
        /// https://reference.wolfram.com/language/ref/DecryptFile.html
        ///</summary>
        corewolf::engine *DecryptFile(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DecryptFile[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a decrypted version of source, putting the result in target.
        /// https://reference.wolfram.com/language/ref/DecryptFile.html
        ///</summary>
        corewolf::engine *DecryptFile(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DecryptFile[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Dedekind eta modular elliptic function .
        /// https://reference.wolfram.com/language/ref/DedekindEta.html
        ///</summary>
        corewolf::engine *DedekindEta(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DedekindEta[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the deep space probe entity.
        /// https://reference.wolfram.com/language/ref/DeepSpaceProbeData.html
        ///</summary>
        corewolf::engine *DeepSpaceProbeData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeepSpaceProbeData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified deep space probe entities.
        /// https://reference.wolfram.com/language/ref/DeepSpaceProbeData.html
        ///</summary>
        corewolf::engine *DeepSpaceProbeData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeepSpaceProbeData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/DeepSpaceProbeData.html
        ///</summary>
        corewolf::engine *DeepSpaceProbeData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DeepSpaceProbeData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the default value for arguments of the function f obtained with a _. pattern object.
        /// https://reference.wolfram.com/language/ref/Default.html
        ///</summary>
        corewolf::engine *Default(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Default[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the default value to use when _. appears as the i argument of f.
        /// https://reference.wolfram.com/language/ref/Default.html
        ///</summary>
        corewolf::engine *Default(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Default[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the default value for the i argument out of a total of n arguments.
        /// https://reference.wolfram.com/language/ref/Default.html
        ///</summary>
        corewolf::engine *Default(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Default[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an OK button that closes a dialog, and is the default when  is pressed in the dialog.
        /// https://reference.wolfram.com/language/ref/DefaultButton.html
        ///</summary>
        corewolf::engine *DefaultButton(const std::string &name = "")
        {
            return this->execute("DefaultButton[]", name);
        }

        ///< summary>
        /// represents a button that is labeled OK, and whose action is to evaluate action.
        /// https://reference.wolfram.com/language/ref/DefaultButton.html
        ///</summary>
        corewolf::engine *DefaultButton(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DefaultButton[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses label as the label for the button.
        /// https://reference.wolfram.com/language/ref/DefaultButton.html
        ///</summary>
        corewolf::engine *DefaultButton(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DefaultButton[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of transformation rules corresponding to all default argument values (values for Default[f,…]) defined for the symbol f.
        /// https://reference.wolfram.com/language/ref/DefaultValues.html
        ///</summary>
        corewolf::engine *DefaultValues(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DefaultValues[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields an const std::string &that displays as the unevaluated form of expr, but that is evaluated if it is explicitly given as Wolfram Language input.
        /// https://reference.wolfram.com/language/ref/Defer.html
        ///</summary>
        corewolf::engine *Defer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Defer[" + arg0 + "]", name);
        }

        ///< summary>
        /// defines a custom input stream method with the specified name, allowing the Wolfram Language to call the stream functions fnamei for opening and reading from an input stream.
        /// https://reference.wolfram.com/language/ref/DefineInputStreamMethod.html
        ///</summary>
        corewolf::engine *DefineInputStreamMethod(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DefineInputStreamMethod[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// defines a custom output stream method with the specified name, allowing the Wolfram Language to call the stream functions for opening and writing to an output stream.
        /// https://reference.wolfram.com/language/ref/DefineOutputStreamMethod.html
        ///</summary>
        corewolf::engine *DefineOutputStreamMethod(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DefineOutputStreamMethod[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// defines a resource function that can be applied to arguments to give the same result as f[…].
        /// https://reference.wolfram.com/language/ref/DefineResourceFunction.html
        ///</summary>
        corewolf::engine *DefineResourceFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DefineResourceFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses name as the name of the resource function.
        /// https://reference.wolfram.com/language/ref/DefineResourceFunction.html
        ///</summary>
        corewolf::engine *DefineResourceFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DefineResourceFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// prints as the definitions given for a symbol.
        /// https://reference.wolfram.com/language/ref/Definition.html
        ///</summary>
        corewolf::engine *Definition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Definition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of vertex degrees for the vertices in the underlying simple graph of g.
        /// https://reference.wolfram.com/language/ref/DegreeCentrality.html
        ///</summary>
        corewolf::engine *DegreeCentrality(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DegreeCentrality[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of vertex in-degrees.
        /// https://reference.wolfram.com/language/ref/DegreeCentrality.html
        ///</summary>
        corewolf::engine *DegreeCentrality(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DegreeCentrality[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/DegreeCentrality.html
        ///</summary>
        corewolf::engine *DegreeCentrality(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DegreeCentrality[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a degree graph distribution with vertex degree dlist.
        /// https://reference.wolfram.com/language/ref/DegreeGraphDistribution.html
        ///</summary>
        corewolf::engine *DegreeGraphDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DegreeGraphDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the n smallest magnitude eigenvalues and eigenfunctions for the linear differential operator ℒ over the region Ω.
        /// https://reference.wolfram.com/language/ref/DEigensystem.html
        ///</summary>
        corewolf::engine *DEigensystem(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("DEigensystem[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the eigenvalues and eigenfunctions for solutions u of the time-dependent differential equations eqns.
        /// https://reference.wolfram.com/language/ref/DEigensystem.html
        ///</summary>
        corewolf::engine *DEigensystem(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("DEigensystem[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// gives the n smallest magnitude eigenvalues for the linear differential operator ℒ over the region Ω.
        /// https://reference.wolfram.com/language/ref/DEigenvalues.html
        ///</summary>
        corewolf::engine *DEigenvalues(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("DEigenvalues[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the eigenvalues for solutions u of the time-dependent differential equations eqns.
        /// https://reference.wolfram.com/language/ref/DEigenvalues.html
        ///</summary>
        corewolf::engine *DEigenvalues(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("DEigenvalues[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Del.html
        ///</summary>
        corewolf::engine *Del(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Del[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a MeshRegion representing the Delaunay mesh from the points p1, p2, ….
        /// https://reference.wolfram.com/language/ref/DelaunayMesh.html
        ///</summary>
        corewolf::engine *DelaunayMesh(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DelaunayMesh[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents an expression whose evaluation is delayed until its value is externally requested.
        /// https://reference.wolfram.com/language/ref/Delayed.html
        ///</summary>
        corewolf::engine *Delayed(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Delayed[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies that the result from evaluating expr should be given in format fmt.
        /// https://reference.wolfram.com/language/ref/Delayed.html
        ///</summary>
        corewolf::engine *Delayed(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Delayed[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies that the result should be given as a response of the form rform.
        /// https://reference.wolfram.com/language/ref/Delayed.html
        ///</summary>
        corewolf::engine *Delayed(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Delayed[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// deletes the element at position n in expr. If n is negative, the position is counted from the end.
        /// https://reference.wolfram.com/language/ref/Delete.html
        ///</summary>
        corewolf::engine *Delete(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Delete[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// deletes the part at position {i,j,…}.
        /// https://reference.wolfram.com/language/ref/Delete.html
        ///</summary>
        corewolf::engine *Delete(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Delete[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// deletes parts at several positions.
        /// https://reference.wolfram.com/language/ref/Delete.html
        ///</summary>
        corewolf::engine *Delete(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Delete[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents an operator form of Delete that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/Delete.html
        ///</summary>
        corewolf::engine *Delete(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Delete[" + arg0 + "]", name);
        }

        ///< summary>
        /// deletes all duplicates in runs of identical elements in list.
        /// https://reference.wolfram.com/language/ref/DeleteAdjacentDuplicates.html
        ///</summary>
        corewolf::engine *DeleteAdjacentDuplicates(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeleteAdjacentDuplicates[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies test to pairs of consecutive elements to determine whether they should be considered duplicates.
        /// https://reference.wolfram.com/language/ref/DeleteAdjacentDuplicates.html
        ///</summary>
        corewolf::engine *DeleteAdjacentDuplicates(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeleteAdjacentDuplicates[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list in which examplei that are considered anomalous have been dropped.
        /// https://reference.wolfram.com/language/ref/DeleteAnomalies.html
        ///</summary>
        corewolf::engine *DeleteAnomalies(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DeleteAnomalies[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// drops anomalies in data using the given AnomalyDetectorFunction[…] or LearnedDistribution[…].
        /// https://reference.wolfram.com/language/ref/DeleteAnomalies.html
        ///</summary>
        corewolf::engine *DeleteAnomalies(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeleteAnomalies[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces connected components adjacent to the border in a binary image image with background pixels.
        /// https://reference.wolfram.com/language/ref/DeleteBorderComponents.html
        ///</summary>
        corewolf::engine *DeleteBorderComponents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeleteBorderComponents[" + arg0 + "]", name);
        }

        ///< summary>
        /// removes all elements of expr that match pattern.
        /// https://reference.wolfram.com/language/ref/DeleteCases.html
        ///</summary>
        corewolf::engine *DeleteCases(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeleteCases[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// removes all parts of expr on levels specified by levelspec that match pattern.
        /// https://reference.wolfram.com/language/ref/DeleteCases.html
        ///</summary>
        corewolf::engine *DeleteCases(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DeleteCases[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// removes the first n parts of expr that match pattern.
        /// https://reference.wolfram.com/language/ref/DeleteCases.html
        ///</summary>
        corewolf::engine *DeleteCases(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("DeleteCases[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an operator form of DeleteCases that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/DeleteCases.html
        ///</summary>
        corewolf::engine *DeleteCases(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeleteCases[" + arg0 + "]", name);
        }

        ///< summary>
        /// deletes the specified channel from the channel broker server.
        /// https://reference.wolfram.com/language/ref/DeleteChannel.html
        ///</summary>
        corewolf::engine *DeleteChannel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeleteChannel[" + arg0 + "]", name);
        }

        ///< summary>
        /// deletes all the channeli.
        /// https://reference.wolfram.com/language/ref/DeleteChannel.html
        ///</summary>
        corewolf::engine *DeleteChannel(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DeleteChannel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// deletes the cloud expression identified by "name".
        /// https://reference.wolfram.com/language/ref/DeleteCloudExpression.html
        ///</summary>
        corewolf::engine *DeleteCloudExpression(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeleteCloudExpression[" + arg0 + "]", name);
        }

        ///< summary>
        /// deletes the specified directory.
        /// https://reference.wolfram.com/language/ref/DeleteDirectory.html
        ///</summary>
        corewolf::engine *DeleteDirectory(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeleteDirectory[" + arg0 + "]", name);
        }

        ///< summary>
        /// deletes all duplicates from list.
        /// https://reference.wolfram.com/language/ref/DeleteDuplicates.html
        ///</summary>
        corewolf::engine *DeleteDuplicates(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeleteDuplicates[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies test to pairs of elements to determine whether they should be considered duplicates.
        /// https://reference.wolfram.com/language/ref/DeleteDuplicates.html
        ///</summary>
        corewolf::engine *DeleteDuplicates(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeleteDuplicates[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// deletes those ei that yield duplicates in the list {f[e1],f[e2],…}.
        /// https://reference.wolfram.com/language/ref/DeleteDuplicatesBy.html
        ///</summary>
        corewolf::engine *DeleteDuplicatesBy(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeleteDuplicatesBy[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of DeleteDuplicatesBy that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/DeleteDuplicatesBy.html
        ///</summary>
        corewolf::engine *DeleteDuplicatesBy(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeleteDuplicatesBy[" + arg0 + "]", name);
        }

        ///< summary>
        /// removes all instances of elements ei from list.
        /// https://reference.wolfram.com/language/ref/DeleteElements.html
        ///</summary>
        corewolf::engine *DeleteElements(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DeleteElements[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// removes up to n instances of each ei from list.
        /// https://reference.wolfram.com/language/ref/DeleteElements.html
        ///</summary>
        corewolf::engine *DeleteElements(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeleteElements[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// deletes a file.
        /// https://reference.wolfram.com/language/ref/DeleteFile.html
        ///</summary>
        corewolf::engine *DeleteFile(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeleteFile[" + arg0 + "]", name);
        }

        ///< summary>
        /// deletes a list of files.
        /// https://reference.wolfram.com/language/ref/DeleteFile.html
        ///</summary>
        corewolf::engine *DeleteFile(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DeleteFile[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// drops elements with head Missing from a list.
        /// https://reference.wolfram.com/language/ref/DeleteMissing.html
        ///</summary>
        corewolf::engine *DeleteMissing(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeleteMissing[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies DeleteMissing to any lists or associations that occur within the first n levels of expr.
        /// https://reference.wolfram.com/language/ref/DeleteMissing.html
        ///</summary>
        corewolf::engine *DeleteMissing(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeleteMissing[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// considers an element at level n to be missing if Missing occurs within the first d levels of the element.
        /// https://reference.wolfram.com/language/ref/DeleteMissing.html
        ///</summary>
        corewolf::engine *DeleteMissing(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DeleteMissing[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// deletes the const std::string &obj.
        /// https://reference.wolfram.com/language/ref/DeleteObject.html
        ///</summary>
        corewolf::engine *DeleteObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeleteObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// deletes all the obji.
        /// https://reference.wolfram.com/language/ref/DeleteObject.html
        ///</summary>
        corewolf::engine *DeleteObject(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DeleteObject[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// deletes a permissions key, rendering it invalid.
        /// https://reference.wolfram.com/language/ref/DeletePermissionsKey.html
        ///</summary>
        corewolf::engine *DeletePermissionsKey(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeletePermissionsKey[" + arg0 + "]", name);
        }

        ///< summary>
        /// deletes several permissions keys.
        /// https://reference.wolfram.com/language/ref/DeletePermissionsKey.html
        ///</summary>
        corewolf::engine *DeletePermissionsKey(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DeletePermissionsKey[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// deletes the search index represented by the search index const std::string &obj.
        /// https://reference.wolfram.com/language/ref/DeleteSearchIndex.html
        ///</summary>
        corewolf::engine *DeleteSearchIndex(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeleteSearchIndex[" + arg0 + "]", name);
        }

        ///< summary>
        /// replaces small connected components in a binary image image with background pixels.
        /// https://reference.wolfram.com/language/ref/DeleteSmallComponents.html
        ///</summary>
        corewolf::engine *DeleteSmallComponents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeleteSmallComponents[" + arg0 + "]", name);
        }

        ///< summary>
        /// replaces components consisting of n or fewer elements.
        /// https://reference.wolfram.com/language/ref/DeleteSmallComponents.html
        ///</summary>
        corewolf::engine *DeleteSmallComponents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeleteSmallComponents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// deletes stopwords from a list of words.
        /// https://reference.wolfram.com/language/ref/DeleteStopwords.html
        ///</summary>
        corewolf::engine *DeleteStopwords(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeleteStopwords[" + arg0 + "]", name);
        }

        ///< summary>
        /// deletes stopwords from a list of strings.
        /// https://reference.wolfram.com/language/ref/DeleteStopwords.html
        ///</summary>
        corewolf::engine *DeleteStopwords(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DeleteStopwords[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a delimited sequence of elements of the specified form in Interpreter and related functions.
        /// https://reference.wolfram.com/language/ref/DelimitedSequence.html
        ///</summary>
        corewolf::engine *DelimitedSequence(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DelimitedSequence[" + arg0 + "]", name);
        }

        ///< summary>
        /// assumes a separator that matches sep.
        /// https://reference.wolfram.com/language/ref/DelimitedSequence.html
        ///</summary>
        corewolf::engine *DelimitedSequence(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DelimitedSequence[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// assumes left and right delimiters matching left and right, respectively.
        /// https://reference.wolfram.com/language/ref/DelimitedSequence.html
        ///</summary>
        corewolf::engine *DelimitedSequence(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DelimitedSequence[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// constructs a dendrogram from the hierarchical clustering of the elements e1, e2, ….
        /// https://reference.wolfram.com/language/ref/Dendrogram.html
        ///</summary>
        corewolf::engine *Dendrogram(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Dendrogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents ei using labels labeli in the constructed dendrogram.
        /// https://reference.wolfram.com/language/ref/Dendrogram.html
        ///</summary>
        corewolf::engine *Dendrogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Dendrogram[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// constructs an oriented dendrogram according to orientation.
        /// https://reference.wolfram.com/language/ref/Dendrogram.html
        ///</summary>
        corewolf::engine *Dendrogram(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Dendrogram[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// constructs the dendrogram corresponding to weighted tree tree.
        /// https://reference.wolfram.com/language/ref/Dendrogram.html
        ///</summary>
        corewolf::engine *Dendrogram(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Dendrogram[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the denominator of expr.
        /// https://reference.wolfram.com/language/ref/Denominator.html
        ///</summary>
        corewolf::engine *Denominator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Denominator[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots a density histogram of the values {xi,yi}.
        /// https://reference.wolfram.com/language/ref/DensityHistogram.html
        ///</summary>
        corewolf::engine *DensityHistogram(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DensityHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots a density histogram with bins specified by bspec.
        /// https://reference.wolfram.com/language/ref/DensityHistogram.html
        ///</summary>
        corewolf::engine *DensityHistogram(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DensityHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// plots a density histogram with bin densities computed according to the specification hspec.
        /// https://reference.wolfram.com/language/ref/DensityHistogram.html
        ///</summary>
        corewolf::engine *DensityHistogram(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("DensityHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// makes a density plot of f as a function of x and y.
        /// https://reference.wolfram.com/language/ref/DensityPlot.html
        ///</summary>
        corewolf::engine *DensityPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("DensityPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// takes the variables {x,y} to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/DensityPlot.html
        ///</summary>
        corewolf::engine *DensityPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DensityPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// makes a density plot of f as a function of x, y, and z.
        /// https://reference.wolfram.com/language/ref/DensityPlot3D.html
        ///</summary>
        corewolf::engine *DensityPlot3D(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("DensityPlot3D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// takes the variables to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/DensityPlot3D.html
        ///</summary>
        corewolf::engine *DensityPlot3D(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DensityPlot3D[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields a deployed version of expr in which elements such as Slider, InputField, Locator and Button are active, but general editing and selection is disabled.
        /// https://reference.wolfram.com/language/ref/Deploy.html
        ///</summary>
        corewolf::engine *Deploy(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Deploy[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the maximum number of indices needed to specify any part of expr, plus 1.
        /// https://reference.wolfram.com/language/ref/Depth.html
        ///</summary>
        corewolf::engine *Depth(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Depth[" + arg0 + "]", name);
        }

        ///< summary>
        /// performs a depth-first scan of the graph g starting at the vertex s and evaluates fi whenever "eventi" occurs.
        /// https://reference.wolfram.com/language/ref/DepthFirstScan.html
        ///</summary>
        corewolf::engine *DepthFirstScan(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("DepthFirstScan[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// performs a depth-first scan of the whole graph g.
        /// https://reference.wolfram.com/language/ref/DepthFirstScan.html
        ///</summary>
        corewolf::engine *DepthFirstScan(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DepthFirstScan[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/DepthFirstScan.html
        ///</summary>
        corewolf::engine *DepthFirstScan(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DepthFirstScan[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes the ni derivative of data at level i.
        /// https://reference.wolfram.com/language/ref/DerivativeFilter.html
        ///</summary>
        corewolf::engine *DerivativeFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DerivativeFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// computes the derivative at a Gaussian scale of standard deviation σ.
        /// https://reference.wolfram.com/language/ref/DerivativeFilter.html
        ///</summary>
        corewolf::engine *DerivativeFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DerivativeFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a load derivative term  with load derivative coefficient  and model variables vars.
        /// https://reference.wolfram.com/language/ref/DerivativePDETerm.html
        ///</summary>
        corewolf::engine *DerivativePDETerm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DerivativePDETerm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses model parameters pars.
        /// https://reference.wolfram.com/language/ref/DerivativePDETerm.html
        ///</summary>
        corewolf::engine *DerivativePDETerm(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DerivativePDETerm[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a derived key generated by GenerateDerivedKey.
        /// https://reference.wolfram.com/language/ref/DerivedKey.html
        ///</summary>
        corewolf::engine *DerivedKey(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DerivedKey[" + arg0 + "]", name);
        }

        ///< summary>
        /// constructs the design matrix for the linear model β0+β1 f1+β2 f2+….
        /// https://reference.wolfram.com/language/ref/DesignMatrix.html
        ///</summary>
        corewolf::engine *DesignMatrix(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("DesignMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// gives the determinant of the square matrix m.
        /// https://reference.wolfram.com/language/ref/Det.html
        ///</summary>
        corewolf::engine *Det(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Det[" + arg0 + "]", name);
        }

        ///< summary>
        /// closes the connection to a device and frees related resources.
        /// https://reference.wolfram.com/language/ref/DeviceClose.html
        ///</summary>
        corewolf::engine *DeviceClose(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeviceClose[" + arg0 + "]", name);
        }

        ///< summary>
        /// configures the specified device according to config.
        /// https://reference.wolfram.com/language/ref/DeviceConfigure.html
        ///</summary>
        corewolf::engine *DeviceConfigure(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeviceConfigure[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// executes the specified command on a device.
        /// https://reference.wolfram.com/language/ref/DeviceExecute.html
        ///</summary>
        corewolf::engine *DeviceExecute(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeviceExecute[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// executes the command with the parameters params.
        /// https://reference.wolfram.com/language/ref/DeviceExecute.html
        ///</summary>
        corewolf::engine *DeviceExecute(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DeviceExecute[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// initiates asynchronous execution of the specified command on a device, calling the handler function fun when an event occurs.
        /// https://reference.wolfram.com/language/ref/DeviceExecuteAsynchronous.html
        ///</summary>
        corewolf::engine *DeviceExecuteAsynchronous(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DeviceExecuteAsynchronous[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// executes the command with the parameters params.
        /// https://reference.wolfram.com/language/ref/DeviceExecuteAsynchronous.html
        ///</summary>
        corewolf::engine *DeviceExecuteAsynchronous(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("DeviceExecuteAsynchronous[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a device that can be accessed in a Wolfram Language session.
        /// https://reference.wolfram.com/language/ref/DeviceObject.html
        ///</summary>
        corewolf::engine *DeviceObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeviceObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// opens a connection to the first available device in the class specified by "devclass".
        /// https://reference.wolfram.com/language/ref/DeviceOpen.html
        ///</summary>
        corewolf::engine *DeviceOpen(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeviceOpen[" + arg0 + "]", name);
        }

        ///< summary>
        /// opens a connection to the particular device defined by spec.
        /// https://reference.wolfram.com/language/ref/DeviceOpen.html
        ///</summary>
        corewolf::engine *DeviceOpen(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeviceOpen[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reads a single default item from the open device corresponding to the specified DeviceObject.
        /// https://reference.wolfram.com/language/ref/DeviceRead.html
        ///</summary>
        corewolf::engine *DeviceRead(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeviceRead[" + arg0 + "]", name);
        }

        ///< summary>
        /// reads the parameter param from the specified device.
        /// https://reference.wolfram.com/language/ref/DeviceRead.html
        ///</summary>
        corewolf::engine *DeviceRead(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeviceRead[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reads the list of parameters parami from the specified device.
        /// https://reference.wolfram.com/language/ref/DeviceRead.html
        ///</summary>
        corewolf::engine *DeviceRead(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DeviceRead[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// reads the complete contents of the buffer on a device.
        /// https://reference.wolfram.com/language/ref/DeviceReadBuffer.html
        ///</summary>
        corewolf::engine *DeviceReadBuffer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeviceReadBuffer[" + arg0 + "]", name);
        }

        ///< summary>
        /// reads n elements from the buffer.
        /// https://reference.wolfram.com/language/ref/DeviceReadBuffer.html
        ///</summary>
        corewolf::engine *DeviceReadBuffer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeviceReadBuffer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reads elements associated with the parameter param.
        /// https://reference.wolfram.com/language/ref/DeviceReadBuffer.html
        ///</summary>
        corewolf::engine *DeviceReadBuffer(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DeviceReadBuffer[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// reads elements associated with the parami.
        /// https://reference.wolfram.com/language/ref/DeviceReadBuffer.html
        ///</summary>
        corewolf::engine *DeviceReadBuffer(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("DeviceReadBuffer[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// returns the most recently collected default item from a device.
        /// https://reference.wolfram.com/language/ref/DeviceReadLatest.html
        ///</summary>
        corewolf::engine *DeviceReadLatest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeviceReadLatest[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a list of the n most recently collected items.
        /// https://reference.wolfram.com/language/ref/DeviceReadLatest.html
        ///</summary>
        corewolf::engine *DeviceReadLatest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeviceReadLatest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the n most recently collected values of param.
        /// https://reference.wolfram.com/language/ref/DeviceReadLatest.html
        ///</summary>
        corewolf::engine *DeviceReadLatest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DeviceReadLatest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns a list of the most recently collected values of the parami.
        /// https://reference.wolfram.com/language/ref/DeviceReadLatest.html
        ///</summary>
        corewolf::engine *DeviceReadLatest(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("DeviceReadLatest[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// reads from the specified device n times, returning a list of the results.
        /// https://reference.wolfram.com/language/ref/DeviceReadList.html
        ///</summary>
        corewolf::engine *DeviceReadList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeviceReadList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reads the parameter param.
        /// https://reference.wolfram.com/language/ref/DeviceReadList.html
        ///</summary>
        corewolf::engine *DeviceReadList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DeviceReadList[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// reads the list of parameters parami.
        /// https://reference.wolfram.com/language/ref/DeviceReadList.html
        ///</summary>
        corewolf::engine *DeviceReadList(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("DeviceReadList[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// repeatedly reads default items from the specified device at interval dt for a total time t, returning a time series of the resulting values.
        /// https://reference.wolfram.com/language/ref/DeviceReadTimeSeries.html
        ///</summary>
        corewolf::engine *DeviceReadTimeSeries(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DeviceReadTimeSeries[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// repeatedly reads the parameter param and returns a time series of its values.
        /// https://reference.wolfram.com/language/ref/DeviceReadTimeSeries.html
        ///</summary>
        corewolf::engine *DeviceReadTimeSeries(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DeviceReadTimeSeries[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// repeatedly reads the parami and returns a time series of their values.
        /// https://reference.wolfram.com/language/ref/DeviceReadTimeSeries.html
        ///</summary>
        corewolf::engine *DeviceReadTimeSeries(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("DeviceReadTimeSeries[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of registered devices on a particular system.
        /// https://reference.wolfram.com/language/ref/Devices.html
        ///</summary>
        corewolf::engine *Devices(const std::string &name = "")
        {
            return this->execute("Devices[]", name);
        }

        ///< summary>
        /// gives a list of devices in classes whose names match the string pattern form.
        /// https://reference.wolfram.com/language/ref/Devices.html
        ///</summary>
        corewolf::engine *Devices(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Devices[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of devices in classes whose names match any of the formi.
        /// https://reference.wolfram.com/language/ref/Devices.html
        ///</summary>
        corewolf::engine *Devices(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Devices[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of all open streams associated with a device.
        /// https://reference.wolfram.com/language/ref/DeviceStreams.html
        ///</summary>
        corewolf::engine *DeviceStreams(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DeviceStreams[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of streams whose names match the string pattern patt.
        /// https://reference.wolfram.com/language/ref/DeviceStreams.html
        ///</summary>
        corewolf::engine *DeviceStreams(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeviceStreams[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of streams whose names match any of the patti.
        /// https://reference.wolfram.com/language/ref/DeviceStreams.html
        ///</summary>
        corewolf::engine *DeviceStreams(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DeviceStreams[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// writes the value val to the specified device.
        /// https://reference.wolfram.com/language/ref/DeviceWrite.html
        ///</summary>
        corewolf::engine *DeviceWrite(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeviceWrite[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// writes the sequence of values vali to the specified device.
        /// https://reference.wolfram.com/language/ref/DeviceWrite.html
        ///</summary>
        corewolf::engine *DeviceWrite(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DeviceWrite[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// fills the buffer on a device with the values vals.
        /// https://reference.wolfram.com/language/ref/DeviceWriteBuffer.html
        ///</summary>
        corewolf::engine *DeviceWriteBuffer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DeviceWriteBuffer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// fills the buffers associated with the parami with the corresponding values valsi .
        /// https://reference.wolfram.com/language/ref/DeviceWriteBuffer.html
        ///</summary>
        corewolf::engine *DeviceWriteBuffer(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DeviceWriteBuffer[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a derivative of Gaussian wavelet of derivative order 2.
        /// https://reference.wolfram.com/language/ref/DGaussianWavelet.html
        ///</summary>
        corewolf::engine *DGaussianWavelet(const std::string &name = "")
        {
            return this->execute("DGaussianWavelet[]", name);
        }

        ///< summary>
        /// represents a derivative of Gaussian wavelet of derivative order n.
        /// https://reference.wolfram.com/language/ref/DGaussianWavelet.html
        ///</summary>
        corewolf::engine *DGaussianWavelet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DGaussianWavelet[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the list of elements on the leading diagonal of the matrix m.
        /// https://reference.wolfram.com/language/ref/Diagonal.html
        ///</summary>
        corewolf::engine *Diagonal(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Diagonal[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the elements on the k diagonal of m.
        /// https://reference.wolfram.com/language/ref/Diagonal.html
        ///</summary>
        corewolf::engine *Diagonal(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Diagonal[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if m is diagonalizable, and False otherwise.
        /// https://reference.wolfram.com/language/ref/DiagonalizableMatrixQ.html
        ///</summary>
        corewolf::engine *DiagonalizableMatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DiagonalizableMatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a matrix with the elements of list on the leading diagonal, and zero elsewhere.
        /// https://reference.wolfram.com/language/ref/DiagonalMatrix.html
        ///</summary>
        corewolf::engine *DiagonalMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DiagonalMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a matrix with the elements of list on the k diagonal.
        /// https://reference.wolfram.com/language/ref/DiagonalMatrix.html
        ///</summary>
        corewolf::engine *DiagonalMatrix(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiagonalMatrix[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// pads with zeros to create an n×n matrix.
        /// https://reference.wolfram.com/language/ref/DiagonalMatrix.html
        ///</summary>
        corewolf::engine *DiagonalMatrix(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DiagonalMatrix[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives True if m is diagonal, and False otherwise.
        /// https://reference.wolfram.com/language/ref/DiagonalMatrixQ.html
        ///</summary>
        corewolf::engine *DiagonalMatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DiagonalMatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if m has nonzero elements only on the k diagonal, and False otherwise.
        /// https://reference.wolfram.com/language/ref/DiagonalMatrixQ.html
        ///</summary>
        corewolf::engine *DiagonalMatrixQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiagonalMatrixQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// initiates a dialog.
        /// https://reference.wolfram.com/language/ref/Dialog.html
        ///</summary>
        corewolf::engine *Dialog(const std::string &name = "")
        {
            return this->execute("Dialog[]", name);
        }

        ///< summary>
        /// initiates a dialog with expr as the current value of %.
        /// https://reference.wolfram.com/language/ref/Dialog.html
        ///</summary>
        corewolf::engine *Dialog(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Dialog[" + arg0 + "]", name);
        }

        ///< summary>
        /// interactively puts up expr as a dialog notebook, waits until a DialogReturn[e] is evaluated from within it, and then returns the result e.
        /// https://reference.wolfram.com/language/ref/DialogInput.html
        ///</summary>
        corewolf::engine *DialogInput(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DialogInput[" + arg0 + "]", name);
        }

        ///< summary>
        /// sets up local variables x, y, … in expr.
        /// https://reference.wolfram.com/language/ref/DialogInput.html
        ///</summary>
        corewolf::engine *DialogInput(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DialogInput[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a dialog notebook that can be manipulated by the Wolfram System front end.
        /// https://reference.wolfram.com/language/ref/DialogNotebook.html
        ///</summary>
        corewolf::engine *DialogNotebook(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DialogNotebook[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// closes a dialog window, returning the expression expr from the dialog.
        /// https://reference.wolfram.com/language/ref/DialogReturn.html
        ///</summary>
        corewolf::engine *DialogReturn(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DialogReturn[" + arg0 + "]", name);
        }

        ///< summary>
        /// closes a dialog window, returning Null.
        /// https://reference.wolfram.com/language/ref/DialogReturn.html
        ///</summary>
        corewolf::engine *DialogReturn(const std::string &name = "")
        {
            return this->execute("DialogReturn[]", name);
        }

        ///< summary>
        /// displays as x⋄y⋄….
        /// https://reference.wolfram.com/language/ref/Diamond.html
        ///</summary>
        corewolf::engine *Diamond(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Diamond[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a matrix whose elements are 1 in a diamond-shaped region that extends r index positions to each side, and are 0 otherwise.
        /// https://reference.wolfram.com/language/ref/DiamondMatrix.html
        ///</summary>
        corewolf::engine *DiamondMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DiamondMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a w×w matrix containing a diamond-shaped region of 1s.
        /// https://reference.wolfram.com/language/ref/DiamondMatrix.html
        ///</summary>
        corewolf::engine *DiamondMatrix(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiamondMatrix[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields an array whose elements are 1 in a diamond-shaped region that extends ri index positions in the i direction.
        /// https://reference.wolfram.com/language/ref/DiamondMatrix.html
        ///</summary>
        corewolf::engine *DiamondMatrix(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiamondMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Dice dissimilarity between Boolean vectors x and y.
        /// https://reference.wolfram.com/language/ref/DiceDissimilarity.html
        ///</summary>
        corewolf::engine *DiceDissimilarity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiceDissimilarity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds all words in an English dictionary that match the string pattern patt.
        /// https://reference.wolfram.com/language/ref/DictionaryLookup.html
        ///</summary>
        corewolf::engine *DictionaryLookup(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DictionaryLookup[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives only the first n words found.
        /// https://reference.wolfram.com/language/ref/DictionaryLookup.html
        ///</summary>
        corewolf::engine *DictionaryLookup(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DictionaryLookup[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds words in the language specified by lang.
        /// https://reference.wolfram.com/language/ref/DictionaryLookup.html
        ///</summary>
        corewolf::engine *DictionaryLookup(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DictionaryLookup[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// tests whether "word" is a recognized dictionary word.
        /// https://reference.wolfram.com/language/ref/DictionaryWordQ.html
        ///</summary>
        corewolf::engine *DictionaryWordQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DictionaryWordQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the discrete difference .
        /// https://reference.wolfram.com/language/ref/DifferenceDelta.html
        ///</summary>
        corewolf::engine *DifferenceDelta(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DifferenceDelta[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the multiple difference .
        /// https://reference.wolfram.com/language/ref/DifferenceDelta.html
        ///</summary>
        corewolf::engine *DifferenceDelta(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DifferenceDelta[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// computes the partial difference with respect to i, j, ….
        /// https://reference.wolfram.com/language/ref/DifferenceDelta.html
        ///</summary>
        corewolf::engine *DifferenceDelta(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("DifferenceDelta[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the difference quotient .
        /// https://reference.wolfram.com/language/ref/DifferenceQuotient.html
        ///</summary>
        corewolf::engine *DifferenceQuotient(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DifferenceQuotient[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// computes the partial difference quotient with respect to x1,x2,….
        /// https://reference.wolfram.com/language/ref/DifferenceQuotient.html
        ///</summary>
        corewolf::engine *DifferenceQuotient(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("DifferenceQuotient[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the holonomic sequence , specified by the linear difference equation lde[h,k].
        /// https://reference.wolfram.com/language/ref/DifferenceRoot.html
        ///</summary>
        corewolf::engine *DifferenceRoot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DifferenceRoot[" + arg0 + "]", name);
        }

        ///< summary>
        /// attempts to reduce expr to a single DifferenceRoot const std::string &as a function of n.
        /// https://reference.wolfram.com/language/ref/DifferenceRootReduce.html
        ///</summary>
        corewolf::engine *DifferenceRootReduce(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DifferenceRootReduce[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the successive differences of elements in list.
        /// https://reference.wolfram.com/language/ref/Differences.html
        ///</summary>
        corewolf::engine *Differences(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Differences[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the n differences of list.
        /// https://reference.wolfram.com/language/ref/Differences.html
        ///</summary>
        corewolf::engine *Differences(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Differences[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the differences of elements step s apart.
        /// https://reference.wolfram.com/language/ref/Differences.html
        ///</summary>
        corewolf::engine *Differences(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Differences[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the successive nk differences at level k in a nested list.
        /// https://reference.wolfram.com/language/ref/Differences.html
        ///</summary>
        corewolf::engine *Differences(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Differences[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// displays as x.
        /// https://reference.wolfram.com/language/ref/DifferentialD.html
        ///</summary>
        corewolf::engine *DifferentialD(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DifferentialD[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the holonomic function , specified by the linear differential equation lde[h,x].
        /// https://reference.wolfram.com/language/ref/DifferentialRoot.html
        ///</summary>
        corewolf::engine *DifferentialRoot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DifferentialRoot[" + arg0 + "]", name);
        }

        ///< summary>
        /// attempts to reduce expr to a single DifferentialRoot const std::string &as a function of x.
        /// https://reference.wolfram.com/language/ref/DifferentialRootReduce.html
        ///</summary>
        corewolf::engine *DifferentialRootReduce(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DifferentialRootReduce[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// takes the initial conditions to be specified at x=x0.
        /// https://reference.wolfram.com/language/ref/DifferentialRootReduce.html
        ///</summary>
        corewolf::engine *DifferentialRootReduce(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DifferentialRootReduce[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// applies a differentiator filter with a cutoff frequency ωc to an array of data.
        /// https://reference.wolfram.com/language/ref/DifferentiatorFilter.html
        ///</summary>
        corewolf::engine *DifferentiatorFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DifferentiatorFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses a filter kernel of length n.
        /// https://reference.wolfram.com/language/ref/DifferentiatorFilter.html
        ///</summary>
        corewolf::engine *DifferentiatorFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DifferentiatorFilter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies a smoothing window wfun to the filter kernel.
        /// https://reference.wolfram.com/language/ref/DifferentiatorFilter.html
        ///</summary>
        corewolf::engine *DifferentiatorFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("DifferentiatorFilter[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a diffusion term  with model variables vars.
        /// https://reference.wolfram.com/language/ref/DiffusionPDETerm.html
        ///</summary>
        corewolf::engine *DiffusionPDETerm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DiffusionPDETerm[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a diffusion term  with diffusion coefficient .
        /// https://reference.wolfram.com/language/ref/DiffusionPDETerm.html
        ///</summary>
        corewolf::engine *DiffusionPDETerm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiffusionPDETerm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses model parameters pars.
        /// https://reference.wolfram.com/language/ref/DiffusionPDETerm.html
        ///</summary>
        corewolf::engine *DiffusionPDETerm(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DiffusionPDETerm[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Diggle–Gates point process with constant intensity μ and interaction radius ρ in .
        /// https://reference.wolfram.com/language/ref/DiggleGatesPointProcess.html
        ///</summary>
        corewolf::engine *DiggleGatesPointProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DiggleGatesPointProcess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Diggle–Gratton point process with constant intensity μ, interaction parameter κ, hard-core interaction radius δ and interaction radius ρ in .
        /// https://reference.wolfram.com/language/ref/DiggleGrattonPointProcess.html
        ///</summary>
        corewolf::engine *DiggleGrattonPointProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("DiggleGrattonPointProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// represents a digital signature object.
        /// https://reference.wolfram.com/language/ref/DigitalSignature.html
        ///</summary>
        corewolf::engine *DigitalSignature(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DigitalSignature[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number of d digits in the base-b representation of n.
        /// https://reference.wolfram.com/language/ref/DigitCount.html
        ///</summary>
        corewolf::engine *DigitCount(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DigitCount[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of the numbers of , , …, ,  digits in the base-b representation of n.
        /// https://reference.wolfram.com/language/ref/DigitCount.html
        ///</summary>
        corewolf::engine *DigitCount(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DigitCount[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the numbers of , , …, ,  digits in the base-10 representation of n.
        /// https://reference.wolfram.com/language/ref/DigitCount.html
        ///</summary>
        corewolf::engine *DigitCount(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DigitCount[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if all the characters in the string are digits in the range 0 through 9, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/DigitQ.html
        ///</summary>
        corewolf::engine *DigitQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DigitQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the angle between two half-planes bounded by the line through p1 and p2 and extended in the direction v and w.
        /// https://reference.wolfram.com/language/ref/DihedralAngle.html
        ///</summary>
        corewolf::engine *DihedralAngle(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DihedralAngle[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents the dihedral group of order 2n.
        /// https://reference.wolfram.com/language/ref/DihedralGroup.html
        ///</summary>
        corewolf::engine *DihedralGroup(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DihedralGroup[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the morphological dilation of image with respect to the structuring element ker.
        /// https://reference.wolfram.com/language/ref/Dilation.html
        ///</summary>
        corewolf::engine *Dilation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Dilation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the possible combinations of the list of physical quantities pqi that are dimensionless.
        /// https://reference.wolfram.com/language/ref/DimensionalCombinations.html
        ///</summary>
        corewolf::engine *DimensionalCombinations(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DimensionalCombinations[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns the possible combinations of the list of physical quantities pqi that match the dimensions of physical quantity dim.
        /// https://reference.wolfram.com/language/ref/DimensionalCombinations.html
        ///</summary>
        corewolf::engine *DimensionalCombinations(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DimensionalCombinations[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list {r0,r1,…} of regions such that rd has dimension d for a mesh region mr.
        /// https://reference.wolfram.com/language/ref/DimensionalMeshComponents.html
        ///</summary>
        corewolf::engine *DimensionalMeshComponents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DimensionalMeshComponents[" + arg0 + "]", name);
        }

        ///< summary>
        /// projects the examples examplei to a lower-dimensional approximating manifold.
        /// https://reference.wolfram.com/language/ref/DimensionReduce.html
        ///</summary>
        corewolf::engine *DimensionReduce(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DimensionReduce[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// projects onto an approximating manifold in n-dimensional space.
        /// https://reference.wolfram.com/language/ref/DimensionReduce.html
        ///</summary>
        corewolf::engine *DimensionReduce(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DimensionReduce[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a function generated by DimensionReduction that projects data onto a lower-dimensional approximating manifold.
        /// https://reference.wolfram.com/language/ref/DimensionReducerFunction.html
        ///</summary>
        corewolf::engine *DimensionReducerFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DimensionReducerFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a DimensionReducerFunction[…] that projects from the space defined by the examplei to a lower-dimensional approximating manifold.
        /// https://reference.wolfram.com/language/ref/DimensionReduction.html
        ///</summary>
        corewolf::engine *DimensionReduction(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DimensionReduction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a DimensionReducerFunction[…] for an n-dimensional approximating manifold.
        /// https://reference.wolfram.com/language/ref/DimensionReduction.html
        ///</summary>
        corewolf::engine *DimensionReduction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DimensionReduction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates the specified properties of the dimensionality reduction.
        /// https://reference.wolfram.com/language/ref/DimensionReduction.html
        ///</summary>
        corewolf::engine *DimensionReduction(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DimensionReduction[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of the dimensions of expr.
        /// https://reference.wolfram.com/language/ref/Dimensions.html
        ///</summary>
        corewolf::engine *Dimensions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Dimensions[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of the dimensions of expr down to level n.
        /// https://reference.wolfram.com/language/ref/Dimensions.html
        ///</summary>
        corewolf::engine *Dimensions(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Dimensions[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the Dirac comb function  giving a delta function at every integer point.
        /// https://reference.wolfram.com/language/ref/DiracComb.html
        ///</summary>
        corewolf::engine *DiracComb(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DiracComb[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the multidimensional Dirac comb function .
        /// https://reference.wolfram.com/language/ref/DiracComb.html
        ///</summary>
        corewolf::engine *DiracComb(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DiracComb[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the Dirac delta function .
        /// https://reference.wolfram.com/language/ref/DiracDelta.html
        ///</summary>
        corewolf::engine *DiracDelta(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DiracDelta[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the multidimensional Dirac delta function .
        /// https://reference.wolfram.com/language/ref/DiracDelta.html
        ///</summary>
        corewolf::engine *DiracDelta(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DiracDelta[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a directed graph from the undirected graph g.
        /// https://reference.wolfram.com/language/ref/DirectedGraph.html
        ///</summary>
        corewolf::engine *DirectedGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DirectedGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a directed graph using the conversion conv.
        /// https://reference.wolfram.com/language/ref/DirectedGraph.html
        ///</summary>
        corewolf::engine *DirectedGraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DirectedGraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/DirectedGraph.html
        ///</summary>
        corewolf::engine *DirectedGraph(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DirectedGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is a directed graph and False otherwise.
        /// https://reference.wolfram.com/language/ref/DirectedGraphQ.html
        ///</summary>
        corewolf::engine *DirectedGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DirectedGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an infinite numerical quantity whose direction in the complex plane is unknown.
        /// https://reference.wolfram.com/language/ref/DirectedInfinity.html
        ///</summary>
        corewolf::engine *DirectedInfinity(const std::string &name = "")
        {
            return this->execute("DirectedInfinity[]", name);
        }

        ///< summary>
        /// represents an infinite numerical quantity that is a positive real multiple of the complex number z.
        /// https://reference.wolfram.com/language/ref/DirectedInfinity.html
        ///</summary>
        corewolf::engine *DirectedInfinity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DirectedInfinity[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a three–dimensional graphics directive that specifies the directional light of color col from the point pt to the center of the bounding box to use in coloring 3D surfaces.
        /// https://reference.wolfram.com/language/ref/DirectionalLight.html
        ///</summary>
        corewolf::engine *DirectionalLight(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DirectionalLight[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses a directional light along the vector from pt1 to pt2.
        /// https://reference.wolfram.com/language/ref/DirectionalLight.html
        ///</summary>
        corewolf::engine *DirectionalLight(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DirectionalLight[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a single graphics directive composed of the directives g1, g2, ….
        /// https://reference.wolfram.com/language/ref/Directive.html
        ///</summary>
        corewolf::engine *Directive(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Directive[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the current working directory.
        /// https://reference.wolfram.com/language/ref/Directory.html
        ///</summary>
        corewolf::engine *Directory(const std::string &name = "")
        {
            return this->execute("Directory[]", name);
        }

        ///< summary>
        /// extracts the directory name from the specification for a file.
        /// https://reference.wolfram.com/language/ref/DirectoryName.html
        ///</summary>
        corewolf::engine *DirectoryName(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DirectoryName[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if the directory with the specified name exists, and gives False otherwise.
        /// https://reference.wolfram.com/language/ref/DirectoryQ.html
        ///</summary>
        corewolf::engine *DirectoryQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DirectoryQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the directory stack that represents the sequence of current directories used.
        /// https://reference.wolfram.com/language/ref/DirectoryStack.html
        ///</summary>
        corewolf::engine *DirectoryStack(const std::string &name = "")
        {
            return this->execute("DirectoryStack[]", name);
        }

        ///< summary>
        /// gives the Dirichlet beta function .
        /// https://reference.wolfram.com/language/ref/DirichletBeta.html
        ///</summary>
        corewolf::engine *DirichletBeta(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DirichletBeta[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Dirichlet character  with modulus k and index j.
        /// https://reference.wolfram.com/language/ref/DirichletCharacter.html
        ///</summary>
        corewolf::engine *DirichletCharacter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DirichletCharacter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Dirichlet boundary condition given by equation beqn, satisfied on the part of the boundary of the region given to NDSolve and related functions where pred is True.
        /// https://reference.wolfram.com/language/ref/DirichletCondition.html
        ///</summary>
        corewolf::engine *DirichletCondition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DirichletCondition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Dirichlet convolution of the expressions f and g.
        /// https://reference.wolfram.com/language/ref/DirichletConvolve.html
        ///</summary>
        corewolf::engine *DirichletConvolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("DirichletConvolve[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a Dirichlet distribution of dimension k with shape parameters αi.
        /// https://reference.wolfram.com/language/ref/DirichletDistribution.html
        ///</summary>
        corewolf::engine *DirichletDistribution(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DirichletDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Dirichlet eta function .
        /// https://reference.wolfram.com/language/ref/DirichletEta.html
        ///</summary>
        corewolf::engine *DirichletEta(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DirichletEta[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Dirichlet L-function  for the Dirichlet character  with modulus k and index j.
        /// https://reference.wolfram.com/language/ref/DirichletL.html
        ///</summary>
        corewolf::engine *DirichletL(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DirichletL[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Dirichlet lambda function .
        /// https://reference.wolfram.com/language/ref/DirichletLambda.html
        ///</summary>
        corewolf::engine *DirichletLambda(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DirichletLambda[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Dirichlet transform of expr with respect to n.
        /// https://reference.wolfram.com/language/ref/DirichletTransform.html
        ///</summary>
        corewolf::engine *DirichletTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DirichletTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Dirichlet window function of x.
        /// https://reference.wolfram.com/language/ref/DirichletWindow.html
        ///</summary>
        corewolf::engine *DirichletWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DirichletWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a form that disables the formatting of expr when it appears inside held expressions, but gives expr as soon as evaluation occurs.
        /// https://reference.wolfram.com/language/ref/DisableFormatting.html
        ///</summary>
        corewolf::engine *DisableFormatting(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DisableFormatting[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an asymptotic approximation for expr as n tends to infinity over the integers.
        /// https://reference.wolfram.com/language/ref/DiscreteAsymptotic.html
        ///</summary>
        corewolf::engine *DiscreteAsymptotic(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteAsymptotic[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an asymptotic series approximation for expr to order m.
        /// https://reference.wolfram.com/language/ref/DiscreteAsymptotic.html
        ///</summary>
        corewolf::engine *DiscreteAsymptotic(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteAsymptotic[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the chirp Z transform of list.
        /// https://reference.wolfram.com/language/ref/DiscreteChirpZTransform.html
        ///</summary>
        corewolf::engine *DiscreteChirpZTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DiscreteChirpZTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a length n chirp Z transform.
        /// https://reference.wolfram.com/language/ref/DiscreteChirpZTransform.html
        ///</summary>
        corewolf::engine *DiscreteChirpZTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteChirpZTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses a spiral path on the complex  plane defined by w.
        /// https://reference.wolfram.com/language/ref/DiscreteChirpZTransform.html
        ///</summary>
        corewolf::engine *DiscreteChirpZTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DiscreteChirpZTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses a as the complex starting point.
        /// https://reference.wolfram.com/language/ref/DiscreteChirpZTransform.html
        ///</summary>
        corewolf::engine *DiscreteChirpZTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("DiscreteChirpZTransform[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional chirp Z transform.
        /// https://reference.wolfram.com/language/ref/DiscreteChirpZTransform.html
        ///</summary>
        corewolf::engine *DiscreteChirpZTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("DiscreteChirpZTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// gives the convolution with respect to n of the expressions f and g.
        /// https://reference.wolfram.com/language/ref/DiscreteConvolve.html
        ///</summary>
        corewolf::engine *DiscreteConvolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("DiscreteConvolve[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional convolution.
        /// https://reference.wolfram.com/language/ref/DiscreteConvolve.html
        ///</summary>
        corewolf::engine *DiscreteConvolve(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("DiscreteConvolve[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// gives the discrete delta function , equal to 1 if all the ni are zero, and 0 otherwise.
        /// https://reference.wolfram.com/language/ref/DiscreteDelta.html
        ///</summary>
        corewolf::engine *DiscreteDelta(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DiscreteDelta[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the discrete Hadamard transform of list.
        /// https://reference.wolfram.com/language/ref/DiscreteHadamardTransform.html
        ///</summary>
        corewolf::engine *DiscreteHadamardTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DiscreteHadamardTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields the discrete indicator function, equal to 1 if x=x1 and, otherwise, to 0 if x=ui for some i.
        /// https://reference.wolfram.com/language/ref/DiscreteIndicator.html
        ///</summary>
        corewolf::engine *DiscreteIndicator(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("DiscreteIndicator[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a discrete-time model with input u and output  at sampling instant i.
        /// https://reference.wolfram.com/language/ref/DiscreteInputOutputModel.html
        ///</summary>
        corewolf::engine *DiscreteInputOutputModel(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteInputOutputModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// can be used to specify outputs  that also depend on the output variables y.
        /// https://reference.wolfram.com/language/ref/DiscreteInputOutputModel.html
        ///</summary>
        corewolf::engine *DiscreteInputOutputModel(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DiscreteInputOutputModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// specifies input and output values for each signal for instants k<=0.
        /// https://reference.wolfram.com/language/ref/DiscreteInputOutputModel.html
        ///</summary>
        corewolf::engine *DiscreteInputOutputModel(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::vector<std::string> &arg4, const std::string &name = "")
        {
            return this->execute("DiscreteInputOutputModel[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + "]", name);
        }

        ///< summary>
        /// gives the limit k∞f(k) for the sequence f as k tends to infinity over the integers.
        /// https://reference.wolfram.com/language/ref/DiscreteLimit.html
        ///</summary>
        corewolf::engine *DiscreteLimit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteLimit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the nested limit ⋯ f(k1,…,kn) over the integers.
        /// https://reference.wolfram.com/language/ref/DiscreteLimit.html
        ///</summary>
        corewolf::engine *DiscreteLimit(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteLimit[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the optimal discrete-time estimator gain matrix with sampling period τ for the continuous-time StateSpaceModel ssm, with process and measurement noise covariance matrices w and v.
        /// https://reference.wolfram.com/language/ref/DiscreteLQEstimatorGains.html
        ///</summary>
        corewolf::engine *DiscreteLQEstimatorGains(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DiscreteLQEstimatorGains[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// specifies sensors as the noisy measurements of ssm.
        /// https://reference.wolfram.com/language/ref/DiscreteLQEstimatorGains.html
        ///</summary>
        corewolf::engine *DiscreteLQEstimatorGains(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DiscreteLQEstimatorGains[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the discrete-time state feedback gains with sampling period τ for the continuous-time system specification sspec that minimizes a cost function with weights wts.
        /// https://reference.wolfram.com/language/ref/DiscreteLQRegulatorGains.html
        ///</summary>
        corewolf::engine *DiscreteLQRegulatorGains(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DiscreteLQRegulatorGains[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the property "prop".
        /// https://reference.wolfram.com/language/ref/DiscreteLQRegulatorGains.html
        ///</summary>
        corewolf::engine *DiscreteLQRegulatorGains(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteLQRegulatorGains[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the numeric solution  of the discrete matrix equation .
        /// https://reference.wolfram.com/language/ref/DiscreteLyapunovSolve.html
        ///</summary>
        corewolf::engine *DiscreteLyapunovSolve(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteLyapunovSolve[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// solves .
        /// https://reference.wolfram.com/language/ref/DiscreteLyapunovSolve.html
        ///</summary>
        corewolf::engine *DiscreteLyapunovSolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DiscreteLyapunovSolve[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// solves .
        /// https://reference.wolfram.com/language/ref/DiscreteLyapunovSolve.html
        ///</summary>
        corewolf::engine *DiscreteLyapunovSolve(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteLyapunovSolve[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// solves .
        /// https://reference.wolfram.com/language/ref/DiscreteLyapunovSolve.html
        ///</summary>
        corewolf::engine *DiscreteLyapunovSolve(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DiscreteLyapunovSolve[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a discrete-time, finite-state Markov process with transition matrix m and initial state i0.
        /// https://reference.wolfram.com/language/ref/DiscreteMarkovProcess.html
        ///</summary>
        corewolf::engine *DiscreteMarkovProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteMarkovProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the max limit k∞f(k) of the sequence f as k tends to ∞ over the integers.
        /// https://reference.wolfram.com/language/ref/DiscreteMaxLimit.html
        ///</summary>
        corewolf::engine *DiscreteMaxLimit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteMaxLimit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the nested max limit ⋯ f(k1,…,kn) over the integers.
        /// https://reference.wolfram.com/language/ref/DiscreteMaxLimit.html
        ///</summary>
        corewolf::engine *DiscreteMaxLimit(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteMaxLimit[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the min limit k∞f(k) of the sequence f as k tends to ∞ over the integers.
        /// https://reference.wolfram.com/language/ref/DiscreteMinLimit.html
        ///</summary>
        corewolf::engine *DiscreteMinLimit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteMinLimit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the nested min limit ⋯ f(k1,…,kn) over the integers.
        /// https://reference.wolfram.com/language/ref/DiscreteMinLimit.html
        ///</summary>
        corewolf::engine *DiscreteMinLimit(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteMinLimit[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a plot of the values of expr when n runs from 1 to nmax.
        /// https://reference.wolfram.com/language/ref/DiscretePlot.html
        ///</summary>
        corewolf::engine *DiscretePlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DiscretePlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses the successive values n1, n2, ….
        /// https://reference.wolfram.com/language/ref/DiscretePlot.html
        ///</summary>
        corewolf::engine *DiscretePlot(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("DiscretePlot[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// plots the values of all the expri.
        /// https://reference.wolfram.com/language/ref/DiscretePlot.html
        ///</summary>
        corewolf::engine *DiscretePlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiscretePlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a plot of the values of expr when i runs from imin to imax and j runs from jmin to jmax.
        /// https://reference.wolfram.com/language/ref/DiscretePlot3D.html
        ///</summary>
        corewolf::engine *DiscretePlot3D(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("DiscretePlot3D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses successive i values i1, i2, … and j values j1,  j2, ….
        /// https://reference.wolfram.com/language/ref/DiscretePlot3D.html
        ///</summary>
        corewolf::engine *DiscretePlot3D(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::vector<std::string> &arg4, const std::string &name = "")
        {
            return this->execute("DiscretePlot3D[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + "]", name);
        }

        ///< summary>
        /// plots the values of all the expri.
        /// https://reference.wolfram.com/language/ref/DiscretePlot3D.html
        ///</summary>
        corewolf::engine *DiscretePlot3D(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DiscretePlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the discrete ratio .
        /// https://reference.wolfram.com/language/ref/DiscreteRatio.html
        ///</summary>
        corewolf::engine *DiscreteRatio(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteRatio[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the multiple discrete ratio.
        /// https://reference.wolfram.com/language/ref/DiscreteRatio.html
        ///</summary>
        corewolf::engine *DiscreteRatio(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteRatio[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// computes the partial difference ratio with respect to i, j, ….
        /// https://reference.wolfram.com/language/ref/DiscreteRatio.html
        ///</summary>
        corewolf::engine *DiscreteRatio(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("DiscreteRatio[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the matrix  that is the stabilizing solution of the discrete algebraic Riccati equation .
        /// https://reference.wolfram.com/language/ref/DiscreteRiccatiSolve.html
        ///</summary>
        corewolf::engine *DiscreteRiccatiSolve(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteRiccatiSolve[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the discrete shift .
        /// https://reference.wolfram.com/language/ref/DiscreteShift.html
        ///</summary>
        corewolf::engine *DiscreteShift(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteShift[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the multiple shift .
        /// https://reference.wolfram.com/language/ref/DiscreteShift.html
        ///</summary>
        corewolf::engine *DiscreteShift(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteShift[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// computes partial shifts with respect to i, j, ….
        /// https://reference.wolfram.com/language/ref/DiscreteShift.html
        ///</summary>
        corewolf::engine *DiscreteShift(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("DiscreteShift[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives True if lsys is a discrete-time systems model, and False otherwise.
        /// https://reference.wolfram.com/language/ref/DiscreteTimeModelQ.html
        ///</summary>
        corewolf::engine *DiscreteTimeModelQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DiscreteTimeModelQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a discrete uniform distribution over the integers from imin to imax.
        /// https://reference.wolfram.com/language/ref/DiscreteUniformDistribution.html
        ///</summary>
        corewolf::engine *DiscreteUniformDistribution(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DiscreteUniformDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a multivariate discrete uniform distribution over integers within the box {{imin,imax},{jmin,jmax},…}.
        /// https://reference.wolfram.com/language/ref/DiscreteUniformDistribution.html
        ///</summary>
        corewolf::engine *DiscreteUniformDistribution(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteUniformDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields a discrete wavelet data const std::string &with wavelet coefficients coefi corresponding to wavelet index windi, wavelet wave, and wavelet transform wtrans.
        /// https://reference.wolfram.com/language/ref/DiscreteWaveletData.html
        ///</summary>
        corewolf::engine *DiscreteWaveletData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DiscreteWaveletData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields a discrete wavelet data const std::string &assuming data dimensions {d1,…}.
        /// https://reference.wolfram.com/language/ref/DiscreteWaveletData.html
        ///</summary>
        corewolf::engine *DiscreteWaveletData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("DiscreteWaveletData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// gives the discrete wavelet packet transform (DWPT) of an array of data.
        /// https://reference.wolfram.com/language/ref/DiscreteWaveletPacketTransform.html
        ///</summary>
        corewolf::engine *DiscreteWaveletPacketTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DiscreteWaveletPacketTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the discrete wavelet packet transform using the wavelet wave.
        /// https://reference.wolfram.com/language/ref/DiscreteWaveletPacketTransform.html
        ///</summary>
        corewolf::engine *DiscreteWaveletPacketTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteWaveletPacketTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the discrete wavelet packet transform using r levels of refinement.
        /// https://reference.wolfram.com/language/ref/DiscreteWaveletPacketTransform.html
        ///</summary>
        corewolf::engine *DiscreteWaveletPacketTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DiscreteWaveletPacketTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the discrete wavelet transform (DWT) of an array of data.
        /// https://reference.wolfram.com/language/ref/DiscreteWaveletTransform.html
        ///</summary>
        corewolf::engine *DiscreteWaveletTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DiscreteWaveletTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the discrete wavelet transform using the wavelet wave.
        /// https://reference.wolfram.com/language/ref/DiscreteWaveletTransform.html
        ///</summary>
        corewolf::engine *DiscreteWaveletTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiscreteWaveletTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the discrete wavelet transform using r levels of refinement.
        /// https://reference.wolfram.com/language/ref/DiscreteWaveletTransform.html
        ///</summary>
        corewolf::engine *DiscreteWaveletTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DiscreteWaveletTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// discretizes a 2D or 3D graphic g into a MeshRegion.
        /// https://reference.wolfram.com/language/ref/DiscretizeGraphics.html
        ///</summary>
        corewolf::engine *DiscretizeGraphics(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DiscretizeGraphics[" + arg0 + "]", name);
        }

        ///< summary>
        /// discretizes only the elements in g that match the pattern patt.
        /// https://reference.wolfram.com/language/ref/DiscretizeGraphics.html
        ///</summary>
        corewolf::engine *DiscretizeGraphics(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiscretizeGraphics[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// discretizes a region reg into a MeshRegion.
        /// https://reference.wolfram.com/language/ref/DiscretizeRegion.html
        ///</summary>
        corewolf::engine *DiscretizeRegion(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DiscretizeRegion[" + arg0 + "]", name);
        }

        ///< summary>
        /// restricts to the bounds .
        /// https://reference.wolfram.com/language/ref/DiscretizeRegion.html
        ///</summary>
        corewolf::engine *DiscretizeRegion(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DiscretizeRegion[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// computes the discriminant of the polynomial poly with respect to the variable var.
        /// https://reference.wolfram.com/language/ref/Discriminant.html
        ///</summary>
        corewolf::engine *Discriminant(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Discriminant[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes the discriminant modulo .
        /// https://reference.wolfram.com/language/ref/Discriminant.html
        ///</summary>
        corewolf::engine *Discriminant(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Discriminant[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields True if list1 and list2 do not share any common elements, and False otherwise.
        /// https://reference.wolfram.com/language/ref/DisjointQ.html
        ///</summary>
        corewolf::engine *DisjointQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DisjointQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the disjunction of expr over all choices of the Boolean variables ai.
        /// https://reference.wolfram.com/language/ref/Disjunction.html
        ///</summary>
        corewolf::engine *Disjunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Disjunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a disk of radius r centered at {x,y}.
        /// https://reference.wolfram.com/language/ref/Disk.html
        ///</summary>
        corewolf::engine *Disk(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Disk[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a disk of radius 1.
        /// https://reference.wolfram.com/language/ref/Disk.html
        ///</summary>
        corewolf::engine *Disk(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Disk[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives an axis-aligned elliptical disk with semiaxes lengths rx and ry.
        /// https://reference.wolfram.com/language/ref/Disk.html
        ///</summary>
        corewolf::engine *Disk(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Disk[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a sector of a disk from angle θ1 to θ2.
        /// https://reference.wolfram.com/language/ref/Disk.html
        ///</summary>
        corewolf::engine *Disk(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Disk[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives a matrix whose elements are 1 in a disk-shaped region of radius r, and are otherwise 0.
        /// https://reference.wolfram.com/language/ref/DiskMatrix.html
        ///</summary>
        corewolf::engine *DiskMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DiskMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a w×w matrix containing a disk of 1s with radius r.
        /// https://reference.wolfram.com/language/ref/DiskMatrix.html
        ///</summary>
        corewolf::engine *DiskMatrix(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiskMatrix[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields an array whose elements are 1 in an ellipsoidal region with semiaxis ri in the i index direction.
        /// https://reference.wolfram.com/language/ref/DiskMatrix.html
        ///</summary>
        corewolf::engine *DiskMatrix(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DiskMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the disk segment from angle θ1 to θ2 in a disk centered at {x,y} of radius r.
        /// https://reference.wolfram.com/language/ref/DiskSegment.html
        ///</summary>
        corewolf::engine *DiskSegment(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("DiskSegment[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents the ellipse segment from angle θ1 to θ2 in an axis-aligned ellipse with semiaxes lengths rx and ry.
        /// https://reference.wolfram.com/language/ref/DiskSegment.html
        ///</summary>
        corewolf::engine *DiskSegment(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("DiskSegment[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates an optimized dispatch table representation of a list of rules. The const std::string &produced by Dispatch can be used to give the rules in expr/.rules.
        /// https://reference.wolfram.com/language/ref/Dispatch.html
        ///</summary>
        corewolf::engine *Dispatch(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Dispatch[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// is a WSTP packet that indicates the end of a series of expressions relating to a postscript graphic.
        /// https://reference.wolfram.com/language/ref/DisplayEndPacket.html
        ///</summary>
        corewolf::engine *DisplayEndPacket(const std::string &name = "")
        {
            return this->execute("DisplayEndPacket[]", name);
        }

        ///< summary>
        /// prints with low-level boxes inside expr shown in explicit two-dimensional or other form.
        /// https://reference.wolfram.com/language/ref/DisplayForm.html
        ///</summary>
        corewolf::engine *DisplayForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DisplayForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a WSTP packet that indicates the beginning of a series of expressions related to a PostScript graphic.
        /// https://reference.wolfram.com/language/ref/DisplayPacket.html
        ///</summary>
        corewolf::engine *DisplayPacket(const std::string &name = "")
        {
            return this->execute("DisplayPacket[]", name);
        }

        ///< summary>
        /// gives the matrix of distances between each pair of elements ui, uj.
        /// https://reference.wolfram.com/language/ref/DistanceMatrix.html
        ///</summary>
        corewolf::engine *DistanceMatrix(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DistanceMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the matrix of distances between each pair of elements ui, vj.
        /// https://reference.wolfram.com/language/ref/DistanceMatrix.html
        ///</summary>
        corewolf::engine *DistanceMatrix(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DistanceMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the distance transform of image, in which the value of each pixel is replaced by its distance to the nearest background pixel.
        /// https://reference.wolfram.com/language/ref/DistanceTransform.html
        ///</summary>
        corewolf::engine *DistanceTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DistanceTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// treats values above t as foreground.
        /// https://reference.wolfram.com/language/ref/DistanceTransform.html
        ///</summary>
        corewolf::engine *DistanceTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DistanceTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// distributes f over Plus appearing in any of the xi.
        /// https://reference.wolfram.com/language/ref/Distribute.html
        ///</summary>
        corewolf::engine *Distribute(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Distribute[" + arg0 + "]", name);
        }

        ///< summary>
        /// distributes over g.
        /// https://reference.wolfram.com/language/ref/Distribute.html
        ///</summary>
        corewolf::engine *Distribute(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Distribute[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// performs the distribution only if the head of expr is f.
        /// https://reference.wolfram.com/language/ref/Distribute.html
        ///</summary>
        corewolf::engine *Distribute(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Distribute[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// or xdist asserts that the random variable x is distributed according to the probability distribution dist.
        /// https://reference.wolfram.com/language/ref/Distributed.html
        ///</summary>
        corewolf::engine *Distributed(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Distributed[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// or {x1,x2,…}dist asserts that the random vector {x1,x2,…} is distributed according to the multivariate probability distribution dist.
        /// https://reference.wolfram.com/language/ref/Distributed.html
        ///</summary>
        corewolf::engine *Distributed(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Distributed[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// distributes all definitions for the symbols si to all parallel kernels.
        /// https://reference.wolfram.com/language/ref/DistributeDefinitions.html
        ///</summary>
        corewolf::engine *DistributeDefinitions(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DistributeDefinitions[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// distributes definitions for all symbols in the specified context.
        /// https://reference.wolfram.com/language/ref/DistributeDefinitions.html
        ///</summary>
        corewolf::engine *DistributeDefinitions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DistributeDefinitions[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes a distribution chart with a distribution symbol for each datai.
        /// https://reference.wolfram.com/language/ref/DistributionChart.html
        ///</summary>
        corewolf::engine *DistributionChart(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DistributionChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// tests whether data is normally distributed.
        /// https://reference.wolfram.com/language/ref/DistributionFitTest.html
        ///</summary>
        corewolf::engine *DistributionFitTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DistributionFitTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether data is distributed according to dist.
        /// https://reference.wolfram.com/language/ref/DistributionFitTest.html
        ///</summary>
        corewolf::engine *DistributionFitTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DistributionFitTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/DistributionFitTest.html
        ///</summary>
        corewolf::engine *DistributionFitTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DistributionFitTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a logical expression for assumptions on parameters in the symbolic distribution dist.
        /// https://reference.wolfram.com/language/ref/DistributionParameterAssumptions.html
        ///</summary>
        corewolf::engine *DistributionParameterAssumptions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DistributionParameterAssumptions[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if dist is a valid distribution, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/DistributionParameterQ.html
        ///</summary>
        corewolf::engine *DistributionParameterQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DistributionParameterQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the divergence .
        /// https://reference.wolfram.com/language/ref/Div.html
        ///</summary>
        corewolf::engine *Div(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Div[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the divergence in the coordinates chart.
        /// https://reference.wolfram.com/language/ref/Div.html
        ///</summary>
        corewolf::engine *Div(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Div[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is equivalent to .
        /// https://reference.wolfram.com/language/ref/Divide.html
        ///</summary>
        corewolf::engine *Divide(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Divide[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// divides each side of the equation or inequality rel by x.
        /// https://reference.wolfram.com/language/ref/DivideSides.html
        ///</summary>
        corewolf::engine *DivideSides(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DivideSides[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// divides each side of rel by the right-hand side, producing a 1 right-hand side.
        /// https://reference.wolfram.com/language/ref/DivideSides.html
        ///</summary>
        corewolf::engine *DivideSides(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DivideSides[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if n is divisible by m, and yields False if it is not.
        /// https://reference.wolfram.com/language/ref/Divisible.html
        ///</summary>
        corewolf::engine *Divisible(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Divisible[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the integers that divide n.
        /// https://reference.wolfram.com/language/ref/Divisors.html
        ///</summary>
        corewolf::engine *Divisors(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Divisors[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the divisor function .
        /// https://reference.wolfram.com/language/ref/DivisorSigma.html
        ///</summary>
        corewolf::engine *DivisorSigma(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DivisorSigma[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the sum of form[i] for all i that divide n.
        /// https://reference.wolfram.com/language/ref/DivisorSum.html
        ///</summary>
        corewolf::engine *DivisorSum(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DivisorSum[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// includes only those divisors for which cond[i] gives True.
        /// https://reference.wolfram.com/language/ref/DivisorSum.html
        ///</summary>
        corewolf::engine *DivisorSum(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DivisorSum[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// converts an angle θ given in decimal degrees to a DMS list {degree,minute,second}.
        /// https://reference.wolfram.com/language/ref/DMSList.html
        ///</summary>
        corewolf::engine *DMSList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DMSList[" + arg0 + "]", name);
        }

        ///< summary>
        /// converts an angle θ given in decimal degrees to a degrees-minutes-seconds string.
        /// https://reference.wolfram.com/language/ref/DMSString.html
        ///</summary>
        corewolf::engine *DMSString(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DMSString[" + arg0 + "]", name);
        }

        ///< summary>
        /// converts latitude and longitude given in decimal degrees to a DMS latitude-longitude string.
        /// https://reference.wolfram.com/language/ref/DMSString.html
        ///</summary>
        corewolf::engine *DMSString(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DMSString[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates expr n times.
        /// https://reference.wolfram.com/language/ref/Do.html
        ///</summary>
        corewolf::engine *Do(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Do[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates expr with the variable i successively taking on the values 1 through imax (in steps of 1).
        /// https://reference.wolfram.com/language/ref/Do.html
        ///</summary>
        corewolf::engine *Do(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Do[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses the successive values i1, i2, ….
        /// https://reference.wolfram.com/language/ref/Do.html
        ///</summary>
        corewolf::engine *Do(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Do[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates expr looping over different values of j etc. for each i.
        /// https://reference.wolfram.com/language/ref/Do.html
        ///</summary>
        corewolf::engine *Do(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Do[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a document generator with template template to be evaluated on the schedule defined by timespec.
        /// https://reference.wolfram.com/language/ref/DocumentGenerator.html
        ///</summary>
        corewolf::engine *DocumentGenerator(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DocumentGenerator[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// takes parameters for filling the template from driver.
        /// https://reference.wolfram.com/language/ref/DocumentGenerator.html
        ///</summary>
        corewolf::engine *DocumentGenerator(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DocumentGenerator[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the properties of the DocumentGenerator cloudobj.
        /// https://reference.wolfram.com/language/ref/DocumentGeneratorInformation.html
        ///</summary>
        corewolf::engine *DocumentGeneratorInformation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DocumentGeneratorInformation[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the value of the property property.
        /// https://reference.wolfram.com/language/ref/DocumentGeneratorInformation.html
        ///</summary>
        corewolf::engine *DocumentGeneratorInformation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DocumentGeneratorInformation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a list of CloudObject expressions that represent currently deployed document generators.
        /// https://reference.wolfram.com/language/ref/DocumentGenerators.html
        ///</summary>
        corewolf::engine *DocumentGenerators(const std::string &name = "")
        {
            return this->execute("DocumentGenerators[]", name);
        }

        ///< summary>
        /// represents a complete document notebook in the Wolfram System front end.
        /// https://reference.wolfram.com/language/ref/DocumentNotebook.html
        ///</summary>
        corewolf::engine *DocumentNotebook(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DocumentNotebook[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a regular dodecahedron centered at the origin with unit edge length.
        /// https://reference.wolfram.com/language/ref/Dodecahedron.html
        ///</summary>
        corewolf::engine *Dodecahedron(const std::string &name = "")
        {
            return this->execute("Dodecahedron[]", name);
        }

        ///< summary>
        /// represents a dodecahedron with edge length l.
        /// https://reference.wolfram.com/language/ref/Dodecahedron.html
        ///</summary>
        corewolf::engine *Dodecahedron(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Dodecahedron[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a dodecahedron rotated by an angle θ with respect to the z axis and angle ϕ with respect to the y axis.
        /// https://reference.wolfram.com/language/ref/Dodecahedron.html
        ///</summary>
        corewolf::engine *Dodecahedron(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Dodecahedron[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns dominant colors in image.
        /// https://reference.wolfram.com/language/ref/DominantColors.html
        ///</summary>
        corewolf::engine *DominantColors(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DominantColors[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns at most n dominant colors in image.
        /// https://reference.wolfram.com/language/ref/DominantColors.html
        ///</summary>
        corewolf::engine *DominantColors(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DominantColors[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the specified property prop for the regions that belong to the same dominant color.
        /// https://reference.wolfram.com/language/ref/DominantColors.html
        ///</summary>
        corewolf::engine *DominantColors(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DominantColors[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the output in the specified format.
        /// https://reference.wolfram.com/language/ref/DominantColors.html
        ///</summary>
        corewolf::engine *DominantColors(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("DominantColors[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// returns dominant colors in each imagei.
        /// https://reference.wolfram.com/language/ref/DominantColors.html
        ///</summary>
        corewolf::engine *DominantColors(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DominantColors[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the dominator tree of the directed graph g from the root vertex v.
        /// https://reference.wolfram.com/language/ref/DominatorTreeGraph.html
        ///</summary>
        corewolf::engine *DominatorTreeGraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DominatorTreeGraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of immediate dominators of the directed graph g from the root vertex v.
        /// https://reference.wolfram.com/language/ref/DominatorVertexList.html
        ///</summary>
        corewolf::engine *DominatorVertexList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DominatorVertexList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives products of vectors, matrices, and tensors.
        /// https://reference.wolfram.com/language/ref/Dot.html
        ///</summary>
        corewolf::engine *Dot(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Dot[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x≐y≐….
        /// https://reference.wolfram.com/language/ref/DotEqual.html
        ///</summary>
        corewolf::engine *DotEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DotEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a net layer that takes the dot product of two or more arrays.
        /// https://reference.wolfram.com/language/ref/DotLayer.html
        ///</summary>
        corewolf::engine *DotLayer(const std::string &name = "")
        {
            return this->execute("DotLayer[]", name);
        }

        ///< summary>
        /// uses given transpose specifications for the respective inputs.
        /// https://reference.wolfram.com/language/ref/DotLayer.html
        ///</summary>
        corewolf::engine *DotLayer(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DotLayer[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// displays as x,y,….
        /// https://reference.wolfram.com/language/ref/DoubleBracketingBar.html
        ///</summary>
        corewolf::engine *DoubleBracketingBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DoubleBracketingBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⇓y….
        /// https://reference.wolfram.com/language/ref/DoubleDownArrow.html
        ///</summary>
        corewolf::engine *DoubleDownArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DoubleDownArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⇐y⇐….
        /// https://reference.wolfram.com/language/ref/DoubleLeftArrow.html
        ///</summary>
        corewolf::engine *DoubleLeftArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DoubleLeftArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⇔y⇔….
        /// https://reference.wolfram.com/language/ref/DoubleLeftRightArrow.html
        ///</summary>
        corewolf::engine *DoubleLeftRightArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DoubleLeftRightArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/DoubleLeftTee.html
        ///</summary>
        corewolf::engine *DoubleLeftTee(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DoubleLeftTee[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as x⟸y⟸….
        /// https://reference.wolfram.com/language/ref/DoubleLongLeftArrow.html
        ///</summary>
        corewolf::engine *DoubleLongLeftArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DoubleLongLeftArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⟺y⟺….
        /// https://reference.wolfram.com/language/ref/DoubleLongLeftRightArrow.html
        ///</summary>
        corewolf::engine *DoubleLongLeftRightArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DoubleLongLeftRightArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⟹y⟹….
        /// https://reference.wolfram.com/language/ref/DoubleLongRightArrow.html
        ///</summary>
        corewolf::engine *DoubleLongRightArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DoubleLongRightArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⇒y⇒….
        /// https://reference.wolfram.com/language/ref/DoubleRightArrow.html
        ///</summary>
        corewolf::engine *DoubleRightArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DoubleRightArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/DoubleRightTee.html
        ///</summary>
        corewolf::engine *DoubleRightTee(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DoubleRightTee[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as x⇑y⇑….
        /// https://reference.wolfram.com/language/ref/DoubleUpArrow.html
        ///</summary>
        corewolf::engine *DoubleUpArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DoubleUpArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⇕y⇕….
        /// https://reference.wolfram.com/language/ref/DoubleUpDownArrow.html
        ///</summary>
        corewolf::engine *DoubleUpDownArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DoubleUpDownArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x∥y∥….
        /// https://reference.wolfram.com/language/ref/DoubleVerticalBar.html
        ///</summary>
        corewolf::engine *DoubleVerticalBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DoubleVerticalBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x↓y↓….
        /// https://reference.wolfram.com/language/ref/DownArrow.html
        ///</summary>
        corewolf::engine *DownArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DownArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⤓y⤓….
        /// https://reference.wolfram.com/language/ref/DownArrowBar.html
        ///</summary>
        corewolf::engine *DownArrowBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DownArrowBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⇵y⇵….
        /// https://reference.wolfram.com/language/ref/DownArrowUpArrow.html
        ///</summary>
        corewolf::engine *DownArrowUpArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DownArrowUpArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⥐y⥐….
        /// https://reference.wolfram.com/language/ref/DownLeftRightVector.html
        ///</summary>
        corewolf::engine *DownLeftRightVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DownLeftRightVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⥞y⥞….
        /// https://reference.wolfram.com/language/ref/DownLeftTeeVector.html
        ///</summary>
        corewolf::engine *DownLeftTeeVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DownLeftTeeVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x↽y↽….
        /// https://reference.wolfram.com/language/ref/DownLeftVector.html
        ///</summary>
        corewolf::engine *DownLeftVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DownLeftVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⥖y⥖….
        /// https://reference.wolfram.com/language/ref/DownLeftVectorBar.html
        ///</summary>
        corewolf::engine *DownLeftVectorBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DownLeftVectorBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⥟y⥟….
        /// https://reference.wolfram.com/language/ref/DownRightTeeVector.html
        ///</summary>
        corewolf::engine *DownRightTeeVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DownRightTeeVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⇁y⇁….
        /// https://reference.wolfram.com/language/ref/DownRightVector.html
        ///</summary>
        corewolf::engine *DownRightVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DownRightVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⥗y⥗….
        /// https://reference.wolfram.com/language/ref/DownRightVectorBar.html
        ///</summary>
        corewolf::engine *DownRightVectorBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DownRightVectorBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns a downsampled version of the array by sampling every n element.
        /// https://reference.wolfram.com/language/ref/Downsample.html
        ///</summary>
        corewolf::engine *Downsample(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Downsample[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// starts sampling from the element at position offset.
        /// https://reference.wolfram.com/language/ref/Downsample.html
        ///</summary>
        corewolf::engine *Downsample(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Downsample[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/DownTee.html
        ///</summary>
        corewolf::engine *DownTee(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DownTee[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as x↧y↧….
        /// https://reference.wolfram.com/language/ref/DownTeeArrow.html
        ///</summary>
        corewolf::engine *DownTeeArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DownTeeArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of transformation rules corresponding to all downvalues (values for f[…]) defined for the symbol f.
        /// https://reference.wolfram.com/language/ref/DownValues.html
        ///</summary>
        corewolf::engine *DownValues(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DownValues[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds the Drazin generalized inverse  of a square matrix m.
        /// https://reference.wolfram.com/language/ref/DrazinInverse.html
        ///</summary>
        corewolf::engine *DrazinInverse(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DrazinInverse[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives list with its first n elements dropped.
        /// https://reference.wolfram.com/language/ref/Drop.html
        ///</summary>
        corewolf::engine *Drop(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Drop[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives list with its n element dropped.
        /// https://reference.wolfram.com/language/ref/Drop.html
        ///</summary>
        corewolf::engine *Drop(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Drop[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a nested list in which elements specified by seqi have been dropped at level i in list.
        /// https://reference.wolfram.com/language/ref/Drop.html
        ///</summary>
        corewolf::engine *Drop(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Drop[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a net layer that sets its input elements to zero with probability 0.5 during training.
        /// https://reference.wolfram.com/language/ref/DropoutLayer.html
        ///</summary>
        corewolf::engine *DropoutLayer(const std::string &name = "")
        {
            return this->execute("DropoutLayer[]", name);
        }

        ///< summary>
        /// sets its input elements to zero with probability p during training.
        /// https://reference.wolfram.com/language/ref/DropoutLayer.html
        ///</summary>
        corewolf::engine *DropoutLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DropoutLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a two‐dimensional directive specifying that graphics objects are to be drawn with an additional blurred offset image.
        /// https://reference.wolfram.com/language/ref/DropShadowing.html
        ///</summary>
        corewolf::engine *DropShadowing(const std::string &name = "")
        {
            return this->execute("DropShadowing[]", name);
        }

        ///< summary>
        /// uses an absolute offset {dx,dy}.
        /// https://reference.wolfram.com/language/ref/DropShadowing.html
        ///</summary>
        corewolf::engine *DropShadowing(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("DropShadowing[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// applies a blur effect with radius r.
        /// https://reference.wolfram.com/language/ref/DropShadowing.html
        ///</summary>
        corewolf::engine *DropShadowing(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DropShadowing[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the specified color col for the blurred offset image.
        /// https://reference.wolfram.com/language/ref/DropShadowing.html
        ///</summary>
        corewolf::engine *DropShadowing(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DropShadowing[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// solves a differential equation for the function u, with independent variable x.
        /// https://reference.wolfram.com/language/ref/DSolve.html
        ///</summary>
        corewolf::engine *DSolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DSolve[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// solves a differential equation for x between xmin and xmax.
        /// https://reference.wolfram.com/language/ref/DSolve.html
        ///</summary>
        corewolf::engine *DSolve(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("DSolve[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// solves a list of differential equations.
        /// https://reference.wolfram.com/language/ref/DSolve.html
        ///</summary>
        corewolf::engine *DSolve(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DSolve[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// changes the solution function in dsolve to  using the transformation trans.
        /// https://reference.wolfram.com/language/ref/DSolveChangeVariables.html
        ///</summary>
        corewolf::engine *DSolveChangeVariables(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("DSolveChangeVariables[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// changes the solution functions in the system to .
        /// https://reference.wolfram.com/language/ref/DSolveChangeVariables.html
        ///</summary>
        corewolf::engine *DSolveChangeVariables(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("DSolveChangeVariables[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// changes the solution function in the partial differential equation to .
        /// https://reference.wolfram.com/language/ref/DSolveChangeVariables.html
        ///</summary>
        corewolf::engine *DSolveChangeVariables(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("DSolveChangeVariables[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the value of expr determined by a symbolic solution to the ordinary differential equation eqn with independent variable x.
        /// https://reference.wolfram.com/language/ref/DSolveValue.html
        ///</summary>
        corewolf::engine *DSolveValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DSolveValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses a symbolic solution for x between xmin and xmax.
        /// https://reference.wolfram.com/language/ref/DSolveValue.html
        ///</summary>
        corewolf::engine *DSolveValue(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("DSolveValue[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses a symbolic solution for a list of differential equations.
        /// https://reference.wolfram.com/language/ref/DSolveValue.html
        ///</summary>
        corewolf::engine *DSolveValue(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("DSolveValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the total derivative df/dx.
        /// https://reference.wolfram.com/language/ref/Dt.html
        ///</summary>
        corewolf::engine *Dt(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Dt[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the total differential df.
        /// https://reference.wolfram.com/language/ref/Dt.html
        ///</summary>
        corewolf::engine *Dt(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Dt[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the multiple derivative dnf/dxn.
        /// https://reference.wolfram.com/language/ref/Dt.html
        ///</summary>
        corewolf::engine *Dt(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Dt[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives d/dx1 d/dx2 … f.
        /// https://reference.wolfram.com/language/ref/Dt.html
        ///</summary>
        corewolf::engine *Dt(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Dt[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the dual of the planar graph g.
        /// https://reference.wolfram.com/language/ref/DualPlanarGraph.html
        ///</summary>
        corewolf::engine *DualPlanarGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DualPlanarGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the dual polyhedron of the polyhedron poly.
        /// https://reference.wolfram.com/language/ref/DualPolyhedron.html
        ///</summary>
        corewolf::engine *DualPolyhedron(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DualPolyhedron[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the dual of the state-space model ssm.
        /// https://reference.wolfram.com/language/ref/DualSystemsModel.html
        ///</summary>
        corewolf::engine *DualSystemsModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DualSystemsModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// writes definitions associated with a symbol to a file in internal Wolfram System format.
        /// https://reference.wolfram.com/language/ref/DumpSave.html
        ///</summary>
        corewolf::engine *DumpSave(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DumpSave[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// writes out definitions for several symbols or contexts.
        /// https://reference.wolfram.com/language/ref/DumpSave.html
        ///</summary>
        corewolf::engine *DumpSave(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("DumpSave[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives True if list has no duplicates, and False otherwise.
        /// https://reference.wolfram.com/language/ref/DuplicateFreeQ.html
        ///</summary>
        corewolf::engine *DuplicateFreeQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DuplicateFreeQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies test to pairs of elements to determine whether they should be considered duplicates.
        /// https://reference.wolfram.com/language/ref/DuplicateFreeQ.html
        ///</summary>
        corewolf::engine *DuplicateFreeQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DuplicateFreeQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the duration of expr.
        /// https://reference.wolfram.com/language/ref/Duration.html
        ///</summary>
        corewolf::engine *Duration(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Duration[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an const std::string &that displays as the dynamically updated current value of expr. If the displayed form of Dynamic[expr] is interactively changed or edited, an assignment expr=val is done to give expr the new value val that corresponds to the displayed form.
        /// https://reference.wolfram.com/language/ref/Dynamic.html
        ///</summary>
        corewolf::engine *Dynamic(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Dynamic[" + arg0 + "]", name);
        }

        ///< summary>
        /// does not allow interactive changing or editing.
        /// https://reference.wolfram.com/language/ref/Dynamic.html
        ///</summary>
        corewolf::engine *Dynamic(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Dynamic[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// also evaluates fend[val,expr] when interactive changing or editing is complete.
        /// https://reference.wolfram.com/language/ref/Dynamic.html
        ///</summary>
        corewolf::engine *Dynamic(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Dynamic[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a dynamic, interactive, two-dimensional geographical image.
        /// https://reference.wolfram.com/language/ref/DynamicGeoGraphics.html
        ///</summary>
        corewolf::engine *DynamicGeoGraphics(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DynamicGeoGraphics[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays a dynamic version of image, supporting panning, zooming, etc.
        /// https://reference.wolfram.com/language/ref/DynamicImage.html
        ///</summary>
        corewolf::engine *DynamicImage(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DynamicImage[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an const std::string &which maintains the same local instance of the symbols x, y, … in the course of all evaluations of Dynamic objects in expr. Symbols specified in a DynamicModule will by default have their values maintained even across Wolfram System sessions.
        /// https://reference.wolfram.com/language/ref/DynamicModule.html
        ///</summary>
        corewolf::engine *DynamicModule(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DynamicModule[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an const std::string &which displays as e, but is interpreted as the dynamically updated current value of Setting[e] if supplied as Wolfram Language input.
        /// https://reference.wolfram.com/language/ref/DynamicSetting.html
        ///</summary>
        corewolf::engine *DynamicSetting(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("DynamicSetting[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as e, but is interpreted as f[e] if supplied as input.
        /// https://reference.wolfram.com/language/ref/DynamicSetting.html
        ///</summary>
        corewolf::engine *DynamicSetting(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DynamicSetting[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an const std::string &that displays as e, but dynamically updates the expression expr whenever that const std::string &is visible on screen.
        /// https://reference.wolfram.com/language/ref/DynamicWrapper.html
        ///</summary>
        corewolf::engine *DynamicWrapper(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("DynamicWrapper[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the earth impact crater entity.
        /// https://reference.wolfram.com/language/ref/EarthImpactData.html
        ///</summary>
        corewolf::engine *EarthImpactData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EarthImpactData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified earth impact crater names.
        /// https://reference.wolfram.com/language/ref/EarthImpactData.html
        ///</summary>
        corewolf::engine *EarthImpactData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EarthImpactData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/EarthImpactData.html
        ///</summary>
        corewolf::engine *EarthImpactData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("EarthImpactData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives all earthquake properties for the location corresponding to loc.
        /// https://reference.wolfram.com/language/ref/EarthquakeData.html
        ///</summary>
        corewolf::engine *EarthquakeData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EarthquakeData[" + arg0 + "]", name);
        }

        ///< summary>
        /// restricts earthquakes returned to the magnitude range mag.
        /// https://reference.wolfram.com/language/ref/EarthquakeData.html
        ///</summary>
        corewolf::engine *EarthquakeData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EarthquakeData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives earthquake data within the magnitude range mag during the time interval start to end.
        /// https://reference.wolfram.com/language/ref/EarthquakeData.html
        ///</summary>
        corewolf::engine *EarthquakeData(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("EarthquakeData[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives a time series for the specific earthquake property for earthquakes within the magnitude range mag during the time interval start to end.
        /// https://reference.wolfram.com/language/ref/EarthquakeData.html
        ///</summary>
        corewolf::engine *EarthquakeData(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("EarthquakeData[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives a list of eccentricity centralities for the vertices in the graph g.
        /// https://reference.wolfram.com/language/ref/EccentricityCentrality.html
        ///</summary>
        corewolf::engine *EccentricityCentrality(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EccentricityCentrality[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/EccentricityCentrality.html
        ///</summary>
        corewolf::engine *EccentricityCentrality(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("EccentricityCentrality[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// prints expr and returns expr.
        /// https://reference.wolfram.com/language/ref/Echo.html
        ///</summary>
        corewolf::engine *Echo(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Echo[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints expr prepending label and returns expr.
        /// https://reference.wolfram.com/language/ref/Echo.html
        ///</summary>
        corewolf::engine *Echo(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Echo[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// prints f[expr] prepending label and returns expr.
        /// https://reference.wolfram.com/language/ref/Echo.html
        ///</summary>
        corewolf::engine *Echo(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Echo[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// prints expr before evaluation, then prints the result after evaluation and returns that result.
        /// https://reference.wolfram.com/language/ref/EchoEvaluation.html
        ///</summary>
        corewolf::engine *EchoEvaluation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EchoEvaluation[" + arg0 + "]", name);
        }

        ///< summary>
        /// prepends label when printing expr before and after evaluation.
        /// https://reference.wolfram.com/language/ref/EchoEvaluation.html
        ///</summary>
        corewolf::engine *EchoEvaluation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EchoEvaluation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// prints expr before evaluation, then evaluates expr to the result res and prints f[res].
        /// https://reference.wolfram.com/language/ref/EchoEvaluation.html
        ///</summary>
        corewolf::engine *EchoEvaluation(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("EchoEvaluation[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// prints f[expr] and returns expr.
        /// https://reference.wolfram.com/language/ref/EchoFunction.html
        ///</summary>
        corewolf::engine *EchoFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EchoFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// evaluates expr, prints the time in seconds used and returns the result of the evaluation.
        /// https://reference.wolfram.com/language/ref/EchoTiming.html
        ///</summary>
        corewolf::engine *EchoTiming(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EchoTiming[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints the timing, prepending label.
        /// https://reference.wolfram.com/language/ref/EchoTiming.html
        ///</summary>
        corewolf::engine *EchoTiming(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EchoTiming[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// makes a graph by adding the edge e to the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeAdd.html
        ///</summary>
        corewolf::engine *EdgeAdd(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EdgeAdd[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// adds a collection of edges to g.
        /// https://reference.wolfram.com/language/ref/EdgeAdd.html
        ///</summary>
        corewolf::engine *EdgeAdd(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EdgeAdd[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeAdd.html
        ///</summary>
        corewolf::engine *EdgeAdd(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EdgeAdd[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of betweenness centralities for the edges in the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeBetweennessCentrality.html
        ///</summary>
        corewolf::engine *EdgeBetweennessCentrality(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EdgeBetweennessCentrality[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeBetweennessCentrality.html
        ///</summary>
        corewolf::engine *EdgeBetweennessCentrality(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("EdgeBetweennessCentrality[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the chromatic number for the edges of the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeChromaticNumber.html
        ///</summary>
        corewolf::engine *EdgeChromaticNumber(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EdgeChromaticNumber[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the edge connectivity of the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeConnectivity.html
        ///</summary>
        corewolf::engine *EdgeConnectivity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EdgeConnectivity[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the s-t edge connectivity of the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeConnectivity.html
        ///</summary>
        corewolf::engine *EdgeConnectivity(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("EdgeConnectivity[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeConnectivity.html
        ///</summary>
        corewolf::engine *EdgeConnectivity(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EdgeConnectivity[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// contracts the edge e of the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeContract.html
        ///</summary>
        corewolf::engine *EdgeContract(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EdgeContract[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// contracts a collection of edges e1,e2,….
        /// https://reference.wolfram.com/language/ref/EdgeContract.html
        ///</summary>
        corewolf::engine *EdgeContract(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EdgeContract[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeContract.html
        ///</summary>
        corewolf::engine *EdgeContract(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EdgeContract[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a count of the number of edges in the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeCount.html
        ///</summary>
        corewolf::engine *EdgeCount(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EdgeCount[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a count of the number of edges that match the pattern patt.
        /// https://reference.wolfram.com/language/ref/EdgeCount.html
        ///</summary>
        corewolf::engine *EdgeCount(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EdgeCount[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeCount.html
        ///</summary>
        corewolf::engine *EdgeCount(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EdgeCount[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if the edge list elist is an edge cover of the graph g and False otherwise.
        /// https://reference.wolfram.com/language/ref/EdgeCoverQ.html
        ///</summary>
        corewolf::engine *EdgeCoverQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EdgeCoverQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the edge cycle matrix of a graph g.
        /// https://reference.wolfram.com/language/ref/EdgeCycleMatrix.html
        ///</summary>
        corewolf::engine *EdgeCycleMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EdgeCycleMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeCycleMatrix.html
        ///</summary>
        corewolf::engine *EdgeCycleMatrix(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("EdgeCycleMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a graph by deleting the edge e from the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeDelete.html
        ///</summary>
        corewolf::engine *EdgeDelete(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EdgeDelete[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// deletes a collection of edges from g.
        /// https://reference.wolfram.com/language/ref/EdgeDelete.html
        ///</summary>
        corewolf::engine *EdgeDelete(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EdgeDelete[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeDelete.html
        ///</summary>
        corewolf::engine *EdgeDelete(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EdgeDelete[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds edges in image and returns the result as a binary image.
        /// https://reference.wolfram.com/language/ref/EdgeDetect.html
        ///</summary>
        corewolf::engine *EdgeDetect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EdgeDetect[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds edges at the scale of the specified pixel range r.
        /// https://reference.wolfram.com/language/ref/EdgeDetect.html
        ///</summary>
        corewolf::engine *EdgeDetect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EdgeDetect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses a threshold t for selecting image edges.
        /// https://reference.wolfram.com/language/ref/EdgeDetect.html
        ///</summary>
        corewolf::engine *EdgeDetect(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("EdgeDetect[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a graphics directive that specifies that edges of polygons and other filled graphics objects are to be drawn using the graphics directive or list of directives g.
        /// https://reference.wolfram.com/language/ref/EdgeForm.html
        ///</summary>
        corewolf::engine *EdgeForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EdgeForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the integer index for the edge e in the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeIndex.html
        ///</summary>
        corewolf::engine *EdgeIndex(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EdgeIndex[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeIndex.html
        ///</summary>
        corewolf::engine *EdgeIndex(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EdgeIndex[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of edges for the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeList.html
        ///</summary>
        corewolf::engine *EdgeList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EdgeList[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of edges that match the pattern patt.
        /// https://reference.wolfram.com/language/ref/EdgeList.html
        ///</summary>
        corewolf::engine *EdgeList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EdgeList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeList.html
        ///</summary>
        corewolf::engine *EdgeList(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EdgeList[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if e is an edge in the graph g and False otherwise.
        /// https://reference.wolfram.com/language/ref/EdgeQ.html
        ///</summary>
        corewolf::engine *EdgeQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EdgeQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of edge rules for the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeRules.html
        ///</summary>
        corewolf::engine *EdgeRules(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EdgeRules[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeRules.html
        ///</summary>
        corewolf::engine *EdgeRules(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("EdgeRules[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// yields a graph with edges ej tagged with unique tags.
        /// https://reference.wolfram.com/language/ref/EdgeTaggedGraph.html
        ///</summary>
        corewolf::engine *EdgeTaggedGraph(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("EdgeTaggedGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// yields a graph with vertices vi and edges ej tagged with tj.
        /// https://reference.wolfram.com/language/ref/EdgeTaggedGraph.html
        ///</summary>
        corewolf::engine *EdgeTaggedGraph(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EdgeTaggedGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if the graph g has edges tagged and False otherwise.
        /// https://reference.wolfram.com/language/ref/EdgeTaggedGraphQ.html
        ///</summary>
        corewolf::engine *EdgeTaggedGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EdgeTaggedGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the list of tags for all edges in the graph g.
        /// https://reference.wolfram.com/language/ref/EdgeTags.html
        ///</summary>
        corewolf::engine *EdgeTags(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EdgeTags[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the list of tags for edges between u and v.
        /// https://reference.wolfram.com/language/ref/EdgeTags.html
        ///</summary>
        corewolf::engine *EdgeTags(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EdgeTags[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is a edge-transitive graph and False otherwise.
        /// https://reference.wolfram.com/language/ref/EdgeTransitiveGraphQ.html
        ///</summary>
        corewolf::engine *EdgeTransitiveGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EdgeTransitiveGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is an edge-weighted graph and False otherwise.
        /// https://reference.wolfram.com/language/ref/EdgeWeightedGraphQ.html
        ///</summary>
        corewolf::engine *EdgeWeightedGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EdgeWeightedGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the edit or Levenshtein distance between strings, vectors or biomolecular sequences u and v.
        /// https://reference.wolfram.com/language/ref/EditDistance.html
        ///</summary>
        corewolf::engine *EditDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EditDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the effective interest rate corresponding to interest specification r, compounded at time intervals q.
        /// https://reference.wolfram.com/language/ref/EffectiveInterest.html
        ///</summary>
        corewolf::engine *EffectiveInterest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EffectiveInterest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list {values,vectors} of the eigenvalues and eigenvectors of the square matrix m.
        /// https://reference.wolfram.com/language/ref/Eigensystem.html
        ///</summary>
        corewolf::engine *Eigensystem(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Eigensystem[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the generalized eigenvalues and eigenvectors of m with respect to a.
        /// https://reference.wolfram.com/language/ref/Eigensystem.html
        ///</summary>
        corewolf::engine *Eigensystem(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Eigensystem[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the eigenvalues and eigenvectors for the first k eigenvalues of m.
        /// https://reference.wolfram.com/language/ref/Eigensystem.html
        ///</summary>
        corewolf::engine *Eigensystem(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Eigensystem[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the first k generalized eigenvalues and eigenvectors.
        /// https://reference.wolfram.com/language/ref/Eigensystem.html
        ///</summary>
        corewolf::engine *Eigensystem(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Eigensystem[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the eigenvalues of the square matrix m.
        /// https://reference.wolfram.com/language/ref/Eigenvalues.html
        ///</summary>
        corewolf::engine *Eigenvalues(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Eigenvalues[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the generalized eigenvalues of m with respect to a.
        /// https://reference.wolfram.com/language/ref/Eigenvalues.html
        ///</summary>
        corewolf::engine *Eigenvalues(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Eigenvalues[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the first k eigenvalues of m.
        /// https://reference.wolfram.com/language/ref/Eigenvalues.html
        ///</summary>
        corewolf::engine *Eigenvalues(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Eigenvalues[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the first k generalized eigenvalues.
        /// https://reference.wolfram.com/language/ref/Eigenvalues.html
        ///</summary>
        corewolf::engine *Eigenvalues(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Eigenvalues[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of eigenvector centralities for the vertices in the graph g.
        /// https://reference.wolfram.com/language/ref/EigenvectorCentrality.html
        ///</summary>
        corewolf::engine *EigenvectorCentrality(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EigenvectorCentrality[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of in-centralities for a directed graph g.
        /// https://reference.wolfram.com/language/ref/EigenvectorCentrality.html
        ///</summary>
        corewolf::engine *EigenvectorCentrality(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EigenvectorCentrality[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/EigenvectorCentrality.html
        ///</summary>
        corewolf::engine *EigenvectorCentrality(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EigenvectorCentrality[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the eigenvectors of the square matrix m.
        /// https://reference.wolfram.com/language/ref/Eigenvectors.html
        ///</summary>
        corewolf::engine *Eigenvectors(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Eigenvectors[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the generalized eigenvectors of m with respect to a.
        /// https://reference.wolfram.com/language/ref/Eigenvectors.html
        ///</summary>
        corewolf::engine *Eigenvectors(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Eigenvectors[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the first k eigenvectors of m.
        /// https://reference.wolfram.com/language/ref/Eigenvectors.html
        ///</summary>
        corewolf::engine *Eigenvectors(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Eigenvectors[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the first k generalized eigenvectors.
        /// https://reference.wolfram.com/language/ref/Eigenvectors.html
        ///</summary>
        corewolf::engine *Eigenvectors(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Eigenvectors[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// or x∈dom asserts that x is an element of the domain dom.
        /// https://reference.wolfram.com/language/ref/Element.html
        ///</summary>
        corewolf::engine *Element(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Element[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the chemical element "name".
        /// https://reference.wolfram.com/language/ref/ElementData.html
        ///</summary>
        corewolf::engine *ElementData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ElementData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a net layer that applies a unary function f to every element of the input array.
        /// https://reference.wolfram.com/language/ref/ElementwiseLayer.html
        ///</summary>
        corewolf::engine *ElementwiseLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ElementwiseLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// eliminates variables between a set of simultaneous equations.
        /// https://reference.wolfram.com/language/ref/Eliminate.html
        ///</summary>
        corewolf::engine *Eliminate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Eliminate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an axis-aligned ellipsoid centered at the point p and with semiaxes lengths ri.
        /// https://reference.wolfram.com/language/ref/Ellipsoid.html
        ///</summary>
        corewolf::engine *Ellipsoid(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Ellipsoid[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an ellipsoid centered at p and weight matrix Σ.
        /// https://reference.wolfram.com/language/ref/Ellipsoid.html
        ///</summary>
        corewolf::engine *Ellipsoid(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Ellipsoid[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the complete elliptic integral .
        /// https://reference.wolfram.com/language/ref/EllipticE.html
        ///</summary>
        corewolf::engine *EllipticE(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EllipticE[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the elliptic integral of the second kind .
        /// https://reference.wolfram.com/language/ref/EllipticE.html
        ///</summary>
        corewolf::engine *EllipticE(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EllipticE[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is the inverse for EllipticLog. It produces a list {x,y} such that u==EllipticLog[{x,y},{a,b}].
        /// https://reference.wolfram.com/language/ref/EllipticExp.html
        ///</summary>
        corewolf::engine *EllipticExp(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EllipticExp[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the derivative of EllipticExp[u,{a,b}] with respect to u.
        /// https://reference.wolfram.com/language/ref/EllipticExpPrime.html
        ///</summary>
        corewolf::engine *EllipticExpPrime(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EllipticExpPrime[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the elliptic integral of the first kind .
        /// https://reference.wolfram.com/language/ref/EllipticF.html
        ///</summary>
        corewolf::engine *EllipticF(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EllipticF[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// designs a lowpass elliptic filter of order n.
        /// https://reference.wolfram.com/language/ref/EllipticFilterModel.html
        ///</summary>
        corewolf::engine *EllipticFilterModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EllipticFilterModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the cutoff frequency ωc.
        /// https://reference.wolfram.com/language/ref/EllipticFilterModel.html
        ///</summary>
        corewolf::engine *EllipticFilterModel(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("EllipticFilterModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// expresses the model in terms of the variable var.
        /// https://reference.wolfram.com/language/ref/EllipticFilterModel.html
        ///</summary>
        corewolf::engine *EllipticFilterModel(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EllipticFilterModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the complete elliptic integral of the first kind .
        /// https://reference.wolfram.com/language/ref/EllipticK.html
        ///</summary>
        corewolf::engine *EllipticK(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EllipticK[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the generalized logarithm associated with the elliptic curve .
        /// https://reference.wolfram.com/language/ref/EllipticLog.html
        ///</summary>
        corewolf::engine *EllipticLog(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EllipticLog[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the nome q corresponding to the parameter m in an elliptic function.
        /// https://reference.wolfram.com/language/ref/EllipticNomeQ.html
        ///</summary>
        corewolf::engine *EllipticNomeQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EllipticNomeQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the complete elliptic integral of the third kind Π(nm).
        /// https://reference.wolfram.com/language/ref/EllipticPi.html
        ///</summary>
        corewolf::engine *EllipticPi(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EllipticPi[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the incomplete elliptic integral Π(n;ϕm).
        /// https://reference.wolfram.com/language/ref/EllipticPi.html
        ///</summary>
        corewolf::engine *EllipticPi(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("EllipticPi[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the theta function .
        /// https://reference.wolfram.com/language/ref/EllipticTheta.html
        ///</summary>
        corewolf::engine *EllipticTheta(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("EllipticTheta[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the theta constant .
        /// https://reference.wolfram.com/language/ref/EllipticTheta.html
        ///</summary>
        corewolf::engine *EllipticTheta(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EllipticTheta[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the derivative with respect to u of the theta function .
        /// https://reference.wolfram.com/language/ref/EllipticThetaPrime.html
        ///</summary>
        corewolf::engine *EllipticThetaPrime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("EllipticThetaPrime[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the theta constant .
        /// https://reference.wolfram.com/language/ref/EllipticThetaPrime.html
        ///</summary>
        corewolf::engine *EllipticThetaPrime(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EllipticThetaPrime[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates the code necessary to embed the const std::string &obj on a webpage.
        /// https://reference.wolfram.com/language/ref/EmbedCode.html
        ///</summary>
        corewolf::engine *EmbedCode(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EmbedCode[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates code for an external environment or language of type "dest".
        /// https://reference.wolfram.com/language/ref/EmbedCode.html
        ///</summary>
        corewolf::engine *EmbedCode(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EmbedCode[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// saves the generated code as files in the directory dir.
        /// https://reference.wolfram.com/language/ref/EmbedCode.html
        ///</summary>
        corewolf::engine *EmbedCode(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("EmbedCode[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is an const std::string &that formats as a web frame containing the HTML content "string".
        /// https://reference.wolfram.com/language/ref/EmbeddedHTML.html
        ///</summary>
        corewolf::engine *EmbeddedHTML(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EmbeddedHTML[" + arg0 + "]", name);
        }

        ///< summary>
        /// is an const std::string &that formats as a web frame containing content from the specified external service.
        /// https://reference.wolfram.com/language/ref/EmbeddedService.html
        ///</summary>
        corewolf::engine *EmbeddedService(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EmbeddedService[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a verbatim SQL query to be interpreted as an entity class with properties given by props.
        /// https://reference.wolfram.com/language/ref/EmbeddedSQLEntityClass.html
        ///</summary>
        corewolf::engine *EmbeddedSQLEntityClass(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EmbeddedSQLEntityClass[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an SQL query string template with arguments provided by args.
        /// https://reference.wolfram.com/language/ref/EmbeddedSQLEntityClass.html
        ///</summary>
        corewolf::engine *EmbeddedSQLEntityClass(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("EmbeddedSQLEntityClass[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an SQL expression to be evaluated verbatim within an EntityFunction object.
        /// https://reference.wolfram.com/language/ref/EmbeddedSQLExpression.html
        ///</summary>
        corewolf::engine *EmbeddedSQLExpression(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EmbeddedSQLExpression[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an SQL expression string template with arguments provided by args.
        /// https://reference.wolfram.com/language/ref/EmbeddedSQLExpression.html
        ///</summary>
        corewolf::engine *EmbeddedSQLExpression(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EmbeddedSQLExpression[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a trainable net layer that embeds integers between 1 and n into a continuous vector space of dimension size.
        /// https://reference.wolfram.com/language/ref/EmbeddingLayer.html
        ///</summary>
        corewolf::engine *EmbeddingLayer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EmbeddingLayer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// leaves the n to be inferred from context.
        /// https://reference.wolfram.com/language/ref/EmbeddingLayer.html
        ///</summary>
        corewolf::engine *EmbeddingLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EmbeddingLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// emits the sound snd when evaluated.
        /// https://reference.wolfram.com/language/ref/EmitSound.html
        ///</summary>
        corewolf::engine *EmitSound(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EmitSound[" + arg0 + "]", name);
        }

        ///< summary>
        /// emits each of the sounds sndi in sequence.
        /// https://reference.wolfram.com/language/ref/EmitSound.html
        ///</summary>
        corewolf::engine *EmitSound(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("EmitSound[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents an empirical distribution based on the data values xi.
        /// https://reference.wolfram.com/language/ref/EmpiricalDistribution.html
        ///</summary>
        corewolf::engine *EmpiricalDistribution(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("EmpiricalDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a multivariate empirical distribution based on the data values {xi,yi,…}.
        /// https://reference.wolfram.com/language/ref/EmpiricalDistribution.html
        ///</summary>
        corewolf::engine *EmpiricalDistribution(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EmpiricalDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if g is an empty graph and False otherwise.
        /// https://reference.wolfram.com/language/ref/EmptyGraphQ.html
        ///</summary>
        corewolf::engine *EmptyGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EmptyGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the empty subset of .
        /// https://reference.wolfram.com/language/ref/EmptyRegion.html
        ///</summary>
        corewolf::engine *EmptyRegion(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EmptyRegion[" + arg0 + "]", name);
        }

        ///< summary>
        /// estimates the empty space function  for point data pdata at radius r.
        /// https://reference.wolfram.com/language/ref/EmptySpaceF.html
        ///</summary>
        corewolf::engine *EmptySpaceF(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EmptySpaceF[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates the function  that can be applied repeatedly to different radii r.
        /// https://reference.wolfram.com/language/ref/EmptySpaceF.html
        ///</summary>
        corewolf::engine *EmptySpaceF(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EmptySpaceF[" + arg0 + "]", name);
        }

        ///< summary>
        /// attempts to evaluate expr and return the result, but stops if it catches an error and returns a failure object.
        /// https://reference.wolfram.com/language/ref/Enclose.html
        ///</summary>
        corewolf::engine *Enclose(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Enclose[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies f to any failure const std::string &generated.
        /// https://reference.wolfram.com/language/ref/Enclose.html
        ///</summary>
        corewolf::engine *Enclose(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Enclose[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// only catches errors with explicitly specified tags matching form.
        /// https://reference.wolfram.com/language/ref/Enclose.html
        ///</summary>
        corewolf::engine *Enclose(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Enclose[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// writes an encoded version of the file source to the file dest.
        /// https://reference.wolfram.com/language/ref/Encode.html
        ///</summary>
        corewolf::engine *Encode(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Encode[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// decodes the file before reading its contents.
        /// https://reference.wolfram.com/language/ref/Encode.html
        ///</summary>
        corewolf::engine *Encode(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Encode[" + arg0 + "]", name);
        }

        ///< summary>
        /// produces an encoded file that must be read in using Get["dest","key"].
        /// https://reference.wolfram.com/language/ref/Encode.html
        ///</summary>
        corewolf::engine *Encode(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Encode[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// encrypts expr using the specified password, to give an encrypted object.
        /// https://reference.wolfram.com/language/ref/Encrypt.html
        ///</summary>
        corewolf::engine *Encrypt(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Encrypt[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// interactively requests a password with which to encrypt expr.
        /// https://reference.wolfram.com/language/ref/Encrypt.html
        ///</summary>
        corewolf::engine *Encrypt(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Encrypt[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents encrypted data generated by Encrypt.
        /// https://reference.wolfram.com/language/ref/EncryptedObject.html
        ///</summary>
        corewolf::engine *EncryptedObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EncryptedObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates an encrypted version of a file, using the specified password.
        /// https://reference.wolfram.com/language/ref/EncryptFile.html
        ///</summary>
        corewolf::engine *EncryptFile(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EncryptFile[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates an encrypted version of source, putting the result in target.
        /// https://reference.wolfram.com/language/ref/EncryptFile.html
        ///</summary>
        corewolf::engine *EncryptFile(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("EncryptFile[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the present context, and reverts to the previous one.
        /// https://reference.wolfram.com/language/ref/End.html
        ///</summary>
        corewolf::engine *End(const std::string &name = "")
        {
            return this->execute("End[]", name);
        }

        ///< summary>
        /// is a WSTP packet indicating the end of the Dialog subsession referenced by integer.
        /// https://reference.wolfram.com/language/ref/EndDialogPacket.html
        ///</summary>
        corewolf::engine *EndDialogPacket(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EndDialogPacket[" + arg0 + "]", name);
        }

        ///< summary>
        /// restores $Context and $ContextPath to their values before the preceding BeginPackage, and prepends the current context to the list $ContextPath.
        /// https://reference.wolfram.com/language/ref/EndPackage.html
        ///</summary>
        corewolf::engine *EndPackage(const std::string &name = "")
        {
            return this->execute("EndPackage[]", name);
        }

        ///< summary>
        /// prints with all real numbers in expr given in engineering notation.
        /// https://reference.wolfram.com/language/ref/EngineeringForm.html
        ///</summary>
        corewolf::engine *EngineeringForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EngineeringForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints with numbers given to n‐digit precision.
        /// https://reference.wolfram.com/language/ref/EngineeringForm.html
        ///</summary>
        corewolf::engine *EngineeringForm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EngineeringForm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a WSTP packet that requests the evaluation of expr.
        /// https://reference.wolfram.com/language/ref/EnterExpressionPacket.html
        ///</summary>
        corewolf::engine *EnterExpressionPacket(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EnterExpressionPacket[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a WSTP packet that requests the parsing and evaluation of string as an expression.
        /// https://reference.wolfram.com/language/ref/EnterTextPacket.html
        ///</summary>
        corewolf::engine *EnterTextPacket(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EnterTextPacket[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an entity of the specified type, identified by name.
        /// https://reference.wolfram.com/language/ref/Entity.html
        ///</summary>
        corewolf::engine *Entity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Entity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a class of entities of the specified type identified by name.
        /// https://reference.wolfram.com/language/ref/EntityClass.html
        ///</summary>
        corewolf::engine *EntityClass(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EntityClass[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an implicitly defined entity class containing entities of the specified type for which the properties propertyi conform to the value selector vspeci.
        /// https://reference.wolfram.com/language/ref/EntityClass.html
        ///</summary>
        corewolf::engine *EntityClass(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EntityClass[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of entity classes for the specified type of entity.
        /// https://reference.wolfram.com/language/ref/EntityClassList.html
        ///</summary>
        corewolf::engine *EntityClassList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EntityClassList[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents n copies of entity.
        /// https://reference.wolfram.com/language/ref/EntityCopies.html
        ///</summary>
        corewolf::engine *EntityCopies(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EntityCopies[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a function with a single formal parameter x, to be used in EntityValue and related functions.
        /// https://reference.wolfram.com/language/ref/EntityFunction.html
        ///</summary>
        corewolf::engine *EntityFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EntityFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is an EntityFunction with a list of formal parameters.
        /// https://reference.wolfram.com/language/ref/EntityFunction.html
        ///</summary>
        corewolf::engine *EntityFunction(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EntityFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a group of entities.
        /// https://reference.wolfram.com/language/ref/EntityGroup.html
        ///</summary>
        corewolf::engine *EntityGroup(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("EntityGroup[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents an entity whose qualifier qual has value val.
        /// https://reference.wolfram.com/language/ref/EntityInstance.html
        ///</summary>
        corewolf::engine *EntityInstance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EntityInstance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an entity whose qualifiers quali have values vali.
        /// https://reference.wolfram.com/language/ref/EntityInstance.html
        ///</summary>
        corewolf::engine *EntityInstance(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EntityInstance[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of entities in the specified entity class.
        /// https://reference.wolfram.com/language/ref/EntityList.html
        ///</summary>
        corewolf::engine *EntityList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EntityList[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of entities; simplify determines whether to reduce entities to the simplest possible type.
        /// https://reference.wolfram.com/language/ref/EntityList.html
        ///</summary>
        corewolf::engine *EntityList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EntityList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// fetches cacheable values associated with all entities of the specified type.
        /// https://reference.wolfram.com/language/ref/EntityPrefetch.html
        ///</summary>
        corewolf::engine *EntityPrefetch(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EntityPrefetch[" + arg0 + "]", name);
        }

        ///< summary>
        /// lists properties associated with entity type type.
        /// https://reference.wolfram.com/language/ref/EntityProperties.html
        ///</summary>
        corewolf::engine *EntityProperties(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EntityProperties[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a property identified by pname for use in EntityValue.
        /// https://reference.wolfram.com/language/ref/EntityProperty.html
        ///</summary>
        corewolf::engine *EntityProperty(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EntityProperty[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a property modified by the qualifier rules qualivali.
        /// https://reference.wolfram.com/language/ref/EntityProperty.html
        ///</summary>
        corewolf::engine *EntityProperty(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("EntityProperty[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a class of properties identified by the name pcname.
        /// https://reference.wolfram.com/language/ref/EntityPropertyClass.html
        ///</summary>
        corewolf::engine *EntityPropertyClass(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EntityPropertyClass[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// registers the entities in the entity store estore so that they can be accessed directly using Entity.
        /// https://reference.wolfram.com/language/ref/EntityRegister.html
        ///</summary>
        corewolf::engine *EntityRegister(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EntityRegister[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an empty entity store for entities of type "type".
        /// https://reference.wolfram.com/language/ref/EntityStore.html
        ///</summary>
        corewolf::engine *EntityStore(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EntityStore[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an entity store for entities of multiple types.
        /// https://reference.wolfram.com/language/ref/EntityStore.html
        ///</summary>
        corewolf::engine *EntityStore(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("EntityStore[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// constructs an entity store by mapping table names in the database specified by dbspec to types as specified by the tspeci.
        /// https://reference.wolfram.com/language/ref/EntityStore.html
        ///</summary>
        corewolf::engine *EntityStore(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EntityStore[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of all registered entity stores that are accessed when Entity is used.
        /// https://reference.wolfram.com/language/ref/EntityStores.html
        ///</summary>
        corewolf::engine *EntityStores(const std::string &name = "")
        {
            return this->execute("EntityStores[]", name);
        }

        ///< summary>
        /// gives the name of the entity type of entity.
        /// https://reference.wolfram.com/language/ref/EntityTypeName.html
        ///</summary>
        corewolf::engine *EntityTypeName(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EntityTypeName[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the name of the entity type for entity1 through entityn.
        /// https://reference.wolfram.com/language/ref/EntityTypeName.html
        ///</summary>
        corewolf::engine *EntityTypeName(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("EntityTypeName[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// unregisters all entities in the first entity store that defines entities of the specified type.
        /// https://reference.wolfram.com/language/ref/EntityUnregister.html
        ///</summary>
        corewolf::engine *EntityUnregister(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EntityUnregister[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the given entity.
        /// https://reference.wolfram.com/language/ref/EntityValue.html
        ///</summary>
        corewolf::engine *EntityValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EntityValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of values of the specified property for each of the entityi.
        /// https://reference.wolfram.com/language/ref/EntityValue.html
        ///</summary>
        corewolf::engine *EntityValue(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EntityValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of values of the propertyi for the specified entity.
        /// https://reference.wolfram.com/language/ref/EntityValue.html
        ///</summary>
        corewolf::engine *EntityValue(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EntityValue[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the base  information entropy of the values in list.
        /// https://reference.wolfram.com/language/ref/Entropy.html
        ///</summary>
        corewolf::engine *Entropy(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Entropy[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the base k information entropy.
        /// https://reference.wolfram.com/language/ref/Entropy.html
        ///</summary>
        corewolf::engine *Entropy(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Entropy[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// filters data by replacing every value by the entropy value in its range-r neighborhood.
        /// https://reference.wolfram.com/language/ref/EntropyFilter.html
        ///</summary>
        corewolf::engine *EntropyFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EntropyFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses ri for filtering the dimension in data.
        /// https://reference.wolfram.com/language/ref/EntropyFilter.html
        ///</summary>
        corewolf::engine *EntropyFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EntropyFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of an operating system environment variable.
        /// https://reference.wolfram.com/language/ref/Environment.html
        ///</summary>
        corewolf::engine *Environment(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Environment[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/EqualTilde.html
        ///</summary>
        corewolf::engine *EqualTilde(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("EqualTilde[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is an operator form that yields x==y when applied to an expression x.
        /// https://reference.wolfram.com/language/ref/EqualTo.html
        ///</summary>
        corewolf::engine *EqualTo(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EqualTo[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Equilibrium.html
        ///</summary>
        corewolf::engine *Equilibrium(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Equilibrium[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// creates a finite impulse response (FIR) filter kernel of length n with an equiripple amplitude response, given the specified left and right band edge frequencies {ωLi,ωRi} and amplitudes ai.
        /// https://reference.wolfram.com/language/ref/EquirippleFilterKernel.html
        ///</summary>
        corewolf::engine *EquirippleFilterKernel(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("EquirippleFilterKernel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// uses relative weights wi for each frequency band.
        /// https://reference.wolfram.com/language/ref/EquirippleFilterKernel.html
        ///</summary>
        corewolf::engine *EquirippleFilterKernel(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("EquirippleFilterKernel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// creates a filter of the specified "type".
        /// https://reference.wolfram.com/language/ref/EquirippleFilterKernel.html
        ///</summary>
        corewolf::engine *EquirippleFilterKernel(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("EquirippleFilterKernel[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the logical equivalence e1⇔e2⇔…, giving True when all of the ei are the same.
        /// https://reference.wolfram.com/language/ref/Equivalent.html
        ///</summary>
        corewolf::engine *Equivalent(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Equivalent[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the error function .
        /// https://reference.wolfram.com/language/ref/Erf.html
        ///</summary>
        corewolf::engine *Erf(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Erf[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the generalized error function .
        /// https://reference.wolfram.com/language/ref/Erf.html
        ///</summary>
        corewolf::engine *Erf(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Erf[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the complementary error function .
        /// https://reference.wolfram.com/language/ref/Erfc.html
        ///</summary>
        corewolf::engine *Erfc(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Erfc[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the imaginary error function .
        /// https://reference.wolfram.com/language/ref/Erfi.html
        ///</summary>
        corewolf::engine *Erfi(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Erfi[" + arg0 + "]", name);
        }

        ///< summary>
        /// computes the Erlang B loss probability for an M/M/c/c queue.
        /// https://reference.wolfram.com/language/ref/ErlangB.html
        ///</summary>
        corewolf::engine *ErlangB(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ErlangB[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes the Erlang C probability for nonzero waiting time in an M/M/c queue.
        /// https://reference.wolfram.com/language/ref/ErlangC.html
        ///</summary>
        corewolf::engine *ErlangC(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ErlangC[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the Erlang distribution with shape parameter k and rate λ.
        /// https://reference.wolfram.com/language/ref/ErlangDistribution.html
        ///</summary>
        corewolf::engine *ErlangDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ErlangDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the morphological erosion of image with respect to the structuring element ker.
        /// https://reference.wolfram.com/language/ref/Erosion.html
        ///</summary>
        corewolf::engine *Erosion(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Erosion[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a low-level box construct that represents boxes that cannot be interpreted in input or output.
        /// https://reference.wolfram.com/language/ref/ErrorBox.html
        ///</summary>
        corewolf::engine *ErrorBox(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ErrorBox[" + arg0 + "]", name);
        }

        ///< summary>
        /// estimates the background of data.
        /// https://reference.wolfram.com/language/ref/EstimatedBackground.html
        ///</summary>
        corewolf::engine *EstimatedBackground(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EstimatedBackground[" + arg0 + "]", name);
        }

        ///< summary>
        /// tries to preserve peaks up to scale σ.
        /// https://reference.wolfram.com/language/ref/EstimatedBackground.html
        ///</summary>
        corewolf::engine *EstimatedBackground(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EstimatedBackground[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// estimates the parametric distribution dist from data.
        /// https://reference.wolfram.com/language/ref/EstimatedDistribution.html
        ///</summary>
        corewolf::engine *EstimatedDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EstimatedDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// estimates the parameters p, q, … with starting values p0, q0, ….
        /// https://reference.wolfram.com/language/ref/EstimatedDistribution.html
        ///</summary>
        corewolf::engine *EstimatedDistribution(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("EstimatedDistribution[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// estimates distribution dist with starting values taken from the instantiated distribution idist.
        /// https://reference.wolfram.com/language/ref/EstimatedDistribution.html
        ///</summary>
        corewolf::engine *EstimatedDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("EstimatedDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// estimates normal vectors for the points p1,p2,….
        /// https://reference.wolfram.com/language/ref/EstimatedPointNormals.html
        ///</summary>
        corewolf::engine *EstimatedPointNormals(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("EstimatedPointNormals[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// estimates normals vectors for the vertices of the mesh region mreg.
        /// https://reference.wolfram.com/language/ref/EstimatedPointNormals.html
        ///</summary>
        corewolf::engine *EstimatedPointNormals(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EstimatedPointNormals[" + arg0 + "]", name);
        }

        ///< summary>
        /// estimates the parametric point process pproc from point data pdata.
        /// https://reference.wolfram.com/language/ref/EstimatedPointProcess.html
        ///</summary>
        corewolf::engine *EstimatedPointProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EstimatedPointProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// estimates the parameters p, q, … with starting values p0, q0, ….
        /// https://reference.wolfram.com/language/ref/EstimatedPointProcess.html
        ///</summary>
        corewolf::engine *EstimatedPointProcess(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("EstimatedPointProcess[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// estimates the parametric process proc from data.
        /// https://reference.wolfram.com/language/ref/EstimatedProcess.html
        ///</summary>
        corewolf::engine *EstimatedProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EstimatedProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// estimates the parameters p, q, … with starting values p0, q0, ….
        /// https://reference.wolfram.com/language/ref/EstimatedProcess.html
        ///</summary>
        corewolf::engine *EstimatedProcess(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("EstimatedProcess[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// estimates process proc with starting values taken from the instantiated process iproc.
        /// https://reference.wolfram.com/language/ref/EstimatedProcess.html
        ///</summary>
        corewolf::engine *EstimatedProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("EstimatedProcess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// estimates the best variogram function from values vali given at locations loci.
        /// https://reference.wolfram.com/language/ref/EstimatedVariogramModel.html
        ///</summary>
        corewolf::engine *EstimatedVariogramModel(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("EstimatedVariogramModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// estimates the best parameters of the variogram function specified by "model".
        /// https://reference.wolfram.com/language/ref/EstimatedVariogramModel.html
        ///</summary>
        corewolf::engine *EstimatedVariogramModel(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EstimatedVariogramModel[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// estimates the non-numeric parameters in params.
        /// https://reference.wolfram.com/language/ref/EstimatedVariogramModel.html
        ///</summary>
        corewolf::engine *EstimatedVariogramModel(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EstimatedVariogramModel[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the estimator gain matrix for the StateSpaceModel ssm, such that the poles of the estimator are pi.
        /// https://reference.wolfram.com/language/ref/EstimatorGains.html
        ///</summary>
        corewolf::engine *EstimatorGains(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EstimatorGains[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// specifies the measured outputs outi to use.
        /// https://reference.wolfram.com/language/ref/EstimatorGains.html
        ///</summary>
        corewolf::engine *EstimatorGains(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("EstimatorGains[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the output feedback controller with estimator and regulator gains l and κ for the system specification sspec.
        /// https://reference.wolfram.com/language/ref/EstimatorRegulator.html
        ///</summary>
        corewolf::engine *EstimatorRegulator(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EstimatorRegulator[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the property "prop".
        /// https://reference.wolfram.com/language/ref/EstimatorRegulator.html
        ///</summary>
        corewolf::engine *EstimatorRegulator(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EstimatorRegulator[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Euclidean distance between vectors u and v.
        /// https://reference.wolfram.com/language/ref/EuclideanDistance.html
        ///</summary>
        corewolf::engine *EuclideanDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EuclideanDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives Euler angles {α,β,γ} corresponding to the rotation matrix r.
        /// https://reference.wolfram.com/language/ref/EulerAngles.html
        ///</summary>
        corewolf::engine *EulerAngles(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EulerAngles[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives Euler angles {α,β,γ} with rotation order {a,b,c}.
        /// https://reference.wolfram.com/language/ref/EulerAngles.html
        ///</summary>
        corewolf::engine *EulerAngles(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EulerAngles[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Euler characteristic of a poly.
        /// https://reference.wolfram.com/language/ref/EulerCharacteristic.html
        ///</summary>
        corewolf::engine *EulerCharacteristic(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EulerCharacteristic[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Euler number .
        /// https://reference.wolfram.com/language/ref/EulerE.html
        ///</summary>
        corewolf::engine *EulerE(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EulerE[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Euler polynomial .
        /// https://reference.wolfram.com/language/ref/EulerE.html
        ///</summary>
        corewolf::engine *EulerE(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EulerE[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is Eulerian, and False otherwise.
        /// https://reference.wolfram.com/language/ref/EulerianGraphQ.html
        ///</summary>
        corewolf::engine *EulerianGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EulerianGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Euler 3D rotation matrix formed by rotating by α around the current  axis, then by β around the current  axis, and then by γ around the current  axis.
        /// https://reference.wolfram.com/language/ref/EulerMatrix.html
        ///</summary>
        corewolf::engine *EulerMatrix(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("EulerMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Euler 3D rotation matrix corresponding, first rotating by α around the current a axis, then by β around the current b axis, and finally by γ around the current c axis.
        /// https://reference.wolfram.com/language/ref/EulerMatrix.html
        ///</summary>
        corewolf::engine *EulerMatrix(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EulerMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Euler totient function .
        /// https://reference.wolfram.com/language/ref/EulerPhi.html
        ///</summary>
        corewolf::engine *EulerPhi(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EulerPhi[" + arg0 + "]", name);
        }

        ///< summary>
        /// causes expr to be evaluated even if it appears as the argument of a function whose attributes specify that it should be held unevaluated.
        /// https://reference.wolfram.com/language/ref/Evaluate.html
        ///</summary>
        corewolf::engine *Evaluate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Evaluate[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a WSTP packet requesting evaluation of expr.
        /// https://reference.wolfram.com/language/ref/EvaluatePacket.html
        ///</summary>
        corewolf::engine *EvaluatePacket(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EvaluatePacket[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a BoxObject corresponding to the box structure in which this function is being evaluated.
        /// https://reference.wolfram.com/language/ref/EvaluationBox.html
        ///</summary>
        corewolf::engine *EvaluationBox(const std::string &name = "")
        {
            return this->execute("EvaluationBox[]", name);
        }

        ///< summary>
        /// returns a CellObject corresponding to the cell in which this function is being evaluated.
        /// https://reference.wolfram.com/language/ref/EvaluationCell.html
        ///</summary>
        corewolf::engine *EvaluationCell(const std::string &name = "")
        {
            return this->execute("EvaluationCell[]", name);
        }

        ///< summary>
        /// gives an association containing the result of evaluating expr and metadata about the process of doing so.
        /// https://reference.wolfram.com/language/ref/EvaluationData.html
        ///</summary>
        corewolf::engine *EvaluationData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EvaluationData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the notebook in which this function is being evaluated.
        /// https://reference.wolfram.com/language/ref/EvaluationNotebook.html
        ///</summary>
        corewolf::engine *EvaluationNotebook(const std::string &name = "")
        {
            return this->execute("EvaluationNotebook[]", name);
        }

        ///< summary>
        /// represents an expression submitted for evaluation on any available parallel kernel.
        /// https://reference.wolfram.com/language/ref/EvaluationObject.html
        ///</summary>
        corewolf::engine *EvaluationObject(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("EvaluationObject[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives True if expr is an even integer, and False otherwise.
        /// https://reference.wolfram.com/language/ref/EvenQ.html
        ///</summary>
        corewolf::engine *EvenQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("EvenQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents event data with explicitly specified censoring ei.
        /// https://reference.wolfram.com/language/ref/EventData.html
        ///</summary>
        corewolf::engine *EventData(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("EventData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents event data ei with censoring indicators cii.
        /// https://reference.wolfram.com/language/ref/EventData.html
        ///</summary>
        corewolf::engine *EventData(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EventData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents event data with censoring and truncation tri.
        /// https://reference.wolfram.com/language/ref/EventData.html
        ///</summary>
        corewolf::engine *EventData(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("EventData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// displays as expr, evaluating actioni whenever "eventi" occurs in connection with expr.
        /// https://reference.wolfram.com/language/ref/EventHandler.html
        ///</summary>
        corewolf::engine *EventHandler(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EventHandler[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a series of events given as time-value pairs {ti,vi}.
        /// https://reference.wolfram.com/language/ref/EventSeries.html
        ///</summary>
        corewolf::engine *EventSeries(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("EventSeries[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a series of events with values vi at times specified by tspec.
        /// https://reference.wolfram.com/language/ref/EventSeries.html
        ///</summary>
        corewolf::engine *EventSeries(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("EventSeries[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an exact Blackman window function of x.
        /// https://reference.wolfram.com/language/ref/ExactBlackmanWindow.html
        ///</summary>
        corewolf::engine *ExactBlackmanWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExactBlackmanWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if expr is an exact real or complex number, and returns False otherwise.
        /// https://reference.wolfram.com/language/ref/ExactNumberQ.html
        ///</summary>
        corewolf::engine *ExactNumberQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExactNumberQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of names of examples of the specified type.
        /// https://reference.wolfram.com/language/ref/ExampleData.html
        ///</summary>
        corewolf::engine *ExampleData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExampleData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the default form of the named example of the specified type.
        /// https://reference.wolfram.com/language/ref/ExampleData.html
        ///</summary>
        corewolf::engine *ExampleData(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ExampleData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the specified element or property of an example.
        /// https://reference.wolfram.com/language/ref/ExampleData.html
        ///</summary>
        corewolf::engine *ExampleData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExampleData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a pattern const std::string &which represents any expression except one that matches c.
        /// https://reference.wolfram.com/language/ref/Except.html
        ///</summary>
        corewolf::engine *Except(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Except[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents any expression that matches p but not c.
        /// https://reference.wolfram.com/language/ref/Except.html
        ///</summary>
        corewolf::engine *Except(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Except[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the statement that there exists a value of x for which expr is True.
        /// https://reference.wolfram.com/language/ref/Exists.html
        ///</summary>
        corewolf::engine *Exists(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Exists[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// states that there exists an x satisfying the condition cond for which expr is True.
        /// https://reference.wolfram.com/language/ref/Exists.html
        ///</summary>
        corewolf::engine *Exists(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Exists[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// states that there exist values for all the  for which expr is True.
        /// https://reference.wolfram.com/language/ref/Exists.html
        ///</summary>
        corewolf::engine *Exists(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Exists[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// terminates a Wolfram Language kernel session.
        /// https://reference.wolfram.com/language/ref/Exit.html
        ///</summary>
        corewolf::engine *Exit(const std::string &name = "")
        {
            return this->execute("Exit[]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the exoplanet entity.
        /// https://reference.wolfram.com/language/ref/ExoplanetData.html
        ///</summary>
        corewolf::engine *ExoplanetData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExoplanetData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified exoplanet entities.
        /// https://reference.wolfram.com/language/ref/ExoplanetData.html
        ///</summary>
        corewolf::engine *ExoplanetData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExoplanetData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/ExoplanetData.html
        ///</summary>
        corewolf::engine *ExoplanetData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ExoplanetData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the exponential of z.
        /// https://reference.wolfram.com/language/ref/Exp.html
        ///</summary>
        corewolf::engine *Exp(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Exp[" + arg0 + "]", name);
        }

        ///< summary>
        /// expands out products and positive integer powers in expr.
        /// https://reference.wolfram.com/language/ref/Expand.html
        ///</summary>
        corewolf::engine *Expand(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Expand[" + arg0 + "]", name);
        }

        ///< summary>
        /// leaves unexpanded any parts of expr that are free of the pattern patt. »
        /// https://reference.wolfram.com/language/ref/Expand.html
        ///</summary>
        corewolf::engine *Expand(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Expand[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// expands out all products and integer powers in any part of expr.
        /// https://reference.wolfram.com/language/ref/ExpandAll.html
        ///</summary>
        corewolf::engine *ExpandAll(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExpandAll[" + arg0 + "]", name);
        }

        ///< summary>
        /// avoids expanding parts of expr that do not contain terms matching the pattern patt.
        /// https://reference.wolfram.com/language/ref/ExpandAll.html
        ///</summary>
        corewolf::engine *ExpandAll(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExpandAll[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// expands out products and powers that appear as denominators in expr.
        /// https://reference.wolfram.com/language/ref/ExpandDenominator.html
        ///</summary>
        corewolf::engine *ExpandDenominator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExpandDenominator[" + arg0 + "]", name);
        }

        ///< summary>
        /// textually expands name to have the form of an absolute file name for your operating system.
        /// https://reference.wolfram.com/language/ref/ExpandFileName.html
        ///</summary>
        corewolf::engine *ExpandFileName(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExpandFileName[" + arg0 + "]", name);
        }

        ///< summary>
        /// expands out products and powers that appear in the numerator of expr.
        /// https://reference.wolfram.com/language/ref/ExpandNumerator.html
        ///</summary>
        corewolf::engine *ExpandNumerator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExpandNumerator[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the expectation of expr under the assumption that x follows the probability distribution dist.
        /// https://reference.wolfram.com/language/ref/Expectation.html
        ///</summary>
        corewolf::engine *Expectation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Expectation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the expectation of expr under the assumption that x1, x2, … are independent and follow the distributions dist1, dist2, ….
        /// https://reference.wolfram.com/language/ref/Expectation.html
        ///</summary>
        corewolf::engine *Expectation(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Expectation[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an exp-gamma distribution with shape parameter κ, scale parameter θ, and location parameter μ.
        /// https://reference.wolfram.com/language/ref/ExpGammaDistribution.html
        ///</summary>
        corewolf::engine *ExpGammaDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ExpGammaDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the exponential integral function .
        /// https://reference.wolfram.com/language/ref/ExpIntegralE.html
        ///</summary>
        corewolf::engine *ExpIntegralE(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExpIntegralE[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the exponential integral function .
        /// https://reference.wolfram.com/language/ref/ExpIntegralEi.html
        ///</summary>
        corewolf::engine *ExpIntegralEi(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExpIntegralEi[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the maximum power with which form appears in the expanded form of expr.
        /// https://reference.wolfram.com/language/ref/Exponent.html
        ///</summary>
        corewolf::engine *Exponent(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Exponent[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies h to the set of exponents with which form appears in expr.
        /// https://reference.wolfram.com/language/ref/Exponent.html
        ///</summary>
        corewolf::engine *Exponent(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Exponent[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an exponential distribution with scale inversely proportional to parameter λ.
        /// https://reference.wolfram.com/language/ref/ExponentialDistribution.html
        ///</summary>
        corewolf::engine *ExponentialDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExponentialDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the exponential generating function in x for the sequence whose n term is given by the expression expr.
        /// https://reference.wolfram.com/language/ref/ExponentialGeneratingFunction.html
        ///</summary>
        corewolf::engine *ExponentialGeneratingFunction(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ExponentialGeneratingFunction[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional exponential generating function in x1, x2, … whose n1, n2, … term is given by expr.
        /// https://reference.wolfram.com/language/ref/ExponentialGeneratingFunction.html
        ///</summary>
        corewolf::engine *ExponentialGeneratingFunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ExponentialGeneratingFunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the exponential moving average of list with smoothing constant α.
        /// https://reference.wolfram.com/language/ref/ExponentialMovingAverage.html
        ///</summary>
        corewolf::engine *ExponentialMovingAverage(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExponentialMovingAverage[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an exponential power distribution with shape parameter κ, location parameter μ, and scale parameter σ.
        /// https://reference.wolfram.com/language/ref/ExponentialPowerDistribution.html
        ///</summary>
        corewolf::engine *ExponentialPowerDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ExponentialPowerDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an exponential power distribution with location parameter 0 and scale parameter 1.
        /// https://reference.wolfram.com/language/ref/ExponentialPowerDistribution.html
        ///</summary>
        corewolf::engine *ExponentialPowerDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExponentialPowerDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// exports data to a file, converting it to the format corresponding to the file extension ext.
        /// https://reference.wolfram.com/language/ref/Export.html
        ///</summary>
        corewolf::engine *Export(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Export[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// exports data in the specified format "fmt".
        /// https://reference.wolfram.com/language/ref/Export.html
        ///</summary>
        corewolf::engine *Export(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Export[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses the specified options.
        /// https://reference.wolfram.com/language/ref/Export.html
        ///</summary>
        corewolf::engine *Export(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Export[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// generates a ByteArray const std::string &corresponding to expr exported in the specified format.
        /// https://reference.wolfram.com/language/ref/ExportByteArray.html
        ///</summary>
        corewolf::engine *ExportByteArray(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExportByteArray[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies that expr should be exported in the specified format in functions like CloudDeploy and in external results from APIFunction and FormFunction.
        /// https://reference.wolfram.com/language/ref/ExportForm.html
        ///</summary>
        corewolf::engine *ExportForm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExportForm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies that when expr is exported, it should be tagged as having the specified MIME type.
        /// https://reference.wolfram.com/language/ref/ExportForm.html
        ///</summary>
        corewolf::engine *ExportForm(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ExportForm[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a string corresponding to expr exported in the specified format.
        /// https://reference.wolfram.com/language/ref/ExportString.html
        ///</summary>
        corewolf::engine *ExportString(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExportString[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives explicit rules for different elements of the data to be exported.
        /// https://reference.wolfram.com/language/ref/ExportString.html
        ///</summary>
        corewolf::engine *ExportString(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ExportString[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives an expression cell that can appear in a Wolfram System notebook.
        /// https://reference.wolfram.com/language/ref/ExpressionCell.html
        ///</summary>
        corewolf::engine *ExpressionCell(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExpressionCell[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an expression cell with the specified style.
        /// https://reference.wolfram.com/language/ref/ExpressionCell.html
        ///</summary>
        corewolf::engine *ExpressionCell(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExpressionCell[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an expression cell with multiple styles applied to it.
        /// https://reference.wolfram.com/language/ref/ExpressionCell.html
        ///</summary>
        corewolf::engine *ExpressionCell(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ExpressionCell[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the tree graph with different levels at different depths.
        /// https://reference.wolfram.com/language/ref/ExpressionGraph.html
        ///</summary>
        corewolf::engine *ExpressionGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExpressionGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the tree graph only down to level n.
        /// https://reference.wolfram.com/language/ref/ExpressionGraph.html
        ///</summary>
        corewolf::engine *ExpressionGraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExpressionGraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a tree graph in which subexpressions that match form are leaves.
        /// https://reference.wolfram.com/language/ref/ExpressionGraph.html
        ///</summary>
        corewolf::engine *ExpressionGraph(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ExpressionGraph[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a Tree const std::string &from the structure of the expression expr.
        /// https://reference.wolfram.com/language/ref/ExpressionTree.html
        ///</summary>
        corewolf::engine *ExpressionTree(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExpressionTree[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a Tree const std::string &from the expression expr with data and subtrees as specified by struct.
        /// https://reference.wolfram.com/language/ref/ExpressionTree.html
        ///</summary>
        corewolf::engine *ExpressionTree(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExpressionTree[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts exponentials in expr to trigonometric functions.
        /// https://reference.wolfram.com/language/ref/ExpToTrig.html
        ///</summary>
        corewolf::engine *ExpToTrig(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExpToTrig[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an entity class derived from class by adding a new computed property "name" whose value for each entity is obtained by applying the entity function f.
        /// https://reference.wolfram.com/language/ref/ExtendedEntityClass.html
        ///</summary>
        corewolf::engine *ExtendedEntityClass(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExtendedEntityClass[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// adds the properties namei defined by the functions fi.
        /// https://reference.wolfram.com/language/ref/ExtendedEntityClass.html
        ///</summary>
        corewolf::engine *ExtendedEntityClass(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ExtendedEntityClass[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the extended greatest common divisor of the integers ni.
        /// https://reference.wolfram.com/language/ref/ExtendedGCD.html
        ///</summary>
        corewolf::engine *ExtendedGCD(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ExtendedGCD[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a bundle of resources to be externally deployed as named URLs, functions, etc.
        /// https://reference.wolfram.com/language/ref/ExternalBundle.html
        ///</summary>
        corewolf::engine *ExternalBundle(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ExternalBundle[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates the command cmd in the external evaluator sys, returning an expression corresponding to the output.
        /// https://reference.wolfram.com/language/ref/ExternalEvaluate.html
        ///</summary>
        corewolf::engine *ExternalEvaluate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExternalEvaluate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the options opts for the external evaluator.
        /// https://reference.wolfram.com/language/ref/ExternalEvaluate.html
        ///</summary>
        corewolf::engine *ExternalEvaluate(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExternalEvaluate[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates the list of commands cmdi.
        /// https://reference.wolfram.com/language/ref/ExternalEvaluate.html
        ///</summary>
        corewolf::engine *ExternalEvaluate(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ExternalEvaluate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an operator form of ExternalEvaluate that can be applied to a command or object.
        /// https://reference.wolfram.com/language/ref/ExternalEvaluate.html
        ///</summary>
        corewolf::engine *ExternalEvaluate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExternalEvaluate[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an external function named "f" defined in the external evaluator sys.
        /// https://reference.wolfram.com/language/ref/ExternalFunction.html
        ///</summary>
        corewolf::engine *ExternalFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExternalFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a resource identified by id in the external identifier system "type".
        /// https://reference.wolfram.com/language/ref/ExternalIdentifier.html
        ///</summary>
        corewolf::engine *ExternalIdentifier(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExternalIdentifier[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// includes the metadata given by the association meta to this instance of the external identifier object.
        /// https://reference.wolfram.com/language/ref/ExternalIdentifier.html
        ///</summary>
        corewolf::engine *ExternalIdentifier(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ExternalIdentifier[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an external const std::string &inside an ExternalSessionObject.
        /// https://reference.wolfram.com/language/ref/ExternalObject.html
        ///</summary>
        corewolf::engine *ExternalObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExternalObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an external session started by StartExternalSession for use with ExternalEvaluate.
        /// https://reference.wolfram.com/language/ref/ExternalSessionObject.html
        ///</summary>
        corewolf::engine *ExternalSessionObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExternalSessionObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the list of currently active external evaluator sessions.
        /// https://reference.wolfram.com/language/ref/ExternalSessions.html
        ///</summary>
        corewolf::engine *ExternalSessions(const std::string &name = "")
        {
            return this->execute("ExternalSessions[]", name);
        }

        ///< summary>
        /// gives the list of sessions associated with the system sys.
        /// https://reference.wolfram.com/language/ref/ExternalSessions.html
        ///</summary>
        corewolf::engine *ExternalSessions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExternalSessions[" + arg0 + "]", name);
        }

        ///< summary>
        /// downloads content from the specified location.
        /// https://reference.wolfram.com/language/ref/ExternalStorageDownload.html
        ///</summary>
        corewolf::engine *ExternalStorageDownload(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExternalStorageDownload[" + arg0 + "]", name);
        }

        ///< summary>
        /// downloads content from the specified location to a local destination file or directory dest.
        /// https://reference.wolfram.com/language/ref/ExternalStorageDownload.html
        ///</summary>
        corewolf::engine *ExternalStorageDownload(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExternalStorageDownload[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// downloads content from the specified locations to local destination dest.
        /// https://reference.wolfram.com/language/ref/ExternalStorageDownload.html
        ///</summary>
        corewolf::engine *ExternalStorageDownload(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExternalStorageDownload[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// downloads content from the specified locations to local destinations.
        /// https://reference.wolfram.com/language/ref/ExternalStorageDownload.html
        ///</summary>
        corewolf::engine *ExternalStorageDownload(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ExternalStorageDownload[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// reads in an expression stored at an external storage specified by the ExternalStorageObject.
        /// https://reference.wolfram.com/language/ref/ExternalStorageGet.html
        ///</summary>
        corewolf::engine *ExternalStorageGet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExternalStorageGet[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a file stored in an external location.
        /// https://reference.wolfram.com/language/ref/ExternalStorageObject.html
        ///</summary>
        corewolf::engine *ExternalStorageObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExternalStorageObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a file stored in an external location with additional elements given by assoc.
        /// https://reference.wolfram.com/language/ref/ExternalStorageObject.html
        ///</summary>
        corewolf::engine *ExternalStorageObject(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExternalStorageObject[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// writes expr to an external storage specified by $ExternalStorageBase.
        /// https://reference.wolfram.com/language/ref/ExternalStoragePut.html
        ///</summary>
        corewolf::engine *ExternalStoragePut(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExternalStoragePut[" + arg0 + "]", name);
        }

        ///< summary>
        /// writes expr to a specific path in an external storage specified by $ExternalStorageBase.
        /// https://reference.wolfram.com/language/ref/ExternalStoragePut.html
        ///</summary>
        corewolf::engine *ExternalStoragePut(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExternalStoragePut[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uploads file to an external storage specified by $ExternalStorageBase.
        /// https://reference.wolfram.com/language/ref/ExternalStorageUpload.html
        ///</summary>
        corewolf::engine *ExternalStorageUpload(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExternalStorageUpload[" + arg0 + "]", name);
        }

        ///< summary>
        /// uploads file to a specific destination dest for external storage services that support it.
        /// https://reference.wolfram.com/language/ref/ExternalStorageUpload.html
        ///</summary>
        corewolf::engine *ExternalStorageUpload(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExternalStorageUpload[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uploads a list of files to a specific destination dest for external storage services that support it.
        /// https://reference.wolfram.com/language/ref/ExternalStorageUpload.html
        ///</summary>
        corewolf::engine *ExternalStorageUpload(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExternalStorageUpload[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uploads a list of files to specific destinations for external storage services that support it.
        /// https://reference.wolfram.com/language/ref/ExternalStorageUpload.html
        ///</summary>
        corewolf::engine *ExternalStorageUpload(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ExternalStorageUpload[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of "sym" in external evaluator sys.
        /// https://reference.wolfram.com/language/ref/ExternalValue.html
        ///</summary>
        corewolf::engine *ExternalValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExternalValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// extracts the part of expr at the position specified by pos.
        /// https://reference.wolfram.com/language/ref/Extract.html
        ///</summary>
        corewolf::engine *Extract(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Extract[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// extracts a list of parts of expr.
        /// https://reference.wolfram.com/language/ref/Extract.html
        ///</summary>
        corewolf::engine *Extract(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Extract[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// extracts parts of expr, wrapping each of them with head h before evaluation.
        /// https://reference.wolfram.com/language/ref/Extract.html
        ///</summary>
        corewolf::engine *Extract(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Extract[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of Extract that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/Extract.html
        ///</summary>
        corewolf::engine *Extract(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Extract[" + arg0 + "]", name);
        }

        ///< summary>
        /// expands an archive file, saving its content into the current directory.
        /// https://reference.wolfram.com/language/ref/ExtractArchive.html
        ///</summary>
        corewolf::engine *ExtractArchive(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExtractArchive[" + arg0 + "]", name);
        }

        ///< summary>
        /// saves the content of an archive file into directory dir.
        /// https://reference.wolfram.com/language/ref/ExtractArchive.html
        ///</summary>
        corewolf::engine *ExtractArchive(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExtractArchive[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// extracts only files whose names match pattern.
        /// https://reference.wolfram.com/language/ref/ExtractArchive.html
        ///</summary>
        corewolf::engine *ExtractArchive(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ExtractArchive[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a net layer that takes an array and a position specification as inputs and extracts the specified parts from the array.
        /// https://reference.wolfram.com/language/ref/ExtractLayer.html
        ///</summary>
        corewolf::engine *ExtractLayer(const std::string &name = "")
        {
            return this->execute("ExtractLayer[]", name);
        }

        ///< summary>
        /// extracts the contents of the paclet archive file into the directory in which file resides.
        /// https://reference.wolfram.com/language/ref/ExtractPacletArchive.html
        ///</summary>
        corewolf::engine *ExtractPacletArchive(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ExtractPacletArchive[" + arg0 + "]", name);
        }

        ///< summary>
        /// extracts the contents of the paclet archive file into destdir.
        /// https://reference.wolfram.com/language/ref/ExtractPacletArchive.html
        ///</summary>
        corewolf::engine *ExtractPacletArchive(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExtractPacletArchive[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an extreme value distribution with location parameter α and scale parameter β.
        /// https://reference.wolfram.com/language/ref/ExtremeValueDistribution.html
        ///</summary>
        corewolf::engine *ExtremeValueDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ExtremeValueDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an extreme value distribution with location parameter 0 and scale parameter 1.
        /// https://reference.wolfram.com/language/ref/ExtremeValueDistribution.html
        ///</summary>
        corewolf::engine *ExtremeValueDistribution(const std::string &name = "")
        {
            return this->execute("ExtremeValueDistribution[]", name);
        }

        ///< summary>
        /// attempts to find faces in image and align them.
        /// https://reference.wolfram.com/language/ref/FaceAlign.html
        ///</summary>
        corewolf::engine *FaceAlign(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FaceAlign[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives aligned faces according to the face reference fref.
        /// https://reference.wolfram.com/language/ref/FaceAlign.html
        ///</summary>
        corewolf::engine *FaceAlign(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FaceAlign[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives aligned faces of the specified size.
        /// https://reference.wolfram.com/language/ref/FaceAlign.html
        ///</summary>
        corewolf::engine *FaceAlign(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FaceAlign[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of aligned faces for all imagei.
        /// https://reference.wolfram.com/language/ref/FaceAlign.html
        ///</summary>
        corewolf::engine *FaceAlign(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FaceAlign[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a graphics directive which specifies that faces of polygons and other filled graphics objects are to be drawn using the graphics directive or list of directives g.
        /// https://reference.wolfram.com/language/ref/FaceForm.html
        ///</summary>
        corewolf::engine *FaceForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FaceForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies that the front faces of three-dimensional polygons should be drawn with directives g, and the backs with directives gback.
        /// https://reference.wolfram.com/language/ref/FaceForm.html
        ///</summary>
        corewolf::engine *FaceForm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FaceForm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a ClassifierFunction[…] based on the face examples and names given.
        /// https://reference.wolfram.com/language/ref/FaceRecognize.html
        ///</summary>
        corewolf::engine *FaceRecognize(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FaceRecognize[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// uses an association of names with their examples.
        /// https://reference.wolfram.com/language/ref/FaceRecognize.html
        ///</summary>
        corewolf::engine *FaceRecognize(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FaceRecognize[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// attempts to find faces present in an image and classify them with the given training set.
        /// https://reference.wolfram.com/language/ref/FaceRecognize.html
        ///</summary>
        corewolf::engine *FaceRecognize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FaceRecognize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a minimal summary of facial features for all detected faces in image.
        /// https://reference.wolfram.com/language/ref/FacialFeatures.html
        ///</summary>
        corewolf::engine *FacialFeatures(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FacialFeatures[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the specified facial features.
        /// https://reference.wolfram.com/language/ref/FacialFeatures.html
        ///</summary>
        corewolf::engine *FacialFeatures(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FacialFeatures[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// factors a polynomial over the integers.
        /// https://reference.wolfram.com/language/ref/Factor.html
        ///</summary>
        corewolf::engine *Factor(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Factor[" + arg0 + "]", name);
        }

        ///< summary>
        /// factors a polynomial modulo a prime p.
        /// https://reference.wolfram.com/language/ref/Factor.html
        ///</summary>
        corewolf::engine *Factor(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Factor[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the r moment of the elements in the list.
        /// https://reference.wolfram.com/language/ref/FactorialMoment.html
        ///</summary>
        corewolf::engine *FactorialMoment(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FactorialMoment[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the r factorial moment.
        /// https://reference.wolfram.com/language/ref/FactorialMoment.html
        ///</summary>
        corewolf::engine *FactorialMoment(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FactorialMoment[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the factorial moment-generating function for the distribution dist as a function of the variable t.
        /// https://reference.wolfram.com/language/ref/FactorialMomentGeneratingFunction.html
        ///</summary>
        corewolf::engine *FactorialMomentGeneratingFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FactorialMomentGeneratingFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the factorial moment-generating function for the multivariate distribution dist as a function of the variables t1, t2, ….
        /// https://reference.wolfram.com/language/ref/FactorialMomentGeneratingFunction.html
        ///</summary>
        corewolf::engine *FactorialMomentGeneratingFunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FactorialMomentGeneratingFunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the factorial power .
        /// https://reference.wolfram.com/language/ref/FactorialPower.html
        ///</summary>
        corewolf::engine *FactorialPower(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FactorialPower[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the step-h factorial power .
        /// https://reference.wolfram.com/language/ref/FactorialPower.html
        ///</summary>
        corewolf::engine *FactorialPower(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FactorialPower[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of the prime factors of the integer n, together with their exponents.
        /// https://reference.wolfram.com/language/ref/FactorInteger.html
        ///</summary>
        corewolf::engine *FactorInteger(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FactorInteger[" + arg0 + "]", name);
        }

        ///< summary>
        /// does partial factorization, pulling out at most k distinct factors.
        /// https://reference.wolfram.com/language/ref/FactorInteger.html
        ///</summary>
        corewolf::engine *FactorInteger(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FactorInteger[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the factors of a polynomial, together with their exponents.
        /// https://reference.wolfram.com/language/ref/FactorList.html
        ///</summary>
        corewolf::engine *FactorList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FactorList[" + arg0 + "]", name);
        }

        ///< summary>
        /// pulls out any multiple factors in a polynomial.
        /// https://reference.wolfram.com/language/ref/FactorSquareFree.html
        ///</summary>
        corewolf::engine *FactorSquareFree(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FactorSquareFree[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of square‐free factors of a polynomial, together with their exponents.
        /// https://reference.wolfram.com/language/ref/FactorSquareFreeList.html
        ///</summary>
        corewolf::engine *FactorSquareFreeList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FactorSquareFreeList[" + arg0 + "]", name);
        }

        ///< summary>
        /// pulls out any overall numerical factor in poly.
        /// https://reference.wolfram.com/language/ref/FactorTerms.html
        ///</summary>
        corewolf::engine *FactorTerms(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FactorTerms[" + arg0 + "]", name);
        }

        ///< summary>
        /// pulls out any overall factor in poly that does not depend on x.
        /// https://reference.wolfram.com/language/ref/FactorTerms.html
        ///</summary>
        corewolf::engine *FactorTerms(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FactorTerms[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// pulls out any overall factor in poly that does not depend on any of the xi.
        /// https://reference.wolfram.com/language/ref/FactorTerms.html
        ///</summary>
        corewolf::engine *FactorTerms(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FactorTerms[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list in which the first element is the overall numerical factor in poly, and the second element is the polynomial with the overall factor removed.
        /// https://reference.wolfram.com/language/ref/FactorTermsList.html
        ///</summary>
        corewolf::engine *FactorTermsList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FactorTermsList[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of factors of poly. The first element in the list is the overall numerical factor. The second element is a factor that does not depend on any of the xi. Subsequent elements are factors which depend on progressively more of the xi.
        /// https://reference.wolfram.com/language/ref/FactorTermsList.html
        ///</summary>
        corewolf::engine *FactorTermsList(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FactorTermsList[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a failure of a type indicated by tag, with details given by the association assoc.
        /// https://reference.wolfram.com/language/ref/Failure.html
        ///</summary>
        corewolf::engine *Failure(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Failure[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the failure distribution for a system with events xi having reliability distribution disti where the top event occurs when the Boolean expression bexpr is True and event xi has occurred when xi is True.
        /// https://reference.wolfram.com/language/ref/FailureDistribution.html
        ///</summary>
        corewolf::engine *FailureDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FailureDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives True if expr has head Failure or is equal to $Failed or $Aborted.
        /// https://reference.wolfram.com/language/ref/FailureQ.html
        ///</summary>
        corewolf::engine *FailureQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FailureQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates the Farey sequence of order n.
        /// https://reference.wolfram.com/language/ref/FareySequence.html
        ///</summary>
        corewolf::engine *FareySequence(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FareySequence[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the k element of the Farey sequence of order n.
        /// https://reference.wolfram.com/language/ref/FareySequence.html
        ///</summary>
        corewolf::engine *FareySequence(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FareySequence[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an autoregressive fractionally integrated moving-average process  such that its d difference is an ARMAProcess[{a1,…,ap},{b1,…,bq,v].
        /// https://reference.wolfram.com/language/ref/FARIMAProcess.html
        ///</summary>
        corewolf::engine *FARIMAProcess(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FARIMAProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a vector autoregressive fractionally integrated moving-average process (y1(t),… ,yn(t)) such that its (d1,…,dn) difference is a vector ARMAProcess.
        /// https://reference.wolfram.com/language/ref/FARIMAProcess.html
        ///</summary>
        corewolf::engine *FARIMAProcess(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FARIMAProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the distance between example1 and example2 in the feature space defined by extractor.
        /// https://reference.wolfram.com/language/ref/FeatureDistance.html
        ///</summary>
        corewolf::engine *FeatureDistance(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FeatureDistance[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of FeatureDistance that can be applied to a pair of examples.
        /// https://reference.wolfram.com/language/ref/FeatureDistance.html
        ///</summary>
        corewolf::engine *FeatureDistance(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FeatureDistance[" + arg0 + "]", name);
        }

        ///< summary>
        /// extracts features for each of the examplei using a feature extractor trained on all the examplei.
        /// https://reference.wolfram.com/language/ref/FeatureExtract.html
        ///</summary>
        corewolf::engine *FeatureExtract(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FeatureExtract[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// extracts features using the specified feature extractor method.
        /// https://reference.wolfram.com/language/ref/FeatureExtract.html
        ///</summary>
        corewolf::engine *FeatureExtract(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FeatureExtract[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// extracts features by applying the extractori in sequence.
        /// https://reference.wolfram.com/language/ref/FeatureExtract.html
        ///</summary>
        corewolf::engine *FeatureExtract(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FeatureExtract[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a FeatureExtractorFunction[…] trained from the examples given.
        /// https://reference.wolfram.com/language/ref/FeatureExtraction.html
        ///</summary>
        corewolf::engine *FeatureExtraction(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FeatureExtraction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// uses the specified feature extractor method.
        /// https://reference.wolfram.com/language/ref/FeatureExtraction.html
        ///</summary>
        corewolf::engine *FeatureExtraction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FeatureExtraction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies the extractori in sequence to generate a feature extractor.
        /// https://reference.wolfram.com/language/ref/FeatureExtraction.html
        ///</summary>
        corewolf::engine *FeatureExtraction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FeatureExtraction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the feature extraction properties specified by props.
        /// https://reference.wolfram.com/language/ref/FeatureExtraction.html
        ///</summary>
        corewolf::engine *FeatureExtraction(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FeatureExtraction[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a feature extractor function generated by FeatureExtraction.
        /// https://reference.wolfram.com/language/ref/FeatureExtractorFunction.html
        ///</summary>
        corewolf::engine *FeatureExtractorFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FeatureExtractorFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots the impact of the value of each feature in data on the result of model.
        /// https://reference.wolfram.com/language/ref/FeatureImpactPlot.html
        ///</summary>
        corewolf::engine *FeatureImpactPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FeatureImpactPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// estimates the feature impacts using synthetic data.
        /// https://reference.wolfram.com/language/ref/FeatureImpactPlot.html
        ///</summary>
        corewolf::engine *FeatureImpactPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FeatureImpactPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the list of elemi to which x is nearest in a computed feature space.
        /// https://reference.wolfram.com/language/ref/FeatureNearest.html
        ///</summary>
        corewolf::engine *FeatureNearest(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FeatureNearest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the property prop for the elemi to which x is nearest.
        /// https://reference.wolfram.com/language/ref/FeatureNearest.html
        ///</summary>
        corewolf::engine *FeatureNearest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FeatureNearest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// effectively gives {FeatureNearest[data,x1],FeatureNearest[data,x2],…}.
        /// https://reference.wolfram.com/language/ref/FeatureNearest.html
        ///</summary>
        corewolf::engine *FeatureNearest(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FeatureNearest[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the n nearest elemi to x.
        /// https://reference.wolfram.com/language/ref/FeatureNearest.html
        ///</summary>
        corewolf::engine *FeatureNearest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FeatureNearest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a NearestFunction[…] that can be applied repeatedly to different x.
        /// https://reference.wolfram.com/language/ref/FeatureNearest.html
        ///</summary>
        corewolf::engine *FeatureNearest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FeatureNearest[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots features extracted from the examplei as a scatter plot.
        /// https://reference.wolfram.com/language/ref/FeatureSpacePlot.html
        ///</summary>
        corewolf::engine *FeatureSpacePlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FeatureSpacePlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots features extracted from the examplei as a scatter 3D plot.
        /// https://reference.wolfram.com/language/ref/FeatureSpacePlot3D.html
        ///</summary>
        corewolf::engine *FeatureSpacePlot3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FeatureSpacePlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots the dependency of the result of model on the value of a particular feature in data.
        /// https://reference.wolfram.com/language/ref/FeatureValueDependencyPlot.html
        ///</summary>
        corewolf::engine *FeatureValueDependencyPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FeatureValueDependencyPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// estimates the feature value dependency using synthetic data.
        /// https://reference.wolfram.com/language/ref/FeatureValueDependencyPlot.html
        ///</summary>
        corewolf::engine *FeatureValueDependencyPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FeatureValueDependencyPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots the impact of the value of a given feature in data on the result of model.
        /// https://reference.wolfram.com/language/ref/FeatureValueImpactPlot.html
        ///</summary>
        corewolf::engine *FeatureValueImpactPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FeatureValueImpactPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// estimates the feature value impact using synthetic data.
        /// https://reference.wolfram.com/language/ref/FeatureValueImpactPlot.html
        ///</summary>
        corewolf::engine *FeatureValueImpactPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FeatureValueImpactPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// input-output linearizes the AffineStateSpaceModel asys by state transformation and feedback.
        /// https://reference.wolfram.com/language/ref/FeedbackLinearize.html
        ///</summary>
        corewolf::engine *FeedbackLinearize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FeedbackLinearize[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies the new states z and the new control inputs v.
        /// https://reference.wolfram.com/language/ref/FeedbackLinearize.html
        ///</summary>
        corewolf::engine *FeedbackLinearize(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FeedbackLinearize[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// computes the property "prop".
        /// https://reference.wolfram.com/language/ref/FeedbackLinearize.html
        ///</summary>
        corewolf::engine *FeedbackLinearize(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FeedbackLinearize[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the values for all properties of fetal development for the specified age of the fetus.
        /// https://reference.wolfram.com/language/ref/FetalGrowthData.html
        ///</summary>
        corewolf::engine *FetalGrowthData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FetalGrowthData[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the value for a property of fetal development for the specified age.
        /// https://reference.wolfram.com/language/ref/FetalGrowthData.html
        ///</summary>
        corewolf::engine *FetalGrowthData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FetalGrowthData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value for a property at the specified age and percentile.
        /// https://reference.wolfram.com/language/ref/FetalGrowthData.html
        ///</summary>
        corewolf::engine *FetalGrowthData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FetalGrowthData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Fibonacci number .
        /// https://reference.wolfram.com/language/ref/Fibonacci.html
        ///</summary>
        corewolf::engine *Fibonacci(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Fibonacci[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Fibonacci polynomial .
        /// https://reference.wolfram.com/language/ref/Fibonacci.html
        ///</summary>
        corewolf::engine *Fibonacci(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Fibonacci[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the fibonorial .
        /// https://reference.wolfram.com/language/ref/Fibonorial.html
        ///</summary>
        corewolf::engine *Fibonorial(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Fibonorial[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a symbolic representation of a location in the local file system.
        /// https://reference.wolfram.com/language/ref/File.html
        ///</summary>
        corewolf::engine *File(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("File[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the base name for a file without its extension.
        /// https://reference.wolfram.com/language/ref/FileBaseName.html
        ///</summary>
        corewolf::engine *FileBaseName(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileBaseName[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number of bytes in a file.
        /// https://reference.wolfram.com/language/ref/FileByteCount.html
        ///</summary>
        corewolf::engine *FileByteCount(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileByteCount[" + arg0 + "]", name);
        }

        ///< summary>
        /// converts the contents of source to the format defined by the extension ext and writes the result to the file dest.ext.
        /// https://reference.wolfram.com/language/ref/FileConvert.html
        ///</summary>
        corewolf::engine *FileConvert(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileConvert[" + arg0 + "]", name);
        }

        ///< summary>
        /// writes the result to the filename defined by source, but with an extension defined by the specified format.
        /// https://reference.wolfram.com/language/ref/FileConvert.html
        ///</summary>
        corewolf::engine *FileConvert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FileConvert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the date and time at which a file was last modified.
        /// https://reference.wolfram.com/language/ref/FileDate.html
        ///</summary>
        corewolf::engine *FileDate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileDate[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives information on the specified type of date associated with a file.
        /// https://reference.wolfram.com/language/ref/FileDate.html
        ///</summary>
        corewolf::engine *FileDate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FileDate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if the file with the specified name exists, and gives False otherwise.
        /// https://reference.wolfram.com/language/ref/FileExistsQ.html
        ///</summary>
        corewolf::engine *FileExistsQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileExistsQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the file extension for a file name.
        /// https://reference.wolfram.com/language/ref/FileExtension.html
        ///</summary>
        corewolf::engine *FileExtension(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileExtension[" + arg0 + "]", name);
        }

        ///< summary>
        /// attempts to determine what Import format could be used to import the file corresponding to source.
        /// https://reference.wolfram.com/language/ref/FileFormat.html
        ///</summary>
        corewolf::engine *FileFormat(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileFormat[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the first "fmti" that can be used to import source.
        /// https://reference.wolfram.com/language/ref/FileFormat.html
        ///</summary>
        corewolf::engine *FileFormat(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FileFormat[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns an association of properties for the specified format "fmt".
        /// https://reference.wolfram.com/language/ref/FileFormatProperties.html
        ///</summary>
        corewolf::engine *FileFormatProperties(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileFormatProperties[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the property "prop" for the format "fmt".
        /// https://reference.wolfram.com/language/ref/FileFormatProperties.html
        ///</summary>
        corewolf::engine *FileFormatProperties(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FileFormatProperties[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns multiple properties.
        /// https://reference.wolfram.com/language/ref/FileFormatProperties.html
        ///</summary>
        corewolf::engine *FileFormatProperties(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FileFormatProperties[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives True if the file corresponding to source might be imported as format "fmt" and gives False otherwise.
        /// https://reference.wolfram.com/language/ref/FileFormatQ.html
        ///</summary>
        corewolf::engine *FileFormatQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FileFormatQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if source might be imported as one of "fmti".
        /// https://reference.wolfram.com/language/ref/FileFormatQ.html
        ///</summary>
        corewolf::engine *FileFormatQ(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FileFormatQ[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives an integer hash code for the contents of the specified file.
        /// https://reference.wolfram.com/language/ref/FileHash.html
        ///</summary>
        corewolf::engine *FileHash(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileHash[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an integer hash of the specified type.
        /// https://reference.wolfram.com/language/ref/FileHash.html
        ///</summary>
        corewolf::engine *FileHash(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FileHash[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a hash code in the specified format.
        /// https://reference.wolfram.com/language/ref/FileHash.html
        ///</summary>
        corewolf::engine *FileHash(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FileHash[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the hash code for the specified range of bytes.
        /// https://reference.wolfram.com/language/ref/FileHash.html
        ///</summary>
        corewolf::engine *FileHash(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FileHash[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the number of path elements in the file name "file".
        /// https://reference.wolfram.com/language/ref/FileNameDepth.html
        ///</summary>
        corewolf::engine *FileNameDepth(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileNameDepth[" + arg0 + "]", name);
        }

        ///< summary>
        /// drops the first n path elements in the file name "name".
        /// https://reference.wolfram.com/language/ref/FileNameDrop.html
        ///</summary>
        corewolf::engine *FileNameDrop(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FileNameDrop[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// drops elements m through n in the file name "name".
        /// https://reference.wolfram.com/language/ref/FileNameDrop.html
        ///</summary>
        corewolf::engine *FileNameDrop(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FileNameDrop[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// drops the last path element in the file name "name".
        /// https://reference.wolfram.com/language/ref/FileNameDrop.html
        ///</summary>
        corewolf::engine *FileNameDrop(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileNameDrop[" + arg0 + "]", name);
        }

        ///< summary>
        /// joins the namei together into a file name suitable for your current operating system.
        /// https://reference.wolfram.com/language/ref/FileNameJoin.html
        ///</summary>
        corewolf::engine *FileNameJoin(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FileNameJoin[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// lists all files in the current working directory.
        /// https://reference.wolfram.com/language/ref/FileNames.html
        ///</summary>
        corewolf::engine *FileNames(const std::string &name = "")
        {
            return this->execute("FileNames[]", name);
        }

        ///< summary>
        /// lists all files in the current working directory whose names match the string pattern form.
        /// https://reference.wolfram.com/language/ref/FileNames.html
        ///</summary>
        corewolf::engine *FileNames(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileNames[" + arg0 + "]", name);
        }

        ///< summary>
        /// lists all files whose names match any of the formi.
        /// https://reference.wolfram.com/language/ref/FileNames.html
        ///</summary>
        corewolf::engine *FileNames(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FileNames[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// lists all files in the directory dir.
        /// https://reference.wolfram.com/language/ref/FileNames.html
        ///</summary>
        corewolf::engine *FileNames(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FileNames[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// lists files with names matching forms in any of the directories diri.
        /// https://reference.wolfram.com/language/ref/FileNames.html
        ///</summary>
        corewolf::engine *FileNames(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FileNames[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// includes files that are in subdirectories up to n levels down.
        /// https://reference.wolfram.com/language/ref/FileNames.html
        ///</summary>
        corewolf::engine *FileNames(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FileNames[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a file name setter which displays as a Browse button and when clicked brings up a system file opening dialog, starting from the location corresponding to name.
        /// https://reference.wolfram.com/language/ref/FileNameSetter.html
        ///</summary>
        corewolf::engine *FileNameSetter(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileNameSetter[" + arg0 + "]", name);
        }

        ///< summary>
        /// brings up a file saving dialog.
        /// https://reference.wolfram.com/language/ref/FileNameSetter.html
        ///</summary>
        corewolf::engine *FileNameSetter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FileNameSetter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// looks for files of types typei with names matching the file patterns pattij.
        /// https://reference.wolfram.com/language/ref/FileNameSetter.html
        ///</summary>
        corewolf::engine *FileNameSetter(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FileNameSetter[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// splits a file name into a list of parts.
        /// https://reference.wolfram.com/language/ref/FileNameSplit.html
        ///</summary>
        corewolf::engine *FileNameSplit(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileNameSplit[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the last path element in the file name "name".
        /// https://reference.wolfram.com/language/ref/FileNameTake.html
        ///</summary>
        corewolf::engine *FileNameTake(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileNameTake[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the first n path elements in the file name "name".
        /// https://reference.wolfram.com/language/ref/FileNameTake.html
        ///</summary>
        corewolf::engine *FileNameTake(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FileNameTake[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives elements m through n in the file name "name".
        /// https://reference.wolfram.com/language/ref/FileNameTake.html
        ///</summary>
        corewolf::engine *FileNameTake(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FileNameTake[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns lists of file formats corresponding to all registered file name patterns.
        /// https://reference.wolfram.com/language/ref/FileNameToFormatList.html
        ///</summary>
        corewolf::engine *FileNameToFormatList(const std::string &name = "")
        {
            return this->execute("FileNameToFormatList[]", name);
        }

        ///< summary>
        /// returns a list of file formats that matches the file name "file".
        /// https://reference.wolfram.com/language/ref/FileNameToFormatList.html
        ///</summary>
        corewolf::engine *FileNameToFormatList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileNameToFormatList[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints out the raw textual contents of file.
        /// https://reference.wolfram.com/language/ref/FilePrint.html
        ///</summary>
        corewolf::engine *FilePrint(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FilePrint[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints out the first n raw textual lines of file.
        /// https://reference.wolfram.com/language/ref/FilePrint.html
        ///</summary>
        corewolf::engine *FilePrint(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FilePrint[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the size of a file as a quantity.
        /// https://reference.wolfram.com/language/ref/FileSize.html
        ///</summary>
        corewolf::engine *FileSize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileSize[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an association whose keys are the names of files in root, and whose values are the results of applying f to the full names of these files.
        /// https://reference.wolfram.com/language/ref/FileSystemMap.html
        ///</summary>
        corewolf::engine *FileSystemMap(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FileSystemMap[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a nested association in which subdirectories down to level n are represented by an association.
        /// https://reference.wolfram.com/language/ref/FileSystemMap.html
        ///</summary>
        corewolf::engine *FileSystemMap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FileSystemMap[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a nested association including files in subdirectories from level m down through n.
        /// https://reference.wolfram.com/language/ref/FileSystemMap.html
        ///</summary>
        corewolf::engine *FileSystemMap(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FileSystemMap[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// combines levels to give a nested output association with r levels.
        /// https://reference.wolfram.com/language/ref/FileSystemMap.html
        ///</summary>
        corewolf::engine *FileSystemMap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FileSystemMap[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// evaluates f on all files contained in root.
        /// https://reference.wolfram.com/language/ref/FileSystemScan.html
        ///</summary>
        corewolf::engine *FileSystemScan(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FileSystemScan[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// restricts the operation to directories at level n.
        /// https://reference.wolfram.com/language/ref/FileSystemScan.html
        ///</summary>
        corewolf::engine *FileSystemScan(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FileSystemScan[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields a TemplateObject expression that represents a file template to be applied using functions like TemplateApply.
        /// https://reference.wolfram.com/language/ref/FileTemplate.html
        ///</summary>
        corewolf::engine *FileTemplate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileTemplate[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields a TemplateObject with arguments, suitable for cloud deployment or other evaluation.
        /// https://reference.wolfram.com/language/ref/FileTemplate.html
        ///</summary>
        corewolf::engine *FileTemplate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FileTemplate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies a template, evaluating all template elements it contains, and then writes the result to a temporary file, whose name is returned.
        /// https://reference.wolfram.com/language/ref/FileTemplateApply.html
        ///</summary>
        corewolf::engine *FileTemplateApply(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileTemplateApply[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies a template, using args to fill its slots, and then writes the result to a temporary file.
        /// https://reference.wolfram.com/language/ref/FileTemplateApply.html
        ///</summary>
        corewolf::engine *FileTemplateApply(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FileTemplateApply[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies a template, using args to fill its slots, and then writes the result to the file represented by output.
        /// https://reference.wolfram.com/language/ref/FileTemplateApply.html
        ///</summary>
        corewolf::engine *FileTemplateApply(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FileTemplateApply[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the type of a file, typically File, Directory, or None.
        /// https://reference.wolfram.com/language/ref/FileType.html
        ///</summary>
        corewolf::engine *FileType(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FileType[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a filled curve consisting of segment1 followed by segment2 etc.
        /// https://reference.wolfram.com/language/ref/FilledCurve.html
        ///</summary>
        corewolf::engine *FilledCurve(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FilledCurve[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a filled torus centered at {x,y,z} with inner radius rinner and outer radius router.
        /// https://reference.wolfram.com/language/ref/FilledTorus.html
        ///</summary>
        corewolf::engine *FilledTorus(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FilledTorus[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a version of image with all extended minima filled.
        /// https://reference.wolfram.com/language/ref/FillingTransform.html
        ///</summary>
        corewolf::engine *FillingTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FillingTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// fills extended minima in regions where at least one corresponding element of marker is nonzero.
        /// https://reference.wolfram.com/language/ref/FillingTransform.html
        ///</summary>
        corewolf::engine *FillingTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FillingTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a class of entities where only entities for which the EntityFunction const std::string &f yields True are kept.
        /// https://reference.wolfram.com/language/ref/FilteredEntityClass.html
        ///</summary>
        corewolf::engine *FilteredEntityClass(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FilteredEntityClass[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// filters the list rules by picking out only those rules whose left-hand sides match patt.
        /// https://reference.wolfram.com/language/ref/FilterRules.html
        ///</summary>
        corewolf::engine *FilterRules(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FilterRules[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// picks out rules whose left-hand sides match any of the patti.
        /// https://reference.wolfram.com/language/ref/FilterRules.html
        ///</summary>
        corewolf::engine *FilterRules(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FilterRules[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of a financial bond instrument.
        /// https://reference.wolfram.com/language/ref/FinancialBond.html
        ///</summary>
        corewolf::engine *FinancialBond(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FinancialBond[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes the specified property prop.
        /// https://reference.wolfram.com/language/ref/FinancialBond.html
        ///</summary>
        corewolf::engine *FinancialBond(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FinancialBond[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the last known price or value for the financial entity specified by "name".
        /// https://reference.wolfram.com/language/ref/FinancialData.html
        ///</summary>
        corewolf::engine *FinancialData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FinancialData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of dates and daily closing values for "name" from start until the current date.
        /// https://reference.wolfram.com/language/ref/FinancialData.html
        ///</summary>
        corewolf::engine *FinancialData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FinancialData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of dates and daily closing values for dates from start to end.
        /// https://reference.wolfram.com/language/ref/FinancialData.html
        ///</summary>
        corewolf::engine *FinancialData(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FinancialData[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of dates and values of a property for a sequence of dates or periods.
        /// https://reference.wolfram.com/language/ref/FinancialData.html
        ///</summary>
        corewolf::engine *FinancialData(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FinancialData[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the specified financial instrument.
        /// https://reference.wolfram.com/language/ref/FinancialDerivative.html
        ///</summary>
        corewolf::engine *FinancialDerivative(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FinancialDerivative[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes the specified property prop.
        /// https://reference.wolfram.com/language/ref/FinancialDerivative.html
        ///</summary>
        corewolf::engine *FinancialDerivative(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FinancialDerivative[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a financial indicator "ind" with parameters par1, par2, etc.
        /// https://reference.wolfram.com/language/ref/FinancialIndicator.html
        ///</summary>
        corewolf::engine *FinancialIndicator(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FinancialIndicator[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// finds the first line in an input stream that contains the specified string.
        /// https://reference.wolfram.com/language/ref/Find.html
        ///</summary>
        corewolf::engine *Find(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Find[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the first line that contains any of the specified strings.
        /// https://reference.wolfram.com/language/ref/Find.html
        ///</summary>
        corewolf::engine *Find(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Find[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of the examplei that are considered anomalous with respect to the other examples.
        /// https://reference.wolfram.com/language/ref/FindAnomalies.html
        ///</summary>
        corewolf::engine *FindAnomalies(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FindAnomalies[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the specified property related to the anomaly computation.
        /// https://reference.wolfram.com/language/ref/FindAnomalies.html
        ///</summary>
        corewolf::engine *FindAnomalies(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindAnomalies[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the properties propi.
        /// https://reference.wolfram.com/language/ref/FindAnomalies.html
        ///</summary>
        corewolf::engine *FindAnomalies(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindAnomalies[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives properties related to the anomaly computation.
        /// https://reference.wolfram.com/language/ref/FindAnomalies.html
        ///</summary>
        corewolf::engine *FindAnomalies(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindAnomalies[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the position xmax of a local maximum of f.
        /// https://reference.wolfram.com/language/ref/FindArgMax.html
        ///</summary>
        corewolf::engine *FindArgMax(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindArgMax[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the position xmax of a local maximum of f, found by a search starting from the point x=x0.
        /// https://reference.wolfram.com/language/ref/FindArgMax.html
        ///</summary>
        corewolf::engine *FindArgMax(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindArgMax[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the position {xmax,ymax,…} of a local maximum of a function of several variables.
        /// https://reference.wolfram.com/language/ref/FindArgMax.html
        ///</summary>
        corewolf::engine *FindArgMax(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindArgMax[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the position of a local maximum subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/FindArgMax.html
        ///</summary>
        corewolf::engine *FindArgMax(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindArgMax[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// starts from a point within the region defined by the constraints.
        /// https://reference.wolfram.com/language/ref/FindArgMax.html
        ///</summary>
        corewolf::engine *FindArgMax(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindArgMax[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the position xmin of a local minimum of f.
        /// https://reference.wolfram.com/language/ref/FindArgMin.html
        ///</summary>
        corewolf::engine *FindArgMin(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindArgMin[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the position xmin of a local minimum of f, found by a search starting from the point x=x0.
        /// https://reference.wolfram.com/language/ref/FindArgMin.html
        ///</summary>
        corewolf::engine *FindArgMin(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindArgMin[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the position {xmin,ymin,…} of a local minimum of a function of several variables.
        /// https://reference.wolfram.com/language/ref/FindArgMin.html
        ///</summary>
        corewolf::engine *FindArgMin(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindArgMin[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the position of a local minimum subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/FindArgMin.html
        ///</summary>
        corewolf::engine *FindArgMin(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindArgMin[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// starts from a point within the region defined by the constraints.
        /// https://reference.wolfram.com/language/ref/FindArgMin.html
        ///</summary>
        corewolf::engine *FindArgMin(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindArgMin[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of channels in your home area on the channel broker server.
        /// https://reference.wolfram.com/language/ref/FindChannels.html
        ///</summary>
        corewolf::engine *FindChannels(const std::string &name = "")
        {
            return this->execute("FindChannels[]", name);
        }

        ///< summary>
        /// gives a list of your unnamed channels.
        /// https://reference.wolfram.com/language/ref/FindChannels.html
        ///</summary>
        corewolf::engine *FindChannels(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindChannels[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds a largest clique in the graph g.
        /// https://reference.wolfram.com/language/ref/FindClique.html
        ///</summary>
        corewolf::engine *FindClique(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindClique[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds a clique containing at most n vertices.
        /// https://reference.wolfram.com/language/ref/FindClique.html
        ///</summary>
        corewolf::engine *FindClique(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindClique[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a clique containing exactly n vertices.
        /// https://reference.wolfram.com/language/ref/FindClique.html
        ///</summary>
        corewolf::engine *FindClique(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindClique[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds at most s cliques.
        /// https://reference.wolfram.com/language/ref/FindClique.html
        ///</summary>
        corewolf::engine *FindClique(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindClique[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds cliques that include the vertex v only.
        /// https://reference.wolfram.com/language/ref/FindClique.html
        ///</summary>
        corewolf::engine *FindClique(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindClique[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// partitions the ei into clusters of similar elements.
        /// https://reference.wolfram.com/language/ref/FindClusters.html
        ///</summary>
        corewolf::engine *FindClusters(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FindClusters[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// partitions data into n clusters.
        /// https://reference.wolfram.com/language/ref/FindClusters.html
        ///</summary>
        corewolf::engine *FindClusters(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindClusters[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of all currently set cookies.
        /// https://reference.wolfram.com/language/ref/FindCookies.html
        ///</summary>
        corewolf::engine *FindCookies(const std::string &name = "")
        {
            return this->execute("FindCookies[]", name);
        }

        ///< summary>
        /// gives a list of cookies associated with the specified domain.
        /// https://reference.wolfram.com/language/ref/FindCookies.html
        ///</summary>
        corewolf::engine *FindCookies(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindCookies[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an ordering of the {xi,yi} that corresponds to one or more smooth curves.
        /// https://reference.wolfram.com/language/ref/FindCurvePath.html
        ///</summary>
        corewolf::engine *FindCurvePath(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindCurvePath[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds a cycle in the graph g.
        /// https://reference.wolfram.com/language/ref/FindCycle.html
        ///</summary>
        corewolf::engine *FindCycle(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindCycle[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds a cycle of length at most k in the graph g.
        /// https://reference.wolfram.com/language/ref/FindCycle.html
        ///</summary>
        corewolf::engine *FindCycle(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindCycle[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a cycle of length exactly k.
        /// https://reference.wolfram.com/language/ref/FindCycle.html
        ///</summary>
        corewolf::engine *FindCycle(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindCycle[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds at most s cycles.
        /// https://reference.wolfram.com/language/ref/FindCycle.html
        ///</summary>
        corewolf::engine *FindCycle(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindCycle[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds cycles that include the vertex v.
        /// https://reference.wolfram.com/language/ref/FindCycle.html
        ///</summary>
        corewolf::engine *FindCycle(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindCycle[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// searches for available devices on your computer system.
        /// https://reference.wolfram.com/language/ref/FindDevices.html
        ///</summary>
        corewolf::engine *FindDevices(const std::string &name = "")
        {
            return this->execute("FindDevices[]", name);
        }

        ///< summary>
        /// gives a list of devices in classes whose names match the string pattern form.
        /// https://reference.wolfram.com/language/ref/FindDevices.html
        ///</summary>
        corewolf::engine *FindDevices(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindDevices[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of devices in classes whose names match any of the formi.
        /// https://reference.wolfram.com/language/ref/FindDevices.html
        ///</summary>
        corewolf::engine *FindDevices(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FindDevices[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns at most n devices.
        /// https://reference.wolfram.com/language/ref/FindDevices.html
        ///</summary>
        corewolf::engine *FindDevices(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindDevices[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a simple functional form to fit the distribution of data.
        /// https://reference.wolfram.com/language/ref/FindDistribution.html
        ///</summary>
        corewolf::engine *FindDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds up to n best distributions.
        /// https://reference.wolfram.com/language/ref/FindDistribution.html
        ///</summary>
        corewolf::engine *FindDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns up to n best distributions associated with property prop.
        /// https://reference.wolfram.com/language/ref/FindDistribution.html
        ///</summary>
        corewolf::engine *FindDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns up to n best distributions associated with properties prop1, prop2, etc.
        /// https://reference.wolfram.com/language/ref/FindDistribution.html
        ///</summary>
        corewolf::engine *FindDistribution(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindDistribution[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// finds the parameter estimates for the distribution dist from data.
        /// https://reference.wolfram.com/language/ref/FindDistributionParameters.html
        ///</summary>
        corewolf::engine *FindDistributionParameters(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindDistributionParameters[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the parameters p, q, … with starting values p0, q0, ….
        /// https://reference.wolfram.com/language/ref/FindDistributionParameters.html
        ///</summary>
        corewolf::engine *FindDistributionParameters(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("FindDistributionParameters[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// finds a list of about n "nice" numbers that divide the interval around xmin to xmax into equally spaced parts.
        /// https://reference.wolfram.com/language/ref/FindDivisions.html
        ///</summary>
        corewolf::engine *FindDivisions(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindDivisions[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds successive subdivisions into about n1, n2, … parts.
        /// https://reference.wolfram.com/language/ref/FindDivisions.html
        ///</summary>
        corewolf::engine *FindDivisions(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindDivisions[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses spacings that are forced to be multiples of dx1, dx2, ….
        /// https://reference.wolfram.com/language/ref/FindDivisions.html
        ///</summary>
        corewolf::engine *FindDivisions(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("FindDivisions[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// finds a coloring with minimal size for the edges in the graph g.
        /// https://reference.wolfram.com/language/ref/FindEdgeColoring.html
        ///</summary>
        corewolf::engine *FindEdgeColoring(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindEdgeColoring[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds a coloring {c1,c2,…,ck} for the edges in the graph g.
        /// https://reference.wolfram.com/language/ref/FindEdgeColoring.html
        ///</summary>
        corewolf::engine *FindEdgeColoring(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindEdgeColoring[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds an edge cover of the graph g with a minimum number of edges.
        /// https://reference.wolfram.com/language/ref/FindEdgeCover.html
        ///</summary>
        corewolf::engine *FindEdgeCover(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindEdgeCover[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindEdgeCover.html
        ///</summary>
        corewolf::engine *FindEdgeCover(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FindEdgeCover[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// finds a smallest edge cut of the graph g.
        /// https://reference.wolfram.com/language/ref/FindEdgeCut.html
        ///</summary>
        corewolf::engine *FindEdgeCut(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindEdgeCut[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds a smallest s-t edge cut of the graph g.
        /// https://reference.wolfram.com/language/ref/FindEdgeCut.html
        ///</summary>
        corewolf::engine *FindEdgeCut(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindEdgeCut[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindEdgeCut.html
        ///</summary>
        corewolf::engine *FindEdgeCut(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindEdgeCut[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds at most k edge-independent paths from vertex s to vertex t in the graph g.
        /// https://reference.wolfram.com/language/ref/FindEdgeIndependentPaths.html
        ///</summary>
        corewolf::engine *FindEdgeIndependentPaths(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FindEdgeIndependentPaths[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindEdgeIndependentPaths.html
        ///</summary>
        corewolf::engine *FindEdgeIndependentPaths(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindEdgeIndependentPaths[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tries to find an equational proof of the symbolic theorem thm using the axioms axms.
        /// https://reference.wolfram.com/language/ref/FindEquationalProof.html
        ///</summary>
        corewolf::engine *FindEquationalProof(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindEquationalProof[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds an Eulerian cycle in the graph g.
        /// https://reference.wolfram.com/language/ref/FindEulerianCycle.html
        ///</summary>
        corewolf::engine *FindEulerianCycle(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindEulerianCycle[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds at most k Eulerian cycles.
        /// https://reference.wolfram.com/language/ref/FindEulerianCycle.html
        ///</summary>
        corewolf::engine *FindEulerianCycle(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindEulerianCycle[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindEulerianCycle.html
        ///</summary>
        corewolf::engine *FindEulerianCycle(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindEulerianCycle[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds installed external evaluators that can be used with ExternalEvaluate, returning a dataset of the results found.
        /// https://reference.wolfram.com/language/ref/FindExternalEvaluators.html
        ///</summary>
        corewolf::engine *FindExternalEvaluators(const std::string &name = "")
        {
            return this->execute("FindExternalEvaluators[]", name);
        }

        ///< summary>
        /// finds only external evaluators for language or system sys.
        /// https://reference.wolfram.com/language/ref/FindExternalEvaluators.html
        ///</summary>
        corewolf::engine *FindExternalEvaluators(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindExternalEvaluators[" + arg0 + "]", name);
        }

        ///< summary>
        /// attempts to find human faces in image and returns a list of bounding boxes.
        /// https://reference.wolfram.com/language/ref/FindFaces.html
        ///</summary>
        corewolf::engine *FindFaces(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindFaces[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the specified property prop for each detected face.
        /// https://reference.wolfram.com/language/ref/FindFaces.html
        ///</summary>
        corewolf::engine *FindFaces(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindFaces[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds faces that satisfy the criterion crit.
        /// https://reference.wolfram.com/language/ref/FindFaces.html
        ///</summary>
        corewolf::engine *FindFaces(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindFaces[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds the file with the specified name that would be loaded by Get[name] and related functions.
        /// https://reference.wolfram.com/language/ref/FindFile.html
        ///</summary>
        corewolf::engine *FindFile(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindFile[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds numerical values of the parameters pars that make expr give a best fit to data as a function of vars.
        /// https://reference.wolfram.com/language/ref/FindFit.html
        ///</summary>
        corewolf::engine *FindFit(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FindFit[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// finds a best fit subject to the parameter constraints cons.
        /// https://reference.wolfram.com/language/ref/FindFit.html
        ///</summary>
        corewolf::engine *FindFit(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FindFit[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// finds a pure function that approximates data.
        /// https://reference.wolfram.com/language/ref/FindFormula.html
        ///</summary>
        corewolf::engine *FindFormula(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindFormula[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds a symbolic function of the variable x that approximates data.
        /// https://reference.wolfram.com/language/ref/FindFormula.html
        ///</summary>
        corewolf::engine *FindFormula(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindFormula[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds up to n functions that approximate data.
        /// https://reference.wolfram.com/language/ref/FindFormula.html
        ///</summary>
        corewolf::engine *FindFormula(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindFormula[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns up to n best functions associated with property prop.
        /// https://reference.wolfram.com/language/ref/FindFormula.html
        ///</summary>
        corewolf::engine *FindFormula(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FindFormula[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// returns up to n best functions associated with properties prop1, prop2, etc.
        /// https://reference.wolfram.com/language/ref/FindFormula.html
        ///</summary>
        corewolf::engine *FindFormula(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("FindFormula[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// finds fundamental cycles of the graph g.
        /// https://reference.wolfram.com/language/ref/FindFundamentalCycles.html
        ///</summary>
        corewolf::engine *FindFundamentalCycles(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindFundamentalCycles[" + arg0 + "]", name);
        }

        ///< summary>
        /// attempts to find a simple generating function in x whose n series coefficient is an.
        /// https://reference.wolfram.com/language/ref/FindGeneratingFunction.html
        ///</summary>
        corewolf::engine *FindGeneratingFunction(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindGeneratingFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// attempts to find a simple generating function whose ni series coefficient is ai.
        /// https://reference.wolfram.com/language/ref/FindGeneratingFunction.html
        ///</summary>
        corewolf::engine *FindGeneratingFunction(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindGeneratingFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// attempts to find the current geo location of your computer.
        /// https://reference.wolfram.com/language/ref/FindGeoLocation.html
        ///</summary>
        corewolf::engine *FindGeoLocation(const std::string &name = "")
        {
            return this->execute("FindGeoLocation[]", name);
        }

        ///< summary>
        /// gives an estimate of the geo location associated with the IP address given.
        /// https://reference.wolfram.com/language/ref/FindGeoLocation.html
        ///</summary>
        corewolf::engine *FindGeoLocation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindGeoLocation[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds conjectures that appear to hold for the GeometricScene const std::string &scene and adds these conjectures to the scene object.
        /// https://reference.wolfram.com/language/ref/FindGeometricConjectures.html
        ///</summary>
        corewolf::engine *FindGeometricConjectures(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindGeometricConjectures[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds conjectures that appear to hold for all instances scenei of a geometric scene and returns a combined scene with the conjectures added.
        /// https://reference.wolfram.com/language/ref/FindGeometricConjectures.html
        ///</summary>
        corewolf::engine *FindGeometricConjectures(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FindGeometricConjectures[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// adds only conjectures that match the pattern patt.
        /// https://reference.wolfram.com/language/ref/FindGeometricConjectures.html
        ///</summary>
        corewolf::engine *FindGeometricConjectures(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindGeometricConjectures[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// adds only up to n conjectures.
        /// https://reference.wolfram.com/language/ref/FindGeometricConjectures.html
        ///</summary>
        corewolf::engine *FindGeometricConjectures(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindGeometricConjectures[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds a geometric transformation that aligns positions specified by pts2 with pts1, returning the alignment error together with the transformation function.
        /// https://reference.wolfram.com/language/ref/FindGeometricTransform.html
        ///</summary>
        corewolf::engine *FindGeometricTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindGeometricTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds geometric transformations that align each of the ptsi with ref.
        /// https://reference.wolfram.com/language/ref/FindGeometricTransform.html
        ///</summary>
        corewolf::engine *FindGeometricTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindGeometricTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds geometric transformations that align each of the ptsi with pts1.
        /// https://reference.wolfram.com/language/ref/FindGeometricTransform.html
        ///</summary>
        corewolf::engine *FindGeometricTransform(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FindGeometricTransform[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// finds communities in the graph g.
        /// https://reference.wolfram.com/language/ref/FindGraphCommunities.html
        ///</summary>
        corewolf::engine *FindGraphCommunities(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindGraphCommunities[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindGraphCommunities.html
        ///</summary>
        corewolf::engine *FindGraphCommunities(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FindGraphCommunities[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// finds an isomorphism that maps the graph g1 to g2 by renaming vertices.
        /// https://reference.wolfram.com/language/ref/FindGraphIsomorphism.html
        ///</summary>
        corewolf::engine *FindGraphIsomorphism(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindGraphIsomorphism[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds at most n isomorphisms.
        /// https://reference.wolfram.com/language/ref/FindGraphIsomorphism.html
        ///</summary>
        corewolf::engine *FindGraphIsomorphism(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindGraphIsomorphism[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindGraphIsomorphism.html
        ///</summary>
        corewolf::engine *FindGraphIsomorphism(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindGraphIsomorphism[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a partition of vertices of the graph g.
        /// https://reference.wolfram.com/language/ref/FindGraphPartition.html
        ///</summary>
        corewolf::engine *FindGraphPartition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindGraphPartition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a partition of vertices into k approximately equal-size parts.
        /// https://reference.wolfram.com/language/ref/FindGraphPartition.html
        ///</summary>
        corewolf::engine *FindGraphPartition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindGraphPartition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a partition of vertices into parts with sizes n1, …, nk.
        /// https://reference.wolfram.com/language/ref/FindGraphPartition.html
        ///</summary>
        corewolf::engine *FindGraphPartition(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindGraphPartition[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindGraphPartition.html
        ///</summary>
        corewolf::engine *FindGraphPartition(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindGraphPartition[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a Hamiltonian cycle in the graph g.
        /// https://reference.wolfram.com/language/ref/FindHamiltonianCycle.html
        ///</summary>
        corewolf::engine *FindHamiltonianCycle(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindHamiltonianCycle[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds at most k Hamiltonian cycles.
        /// https://reference.wolfram.com/language/ref/FindHamiltonianCycle.html
        ///</summary>
        corewolf::engine *FindHamiltonianCycle(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindHamiltonianCycle[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindHamiltonianCycle.html
        ///</summary>
        corewolf::engine *FindHamiltonianCycle(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindHamiltonianCycle[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a Hamiltonian path in the graph g with the smallest total length.
        /// https://reference.wolfram.com/language/ref/FindHamiltonianPath.html
        ///</summary>
        corewolf::engine *FindHamiltonianPath(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindHamiltonianPath[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds a Hamiltonian path with the smallest total length from s to t.
        /// https://reference.wolfram.com/language/ref/FindHamiltonianPath.html
        ///</summary>
        corewolf::engine *FindHamiltonianPath(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindHamiltonianPath[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds the most likely hidden states of the HiddenMarkovProcess hmm corresponding to the emissions data.
        /// https://reference.wolfram.com/language/ref/FindHiddenMarkovStates.html
        ///</summary>
        corewolf::engine *FindHiddenMarkovStates(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindHiddenMarkovStates[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the given criterion crit to find the hidden states.
        /// https://reference.wolfram.com/language/ref/FindHiddenMarkovStates.html
        ///</summary>
        corewolf::engine *FindHiddenMarkovStates(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindHiddenMarkovStates[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// detects text in image and returns a single bounding box.
        /// https://reference.wolfram.com/language/ref/FindImageText.html
        ///</summary>
        corewolf::engine *FindImageText(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindImageText[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a list of bounding boxes at the specified structural level.
        /// https://reference.wolfram.com/language/ref/FindImageText.html
        ///</summary>
        corewolf::engine *FindImageText(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindImageText[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns prop for text at the given level.
        /// https://reference.wolfram.com/language/ref/FindImageText.html
        ///</summary>
        corewolf::engine *FindImageText(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindImageText[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds an independent edge set of the graph g with a maximum number of edges.
        /// https://reference.wolfram.com/language/ref/FindIndependentEdgeSet.html
        ///</summary>
        corewolf::engine *FindIndependentEdgeSet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindIndependentEdgeSet[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindIndependentEdgeSet.html
        ///</summary>
        corewolf::engine *FindIndependentEdgeSet(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FindIndependentEdgeSet[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// finds an independent vertex set of the graph g with a maximum number of vertices.
        /// https://reference.wolfram.com/language/ref/FindIndependentVertexSet.html
        ///</summary>
        corewolf::engine *FindIndependentVertexSet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindIndependentVertexSet[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds an independent vertex set with at most n vertices.
        /// https://reference.wolfram.com/language/ref/FindIndependentVertexSet.html
        ///</summary>
        corewolf::engine *FindIndependentVertexSet(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindIndependentVertexSet[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds an independent vertex set with exactly n vertices.
        /// https://reference.wolfram.com/language/ref/FindIndependentVertexSet.html
        ///</summary>
        corewolf::engine *FindIndependentVertexSet(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindIndependentVertexSet[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds at most s independent vertex sets.
        /// https://reference.wolfram.com/language/ref/FindIndependentVertexSet.html
        ///</summary>
        corewolf::engine *FindIndependentVertexSet(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindIndependentVertexSet[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds independent sets that include the vertex v only.
        /// https://reference.wolfram.com/language/ref/FindIndependentVertexSet.html
        ///</summary>
        corewolf::engine *FindIndependentVertexSet(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindIndependentVertexSet[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds an instance of vars that makes the statement expr be True.
        /// https://reference.wolfram.com/language/ref/FindInstance.html
        ///</summary>
        corewolf::engine *FindInstance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindInstance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds an instance over the domain dom. Common choices of dom are Complexes, Reals, Integers, and Booleans.
        /// https://reference.wolfram.com/language/ref/FindInstance.html
        ///</summary>
        corewolf::engine *FindInstance(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindInstance[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds n instances.
        /// https://reference.wolfram.com/language/ref/FindInstance.html
        ///</summary>
        corewolf::engine *FindInstance(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FindInstance[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// finds a list of integers  such that .
        /// https://reference.wolfram.com/language/ref/FindIntegerNullVector.html
        ///</summary>
        corewolf::engine *FindIntegerNullVector(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FindIntegerNullVector[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// finds a list of integers  with  such that .
        /// https://reference.wolfram.com/language/ref/FindIntegerNullVector.html
        ///</summary>
        corewolf::engine *FindIntegerNullVector(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindIntegerNullVector[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a list of molecules with the same chemical formula as chem.
        /// https://reference.wolfram.com/language/ref/FindIsomers.html
        ///</summary>
        corewolf::engine *FindIsomers(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindIsomers[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds isomers of chem and returns them in the given form.
        /// https://reference.wolfram.com/language/ref/FindIsomers.html
        ///</summary>
        corewolf::engine *FindIsomers(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindIsomers[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a subgraph of g1 that is isomorphic to g2.
        /// https://reference.wolfram.com/language/ref/FindIsomorphicSubgraph.html
        ///</summary>
        corewolf::engine *FindIsomorphicSubgraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindIsomorphicSubgraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds at most n subgraphs.
        /// https://reference.wolfram.com/language/ref/FindIsomorphicSubgraph.html
        ///</summary>
        corewolf::engine *FindIsomorphicSubgraph(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindIsomorphicSubgraph[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds a largest k-clan in the graph g.
        /// https://reference.wolfram.com/language/ref/FindKClan.html
        ///</summary>
        corewolf::engine *FindKClan(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindKClan[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a k-clan containing at most n vertices.
        /// https://reference.wolfram.com/language/ref/FindKClan.html
        ///</summary>
        corewolf::engine *FindKClan(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindKClan[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds a k-clan containing exactly n vertices.
        /// https://reference.wolfram.com/language/ref/FindKClan.html
        ///</summary>
        corewolf::engine *FindKClan(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindKClan[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// finds at most s k-clans.
        /// https://reference.wolfram.com/language/ref/FindKClan.html
        ///</summary>
        corewolf::engine *FindKClan(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FindKClan[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// finds k-clans that include the vertex v only.
        /// https://reference.wolfram.com/language/ref/FindKClan.html
        ///</summary>
        corewolf::engine *FindKClan(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindKClan[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindKClan.html
        ///</summary>
        corewolf::engine *FindKClan(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindKClan[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a largest k-clique in the graph g.
        /// https://reference.wolfram.com/language/ref/FindKClique.html
        ///</summary>
        corewolf::engine *FindKClique(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindKClique[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a k-clique containing at most n vertices.
        /// https://reference.wolfram.com/language/ref/FindKClique.html
        ///</summary>
        corewolf::engine *FindKClique(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindKClique[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds a k-clique containing exactly n vertices.
        /// https://reference.wolfram.com/language/ref/FindKClique.html
        ///</summary>
        corewolf::engine *FindKClique(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindKClique[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// finds at most s k-cliques.
        /// https://reference.wolfram.com/language/ref/FindKClique.html
        ///</summary>
        corewolf::engine *FindKClique(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FindKClique[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// finds k-cliques that include the vertex v only.
        /// https://reference.wolfram.com/language/ref/FindKClique.html
        ///</summary>
        corewolf::engine *FindKClique(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindKClique[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindKClique.html
        ///</summary>
        corewolf::engine *FindKClique(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindKClique[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a largest k-club in the graph g.
        /// https://reference.wolfram.com/language/ref/FindKClub.html
        ///</summary>
        corewolf::engine *FindKClub(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindKClub[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a largest k-plex in the graph g.
        /// https://reference.wolfram.com/language/ref/FindKPlex.html
        ///</summary>
        corewolf::engine *FindKPlex(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindKPlex[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a k-plex containing at most n vertices.
        /// https://reference.wolfram.com/language/ref/FindKPlex.html
        ///</summary>
        corewolf::engine *FindKPlex(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindKPlex[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds a k-plex containing exactly n vertices.
        /// https://reference.wolfram.com/language/ref/FindKPlex.html
        ///</summary>
        corewolf::engine *FindKPlex(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindKPlex[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// finds at most s k-plexes.
        /// https://reference.wolfram.com/language/ref/FindKPlex.html
        ///</summary>
        corewolf::engine *FindKPlex(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FindKPlex[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// finds k-plexes that include the vertex v only.
        /// https://reference.wolfram.com/language/ref/FindKPlex.html
        ///</summary>
        corewolf::engine *FindKPlex(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindKPlex[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindKPlex.html
        ///</summary>
        corewolf::engine *FindKPlex(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindKPlex[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a dynamic library that can be loaded by LibraryFunctionLoad.
        /// https://reference.wolfram.com/language/ref/FindLibrary.html
        ///</summary>
        corewolf::engine *FindLibrary(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindLibrary[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds if possible the minimal linear recurrence that generates list.
        /// https://reference.wolfram.com/language/ref/FindLinearRecurrence.html
        ///</summary>
        corewolf::engine *FindLinearRecurrence(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindLinearRecurrence[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds if possible the linear recurrence of maximum order d that generates list.
        /// https://reference.wolfram.com/language/ref/FindLinearRecurrence.html
        ///</summary>
        corewolf::engine *FindLinearRecurrence(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindLinearRecurrence[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of lines in the file that contain the specified string.
        /// https://reference.wolfram.com/language/ref/FindList.html
        ///</summary>
        corewolf::engine *FindList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of all lines that contain any of the specified strings.
        /// https://reference.wolfram.com/language/ref/FindList.html
        ///</summary>
        corewolf::engine *FindList(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindList[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of lines containing the specified strings in any of the filei.
        /// https://reference.wolfram.com/language/ref/FindList.html
        ///</summary>
        corewolf::engine *FindList(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindList[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// includes only the first n lines found.
        /// https://reference.wolfram.com/language/ref/FindList.html
        ///</summary>
        corewolf::engine *FindList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindList[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns a color similar to the color that is present in image.
        /// https://reference.wolfram.com/language/ref/FindMatchingColor.html
        ///</summary>
        corewolf::engine *FindMatchingColor(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindMatchingColor[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a list of colors matching each colori.
        /// https://reference.wolfram.com/language/ref/FindMatchingColor.html
        ///</summary>
        corewolf::engine *FindMatchingColor(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindMatchingColor[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns lists of matching colors for all imagei.
        /// https://reference.wolfram.com/language/ref/FindMatchingColor.html
        ///</summary>
        corewolf::engine *FindMatchingColor(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindMatchingColor[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// searches for a local maximum in f, starting from an automatically selected point.
        /// https://reference.wolfram.com/language/ref/FindMaximum.html
        ///</summary>
        corewolf::engine *FindMaximum(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindMaximum[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// searches for a local maximum in f, starting from the point x=x0.
        /// https://reference.wolfram.com/language/ref/FindMaximum.html
        ///</summary>
        corewolf::engine *FindMaximum(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindMaximum[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// searches for a local maximum in a function of several variables.
        /// https://reference.wolfram.com/language/ref/FindMaximum.html
        ///</summary>
        corewolf::engine *FindMaximum(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindMaximum[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// searches for a local maximum subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/FindMaximum.html
        ///</summary>
        corewolf::engine *FindMaximum(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindMaximum[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// starts from a point within the region defined by the constraints.
        /// https://reference.wolfram.com/language/ref/FindMaximum.html
        ///</summary>
        corewolf::engine *FindMaximum(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindMaximum[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the maximum cut of the graph g.
        /// https://reference.wolfram.com/language/ref/FindMaximumCut.html
        ///</summary>
        corewolf::engine *FindMaximumCut(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindMaximumCut[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds the maximum flow between source vertex s and target vertex t in a graph g.
        /// https://reference.wolfram.com/language/ref/FindMaximumFlow.html
        ///</summary>
        corewolf::engine *FindMaximumFlow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindMaximumFlow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds the maximum flow between multi-sources s1, … and multi-targets t1, ….
        /// https://reference.wolfram.com/language/ref/FindMaximumFlow.html
        ///</summary>
        corewolf::engine *FindMaximumFlow(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindMaximumFlow[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/FindMaximumFlow.html
        ///</summary>
        corewolf::engine *FindMaximumFlow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FindMaximumFlow[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindMaximumFlow.html
        ///</summary>
        corewolf::engine *FindMaximumFlow(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindMaximumFlow[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value at a local maximum of f.
        /// https://reference.wolfram.com/language/ref/FindMaxValue.html
        ///</summary>
        corewolf::engine *FindMaxValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindMaxValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value at a local maximum of f, found by a search starting from the point x=x0.
        /// https://reference.wolfram.com/language/ref/FindMaxValue.html
        ///</summary>
        corewolf::engine *FindMaxValue(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindMaxValue[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value at a local maximum of a function of several variables.
        /// https://reference.wolfram.com/language/ref/FindMaxValue.html
        ///</summary>
        corewolf::engine *FindMaxValue(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindMaxValue[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value at a local maximum subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/FindMaxValue.html
        ///</summary>
        corewolf::engine *FindMaxValue(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindMaxValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// starts from a point within the region defined by the constraints.
        /// https://reference.wolfram.com/language/ref/FindMaxValue.html
        ///</summary>
        corewolf::engine *FindMaxValue(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindMaxValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds defects in the mesh region mreg.
        /// https://reference.wolfram.com/language/ref/FindMeshDefects.html
        ///</summary>
        corewolf::engine *FindMeshDefects(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindMeshDefects[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds only the specified type of defects def1, ….
        /// https://reference.wolfram.com/language/ref/FindMeshDefects.html
        ///</summary>
        corewolf::engine *FindMeshDefects(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindMeshDefects[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// formats the results according to format specification.
        /// https://reference.wolfram.com/language/ref/FindMeshDefects.html
        ///</summary>
        corewolf::engine *FindMeshDefects(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindMeshDefects[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// searches for a local minimum in f, starting from an automatically selected point.
        /// https://reference.wolfram.com/language/ref/FindMinimum.html
        ///</summary>
        corewolf::engine *FindMinimum(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindMinimum[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// searches for a local minimum in f, starting from the point x=x0.
        /// https://reference.wolfram.com/language/ref/FindMinimum.html
        ///</summary>
        corewolf::engine *FindMinimum(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindMinimum[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// searches for a local minimum in a function of several variables.
        /// https://reference.wolfram.com/language/ref/FindMinimum.html
        ///</summary>
        corewolf::engine *FindMinimum(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindMinimum[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// searches for a local minimum subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/FindMinimum.html
        ///</summary>
        corewolf::engine *FindMinimum(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindMinimum[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// starts from a point within the region defined by the constraints.
        /// https://reference.wolfram.com/language/ref/FindMinimum.html
        ///</summary>
        corewolf::engine *FindMinimum(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindMinimum[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds the minimum cost flow in the graph g with sd1, sd2, … vertex supplies or demands.
        /// https://reference.wolfram.com/language/ref/FindMinimumCostFlow.html
        ///</summary>
        corewolf::engine *FindMinimumCostFlow(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindMinimumCostFlow[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds the minimum cost maximum flow between source vertex s and target vertex t in a graph g.
        /// https://reference.wolfram.com/language/ref/FindMinimumCostFlow.html
        ///</summary>
        corewolf::engine *FindMinimumCostFlow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindMinimumCostFlow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds the minimum cost flow between source s and target t, with the required flow d.
        /// https://reference.wolfram.com/language/ref/FindMinimumCostFlow.html
        ///</summary>
        corewolf::engine *FindMinimumCostFlow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FindMinimumCostFlow[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// finds the minimum cost flow in a graph with cost matrix m.
        /// https://reference.wolfram.com/language/ref/FindMinimumCostFlow.html
        ///</summary>
        corewolf::engine *FindMinimumCostFlow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindMinimumCostFlow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindMinimumCostFlow.html
        ///</summary>
        corewolf::engine *FindMinimumCostFlow(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindMinimumCostFlow[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the minimum cut of the graph g.
        /// https://reference.wolfram.com/language/ref/FindMinimumCut.html
        ///</summary>
        corewolf::engine *FindMinimumCut(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindMinimumCut[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindMinimumCut.html
        ///</summary>
        corewolf::engine *FindMinimumCut(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FindMinimumCut[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value at a local minimum of f.
        /// https://reference.wolfram.com/language/ref/FindMinValue.html
        ///</summary>
        corewolf::engine *FindMinValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindMinValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value at a local minimum of f, found by a search starting from the point x=x0.
        /// https://reference.wolfram.com/language/ref/FindMinValue.html
        ///</summary>
        corewolf::engine *FindMinValue(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindMinValue[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value at a local minimum of a function of several variables.
        /// https://reference.wolfram.com/language/ref/FindMinValue.html
        ///</summary>
        corewolf::engine *FindMinValue(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindMinValue[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value at a local minimum subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/FindMinValue.html
        ///</summary>
        corewolf::engine *FindMinValue(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindMinValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// starts from a point within the region defined by the constraints.
        /// https://reference.wolfram.com/language/ref/FindMinValue.html
        ///</summary>
        corewolf::engine *FindMinValue(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindMinValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds a mapping between the atom indices in mol and an occurrence of patt in mol.
        /// https://reference.wolfram.com/language/ref/FindMoleculeSubstructure.html
        ///</summary>
        corewolf::engine *FindMoleculeSubstructure(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindMoleculeSubstructure[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds all occurrences of patt in mol and returns all mappings.
        /// https://reference.wolfram.com/language/ref/FindMoleculeSubstructure.html
        ///</summary>
        corewolf::engine *FindMoleculeSubstructure(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindMoleculeSubstructure[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds a path between vertex s and vertex t in the graph g.
        /// https://reference.wolfram.com/language/ref/FindPath.html
        ///</summary>
        corewolf::engine *FindPath(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindPath[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds a path of length at most k between vertex s and vertex t in the graph g.
        /// https://reference.wolfram.com/language/ref/FindPath.html
        ///</summary>
        corewolf::engine *FindPath(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FindPath[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// finds a path of length exactly k.
        /// https://reference.wolfram.com/language/ref/FindPath.html
        ///</summary>
        corewolf::engine *FindPath(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("FindPath[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// finds at most n paths.
        /// https://reference.wolfram.com/language/ref/FindPath.html
        ///</summary>
        corewolf::engine *FindPath(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("FindPath[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindPath.html
        ///</summary>
        corewolf::engine *FindPath(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindPath[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives positions and values of the detected peaks in list.
        /// https://reference.wolfram.com/language/ref/FindPeaks.html
        ///</summary>
        corewolf::engine *FindPeaks(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindPeaks[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds peaks that survive Gaussian blurring up to scale σ.
        /// https://reference.wolfram.com/language/ref/FindPeaks.html
        ///</summary>
        corewolf::engine *FindPeaks(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindPeaks[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds peaks with minimum sharpness s.
        /// https://reference.wolfram.com/language/ref/FindPeaks.html
        ///</summary>
        corewolf::engine *FindPeaks(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindPeaks[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds only peaks with values greater than t.
        /// https://reference.wolfram.com/language/ref/FindPeaks.html
        ///</summary>
        corewolf::engine *FindPeaks(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FindPeaks[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// uses different scales for thresholding sharpness and value.
        /// https://reference.wolfram.com/language/ref/FindPeaks.html
        ///</summary>
        corewolf::engine *FindPeaks(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("FindPeaks[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// gives a permutation that produces expr by permuting Sort[expr].
        /// https://reference.wolfram.com/language/ref/FindPermutation.html
        ///</summary>
        corewolf::engine *FindPermutation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindPermutation[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a permutation that converts expr1 to expr2 for two expressions that differ only in the order of their arguments.
        /// https://reference.wolfram.com/language/ref/FindPermutation.html
        ///</summary>
        corewolf::engine *FindPermutation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindPermutation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a coloring with minimal size for the faces of the planar graph g.
        /// https://reference.wolfram.com/language/ref/FindPlanarColoring.html
        ///</summary>
        corewolf::engine *FindPlanarColoring(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindPlanarColoring[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds a coloring {c1,c2,…,ck} for the faces in the graph g.
        /// https://reference.wolfram.com/language/ref/FindPlanarColoring.html
        ///</summary>
        corewolf::engine *FindPlanarColoring(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindPlanarColoring[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// estimates the parameters of the point process pproc from point data pdata.
        /// https://reference.wolfram.com/language/ref/FindPointProcessParameters.html
        ///</summary>
        corewolf::engine *FindPointProcessParameters(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindPointProcessParameters[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// estimates the parameters p, q, … with starting values p0, q0, ….
        /// https://reference.wolfram.com/language/ref/FindPointProcessParameters.html
        ///</summary>
        corewolf::engine *FindPointProcessParameters(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("FindPointProcessParameters[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// finds a Chinese postman tour in the graph g of minimal length.
        /// https://reference.wolfram.com/language/ref/FindPostmanTour.html
        ///</summary>
        corewolf::engine *FindPostmanTour(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindPostmanTour[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds at most k Chinese postman tours.
        /// https://reference.wolfram.com/language/ref/FindPostmanTour.html
        ///</summary>
        corewolf::engine *FindPostmanTour(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindPostmanTour[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindPostmanTour.html
        ///</summary>
        corewolf::engine *FindPostmanTour(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindPostmanTour[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the parameter estimates for the process proc from data.
        /// https://reference.wolfram.com/language/ref/FindProcessParameters.html
        ///</summary>
        corewolf::engine *FindProcessParameters(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindProcessParameters[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the parameters p, q, … with starting values p0, q0, … .
        /// https://reference.wolfram.com/language/ref/FindProcessParameters.html
        ///</summary>
        corewolf::engine *FindProcessParameters(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("FindProcessParameters[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// gives the transformation function that maps the region reg1 to the region reg2.
        /// https://reference.wolfram.com/language/ref/FindRegionTransform.html
        ///</summary>
        corewolf::engine *FindRegionTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindRegionTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the minimal sublist or subarray that repeats to give list.
        /// https://reference.wolfram.com/language/ref/FindRepeat.html
        ///</summary>
        corewolf::engine *FindRepeat(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindRepeat[" + arg0 + "]", name);
        }

        ///< summary>
        /// requires that the sublist be repeated at least n times in list.
        /// https://reference.wolfram.com/language/ref/FindRepeat.html
        ///</summary>
        corewolf::engine *FindRepeat(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindRepeat[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// requires ni to repeat at level i in list.
        /// https://reference.wolfram.com/language/ref/FindRepeat.html
        ///</summary>
        corewolf::engine *FindRepeat(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindRepeat[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// searches for a numerical root of f, starting from the point x=x0.
        /// https://reference.wolfram.com/language/ref/FindRoot.html
        ///</summary>
        corewolf::engine *FindRoot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindRoot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// searches for a simultaneous numerical root of all the fi.
        /// https://reference.wolfram.com/language/ref/FindRoot.html
        ///</summary>
        corewolf::engine *FindRoot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FindRoot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// attempts to find a simple function that yields the sequence an when given successive integer arguments.
        /// https://reference.wolfram.com/language/ref/FindSequenceFunction.html
        ///</summary>
        corewolf::engine *FindSequenceFunction(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FindSequenceFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// attempts to find a simple function that yields ai when given argument ni.
        /// https://reference.wolfram.com/language/ref/FindSequenceFunction.html
        ///</summary>
        corewolf::engine *FindSequenceFunction(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindSequenceFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a function that yields ai when given argument ni.
        /// https://reference.wolfram.com/language/ref/FindSequenceFunction.html
        ///</summary>
        corewolf::engine *FindSequenceFunction(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindSequenceFunction[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the function applied to n.
        /// https://reference.wolfram.com/language/ref/FindSequenceFunction.html
        ///</summary>
        corewolf::engine *FindSequenceFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindSequenceFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the shortest path from source vertex s to target vertex t in the graph g.
        /// https://reference.wolfram.com/language/ref/FindShortestPath.html
        ///</summary>
        corewolf::engine *FindShortestPath(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindShortestPath[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindShortestPath.html
        ///</summary>
        corewolf::engine *FindShortestPath(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindShortestPath[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// attempts to find an ordering of the vi that minimizes the total distance on a tour that visits all the vi once.
        /// https://reference.wolfram.com/language/ref/FindShortestTour.html
        ///</summary>
        corewolf::engine *FindShortestTour(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FindShortestTour[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// attempts to find an ordering of the vertices in graph that minimizes the total length when visiting each vertex once.
        /// https://reference.wolfram.com/language/ref/FindShortestTour.html
        ///</summary>
        corewolf::engine *FindShortestTour(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindShortestTour[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds an ordering of the vi that minimizes the total distance on a path from vj to vk.
        /// https://reference.wolfram.com/language/ref/FindShortestTour.html
        ///</summary>
        corewolf::engine *FindShortestTour(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindShortestTour[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds an ordering of the vertices that minimizes the total length on a path from s to t.
        /// https://reference.wolfram.com/language/ref/FindShortestTour.html
        ///</summary>
        corewolf::engine *FindShortestTour(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindShortestTour[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindShortestTour.html
        ///</summary>
        corewolf::engine *FindShortestTour(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindShortestTour[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a spanning tree that minimizes the total distance between the vi.
        /// https://reference.wolfram.com/language/ref/FindSpanningTree.html
        ///</summary>
        corewolf::engine *FindSpanningTree(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FindSpanningTree[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// finds a spanning tree of the graph g that minimizes the total distances between vertices.
        /// https://reference.wolfram.com/language/ref/FindSpanningTree.html
        ///</summary>
        corewolf::engine *FindSpanningTree(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindSpanningTree[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds a spanning tree of the connected component of g that includes the vertex v.
        /// https://reference.wolfram.com/language/ref/FindSpanningTree.html
        ///</summary>
        corewolf::engine *FindSpanningTree(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindSpanningTree[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a subgraph isomorphism that maps the graph g1 to a subgraph of g2 by renaming vertices.
        /// https://reference.wolfram.com/language/ref/FindSubgraphIsomorphism.html
        ///</summary>
        corewolf::engine *FindSubgraphIsomorphism(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindSubgraphIsomorphism[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds at most n subgraph isomorphisms.
        /// https://reference.wolfram.com/language/ref/FindSubgraphIsomorphism.html
        ///</summary>
        corewolf::engine *FindSubgraphIsomorphism(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindSubgraphIsomorphism[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// searches for an equilibrium to the model model.
        /// https://reference.wolfram.com/language/ref/FindSystemModelEquilibrium.html
        ///</summary>
        corewolf::engine *FindSystemModelEquilibrium(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindSystemModelEquilibrium[" + arg0 + "]", name);
        }

        ///< summary>
        /// searches for an equilibrium, starting from the points xi=xi0, ui=ui0 and yi=yi0.
        /// https://reference.wolfram.com/language/ref/FindSystemModelEquilibrium.html
        ///</summary>
        corewolf::engine *FindSystemModelEquilibrium(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("FindSystemModelEquilibrium[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// searches for an equilibrium, with variable xi constrained to have the value vi etc.
        /// https://reference.wolfram.com/language/ref/FindSystemModelEquilibrium.html
        ///</summary>
        corewolf::engine *FindSystemModelEquilibrium(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindSystemModelEquilibrium[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the substring of text that best appears to answer question.
        /// https://reference.wolfram.com/language/ref/FindTextualAnswer.html
        ///</summary>
        corewolf::engine *FindTextualAnswer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindTextualAnswer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of up to n answers that appear most probable.
        /// https://reference.wolfram.com/language/ref/FindTextualAnswer.html
        ///</summary>
        corewolf::engine *FindTextualAnswer(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindTextualAnswer[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the specified property for each answer.
        /// https://reference.wolfram.com/language/ref/FindTextualAnswer.html
        ///</summary>
        corewolf::engine *FindTextualAnswer(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FindTextualAnswer[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// finds a global threshold value that partitions the intensity values in image into two intervals.
        /// https://reference.wolfram.com/language/ref/FindThreshold.html
        ///</summary>
        corewolf::engine *FindThreshold(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindThreshold[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a pair of lists {transient,repeat} where the elements of repeat occur successively at least n times after the elements of the transient part of list.
        /// https://reference.wolfram.com/language/ref/FindTransientRepeat.html
        ///</summary>
        corewolf::engine *FindTransientRepeat(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindTransientRepeat[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a coloring with minimal size for the vertices in the graph g.
        /// https://reference.wolfram.com/language/ref/FindVertexColoring.html
        ///</summary>
        corewolf::engine *FindVertexColoring(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindVertexColoring[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds a coloring {c1,c2,…,ck} for the vertices in the graph g.
        /// https://reference.wolfram.com/language/ref/FindVertexColoring.html
        ///</summary>
        corewolf::engine *FindVertexColoring(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FindVertexColoring[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds a vertex cover of the graph g with a minimum number of vertices.
        /// https://reference.wolfram.com/language/ref/FindVertexCover.html
        ///</summary>
        corewolf::engine *FindVertexCover(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindVertexCover[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindVertexCover.html
        ///</summary>
        corewolf::engine *FindVertexCover(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FindVertexCover[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// finds a smallest vertex cut of the graph g.
        /// https://reference.wolfram.com/language/ref/FindVertexCut.html
        ///</summary>
        corewolf::engine *FindVertexCut(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FindVertexCut[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds a smallest s-t vertex cut of the graph g.
        /// https://reference.wolfram.com/language/ref/FindVertexCut.html
        ///</summary>
        corewolf::engine *FindVertexCut(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FindVertexCut[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindVertexCut.html
        ///</summary>
        corewolf::engine *FindVertexCut(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindVertexCut[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds at most k vertex-independent paths from vertex s to vertex t in the graph g.
        /// https://reference.wolfram.com/language/ref/FindVertexIndependentPaths.html
        ///</summary>
        corewolf::engine *FindVertexIndependentPaths(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FindVertexIndependentPaths[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FindVertexIndependentPaths.html
        ///</summary>
        corewolf::engine *FindVertexIndependentPaths(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FindVertexIndependentPaths[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finishes updating and displaying all currently visible Dynamic objects.
        /// https://reference.wolfram.com/language/ref/FinishDynamic.html
        ///</summary>
        corewolf::engine *FinishDynamic(const std::string &name = "")
        {
            return this->execute("FinishDynamic[]", name);
        }

        ///< summary>
        /// gives the number of finite Abelian groups of order n.
        /// https://reference.wolfram.com/language/ref/FiniteAbelianGroupCount.html
        ///</summary>
        corewolf::engine *FiniteAbelianGroupCount(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FiniteAbelianGroupCount[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number of finite groups of order n.
        /// https://reference.wolfram.com/language/ref/FiniteGroupCount.html
        ///</summary>
        corewolf::engine *FiniteGroupCount(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FiniteGroupCount[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the finite group specified by name.
        /// https://reference.wolfram.com/language/ref/FiniteGroupData.html
        ///</summary>
        corewolf::engine *FiniteGroupData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FiniteGroupData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of finite groups in the specified class.
        /// https://reference.wolfram.com/language/ref/FiniteGroupData.html
        ///</summary>
        corewolf::engine *FiniteGroupData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FiniteGroupData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the first element in expr.
        /// https://reference.wolfram.com/language/ref/First.html
        ///</summary>
        corewolf::engine *First(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("First[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the first element if it exists, or def otherwise.
        /// https://reference.wolfram.com/language/ref/First.html
        ///</summary>
        corewolf::engine *First(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("First[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the first ei to match pattern, or Missing["NotFound"] if none matching pattern is found.
        /// https://reference.wolfram.com/language/ref/FirstCase.html
        ///</summary>
        corewolf::engine *FirstCase(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FirstCase[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives default if no element matching pattern is found.
        /// https://reference.wolfram.com/language/ref/FirstCase.html
        ///</summary>
        corewolf::engine *FirstCase(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FirstCase[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds only objects that appear on levels specified by levelspec.
        /// https://reference.wolfram.com/language/ref/FirstCase.html
        ///</summary>
        corewolf::engine *FirstCase(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FirstCase[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an operator form of FirstCase that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/FirstCase.html
        ///</summary>
        corewolf::engine *FirstCase(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FirstCase[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the distribution of times for the Markov process mproc to pass from the initial state to final states f for the first time.
        /// https://reference.wolfram.com/language/ref/FirstPassageTimeDistribution.html
        ///</summary>
        corewolf::engine *FirstPassageTimeDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FirstPassageTimeDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the position of the first element in expr that matches pattern, or Missing["NotFound"] if no such element is found.
        /// https://reference.wolfram.com/language/ref/FirstPosition.html
        ///</summary>
        corewolf::engine *FirstPosition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FirstPosition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives default if no element matching pattern is found.
        /// https://reference.wolfram.com/language/ref/FirstPosition.html
        ///</summary>
        corewolf::engine *FirstPosition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FirstPosition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds only objects that appear on levels specified by levelspec.
        /// https://reference.wolfram.com/language/ref/FirstPosition.html
        ///</summary>
        corewolf::engine *FirstPosition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FirstPosition[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an operator form of FirstPosition that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/FirstPosition.html
        ///</summary>
        corewolf::engine *FirstPosition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FirstPosition[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the sporadic simple Fischer group .
        /// https://reference.wolfram.com/language/ref/FischerGroupFi22.html
        ///</summary>
        corewolf::engine *FischerGroupFi22(const std::string &name = "")
        {
            return this->execute("FischerGroupFi22[]", name);
        }

        ///< summary>
        /// represents the sporadic simple Fischer group .
        /// https://reference.wolfram.com/language/ref/FischerGroupFi23.html
        ///</summary>
        corewolf::engine *FischerGroupFi23(const std::string &name = "")
        {
            return this->execute("FischerGroupFi23[]", name);
        }

        ///< summary>
        /// represents the sporadic simple Fischer group .
        /// https://reference.wolfram.com/language/ref/FischerGroupFi24Prime.html
        ///</summary>
        corewolf::engine *FischerGroupFi24Prime(const std::string &name = "")
        {
            return this->execute("FischerGroupFi24Prime[]", name);
        }

        ///< summary>
        /// represents a Fisher noncentral hypergeometric distribution.
        /// https://reference.wolfram.com/language/ref/FisherHypergeometricDistribution.html
        ///</summary>
        corewolf::engine *FisherHypergeometricDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FisherHypergeometricDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// tests whether the variance of data is 1.
        /// https://reference.wolfram.com/language/ref/FisherRatioTest.html
        ///</summary>
        corewolf::engine *FisherRatioTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FisherRatioTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the variances of data1 and data2 are equal.
        /// https://reference.wolfram.com/language/ref/FisherRatioTest.html
        ///</summary>
        corewolf::engine *FisherRatioTest(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FisherRatioTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/FisherRatioTest.html
        ///</summary>
        corewolf::engine *FisherRatioTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FisherRatioTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Fisher  distribution with n numerator and m denominator degrees of freedom.
        /// https://reference.wolfram.com/language/ref/FisherZDistribution.html
        ///</summary>
        corewolf::engine *FisherZDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FisherZDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a fit a1 f1+…+an fn to a list of data for functions f1,…,fn of variables {x,y,…}.
        /// https://reference.wolfram.com/language/ref/Fit.html
        ///</summary>
        corewolf::engine *Fit(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Fit[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// finds a fit vector a that minimizes  for a design matrix m.
        /// https://reference.wolfram.com/language/ref/Fit.html
        ///</summary>
        corewolf::engine *Fit(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Fit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// specifies what fit property prop should be returned.
        /// https://reference.wolfram.com/language/ref/Fit.html
        ///</summary>
        corewolf::engine *Fit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Fit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the symbolic fitted model obtained from functions like LinearModelFit.
        /// https://reference.wolfram.com/language/ref/FittedModel.html
        ///</summary>
        corewolf::engine *FittedModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FittedModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a grammar rules pattern const std::string &that represents a sequence of elements matching p1, p2, …, in the fixed order given.
        /// https://reference.wolfram.com/language/ref/FixedOrder.html
        ///</summary>
        corewolf::engine *FixedOrder(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FixedOrder[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// starts with expr, then applies f repeatedly until the result no longer changes.
        /// https://reference.wolfram.com/language/ref/FixedPoint.html
        ///</summary>
        corewolf::engine *FixedPoint(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FixedPoint[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a list giving the results of applying f repeatedly, starting with expr, until the results no longer change.
        /// https://reference.wolfram.com/language/ref/FixedPointList.html
        ///</summary>
        corewolf::engine *FixedPointList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FixedPointList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a three-dimensional graphics directive that specifies that faces of polygons and other filled graphics objects are to be drawn to reflect as a flat surface.
        /// https://reference.wolfram.com/language/ref/FlatShading.html
        ///</summary>
        corewolf::engine *FlatShading(const std::string &name = "")
        {
            return this->execute("FlatShading[]", name);
        }

        ///< summary>
        /// uses the attenuation factor d for the diffuse light.
        /// https://reference.wolfram.com/language/ref/FlatShading.html
        ///</summary>
        corewolf::engine *FlatShading(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FlatShading[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the attenuation factor a for the ambient light.
        /// https://reference.wolfram.com/language/ref/FlatShading.html
        ///</summary>
        corewolf::engine *FlatShading(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FlatShading[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// flattens out nested lists.
        /// https://reference.wolfram.com/language/ref/Flatten.html
        ///</summary>
        corewolf::engine *Flatten(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Flatten[" + arg0 + "]", name);
        }

        ///< summary>
        /// flattens to level n.
        /// https://reference.wolfram.com/language/ref/Flatten.html
        ///</summary>
        corewolf::engine *Flatten(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Flatten[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// flattens subexpressions with head h.
        /// https://reference.wolfram.com/language/ref/Flatten.html
        ///</summary>
        corewolf::engine *Flatten(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Flatten[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// flattens list by combining all levels sij to make each level i in the result.
        /// https://reference.wolfram.com/language/ref/Flatten.html
        ///</summary>
        corewolf::engine *Flatten(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Flatten[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// flattens out a sublist that appears as the n th element of list. If n is negative, the position is counted from the end.
        /// https://reference.wolfram.com/language/ref/FlattenAt.html
        ///</summary>
        corewolf::engine *FlattenAt(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FlattenAt[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// flattens out the part of expr at position {i,j,…}.
        /// https://reference.wolfram.com/language/ref/FlattenAt.html
        ///</summary>
        corewolf::engine *FlattenAt(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FlattenAt[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// flattens out parts of expr at several positions.
        /// https://reference.wolfram.com/language/ref/FlattenAt.html
        ///</summary>
        corewolf::engine *FlattenAt(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FlattenAt[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents an operator form of FlattenAt that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/FlattenAt.html
        ///</summary>
        corewolf::engine *FlattenAt(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FlattenAt[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a net layer that flattens any input array into a vector.
        /// https://reference.wolfram.com/language/ref/FlattenLayer.html
        ///</summary>
        corewolf::engine *FlattenLayer(const std::string &name = "")
        {
            return this->execute("FlattenLayer[]", name);
        }

        ///< summary>
        /// represents a net layer that flattens its input to level n.
        /// https://reference.wolfram.com/language/ref/FlattenLayer.html
        ///</summary>
        corewolf::engine *FlattenLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FlattenLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a net layer that flattens its input by combining all levels sij to make each level i in the result.
        /// https://reference.wolfram.com/language/ref/FlattenLayer.html
        ///</summary>
        corewolf::engine *FlattenLayer(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FlattenLayer[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an exact flat top window function of x.
        /// https://reference.wolfram.com/language/ref/FlatTopWindow.html
        ///</summary>
        corewolf::engine *FlatTopWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FlatTopWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a subset of properties for a flight or selection of flights with specifications spec.
        /// https://reference.wolfram.com/language/ref/FlightData.html
        ///</summary>
        corewolf::engine *FlightData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FlightData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of the property prop for specifications spec.
        /// https://reference.wolfram.com/language/ref/FlightData.html
        ///</summary>
        corewolf::engine *FlightData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FlightData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the value of the property prop for a specific time or time range datespec.
        /// https://reference.wolfram.com/language/ref/FlightData.html
        ///</summary>
        corewolf::engine *FlightData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FlightData[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an const std::string &which flips between displaying expr1 and expr2 each time it is clicked.
        /// https://reference.wolfram.com/language/ref/FlipView.html
        ///</summary>
        corewolf::engine *FlipView(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FlipView[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes expri be the const std::string &currently displayed.
        /// https://reference.wolfram.com/language/ref/FlipView.html
        ///</summary>
        corewolf::engine *FlipView(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FlipView[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the greatest integer less than or equal to x.
        /// https://reference.wolfram.com/language/ref/Floor.html
        ///</summary>
        corewolf::engine *Floor(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Floor[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the greatest multiple of a less than or equal to x.
        /// https://reference.wolfram.com/language/ref/Floor.html
        ///</summary>
        corewolf::engine *Floor(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Floor[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the flow polynomial of the graph g.
        /// https://reference.wolfram.com/language/ref/FlowPolynomial.html
        ///</summary>
        corewolf::engine *FlowPolynomial(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FlowPolynomial[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/FlowPolynomial.html
        ///</summary>
        corewolf::engine *FlowPolynomial(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FlowPolynomial[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the last element of FoldList[f,x,list].
        /// https://reference.wolfram.com/language/ref/Fold.html
        ///</summary>
        corewolf::engine *Fold(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Fold[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is equivalent to Fold[f,First[list],Rest[list]].
        /// https://reference.wolfram.com/language/ref/Fold.html
        ///</summary>
        corewolf::engine *Fold(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Fold[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of Fold that can be applied to expressions.
        /// https://reference.wolfram.com/language/ref/Fold.html
        ///</summary>
        corewolf::engine *Fold(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Fold[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives {x,f[x,a],f[f[x,a],b],…}.
        /// https://reference.wolfram.com/language/ref/FoldList.html
        ///</summary>
        corewolf::engine *FoldList(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FoldList[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives {a,f[a,b],f[f[a,b],c],…}.
        /// https://reference.wolfram.com/language/ref/FoldList.html
        ///</summary>
        corewolf::engine *FoldList(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FoldList[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an operator form of FoldList that can be applied to expressions.
        /// https://reference.wolfram.com/language/ref/FoldList.html
        ///</summary>
        corewolf::engine *FoldList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FoldList[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the last element of FoldPairList[f,y0,list].
        /// https://reference.wolfram.com/language/ref/FoldPair.html
        ///</summary>
        corewolf::engine *FoldPair(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FoldPair[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the last element of FoldPairList[f,y0,list,g].
        /// https://reference.wolfram.com/language/ref/FoldPair.html
        ///</summary>
        corewolf::engine *FoldPair(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FoldPair[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// is equivalent to FoldPair[f,a0,{a1,a2,…}].
        /// https://reference.wolfram.com/language/ref/FoldPair.html
        ///</summary>
        corewolf::engine *FoldPair(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FoldPair[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the list of successive xi obtained by applying f to pairs of the form {yi-1,ai}, where at each step f returns {xi,yi}.
        /// https://reference.wolfram.com/language/ref/FoldPairList.html
        ///</summary>
        corewolf::engine *FoldPairList(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FoldPairList[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the list of successive values of g[{xi,yi}].
        /// https://reference.wolfram.com/language/ref/FoldPairList.html
        ///</summary>
        corewolf::engine *FoldPairList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FoldPairList[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// is equivalent to FoldPairList[f,a0,{a1,a2,…}].
        /// https://reference.wolfram.com/language/ref/FoldPairList.html
        ///</summary>
        corewolf::engine *FoldPairList(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FoldPairList[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns the first expression f[… f[f[x,a1],a2]…,ak] to which applying test does not yield True.
        /// https://reference.wolfram.com/language/ref/FoldWhile.html
        ///</summary>
        corewolf::engine *FoldWhile(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FoldWhile[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// is equivalent to FoldWhile[f,First[list],Rest[list],test].
        /// https://reference.wolfram.com/language/ref/FoldWhile.html
        ///</summary>
        corewolf::engine *FoldWhile(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FoldWhile[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// supplies the most recent m results as arguments for test at each step.
        /// https://reference.wolfram.com/language/ref/FoldWhile.html
        ///</summary>
        corewolf::engine *FoldWhile(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("FoldWhile[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// returns the result after applying f an extra n times after test fails.
        /// https://reference.wolfram.com/language/ref/FoldWhile.html
        ///</summary>
        corewolf::engine *FoldWhile(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("FoldWhile[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// represents an operator form of FoldWhile that can be applied to expressions.
        /// https://reference.wolfram.com/language/ref/FoldWhile.html
        ///</summary>
        corewolf::engine *FoldWhile(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FoldWhile[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns {x,f[x,a1],f[f[x,a1],a2],…}, repeatedly applying f with subsequent values ai until applying test to the result does not yield True.
        /// https://reference.wolfram.com/language/ref/FoldWhileList.html
        ///</summary>
        corewolf::engine *FoldWhileList(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FoldWhileList[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// is equivalent to FoldWhileList[f,First[list],Rest[list],test].
        /// https://reference.wolfram.com/language/ref/FoldWhileList.html
        ///</summary>
        corewolf::engine *FoldWhileList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FoldWhileList[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// supplies the most recent m results as arguments for test at each step.
        /// https://reference.wolfram.com/language/ref/FoldWhileList.html
        ///</summary>
        corewolf::engine *FoldWhileList(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("FoldWhileList[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// returns n additional results by applying f an extra n times after test fails.
        /// https://reference.wolfram.com/language/ref/FoldWhileList.html
        ///</summary>
        corewolf::engine *FoldWhileList(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("FoldWhileList[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// represents an operator form of FoldWhileList that can be applied to expressions.
        /// https://reference.wolfram.com/language/ref/FoldWhileList.html
        ///</summary>
        corewolf::engine *FoldWhileList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FoldWhileList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// executes start, then repeatedly evaluates body and incr until test fails to give True.
        /// https://reference.wolfram.com/language/ref/For.html
        ///</summary>
        corewolf::engine *For(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("For[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents the statement that expr is True for all values of .
        /// https://reference.wolfram.com/language/ref/ForAll.html
        ///</summary>
        corewolf::engine *ForAll(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ForAll[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// states that expr is True for all x satisfying the condition cond.
        /// https://reference.wolfram.com/language/ref/ForAll.html
        ///</summary>
        corewolf::engine *ForAll(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ForAll[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// states that expr is True for all values of all the xi.
        /// https://reference.wolfram.com/language/ref/ForAll.html
        ///</summary>
        corewolf::engine *ForAll(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ForAll[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a type parameterized by x.
        /// https://reference.wolfram.com/language/ref/ForAllType.html
        ///</summary>
        corewolf::engine *ForAllType(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ForAllType[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a type satisfying cond.
        /// https://reference.wolfram.com/language/ref/ForAllType.html
        ///</summary>
        corewolf::engine *ForAllType(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ForAllType[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a type with multiple parameters.
        /// https://reference.wolfram.com/language/ref/ForAllType.html
        ///</summary>
        corewolf::engine *ForAllType(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ForAllType[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// prints as the formatted form of expr. Assigning values to Format[expr] defines print forms for expressions.
        /// https://reference.wolfram.com/language/ref/Format.html
        ///</summary>
        corewolf::engine *Format(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Format[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a format for the specified form of output.
        /// https://reference.wolfram.com/language/ref/Format.html
        ///</summary>
        corewolf::engine *Format(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Format[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a low-level box construct which displays as boxes but specifies that rules associated with form should be used to interpret boxes on input.
        /// https://reference.wolfram.com/language/ref/FormBox.html
        ///</summary>
        corewolf::engine *FormBox(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FormBox[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an editable form in a notebook, with structure specified by struct and current values specified by assoc.
        /// https://reference.wolfram.com/language/ref/FormControl.html
        ///</summary>
        corewolf::engine *FormControl(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FormControl[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an active form that, when submitted, applies func to the values obtained from the form specified by formspec.
        /// https://reference.wolfram.com/language/ref/FormFunction.html
        ///</summary>
        corewolf::engine *FormFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FormFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an active form with fields named namei interpreted as types typei.
        /// https://reference.wolfram.com/language/ref/FormFunction.html
        ///</summary>
        corewolf::engine *FormFunction(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FormFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies that in the cloud, the result from applying func should be returned in format fmt.
        /// https://reference.wolfram.com/language/ref/FormFunction.html
        ///</summary>
        corewolf::engine *FormFunction(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FormFunction[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a multipage form, in which the successive formspeci can be functions that are applied to the values obtained so far.
        /// https://reference.wolfram.com/language/ref/FormFunction.html
        ///</summary>
        corewolf::engine *FormFunction(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FormFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a form with fields having names namei that take data of type typei.
        /// https://reference.wolfram.com/language/ref/FormObject.html
        ///</summary>
        corewolf::engine *FormObject(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FormObject[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents an active page that takes input from a form and generates results on the same page by applying func to the values obtained from the form whose structure is defined by formspec.
        /// https://reference.wolfram.com/language/ref/FormPage.html
        ///</summary>
        corewolf::engine *FormPage(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FormPage[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an active form page with fields named namei interpreted as types typei.
        /// https://reference.wolfram.com/language/ref/FormPage.html
        ///</summary>
        corewolf::engine *FormPage(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FormPage[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// lays out the page according to the layout specification form.
        /// https://reference.wolfram.com/language/ref/FormPage.html
        ///</summary>
        corewolf::engine *FormPage(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FormPage[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the equations for the formula name.
        /// https://reference.wolfram.com/language/ref/FormulaData.html
        ///</summary>
        corewolf::engine *FormulaData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FormulaData[" + arg0 + "]", name);
        }

        ///< summary>
        /// solves or simplifies equations using the specified values quantityi for the variables vari.
        /// https://reference.wolfram.com/language/ref/FormulaData.html
        ///</summary>
        corewolf::engine *FormulaData(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FormulaData[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the formula name.
        /// https://reference.wolfram.com/language/ref/FormulaData.html
        ///</summary>
        corewolf::engine *FormulaData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FormulaData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the full names of formulas whose names are consistent with "query".
        /// https://reference.wolfram.com/language/ref/FormulaLookup.html
        ///</summary>
        corewolf::engine *FormulaLookup(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FormulaLookup[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns at most n results.
        /// https://reference.wolfram.com/language/ref/FormulaLookup.html
        ///</summary>
        corewolf::engine *FormulaLookup(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FormulaLookup[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// prints as a Fortran language version of expr.
        /// https://reference.wolfram.com/language/ref/FortranForm.html
        ///</summary>
        corewolf::engine *FortranForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FortranForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds the discrete Fourier transform of a list of complex numbers.
        /// https://reference.wolfram.com/language/ref/Fourier.html
        ///</summary>
        corewolf::engine *Fourier(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Fourier[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the specified positions of the discrete Fourier transform.
        /// https://reference.wolfram.com/language/ref/Fourier.html
        ///</summary>
        corewolf::engine *Fourier(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Fourier[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the n coefficient in the Fourier series expansion of expr.
        /// https://reference.wolfram.com/language/ref/FourierCoefficient.html
        ///</summary>
        corewolf::engine *FourierCoefficient(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FourierCoefficient[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a multidimensional Fourier coefficient.
        /// https://reference.wolfram.com/language/ref/FourierCoefficient.html
        ///</summary>
        corewolf::engine *FourierCoefficient(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FourierCoefficient[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the n coefficient in the Fourier cosine series expansion of expr.
        /// https://reference.wolfram.com/language/ref/FourierCosCoefficient.html
        ///</summary>
        corewolf::engine *FourierCosCoefficient(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FourierCosCoefficient[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a multidimensional Fourier cosine coefficient.
        /// https://reference.wolfram.com/language/ref/FourierCosCoefficient.html
        ///</summary>
        corewolf::engine *FourierCosCoefficient(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FourierCosCoefficient[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the n-order Fourier cosine series expansion of expr in t.
        /// https://reference.wolfram.com/language/ref/FourierCosSeries.html
        ///</summary>
        corewolf::engine *FourierCosSeries(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FourierCosSeries[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional Fourier cosine series of expr.
        /// https://reference.wolfram.com/language/ref/FourierCosSeries.html
        ///</summary>
        corewolf::engine *FourierCosSeries(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FourierCosSeries[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the symbolic Fourier cosine transform of expr.
        /// https://reference.wolfram.com/language/ref/FourierCosTransform.html
        ///</summary>
        corewolf::engine *FourierCosTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FourierCosTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional Fourier cosine transform of expr.
        /// https://reference.wolfram.com/language/ref/FourierCosTransform.html
        ///</summary>
        corewolf::engine *FourierCosTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FourierCosTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// finds the Fourier discrete cosine transform of a list of real numbers.
        /// https://reference.wolfram.com/language/ref/FourierDCT.html
        ///</summary>
        corewolf::engine *FourierDCT(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FourierDCT[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds the Fourier discrete cosine transform of type m.
        /// https://reference.wolfram.com/language/ref/FourierDCT.html
        ///</summary>
        corewolf::engine *FourierDCT(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FourierDCT[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reduces noise in image by locally thresholding the discrete cosine transforms of overlapping subimages, using the hard threshold t.
        /// https://reference.wolfram.com/language/ref/FourierDCTFilter.html
        ///</summary>
        corewolf::engine *FourierDCTFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FourierDCTFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns an n×n discrete cosine transform matrix of type 2.
        /// https://reference.wolfram.com/language/ref/FourierDCTMatrix.html
        ///</summary>
        corewolf::engine *FourierDCTMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FourierDCTMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns an n×n discrete cosine transform matrix of type m.
        /// https://reference.wolfram.com/language/ref/FourierDCTMatrix.html
        ///</summary>
        corewolf::engine *FourierDCTMatrix(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FourierDCTMatrix[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the Fourier discrete sine transform of a list of real numbers.
        /// https://reference.wolfram.com/language/ref/FourierDST.html
        ///</summary>
        corewolf::engine *FourierDST(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FourierDST[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds the Fourier discrete sine transform of type .
        /// https://reference.wolfram.com/language/ref/FourierDST.html
        ///</summary>
        corewolf::engine *FourierDST(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FourierDST[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns an n×n discrete sine transform matrix of type 2.
        /// https://reference.wolfram.com/language/ref/FourierDSTMatrix.html
        ///</summary>
        corewolf::engine *FourierDSTMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FourierDSTMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns an n×n discrete sine transform matrix of type m.
        /// https://reference.wolfram.com/language/ref/FourierDSTMatrix.html
        ///</summary>
        corewolf::engine *FourierDSTMatrix(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FourierDSTMatrix[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns an n×n Fourier matrix.
        /// https://reference.wolfram.com/language/ref/FourierMatrix.html
        ///</summary>
        corewolf::engine *FourierMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FourierMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Fourier sequence transform of expr.
        /// https://reference.wolfram.com/language/ref/FourierSequenceTransform.html
        ///</summary>
        corewolf::engine *FourierSequenceTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FourierSequenceTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional Fourier sequence transform.
        /// https://reference.wolfram.com/language/ref/FourierSequenceTransform.html
        ///</summary>
        corewolf::engine *FourierSequenceTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FourierSequenceTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the n-order Fourier series expansion of expr in t.
        /// https://reference.wolfram.com/language/ref/FourierSeries.html
        ///</summary>
        corewolf::engine *FourierSeries(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FourierSeries[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional Fourier series.
        /// https://reference.wolfram.com/language/ref/FourierSeries.html
        ///</summary>
        corewolf::engine *FourierSeries(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FourierSeries[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the n coefficient in the Fourier sine series expansion of expr.
        /// https://reference.wolfram.com/language/ref/FourierSinCoefficient.html
        ///</summary>
        corewolf::engine *FourierSinCoefficient(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FourierSinCoefficient[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a multidimensional Fourier sine coefficient.
        /// https://reference.wolfram.com/language/ref/FourierSinCoefficient.html
        ///</summary>
        corewolf::engine *FourierSinCoefficient(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FourierSinCoefficient[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the n-order Fourier sine series expansion of expr in t.
        /// https://reference.wolfram.com/language/ref/FourierSinSeries.html
        ///</summary>
        corewolf::engine *FourierSinSeries(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FourierSinSeries[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional Fourier sine series of expr.
        /// https://reference.wolfram.com/language/ref/FourierSinSeries.html
        ///</summary>
        corewolf::engine *FourierSinSeries(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FourierSinSeries[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the symbolic Fourier sine transform of expr.
        /// https://reference.wolfram.com/language/ref/FourierSinTransform.html
        ///</summary>
        corewolf::engine *FourierSinTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FourierSinTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional Fourier sine transform of expr.
        /// https://reference.wolfram.com/language/ref/FourierSinTransform.html
        ///</summary>
        corewolf::engine *FourierSinTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FourierSinTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the symbolic Fourier transform of expr.
        /// https://reference.wolfram.com/language/ref/FourierTransform.html
        ///</summary>
        corewolf::engine *FourierTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FourierTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional Fourier transform of expr.
        /// https://reference.wolfram.com/language/ref/FourierTransform.html
        ///</summary>
        corewolf::engine *FourierTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FourierTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the n-order Fourier trigonometric series expansion of expr in t.
        /// https://reference.wolfram.com/language/ref/FourierTrigSeries.html
        ///</summary>
        corewolf::engine *FourierTrigSeries(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FourierTrigSeries[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional Fourier trigonometric series of expr.
        /// https://reference.wolfram.com/language/ref/FourierTrigSeries.html
        ///</summary>
        corewolf::engine *FourierTrigSeries(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("FourierTrigSeries[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// is the Fox H function .
        /// https://reference.wolfram.com/language/ref/FoxH.html
        ///</summary>
        corewolf::engine *FoxH(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &arg4, const std::vector<std::string> &arg5, const std::vector<std::string> &arg6, const std::string &arg7, const std::vector<std::string> &arg8, const std::vector<std::string> &arg9, const std::string &arg10, const std::vector<std::string> &arg11, const std::string &arg12, const std::string &name = "")
        {
            return this->execute("FoxH[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + arg4 + ", " + std::to_string('{') + engine::_print_vector(arg5) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg6) + "}" + ", " + arg7 + ", " + std::to_string('{') + engine::_print_vector(arg8) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg9) + "}" + ", " + arg10 + ", " + std::to_string('{') + engine::_print_vector(arg11) + "}" + ", " + arg12 + "]", name);
        }

        ///< summary>
        /// attempts to reduce expr to a single FoxH const std::string &as a function of x.
        /// https://reference.wolfram.com/language/ref/FoxHReduce.html
        ///</summary>
        corewolf::engine *FoxHReduce(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FoxHReduce[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents fractional Brownian motion process with drift μ, volatility σ, and Hurst index h.
        /// https://reference.wolfram.com/language/ref/FractionalBrownianMotionProcess.html
        ///</summary>
        corewolf::engine *FractionalBrownianMotionProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FractionalBrownianMotionProcess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents fractional Brownian motion process with drift 0, volatility 1, and Hurst index h.
        /// https://reference.wolfram.com/language/ref/FractionalBrownianMotionProcess.html
        ///</summary>
        corewolf::engine *FractionalBrownianMotionProcess(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FractionalBrownianMotionProcess[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Riemann–Liouville fractional derivative  of order α of the function f.
        /// https://reference.wolfram.com/language/ref/FractionalD.html
        ///</summary>
        corewolf::engine *FractionalD(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FractionalD[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a fractional Gaussian noise process with drift μ, volatility σ, and Hurst index h.
        /// https://reference.wolfram.com/language/ref/FractionalGaussianNoiseProcess.html
        ///</summary>
        corewolf::engine *FractionalGaussianNoiseProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FractionalGaussianNoiseProcess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a fractional Gaussian noise process with drift 0, volatility 1, and Hurst index h.
        /// https://reference.wolfram.com/language/ref/FractionalGaussianNoiseProcess.html
        ///</summary>
        corewolf::engine *FractionalGaussianNoiseProcess(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FractionalGaussianNoiseProcess[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the fractional part of x.
        /// https://reference.wolfram.com/language/ref/FractionalPart.html
        ///</summary>
        corewolf::engine *FractionalPart(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FractionalPart[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a low-level formatting construct that represents  in notebook expressions.
        /// https://reference.wolfram.com/language/ref/FractionBox.html
        ///</summary>
        corewolf::engine *FractionBox(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FractionBox[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a low-level box construct that represents box with a frame drawn around it.
        /// https://reference.wolfram.com/language/ref/FrameBox.html
        ///</summary>
        corewolf::engine *FrameBox(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FrameBox[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays a framed version of expr.
        /// https://reference.wolfram.com/language/ref/Framed.html
        ///</summary>
        corewolf::engine *Framed(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Framed[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a video containing frames image1, image2, etc.
        /// https://reference.wolfram.com/language/ref/FrameListVideo.html
        ///</summary>
        corewolf::engine *FrameListVideo(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FrameListVideo[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a video from existing image files.
        /// https://reference.wolfram.com/language/ref/FrameListVideo.html
        ///</summary>
        corewolf::engine *FrameListVideo(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FrameListVideo[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an F-ratio distribution with n numerator and m denominator degrees of freedom.
        /// https://reference.wolfram.com/language/ref/FRatioDistribution.html
        ///</summary>
        corewolf::engine *FRatioDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FRatioDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the Fréchet distribution with shape parameter α and scale parameter β.
        /// https://reference.wolfram.com/language/ref/FrechetDistribution.html
        ///</summary>
        corewolf::engine *FrechetDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FrechetDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the Fréchet distribution with shape parameter α, scale parameter β, and location parameter μ.
        /// https://reference.wolfram.com/language/ref/FrechetDistribution.html
        ///</summary>
        corewolf::engine *FrechetDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FrechetDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields True if no subexpression in expr matches form, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/FreeQ.html
        ///</summary>
        corewolf::engine *FreeQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FreeQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests only those parts of expr on levels specified by levelspec.
        /// https://reference.wolfram.com/language/ref/FreeQ.html
        ///</summary>
        corewolf::engine *FreeQ(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FreeQ[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of FreeQ that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/FreeQ.html
        ///</summary>
        corewolf::engine *FreeQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FreeQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the generalized curvatures and Frenet–Serret basis for the parametric curve xi[t].
        /// https://reference.wolfram.com/language/ref/FrenetSerretSystem.html
        ///</summary>
        corewolf::engine *FrenetSerretSystem(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FrenetSerretSystem[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// interprets the xi as coordinates in the specified coordinate chart.
        /// https://reference.wolfram.com/language/ref/FrenetSerretSystem.html
        ///</summary>
        corewolf::engine *FrenetSerretSystem(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FrenetSerretSystem[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// creates a finite impulse response (FIR) filter kernel using a frequency sampling method from amplitude values ai.
        /// https://reference.wolfram.com/language/ref/FrequencySamplingFilterKernel.html
        ///</summary>
        corewolf::engine *FrequencySamplingFilterKernel(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FrequencySamplingFilterKernel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// creates an FIR filter kernel of type m.
        /// https://reference.wolfram.com/language/ref/FrequencySamplingFilterKernel.html
        ///</summary>
        corewolf::engine *FrequencySamplingFilterKernel(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FrequencySamplingFilterKernel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Fresnel integral .
        /// https://reference.wolfram.com/language/ref/FresnelC.html
        ///</summary>
        corewolf::engine *FresnelC(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FresnelC[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Fresnel auxiliary function .
        /// https://reference.wolfram.com/language/ref/FresnelF.html
        ///</summary>
        corewolf::engine *FresnelF(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FresnelF[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Fresnel auxiliary function .
        /// https://reference.wolfram.com/language/ref/FresnelG.html
        ///</summary>
        corewolf::engine *FresnelG(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FresnelG[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Fresnel integral .
        /// https://reference.wolfram.com/language/ref/FresnelS.html
        ///</summary>
        corewolf::engine *FresnelS(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FresnelS[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Frobenius number of a1,…,an.
        /// https://reference.wolfram.com/language/ref/FrobeniusNumber.html
        ///</summary>
        corewolf::engine *FrobeniusNumber(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FrobeniusNumber[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of all solutions of the Frobenius equation .
        /// https://reference.wolfram.com/language/ref/FrobeniusSolve.html
        ///</summary>
        corewolf::engine *FrobeniusSolve(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FrobeniusSolve[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives at most m solutions.
        /// https://reference.wolfram.com/language/ref/FrobeniusSolve.html
        ///</summary>
        corewolf::engine *FrobeniusSolve(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FrobeniusSolve[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a date const std::string &corresponding to an absolute time specification as given by AbsoluteTime.
        /// https://reference.wolfram.com/language/ref/FromAbsoluteTime.html
        ///</summary>
        corewolf::engine *FromAbsoluteTime(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FromAbsoluteTime[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a string consisting of the character with integer code n.
        /// https://reference.wolfram.com/language/ref/FromCharacterCode.html
        ///</summary>
        corewolf::engine *FromCharacterCode(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FromCharacterCode[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a string consisting of the sequence of characters with codes ni.
        /// https://reference.wolfram.com/language/ref/FromCharacterCode.html
        ///</summary>
        corewolf::engine *FromCharacterCode(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FromCharacterCode[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of strings.
        /// https://reference.wolfram.com/language/ref/FromCharacterCode.html
        ///</summary>
        corewolf::engine *FromCharacterCode(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FromCharacterCode[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses the specified character encoding.
        /// https://reference.wolfram.com/language/ref/FromCharacterCode.html
        ///</summary>
        corewolf::engine *FromCharacterCode(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FromCharacterCode[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// constructs a polynomial from a list of rules for exponent vectors and coefficients.
        /// https://reference.wolfram.com/language/ref/FromCoefficientRules.html
        ///</summary>
        corewolf::engine *FromCoefficientRules(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FromCoefficientRules[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// reconstructs a number from the list of its continued fraction terms.
        /// https://reference.wolfram.com/language/ref/FromContinuedFraction.html
        ///</summary>
        corewolf::engine *FromContinuedFraction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FromContinuedFraction[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a date const std::string &corresponding to the date represented by "string".
        /// https://reference.wolfram.com/language/ref/FromDateString.html
        ///</summary>
        corewolf::engine *FromDateString(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FromDateString[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the date const std::string &obtained by extracting elements "ei" from "string".
        /// https://reference.wolfram.com/language/ref/FromDateString.html
        ///</summary>
        corewolf::engine *FromDateString(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FromDateString[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the date const std::string &obtained using the date format fmt.
        /// https://reference.wolfram.com/language/ref/FromDateString.html
        ///</summary>
        corewolf::engine *FromDateString(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FromDateString[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// constructs an integer from the list of its decimal digits.
        /// https://reference.wolfram.com/language/ref/FromDigits.html
        ///</summary>
        corewolf::engine *FromDigits(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FromDigits[" + arg0 + "]", name);
        }

        ///< summary>
        /// takes the digits to be given in base b.
        /// https://reference.wolfram.com/language/ref/FromDigits.html
        ///</summary>
        corewolf::engine *FromDigits(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FromDigits[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts from degrees, minutes, and seconds to decimal degrees.
        /// https://reference.wolfram.com/language/ref/FromDMS.html
        ///</summary>
        corewolf::engine *FromDMS(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FromDMS[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// converts from a DMS string to decimal degrees.
        /// https://reference.wolfram.com/language/ref/FromDMS.html
        ///</summary>
        corewolf::engine *FromDMS(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FromDMS[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a Wolfram Language const std::string &corresponding to an entity.
        /// https://reference.wolfram.com/language/ref/FromEntity.html
        ///</summary>
        corewolf::engine *FromEntity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FromEntity[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a date const std::string &corresponding to the Julian date jd.
        /// https://reference.wolfram.com/language/ref/FromJulianDate.html
        ///</summary>
        corewolf::engine *FromJulianDate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FromJulianDate[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a date const std::string &corresponding to the specified Julian date variant.
        /// https://reference.wolfram.com/language/ref/FromJulianDate.html
        ///</summary>
        corewolf::engine *FromJulianDate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FromJulianDate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the lowercase letter at position n in the English alphabet.
        /// https://reference.wolfram.com/language/ref/FromLetterNumber.html
        ///</summary>
        corewolf::engine *FromLetterNumber(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FromLetterNumber[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the letter at position n in the alphabet specified by alpha.
        /// https://reference.wolfram.com/language/ref/FromLetterNumber.html
        ///</summary>
        corewolf::engine *FromLetterNumber(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FromLetterNumber[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the {x,y} Cartesian coordinates corresponding to the polar coordinates {r,θ}.
        /// https://reference.wolfram.com/language/ref/FromPolarCoordinates.html
        ///</summary>
        corewolf::engine *FromPolarCoordinates(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FromPolarCoordinates[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns the value referred to by the pointer p for use in compiled code.
        /// https://reference.wolfram.com/language/ref/FromRawPointer.html
        ///</summary>
        corewolf::engine *FromRawPointer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FromRawPointer[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the value of a C array at an offset.
        /// https://reference.wolfram.com/language/ref/FromRawPointer.html
        ///</summary>
        corewolf::engine *FromRawPointer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FromRawPointer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the integer corresponding to the Roman numeral "string".
        /// https://reference.wolfram.com/language/ref/FromRomanNumeral.html
        ///</summary>
        corewolf::engine *FromRomanNumeral(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FromRomanNumeral[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the {x,y,z} Cartesian coordinates corresponding to the spherical coordinates {r,θ,ϕ}.
        /// https://reference.wolfram.com/language/ref/FromSphericalCoordinates.html
        ///</summary>
        corewolf::engine *FromSphericalCoordinates(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FromSphericalCoordinates[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a date const std::string &corresponding to a UnixTime specification.
        /// https://reference.wolfram.com/language/ref/FromUnixTime.html
        ///</summary>
        corewolf::engine *FromUnixTime(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FromUnixTime[" + arg0 + "]", name);
        }

        ///< summary>
        /// sends expr to be executed by the Wolfram System front end.
        /// https://reference.wolfram.com/language/ref/FrontEndExecute.html
        ///</summary>
        corewolf::engine *FrontEndExecute(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FrontEndExecute[" + arg0 + "]", name);
        }

        ///< summary>
        /// is an const std::string &that represents a front end command token, typically corresponding to a front end menu item, to be executed by FrontEndExecute.
        /// https://reference.wolfram.com/language/ref/FrontEndToken.html
        ///</summary>
        corewolf::engine *FrontEndToken(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FrontEndToken[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a command that targets the specified notebook.
        /// https://reference.wolfram.com/language/ref/FrontEndToken.html
        ///</summary>
        corewolf::engine *FrontEndToken(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FrontEndToken[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a command with a parameter.
        /// https://reference.wolfram.com/language/ref/FrontEndToken.html
        ///</summary>
        corewolf::engine *FrontEndToken(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FrontEndToken[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// executes the specified front end command token, typically corresponding to a front end menu item.
        /// https://reference.wolfram.com/language/ref/FrontEndTokenExecute.html
        ///</summary>
        corewolf::engine *FrontEndTokenExecute(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FrontEndTokenExecute[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints as the definitions given for symbol, and all symbols on which these depend.
        /// https://reference.wolfram.com/language/ref/FullDefinition.html
        ///</summary>
        corewolf::engine *FullDefinition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FullDefinition[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints as the full form of expr, with no special syntax.
        /// https://reference.wolfram.com/language/ref/FullForm.html
        ///</summary>
        corewolf::engine *FullForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FullForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// takes a graphics object, and generates a new one in which objects specified by graphics options are given as explicit lists of graphics primitives.
        /// https://reference.wolfram.com/language/ref/FullGraphics.html
        ///</summary>
        corewolf::engine *FullGraphics(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FullGraphics[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the full state information output regulator for sys using specification rspec.
        /// https://reference.wolfram.com/language/ref/FullInformationOutputRegulator.html
        ///</summary>
        corewolf::engine *FullInformationOutputRegulator(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FullInformationOutputRegulator[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies the regulated outputs outi and the controlled inputs inj.
        /// https://reference.wolfram.com/language/ref/FullInformationOutputRegulator.html
        ///</summary>
        corewolf::engine *FullInformationOutputRegulator(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FullInformationOutputRegulator[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents the full region .
        /// https://reference.wolfram.com/language/ref/FullRegion.html
        ///</summary>
        corewolf::engine *FullRegion(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FullRegion[" + arg0 + "]", name);
        }

        ///< summary>
        /// tries a wide range of transformations on expr involving elementary and special functions and returns the simplest form it finds.
        /// https://reference.wolfram.com/language/ref/FullSimplify.html
        ///</summary>
        corewolf::engine *FullSimplify(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FullSimplify[" + arg0 + "]", name);
        }

        ///< summary>
        /// does simplification using assumptions.
        /// https://reference.wolfram.com/language/ref/FullSimplify.html
        ///</summary>
        corewolf::engine *FullSimplify(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FullSimplify[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a pure (or "anonymous") function. The formal parameters are # (or #1), #2, etc.
        /// https://reference.wolfram.com/language/ref/Function.html
        ///</summary>
        corewolf::engine *Function(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Function[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a pure function with a single formal parameter x.
        /// https://reference.wolfram.com/language/ref/Function.html
        ///</summary>
        corewolf::engine *Function(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Function[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a pure function that is treated as having attributes attrs for purposes of evaluation.
        /// https://reference.wolfram.com/language/ref/Function.html
        ///</summary>
        corewolf::engine *Function(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Function[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether  is an analytic function for x∈Reals.
        /// https://reference.wolfram.com/language/ref/FunctionAnalytic.html
        ///</summary>
        corewolf::engine *FunctionAnalytic(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionAnalytic[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether  is an analytic function for x∈dom.
        /// https://reference.wolfram.com/language/ref/FunctionAnalytic.html
        ///</summary>
        corewolf::engine *FunctionAnalytic(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionAnalytic[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether  are analytic functions for x1,x2,…∈dom.
        /// https://reference.wolfram.com/language/ref/FunctionAnalytic.html
        ///</summary>
        corewolf::engine *FunctionAnalytic(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionAnalytic[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether  are analytic functions for xvars in an open set containing the solutions of the constraints cons over the domain dom.
        /// https://reference.wolfram.com/language/ref/FunctionAnalytic.html
        ///</summary>
        corewolf::engine *FunctionAnalytic(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionAnalytic[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether  has exactly one solution x∈Reals for each y∈Reals.
        /// https://reference.wolfram.com/language/ref/FunctionBijective.html
        ///</summary>
        corewolf::engine *FunctionBijective(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionBijective[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether  has exactly one solution x∈dom for each y∈dom.
        /// https://reference.wolfram.com/language/ref/FunctionBijective.html
        ///</summary>
        corewolf::engine *FunctionBijective(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionBijective[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether  has exactly one solution x1,x2,…∈dom for each y1,y2,…∈dom.
        /// https://reference.wolfram.com/language/ref/FunctionBijective.html
        ///</summary>
        corewolf::engine *FunctionBijective(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionBijective[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether  has exactly one solution with xvars∈dom restricted by the constraints xcons for each yvars∈dom restricted by the constraints ycons.
        /// https://reference.wolfram.com/language/ref/FunctionBijective.html
        ///</summary>
        corewolf::engine *FunctionBijective(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FunctionBijective[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// generates a compiled code function from a pure function.
        /// https://reference.wolfram.com/language/ref/FunctionCompile.html
        ///</summary>
        corewolf::engine *FunctionCompile(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FunctionCompile[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a list of compiled code functions from a list of pure functions.
        /// https://reference.wolfram.com/language/ref/FunctionCompile.html
        ///</summary>
        corewolf::engine *FunctionCompile(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("FunctionCompile[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates an association of compiled code functions from an association of Wolfram Language functions.
        /// https://reference.wolfram.com/language/ref/FunctionCompile.html
        ///</summary>
        corewolf::engine *FunctionCompile(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionCompile[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses the local auxiliary definitions defs.
        /// https://reference.wolfram.com/language/ref/FunctionCompile.html
        ///</summary>
        corewolf::engine *FunctionCompile(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionCompile[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// exports a compiled version of functions fspec in the format specified by the file extension ext.
        /// https://reference.wolfram.com/language/ref/FunctionCompileExport.html
        ///</summary>
        corewolf::engine *FunctionCompileExport(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionCompileExport[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// exports a compiled version of fspec using local auxiliary definitions defs.
        /// https://reference.wolfram.com/language/ref/FunctionCompileExport.html
        ///</summary>
        corewolf::engine *FunctionCompileExport(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionCompileExport[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// exports a compiled version using local auxiliary definitions.
        /// https://reference.wolfram.com/language/ref/FunctionCompileExport.html
        ///</summary>
        corewolf::engine *FunctionCompileExport(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FunctionCompileExport[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives a byte array of binary LLVM code obtained by compiling the function specification fspec.
        /// https://reference.wolfram.com/language/ref/FunctionCompileExportByteArray.html
        ///</summary>
        corewolf::engine *FunctionCompileExportByteArray(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FunctionCompileExportByteArray[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the auxiliary definitions defs for compilation.
        /// https://reference.wolfram.com/language/ref/FunctionCompileExportByteArray.html
        ///</summary>
        corewolf::engine *FunctionCompileExportByteArray(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionCompileExportByteArray[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// exports a compiled version of function specification fspec as a shared library suitable for external use.
        /// https://reference.wolfram.com/language/ref/FunctionCompileExportLibrary.html
        ///</summary>
        corewolf::engine *FunctionCompileExportLibrary(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionCompileExportLibrary[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the auxiliary definitions defs for compilation.
        /// https://reference.wolfram.com/language/ref/FunctionCompileExportLibrary.html
        ///</summary>
        corewolf::engine *FunctionCompileExportLibrary(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionCompileExportLibrary[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a string of textual LLVM code obtained by compiling the function specification fspec.
        /// https://reference.wolfram.com/language/ref/FunctionCompileExportString.html
        ///</summary>
        corewolf::engine *FunctionCompileExportString(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FunctionCompileExportString[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the auxiliary definitions defs for compilation.
        /// https://reference.wolfram.com/language/ref/FunctionCompileExportString.html
        ///</summary>
        corewolf::engine *FunctionCompileExportString(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionCompileExportString[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether  is a real-valued continuous function for x∈Reals.
        /// https://reference.wolfram.com/language/ref/FunctionContinuous.html
        ///</summary>
        corewolf::engine *FunctionContinuous(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionContinuous[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether  is a continuous function for x∈dom.
        /// https://reference.wolfram.com/language/ref/FunctionContinuous.html
        ///</summary>
        corewolf::engine *FunctionContinuous(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionContinuous[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether  are continuous functions for x1,x2,…∈dom.
        /// https://reference.wolfram.com/language/ref/FunctionContinuous.html
        ///</summary>
        corewolf::engine *FunctionContinuous(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionContinuous[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether  are continuous functions for xvars∈dom restricted by the constraints cons.
        /// https://reference.wolfram.com/language/ref/FunctionContinuous.html
        ///</summary>
        corewolf::engine *FunctionContinuous(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionContinuous[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds the convexity of the function f with variables x1,x2,… over the reals.
        /// https://reference.wolfram.com/language/ref/FunctionConvexity.html
        ///</summary>
        corewolf::engine *FunctionConvexity(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FunctionConvexity[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds the convexity when variables are restricted by the constraints cons representing a convex region.
        /// https://reference.wolfram.com/language/ref/FunctionConvexity.html
        ///</summary>
        corewolf::engine *FunctionConvexity(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FunctionConvexity[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// declares name to be a typed function suitable for use in a compiler environment.
        /// https://reference.wolfram.com/language/ref/FunctionDeclaration.html
        ///</summary>
        corewolf::engine *FunctionDeclaration(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionDeclaration[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the discontinuities of  for x∈Reals.
        /// https://reference.wolfram.com/language/ref/FunctionDiscontinuities.html
        ///</summary>
        corewolf::engine *FunctionDiscontinuities(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionDiscontinuities[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the discontinuities of  for x∈dom.
        /// https://reference.wolfram.com/language/ref/FunctionDiscontinuities.html
        ///</summary>
        corewolf::engine *FunctionDiscontinuities(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionDiscontinuities[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds the discontinuities of  for x1,x2,…∈dom.
        /// https://reference.wolfram.com/language/ref/FunctionDiscontinuities.html
        ///</summary>
        corewolf::engine *FunctionDiscontinuities(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionDiscontinuities[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds the largest domain of definition of the real function f of the variable x.
        /// https://reference.wolfram.com/language/ref/FunctionDomain.html
        ///</summary>
        corewolf::engine *FunctionDomain(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionDomain[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// considers f to be a function with arguments and values in the domain dom.
        /// https://reference.wolfram.com/language/ref/FunctionDomain.html
        ///</summary>
        corewolf::engine *FunctionDomain(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionDomain[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds the domain of funs with the values of vars restricted by constraints cons.
        /// https://reference.wolfram.com/language/ref/FunctionDomain.html
        ///</summary>
        corewolf::engine *FunctionDomain(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionDomain[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tries to expand out special and certain other functions in expr, when possible reducing compound arguments to simpler ones.
        /// https://reference.wolfram.com/language/ref/FunctionExpand.html
        ///</summary>
        corewolf::engine *FunctionExpand(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FunctionExpand[" + arg0 + "]", name);
        }

        ///< summary>
        /// expands using assumptions.
        /// https://reference.wolfram.com/language/ref/FunctionExpand.html
        ///</summary>
        corewolf::engine *FunctionExpand(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionExpand[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether  has at most one solution x∈Reals for each y.
        /// https://reference.wolfram.com/language/ref/FunctionInjective.html
        ///</summary>
        corewolf::engine *FunctionInjective(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionInjective[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether  has at most one solution x∈dom.
        /// https://reference.wolfram.com/language/ref/FunctionInjective.html
        ///</summary>
        corewolf::engine *FunctionInjective(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionInjective[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether  has at most one solution x1,x2,…∈dom.
        /// https://reference.wolfram.com/language/ref/FunctionInjective.html
        ///</summary>
        corewolf::engine *FunctionInjective(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionInjective[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether  has at most one solution with xvars∈dom restricted by the constraints xcons for each yvars∈dom restricted by the constraints ycons.
        /// https://reference.wolfram.com/language/ref/FunctionInjective.html
        ///</summary>
        corewolf::engine *FunctionInjective(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FunctionInjective[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// evaluates expr with x running from xmin to xmax and constructs an InterpolatingFunction const std::string &which represents an approximate function corresponding to the result.
        /// https://reference.wolfram.com/language/ref/FunctionInterpolation.html
        ///</summary>
        corewolf::engine *FunctionInterpolation(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FunctionInterpolation[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// constructs an InterpolatingFunction const std::string &with several arguments.
        /// https://reference.wolfram.com/language/ref/FunctionInterpolation.html
        ///</summary>
        corewolf::engine *FunctionInterpolation(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FunctionInterpolation[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a net layer that applies function f to its input.
        /// https://reference.wolfram.com/language/ref/FunctionLayer.html
        ///</summary>
        corewolf::engine *FunctionLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("FunctionLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// test whether  is a meromorphic function of x.
        /// https://reference.wolfram.com/language/ref/FunctionMeromorphic.html
        ///</summary>
        corewolf::engine *FunctionMeromorphic(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionMeromorphic[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// test whether  is a meromorphic function of x1,x2,….
        /// https://reference.wolfram.com/language/ref/FunctionMeromorphic.html
        ///</summary>
        corewolf::engine *FunctionMeromorphic(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FunctionMeromorphic[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// test whether  are meromorphic functions for x1,x2,….
        /// https://reference.wolfram.com/language/ref/FunctionMeromorphic.html
        ///</summary>
        corewolf::engine *FunctionMeromorphic(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FunctionMeromorphic[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// test whether  are meromorphic functions for xvars in an open set containing the solutions of the constraints cons.
        /// https://reference.wolfram.com/language/ref/FunctionMeromorphic.html
        ///</summary>
        corewolf::engine *FunctionMeromorphic(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionMeromorphic[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the monotonicity of the function f with the variable x over the reals.
        /// https://reference.wolfram.com/language/ref/FunctionMonotonicity.html
        ///</summary>
        corewolf::engine *FunctionMonotonicity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionMonotonicity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the monotonicity of f when x is restricted to the domain dom.
        /// https://reference.wolfram.com/language/ref/FunctionMonotonicity.html
        ///</summary>
        corewolf::engine *FunctionMonotonicity(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionMonotonicity[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the monotonicity of f when x is restricted by the constraints cons.
        /// https://reference.wolfram.com/language/ref/FunctionMonotonicity.html
        ///</summary>
        corewolf::engine *FunctionMonotonicity(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionMonotonicity[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a period p of the function f over the reals such that .
        /// https://reference.wolfram.com/language/ref/FunctionPeriod.html
        ///</summary>
        corewolf::engine *FunctionPeriod(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionPeriod[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a period with x restricted to the domain dom.
        /// https://reference.wolfram.com/language/ref/FunctionPeriod.html
        ///</summary>
        corewolf::engine *FunctionPeriod(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionPeriod[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives periods {p1,p2,…} for {x1,x2,…} such that .
        /// https://reference.wolfram.com/language/ref/FunctionPeriod.html
        ///</summary>
        corewolf::engine *FunctionPeriod(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionPeriod[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds the poles of the meromorphic function f with the variable x.
        /// https://reference.wolfram.com/language/ref/FunctionPoles.html
        ///</summary>
        corewolf::engine *FunctionPoles(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionPoles[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the poles of f when x is restricted by the constraints cons.
        /// https://reference.wolfram.com/language/ref/FunctionPoles.html
        ///</summary>
        corewolf::engine *FunctionPoles(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionPoles[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the range of the real function f of the variable x returning the result in terms of y.
        /// https://reference.wolfram.com/language/ref/FunctionRange.html
        ///</summary>
        corewolf::engine *FunctionRange(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionRange[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// considers f to be a function with arguments and values in the domain dom.
        /// https://reference.wolfram.com/language/ref/FunctionRange.html
        ///</summary>
        corewolf::engine *FunctionRange(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FunctionRange[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// finds the range of the mapping funs with the values of xvars restricted by constraints cons.
        /// https://reference.wolfram.com/language/ref/FunctionRange.html
        ///</summary>
        corewolf::engine *FunctionRange(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FunctionRange[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// finds the real sign of the function f with variables x1,x2,… over the reals.
        /// https://reference.wolfram.com/language/ref/FunctionSign.html
        ///</summary>
        corewolf::engine *FunctionSign(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("FunctionSign[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds the real sign with variables restricted to the domain dom.
        /// https://reference.wolfram.com/language/ref/FunctionSign.html
        ///</summary>
        corewolf::engine *FunctionSign(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionSign[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the sign when variables are restricted by the constraints cons.
        /// https://reference.wolfram.com/language/ref/FunctionSign.html
        ///</summary>
        corewolf::engine *FunctionSign(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionSign[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds the singularities of  for x∈Reals.
        /// https://reference.wolfram.com/language/ref/FunctionSingularities.html
        ///</summary>
        corewolf::engine *FunctionSingularities(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionSingularities[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the singularities of  for x∈dom.
        /// https://reference.wolfram.com/language/ref/FunctionSingularities.html
        ///</summary>
        corewolf::engine *FunctionSingularities(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionSingularities[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds the singularities of  for x1,x2,…∈dom.
        /// https://reference.wolfram.com/language/ref/FunctionSingularities.html
        ///</summary>
        corewolf::engine *FunctionSingularities(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionSingularities[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether  has at least one solution  for each y∈Reals.
        /// https://reference.wolfram.com/language/ref/FunctionSurjective.html
        ///</summary>
        corewolf::engine *FunctionSurjective(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FunctionSurjective[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether  has at least one solution x∈dom for each y∈dom.
        /// https://reference.wolfram.com/language/ref/FunctionSurjective.html
        ///</summary>
        corewolf::engine *FunctionSurjective(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionSurjective[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether  has at least one solution x1,x2,…∈dom for each y1,y2,…∈dom.
        /// https://reference.wolfram.com/language/ref/FunctionSurjective.html
        ///</summary>
        corewolf::engine *FunctionSurjective(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("FunctionSurjective[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether  has at least one solution with xvars∈dom restricted by the constraints xcons for each yvars∈dom restricted by the constraints ycons.
        /// https://reference.wolfram.com/language/ref/FunctionSurjective.html
        ///</summary>
        corewolf::engine *FunctionSurjective(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("FunctionSurjective[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the Fussell–Vesely importances for all components in the ReliabilityDistribution rdist at time t.
        /// https://reference.wolfram.com/language/ref/FussellVeselyImportance.html
        ///</summary>
        corewolf::engine *FussellVeselyImportance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("FussellVeselyImportance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// filters data by convolving with a Gabor kernel of pixel radius r and wave vector k.
        /// https://reference.wolfram.com/language/ref/GaborFilter.html
        ///</summary>
        corewolf::engine *GaborFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GaborFilter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses a Gabor kernel with phase shift ϕ.
        /// https://reference.wolfram.com/language/ref/GaborFilter.html
        ///</summary>
        corewolf::engine *GaborFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("GaborFilter[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// uses a Gabor kernel with radius r  and standard deviation σ.
        /// https://reference.wolfram.com/language/ref/GaborFilter.html
        ///</summary>
        corewolf::engine *GaborFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GaborFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a matrix that corresponds to the real part of a Gabor kernel of radius r and wave vector k.
        /// https://reference.wolfram.com/language/ref/GaborMatrix.html
        ///</summary>
        corewolf::engine *GaborMatrix(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GaborMatrix[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses phase shift ϕ.
        /// https://reference.wolfram.com/language/ref/GaborMatrix.html
        ///</summary>
        corewolf::engine *GaborMatrix(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GaborMatrix[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses the specified standard deviation σ.
        /// https://reference.wolfram.com/language/ref/GaborMatrix.html
        ///</summary>
        corewolf::engine *GaborMatrix(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GaborMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Gabor wavelet of frequency 6.
        /// https://reference.wolfram.com/language/ref/GaborWavelet.html
        ///</summary>
        corewolf::engine *GaborWavelet(const std::string &name = "")
        {
            return this->execute("GaborWavelet[]", name);
        }

        ///< summary>
        /// represents a Gabor wavelet of frequency w.
        /// https://reference.wolfram.com/language/ref/GaborWavelet.html
        ///</summary>
        corewolf::engine *GaborWavelet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GaborWavelet[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the gain margins of the linear time-invariant system lsys.
        /// https://reference.wolfram.com/language/ref/GainMargins.html
        ///</summary>
        corewolf::engine *GainMargins(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GainMargins[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the gain and phase margins of the linear time-invariant system lsys.
        /// https://reference.wolfram.com/language/ref/GainPhaseMargins.html
        ///</summary>
        corewolf::engine *GainPhaseMargins(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GainPhaseMargins[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the galaxy entity.
        /// https://reference.wolfram.com/language/ref/GalaxyData.html
        ///</summary>
        corewolf::engine *GalaxyData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GalaxyData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified galaxy entities.
        /// https://reference.wolfram.com/language/ref/GalaxyData.html
        ///</summary>
        corewolf::engine *GalaxyData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GalaxyData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/GalaxyData.html
        ///</summary>
        corewolf::engine *GalaxyData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GalaxyData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an const std::string &in which the expri are displayed in a browsable gallery layout.
        /// https://reference.wolfram.com/language/ref/GalleryView.html
        ///</summary>
        corewolf::engine *GalleryView(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GalleryView[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// is the Euler gamma function .
        /// https://reference.wolfram.com/language/ref/Gamma.html
        ///</summary>
        corewolf::engine *Gamma(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Gamma[" + arg0 + "]", name);
        }

        ///< summary>
        /// is the incomplete gamma function .
        /// https://reference.wolfram.com/language/ref/Gamma.html
        ///</summary>
        corewolf::engine *Gamma(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Gamma[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is the generalized incomplete gamma function .
        /// https://reference.wolfram.com/language/ref/Gamma.html
        ///</summary>
        corewolf::engine *Gamma(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Gamma[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a gamma distribution with shape parameter α and scale parameter β.
        /// https://reference.wolfram.com/language/ref/GammaDistribution.html
        ///</summary>
        corewolf::engine *GammaDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GammaDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a generalized gamma distribution with shape parameters α and γ, scale parameter β, and location parameter μ.
        /// https://reference.wolfram.com/language/ref/GammaDistribution.html
        ///</summary>
        corewolf::engine *GammaDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("GammaDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// is the regularized incomplete gamma function .
        /// https://reference.wolfram.com/language/ref/GammaRegularized.html
        ///</summary>
        corewolf::engine *GammaRegularized(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GammaRegularized[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a generalized autoregressive conditionally heteroscedastic process of orders p and q, driven by a standard white noise.
        /// https://reference.wolfram.com/language/ref/GARCHProcess.html
        ///</summary>
        corewolf::engine *GARCHProcess(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("GARCHProcess[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a GARCH process with initial data init.
        /// https://reference.wolfram.com/language/ref/GARCHProcess.html
        ///</summary>
        corewolf::engine *GARCHProcess(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("GARCHProcess[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a trainable recurrent layer that takes a sequence of vectors and produces a sequence of vectors each of size n.
        /// https://reference.wolfram.com/language/ref/GatedRecurrentLayer.html
        ///</summary>
        corewolf::engine *GatedRecurrentLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GatedRecurrentLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// includes options for initial weights and other parameters.
        /// https://reference.wolfram.com/language/ref/GatedRecurrentLayer.html
        ///</summary>
        corewolf::engine *GatedRecurrentLayer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GatedRecurrentLayer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gathers the elements of list into sublists of identical elements.
        /// https://reference.wolfram.com/language/ref/Gather.html
        ///</summary>
        corewolf::engine *Gather(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Gather[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies test to pairs of elements to determine if they should be considered identical.
        /// https://reference.wolfram.com/language/ref/Gather.html
        ///</summary>
        corewolf::engine *Gather(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Gather[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gathers into sublists each set of elements in list that gives the same value when f is applied.
        /// https://reference.wolfram.com/language/ref/GatherBy.html
        ///</summary>
        corewolf::engine *GatherBy(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GatherBy[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gathers list into nested sublists using fi at level i.
        /// https://reference.wolfram.com/language/ref/GatherBy.html
        ///</summary>
        corewolf::engine *GatherBy(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GatherBy[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// filters data by convolving with a Gaussian kernel of radius r.
        /// https://reference.wolfram.com/language/ref/GaussianFilter.html
        ///</summary>
        corewolf::engine *GaussianFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GaussianFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// convolves data with a kernel formed from the ni derivatives of the discrete Gaussian.
        /// https://reference.wolfram.com/language/ref/GaussianFilter.html
        ///</summary>
        corewolf::engine *GaussianFilter(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("GaussianFilter[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses a Gaussian kernel with radius r and standard deviation σ.
        /// https://reference.wolfram.com/language/ref/GaussianFilter.html
        ///</summary>
        corewolf::engine *GaussianFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GaussianFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses radius ri at level i in data.
        /// https://reference.wolfram.com/language/ref/GaussianFilter.html
        ///</summary>
        corewolf::engine *GaussianFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GaussianFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a matrix that corresponds to a Gaussian kernel of radius r.
        /// https://reference.wolfram.com/language/ref/GaussianMatrix.html
        ///</summary>
        corewolf::engine *GaussianMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GaussianMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a matrix corresponding to a Gaussian kernel with radius r and standard deviation σ.
        /// https://reference.wolfram.com/language/ref/GaussianMatrix.html
        ///</summary>
        corewolf::engine *GaussianMatrix(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GaussianMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a matrix formed from the n1 derivative of the Gaussian with respect to rows and the n2 derivative with respect to columns.
        /// https://reference.wolfram.com/language/ref/GaussianMatrix.html
        ///</summary>
        corewolf::engine *GaussianMatrix(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GaussianMatrix[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a matrix formed from the sums of the ni1 and ni2 derivatives.
        /// https://reference.wolfram.com/language/ref/GaussianMatrix.html
        ///</summary>
        corewolf::engine *GaussianMatrix(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("GaussianMatrix[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives an array corresponding to a Gaussian kernel with radius ri in the i index direction.
        /// https://reference.wolfram.com/language/ref/GaussianMatrix.html
        ///</summary>
        corewolf::engine *GaussianMatrix(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GaussianMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Gaussian orthogonal matrix distribution with matrix dimensions {n,n} and scale parameter σ.
        /// https://reference.wolfram.com/language/ref/GaussianOrthogonalMatrixDistribution.html
        ///</summary>
        corewolf::engine *GaussianOrthogonalMatrixDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GaussianOrthogonalMatrixDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Gaussian orthogonal matrix distribution with unit scale parameter.
        /// https://reference.wolfram.com/language/ref/GaussianOrthogonalMatrixDistribution.html
        ///</summary>
        corewolf::engine *GaussianOrthogonalMatrixDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GaussianOrthogonalMatrixDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Gaussian symplectic matrix distribution with matrix dimensions {2 n,2 n} over the field of complex numbers and scale parameter σ.
        /// https://reference.wolfram.com/language/ref/GaussianSymplecticMatrixDistribution.html
        ///</summary>
        corewolf::engine *GaussianSymplecticMatrixDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GaussianSymplecticMatrixDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Gaussian symplectic matrix distribution with unit scale parameter.
        /// https://reference.wolfram.com/language/ref/GaussianSymplecticMatrixDistribution.html
        ///</summary>
        corewolf::engine *GaussianSymplecticMatrixDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GaussianSymplecticMatrixDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Gaussian unitary matrix distribution with matrix dimensions {n,n} and scale parameter σ.
        /// https://reference.wolfram.com/language/ref/GaussianUnitaryMatrixDistribution.html
        ///</summary>
        corewolf::engine *GaussianUnitaryMatrixDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GaussianUnitaryMatrixDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Gaussian unitary matrix distribution with unit scale parameter.
        /// https://reference.wolfram.com/language/ref/GaussianUnitaryMatrixDistribution.html
        ///</summary>
        corewolf::engine *GaussianUnitaryMatrixDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GaussianUnitaryMatrixDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Gaussian window function of x.
        /// https://reference.wolfram.com/language/ref/GaussianWindow.html
        ///</summary>
        corewolf::engine *GaussianWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GaussianWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses standard deviation σ.
        /// https://reference.wolfram.com/language/ref/GaussianWindow.html
        ///</summary>
        corewolf::engine *GaussianWindow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GaussianWindow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the greatest common divisor of the ni.
        /// https://reference.wolfram.com/language/ref/GCD.html
        ///</summary>
        corewolf::engine *GCD(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GCD[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Gegenbauer polynomial .
        /// https://reference.wolfram.com/language/ref/GegenbauerC.html
        ///</summary>
        corewolf::engine *GegenbauerC(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GegenbauerC[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the renormalized form .
        /// https://reference.wolfram.com/language/ref/GegenbauerC.html
        ///</summary>
        corewolf::engine *GegenbauerC(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GegenbauerC[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// constructs a generalized linear model of the form  that fits the yi for successive x values 1, 2, ….
        /// https://reference.wolfram.com/language/ref/GeneralizedLinearModelFit.html
        ///</summary>
        corewolf::engine *GeneralizedLinearModelFit(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeneralizedLinearModelFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// constructs a generalized linear model of the form  where the fi depend on the variables xk.
        /// https://reference.wolfram.com/language/ref/GeneralizedLinearModelFit.html
        ///</summary>
        corewolf::engine *GeneralizedLinearModelFit(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("GeneralizedLinearModelFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// constructs a generalized linear model from the design matrix m and response vector v.
        /// https://reference.wolfram.com/language/ref/GeneralizedLinearModelFit.html
        ///</summary>
        corewolf::engine *GeneralizedLinearModelFit(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeneralizedLinearModelFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// randomly generates a PrivateKey and corresponding PublicKey const std::string &for use with public-key cryptographic functions.
        /// https://reference.wolfram.com/language/ref/GenerateAsymmetricKeyPair.html
        ///</summary>
        corewolf::engine *GenerateAsymmetricKeyPair(const std::string &name = "")
        {
            return this->execute("GenerateAsymmetricKeyPair[]", name);
        }

        ///< summary>
        /// randomly generates private and public keys of the specified type.
        /// https://reference.wolfram.com/language/ref/GenerateAsymmetricKeyPair.html
        ///</summary>
        corewolf::engine *GenerateAsymmetricKeyPair(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GenerateAsymmetricKeyPair[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a DerivedKey const std::string &from the password given.
        /// https://reference.wolfram.com/language/ref/GenerateDerivedKey.html
        ///</summary>
        corewolf::engine *GenerateDerivedKey(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GenerateDerivedKey[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a DerivedKey const std::string &from the password and salt given.
        /// https://reference.wolfram.com/language/ref/GenerateDerivedKey.html
        ///</summary>
        corewolf::engine *GenerateDerivedKey(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GenerateDerivedKey[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a digital signature for expr using the specified private key.
        /// https://reference.wolfram.com/language/ref/GenerateDigitalSignature.html
        ///</summary>
        corewolf::engine *GenerateDigitalSignature(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GenerateDigitalSignature[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of GenerateDigitalSignature that can be applied to expressions.
        /// https://reference.wolfram.com/language/ref/GenerateDigitalSignature.html
        ///</summary>
        corewolf::engine *GenerateDigitalSignature(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GenerateDigitalSignature[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a document by evaluating all template elements in the notebook nb.
        /// https://reference.wolfram.com/language/ref/GenerateDocument.html
        ///</summary>
        corewolf::engine *GenerateDocument(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GenerateDocument[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a document using args to fill template slots.
        /// https://reference.wolfram.com/language/ref/GenerateDocument.html
        ///</summary>
        corewolf::engine *GenerateDocument(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GenerateDocument[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses args to fill template slots and puts the result in output.
        /// https://reference.wolfram.com/language/ref/GenerateDocument.html
        ///</summary>
        corewolf::engine *GenerateDocument(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GenerateDocument[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a digital signature of file using the specified private key.
        /// https://reference.wolfram.com/language/ref/GenerateFileSignature.html
        ///</summary>
        corewolf::engine *GenerateFileSignature(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GenerateFileSignature[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a digital signature of the specified range of bytes in the file.
        /// https://reference.wolfram.com/language/ref/GenerateFileSignature.html
        ///</summary>
        corewolf::engine *GenerateFileSignature(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GenerateFileSignature[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates digital signatures for each specified filei and rangei.
        /// https://reference.wolfram.com/language/ref/GenerateFileSignature.html
        ///</summary>
        corewolf::engine *GenerateFileSignature(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GenerateFileSignature[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of GenerateFileSignature that can be applied to files.
        /// https://reference.wolfram.com/language/ref/GenerateFileSignature.html
        ///</summary>
        corewolf::engine *GenerateFileSignature(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GenerateFileSignature[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the HTTPResponse const std::string &that is generated when a cloud const std::string &containing expr is requested on the web.
        /// https://reference.wolfram.com/language/ref/GenerateHTTPResponse.html
        ///</summary>
        corewolf::engine *GenerateHTTPResponse(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GenerateHTTPResponse[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the response for the HTTP request specified by req.
        /// https://reference.wolfram.com/language/ref/GenerateHTTPResponse.html
        ///</summary>
        corewolf::engine *GenerateHTTPResponse(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GenerateHTTPResponse[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a new anonymous SecuredAuthenticationKey owned by the current user ID.
        /// https://reference.wolfram.com/language/ref/GenerateSecuredAuthenticationKey.html
        ///</summary>
        corewolf::engine *GenerateSecuredAuthenticationKey(const std::string &name = "")
        {
            return this->execute("GenerateSecuredAuthenticationKey[]", name);
        }

        ///< summary>
        /// generates a new SecuredAuthenticationKey with the specified name owned by the current user ID.
        /// https://reference.wolfram.com/language/ref/GenerateSecuredAuthenticationKey.html
        ///</summary>
        corewolf::engine *GenerateSecuredAuthenticationKey(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GenerateSecuredAuthenticationKey[" + arg0 + "]", name);
        }

        ///< summary>
        /// randomly generates a SymmetricKey const std::string &suitable for use with cryptographic functions.
        /// https://reference.wolfram.com/language/ref/GenerateSymmetricKey.html
        ///</summary>
        corewolf::engine *GenerateSymmetricKey(const std::string &name = "")
        {
            return this->execute("GenerateSymmetricKey[]", name);
        }

        ///< summary>
        /// derives a SymmetricKey const std::string &from the password string given.
        /// https://reference.wolfram.com/language/ref/GenerateSymmetricKey.html
        ///</summary>
        corewolf::engine *GenerateSymmetricKey(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GenerateSymmetricKey[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the generating function in x for the sequence whose n series coefficient is given by the expression expr.
        /// https://reference.wolfram.com/language/ref/GeneratingFunction.html
        ///</summary>
        corewolf::engine *GeneratingFunction(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeneratingFunction[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional generating function in x1, x2, … whose n1, n2, … coefficient is given by expr.
        /// https://reference.wolfram.com/language/ref/GeneratingFunction.html
        ///</summary>
        corewolf::engine *GeneratingFunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("GeneratingFunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// finds the full-dimensional part of the decomposition of the region represented by the inequalities ineqs into cylindrical parts whose directions correspond to the successive xi, together with any hypersurfaces containing the rest of the region.
        /// https://reference.wolfram.com/language/ref/GenericCylindricalDecomposition.html
        ///</summary>
        corewolf::engine *GenericCylindricalDecomposition(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GenericCylindricalDecomposition[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the DNA sequence for the specified gene on the reference human genome.
        /// https://reference.wolfram.com/language/ref/GenomeData.html
        ///</summary>
        corewolf::engine *GenomeData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GenomeData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the human gene gene.
        /// https://reference.wolfram.com/language/ref/GenomeData.html
        ///</summary>
        corewolf::engine *GenomeData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GenomeData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the sequence from positions n1 to n2 on chromosome chr in the reference human genome.
        /// https://reference.wolfram.com/language/ref/GenomeData.html
        ///</summary>
        corewolf::engine *GenomeData(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GenomeData[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns the positions of exact matches for the DNA sequence seq on the reference human genome.
        /// https://reference.wolfram.com/language/ref/GenomeLookup.html
        ///</summary>
        corewolf::engine *GenomeLookup(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GenomeLookup[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns at most n matches.
        /// https://reference.wolfram.com/language/ref/GenomeLookup.html
        ///</summary>
        corewolf::engine *GenomeLookup(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GenomeLookup[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the antipodal position of location loc.
        /// https://reference.wolfram.com/language/ref/GeoAntipode.html
        ///</summary>
        corewolf::engine *GeoAntipode(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoAntipode[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the area of the geo region g.
        /// https://reference.wolfram.com/language/ref/GeoArea.html
        ///</summary>
        corewolf::engine *GeoArea(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoArea[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the boundary line of the geo region g.
        /// https://reference.wolfram.com/language/ref/GeoBoundary.html
        ///</summary>
        corewolf::engine *GeoBoundary(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoBoundary[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the geo positions that define the bounding rectangle enclosing the geo region g.
        /// https://reference.wolfram.com/language/ref/GeoBoundingBox.html
        ///</summary>
        corewolf::engine *GeoBoundingBox(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoBoundingBox[" + arg0 + "]", name);
        }

        ///< summary>
        /// pads the region on all sides by an amount δ.
        /// https://reference.wolfram.com/language/ref/GeoBoundingBox.html
        ///</summary>
        corewolf::engine *GeoBoundingBox(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoBoundingBox[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the ranges of latitudes and longitudes in the geo region g.
        /// https://reference.wolfram.com/language/ref/GeoBounds.html
        ///</summary>
        corewolf::engine *GeoBounds(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoBounds[" + arg0 + "]", name);
        }

        ///< summary>
        /// pads ranges of latitudes and longitudes by ±δ.
        /// https://reference.wolfram.com/language/ref/GeoBounds.html
        ///</summary>
        corewolf::engine *GeoBounds(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoBounds[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a two-dimensional GeoGraphics primitive that represents a geo region bounded by parallels latmin, latmax and meridians lonmin, lonmax on the surface of the Earth.
        /// https://reference.wolfram.com/language/ref/GeoBoundsRegion.html
        ///</summary>
        corewolf::engine *GeoBoundsRegion(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GeoBoundsRegion[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents the latitude-longitude bounding box of the geo region g.
        /// https://reference.wolfram.com/language/ref/GeoBoundsRegion.html
        ///</summary>
        corewolf::engine *GeoBoundsRegion(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoBoundsRegion[" + arg0 + "]", name);
        }

        ///< summary>
        /// pads the ranges of latitudes and longitudes by ±δ.
        /// https://reference.wolfram.com/language/ref/GeoBoundsRegion.html
        ///</summary>
        corewolf::engine *GeoBoundsRegion(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoBoundsRegion[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a one-dimensional GeoGraphics primitive that represents the boundary of the region between parallels latmin, latmax and meridians lonmin, lonmax on the surface of the Earth.
        /// https://reference.wolfram.com/language/ref/GeoBoundsRegionBoundary.html
        ///</summary>
        corewolf::engine *GeoBoundsRegionBoundary(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GeoBoundsRegionBoundary[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents the boundary of the latitude-longitude bounding box of the geo region g.
        /// https://reference.wolfram.com/language/ref/GeoBoundsRegionBoundary.html
        ///</summary>
        corewolf::engine *GeoBoundsRegionBoundary(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoBoundsRegionBoundary[" + arg0 + "]", name);
        }

        ///< summary>
        /// pads the ranges of latitudes and longitudes by ±δ.
        /// https://reference.wolfram.com/language/ref/GeoBoundsRegionBoundary.html
        ///</summary>
        corewolf::engine *GeoBoundsRegionBoundary(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoBoundsRegionBoundary[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// makes a geo bubble chart with bubbles centered at the geographic regions regi with sizes vali.
        /// https://reference.wolfram.com/language/ref/GeoBubbleChart.html
        ///</summary>
        corewolf::engine *GeoBubbleChart(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoBubbleChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// uses a collection of regions regi from regions with corresponding sizes vali from values.
        /// https://reference.wolfram.com/language/ref/GeoBubbleChart.html
        ///</summary>
        corewolf::engine *GeoBubbleChart(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoBubbleChart[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a two-dimensional GeoGraphics primitive that represents a circle of radius r centered at the location loc on the surface of the Earth.
        /// https://reference.wolfram.com/language/ref/GeoCircle.html
        ///</summary>
        corewolf::engine *GeoCircle(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoCircle[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a sector of a circle from bearing α1 to bearing α2.
        /// https://reference.wolfram.com/language/ref/GeoCircle.html
        ///</summary>
        corewolf::engine *GeoCircle(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("GeoCircle[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// makes a geo contour plot from values vali defined at specified locations loci.
        /// https://reference.wolfram.com/language/ref/GeoContourPlot.html
        ///</summary>
        corewolf::engine *GeoContourPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoContourPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// uses a collection of locations locs with corresponding values vals.
        /// https://reference.wolfram.com/language/ref/GeoContourPlot.html
        ///</summary>
        corewolf::engine *GeoContourPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoContourPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes a geo density plot with colors at the location loci determined by the value vali.
        /// https://reference.wolfram.com/language/ref/GeoDensityPlot.html
        ///</summary>
        corewolf::engine *GeoDensityPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoDensityPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// uses a collection of locations locs with corresponding values vals.
        /// https://reference.wolfram.com/language/ref/GeoDensityPlot.html
        ///</summary>
        corewolf::engine *GeoDensityPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoDensityPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the fixed point of the geodesic erosion of the marker constrained by the mask.
        /// https://reference.wolfram.com/language/ref/GeodesicErosion.html
        ///</summary>
        corewolf::engine *GeodesicErosion(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeodesicErosion[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the geodesic opening of image with respect to the structuring element ker.
        /// https://reference.wolfram.com/language/ref/GeodesicOpening.html
        ///</summary>
        corewolf::engine *GeodesicOpening(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeodesicOpening[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the order‐n geodesic polyhedron.
        /// https://reference.wolfram.com/language/ref/GeodesicPolyhedron.html
        ///</summary>
        corewolf::engine *GeodesicPolyhedron(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeodesicPolyhedron[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the order‐n geodesic polyhedron based on the polyhedron "poly".
        /// https://reference.wolfram.com/language/ref/GeodesicPolyhedron.html
        ///</summary>
        corewolf::engine *GeodesicPolyhedron(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeodesicPolyhedron[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the end position of the geodesic of length d starting from loc with azimuthal direction α.
        /// https://reference.wolfram.com/language/ref/GeoDestination.html
        ///</summary>
        corewolf::engine *GeoDestination(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GeoDestination[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for a named geodetic datum or reference ellipsoid.
        /// https://reference.wolfram.com/language/ref/GeodesyData.html
        ///</summary>
        corewolf::engine *GeodesyData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeodesyData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the property for the ellipsoid with semimajor axis a and semiminor axis b.
        /// https://reference.wolfram.com/language/ref/GeodesyData.html
        ///</summary>
        corewolf::engine *GeodesyData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeodesyData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the property at the specified coordinates.
        /// https://reference.wolfram.com/language/ref/GeodesyData.html
        ///</summary>
        corewolf::engine *GeodesyData(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GeodesyData[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the azimuthal direction from one latitude-longitude position on the Earth to another.
        /// https://reference.wolfram.com/language/ref/GeoDirection.html
        ///</summary>
        corewolf::engine *GeoDirection(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GeoDirection[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the azimuthal direction between locations specified by position objects or geographic entities.
        /// https://reference.wolfram.com/language/ref/GeoDirection.html
        ///</summary>
        corewolf::engine *GeoDirection(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoDirection[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a two-dimensional GeoGraphics primitive that represents a filled disk of radius r centered at the location loc on the surface of the Earth.
        /// https://reference.wolfram.com/language/ref/GeoDisk.html
        ///</summary>
        corewolf::engine *GeoDisk(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoDisk[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a sector of a disk from bearing α1 to bearing α2.
        /// https://reference.wolfram.com/language/ref/GeoDisk.html
        ///</summary>
        corewolf::engine *GeoDisk(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("GeoDisk[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a geodesic displacement of length dist and initial bearing α from a geo location.
        /// https://reference.wolfram.com/language/ref/GeoDisplacement.html
        ///</summary>
        corewolf::engine *GeoDisplacement(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoDisplacement[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a displacement of length dist and initial bearing α along a path of type pathtype.
        /// https://reference.wolfram.com/language/ref/GeoDisplacement.html
        ///</summary>
        corewolf::engine *GeoDisplacement(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoDisplacement[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the displacement needed to reach loc2 from loc1 along a path of type pathtype.
        /// https://reference.wolfram.com/language/ref/GeoDisplacement.html
        ///</summary>
        corewolf::engine *GeoDisplacement(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeoDisplacement[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the geodesic distance between latitude-longitude positions on the Earth.
        /// https://reference.wolfram.com/language/ref/GeoDistance.html
        ///</summary>
        corewolf::engine *GeoDistance(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GeoDistance[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the distance between locations specified by position objects or geographical entities.
        /// https://reference.wolfram.com/language/ref/GeoDistance.html
        ///</summary>
        corewolf::engine *GeoDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the total distance from loc1 to locn through all the intermediate loci.
        /// https://reference.wolfram.com/language/ref/GeoDistance.html
        ///</summary>
        corewolf::engine *GeoDistance(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoDistance[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns the list of geodesic distances between consecutive pairs of locations.
        /// https://reference.wolfram.com/language/ref/GeoDistanceList.html
        ///</summary>
        corewolf::engine *GeoDistanceList(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoDistanceList[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the elevation above sea level at $GeoLocation.
        /// https://reference.wolfram.com/language/ref/GeoElevationData.html
        ///</summary>
        corewolf::engine *GeoElevationData(const std::string &name = "")
        {
            return this->execute("GeoElevationData[]", name);
        }

        ///< summary>
        /// gives the elevation at the geographic location loc.
        /// https://reference.wolfram.com/language/ref/GeoElevationData.html
        ///</summary>
        corewolf::engine *GeoElevationData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoElevationData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an array of elevation values within the bounding box given by {loc1,loc2}.
        /// https://reference.wolfram.com/language/ref/GeoElevationData.html
        ///</summary>
        corewolf::engine *GeoElevationData(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoElevationData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the elevation of type etype for the location loc.
        /// https://reference.wolfram.com/language/ref/GeoElevationData.html
        ///</summary>
        corewolf::engine *GeoElevationData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoElevationData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the elevation in the specified format.
        /// https://reference.wolfram.com/language/ref/GeoElevationData.html
        ///</summary>
        corewolf::engine *GeoElevationData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeoElevationData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of the geographic entities of type enttype contained in the extended region reg.
        /// https://reference.wolfram.com/language/ref/GeoEntities.html
        ///</summary>
        corewolf::engine *GeoEntities(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoEntities[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a two-dimensional geographical image.
        /// https://reference.wolfram.com/language/ref/GeoGraphics.html
        ///</summary>
        corewolf::engine *GeoGraphics(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoGraphics[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a plot of the geographic graph with edges ei.
        /// https://reference.wolfram.com/language/ref/GeoGraphPlot.html
        ///</summary>
        corewolf::engine *GeoGraphPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoGraphPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a plot with vertices vi and edges ej.
        /// https://reference.wolfram.com/language/ref/GeoGraphPlot.html
        ///</summary>
        corewolf::engine *GeoGraphPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GeoGraphPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// displays the graph g with vertices at geographic locations on a map.
        /// https://reference.wolfram.com/language/ref/GeoGraphPlot.html
        ///</summary>
        corewolf::engine *GeoGraphPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoGraphPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots the flows between geo locations.
        /// https://reference.wolfram.com/language/ref/GeoGraphValuePlot.html
        ///</summary>
        corewolf::engine *GeoGraphValuePlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("GeoGraphValuePlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// plots the values vali for the edges ei.
        /// https://reference.wolfram.com/language/ref/GeoGraphValuePlot.html
        ///</summary>
        corewolf::engine *GeoGraphValuePlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GeoGraphValuePlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots the flow for a graph g with associated edge weights.
        /// https://reference.wolfram.com/language/ref/GeoGraphValuePlot.html
        ///</summary>
        corewolf::engine *GeoGraphValuePlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoGraphValuePlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the gravitational field data for the current location.
        /// https://reference.wolfram.com/language/ref/GeogravityModelData.html
        ///</summary>
        corewolf::engine *GeogravityModelData(const std::string &name = "")
        {
            return this->execute("GeogravityModelData[]", name);
        }

        ///< summary>
        /// returns the gravitational field data for a location.
        /// https://reference.wolfram.com/language/ref/GeogravityModelData.html
        ///</summary>
        corewolf::engine *GeogravityModelData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeogravityModelData[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the component of the gravitational field.
        /// https://reference.wolfram.com/language/ref/GeogravityModelData.html
        ///</summary>
        corewolf::engine *GeogravityModelData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeogravityModelData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the difference between the angle from north to direction β on the geo grid obtained with projection proj and the actual angle from north to direction β at location loc.
        /// https://reference.wolfram.com/language/ref/GeoGridDirectionDifference.html
        ///</summary>
        corewolf::engine *GeoGridDirectionDifference(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeoGridDirectionDifference[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a point {x,y} in a planimetric cartographic grid using the projection proj.
        /// https://reference.wolfram.com/language/ref/GeoGridPosition.html
        ///</summary>
        corewolf::engine *GeoGridPosition(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoGridPosition[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an array of cartographic grid positions.
        /// https://reference.wolfram.com/language/ref/GeoGridPosition.html
        ///</summary>
        corewolf::engine *GeoGridPosition(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeoGridPosition[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a point in a cartographic grid obtained by projection from data in the given datum.
        /// https://reference.wolfram.com/language/ref/GeoGridPosition.html
        ///</summary>
        corewolf::engine *GeoGridPosition(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeoGridPosition[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the cartographic grid position of the specified geographical entity.
        /// https://reference.wolfram.com/language/ref/GeoGridPosition.html
        ///</summary>
        corewolf::engine *GeoGridPosition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoGridPosition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the actual geo area corresponding to a unit area on the geo grid obtained with projection proj, evaluated in the limit of small geo regions around location loc.
        /// https://reference.wolfram.com/language/ref/GeoGridUnitArea.html
        ///</summary>
        corewolf::engine *GeoGridUnitArea(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoGridUnitArea[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the actual geo distance corresponding to a unit distance on the geo grid obtained with projection proj, evaluated in the limit of small displacement from location loc in direction α.
        /// https://reference.wolfram.com/language/ref/GeoGridUnitDistance.html
        ///</summary>
        corewolf::engine *GeoGridUnitDistance(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeoGridUnitDistance[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a horizontal two-dimensional vector of components vx, vy in the orthonormal frame of the coordinates of the geo projection proj, at geo location loc.
        /// https://reference.wolfram.com/language/ref/GeoGridVector.html
        ///</summary>
        corewolf::engine *GeoGridVector(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoGridVector[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a collection of vectors veci at respective geo locations loci.
        /// https://reference.wolfram.com/language/ref/GeoGridVector.html
        ///</summary>
        corewolf::engine *GeoGridVector(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoGridVector[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a list of geographic objects to be treated as a single const std::string &for certain operations.
        /// https://reference.wolfram.com/language/ref/GeoGroup.html
        ///</summary>
        corewolf::engine *GeoGroup(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoGroup[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a two-dimensional GeoGraphics primitive that represents the half of the Earth centered at your current geo location.
        /// https://reference.wolfram.com/language/ref/GeoHemisphere.html
        ///</summary>
        corewolf::engine *GeoHemisphere(const std::string &name = "")
        {
            return this->execute("GeoHemisphere[]", name);
        }

        ///< summary>
        /// represents the half of the Earth centered at the location loc.
        /// https://reference.wolfram.com/language/ref/GeoHemisphere.html
        ///</summary>
        corewolf::engine *GeoHemisphere(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoHemisphere[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a one-dimensional GeoGraphics primitive that represents the boundary line of a hemisphere of the Earth centered at the current geo location.
        /// https://reference.wolfram.com/language/ref/GeoHemisphereBoundary.html
        ///</summary>
        corewolf::engine *GeoHemisphereBoundary(const std::string &name = "")
        {
            return this->execute("GeoHemisphereBoundary[]", name);
        }

        ///< summary>
        /// represents the boundary line of a hemisphere centered at the location loc.
        /// https://reference.wolfram.com/language/ref/GeoHemisphereBoundary.html
        ///</summary>
        corewolf::engine *GeoHemisphereBoundary(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoHemisphereBoundary[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots a density histogram of the geographic locations locs.
        /// https://reference.wolfram.com/language/ref/GeoHistogram.html
        ///</summary>
        corewolf::engine *GeoHistogram(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoHistogram[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots a density histogram with bins specified by bspec.
        /// https://reference.wolfram.com/language/ref/GeoHistogram.html
        ///</summary>
        corewolf::engine *GeoHistogram(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoHistogram[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// plots a density histogram with bin densities computed according to the specification hspec.
        /// https://reference.wolfram.com/language/ref/GeoHistogram.html
        ///</summary>
        corewolf::engine *GeoHistogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeoHistogram[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// identifies the geographic entities of the type enttype in which the current geo location is contained.
        /// https://reference.wolfram.com/language/ref/GeoIdentify.html
        ///</summary>
        corewolf::engine *GeoIdentify(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoIdentify[" + arg0 + "]", name);
        }

        ///< summary>
        /// identifies the entities in which the location loc is contained.
        /// https://reference.wolfram.com/language/ref/GeoIdentify.html
        ///</summary>
        corewolf::engine *GeoIdentify(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoIdentify[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// identifies the entities of any type in which the current geo location is contained.
        /// https://reference.wolfram.com/language/ref/GeoIdentify.html
        ///</summary>
        corewolf::engine *GeoIdentify(const std::string &name = "")
        {
            return this->execute("GeoIdentify[]", name);
        }

        ///< summary>
        /// gives a satellite image of the geo region reg.
        /// https://reference.wolfram.com/language/ref/GeoImage.html
        ///</summary>
        corewolf::engine *GeoImage(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoImage[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an image of the geo region reg with style mapstyle.
        /// https://reference.wolfram.com/language/ref/GeoImage.html
        ///</summary>
        corewolf::engine *GeoImage(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoImage[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the length of the geo path g.
        /// https://reference.wolfram.com/language/ref/GeoLength.html
        ///</summary>
        corewolf::engine *GeoLength(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoLength[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a map on which the locations loci are indicated.
        /// https://reference.wolfram.com/language/ref/GeoListPlot.html
        ///</summary>
        corewolf::engine *GeoListPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoListPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the geological period entity.
        /// https://reference.wolfram.com/language/ref/GeologicalPeriodData.html
        ///</summary>
        corewolf::engine *GeologicalPeriodData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeologicalPeriodData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified period name entities.
        /// https://reference.wolfram.com/language/ref/GeologicalPeriodData.html
        ///</summary>
        corewolf::engine *GeologicalPeriodData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeologicalPeriodData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/GeologicalPeriodData.html
        ///</summary>
        corewolf::engine *GeologicalPeriodData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeologicalPeriodData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the current magnetic field data for the current location.
        /// https://reference.wolfram.com/language/ref/GeomagneticModelData.html
        ///</summary>
        corewolf::engine *GeomagneticModelData(const std::string &name = "")
        {
            return this->execute("GeomagneticModelData[]", name);
        }

        ///< summary>
        /// returns the current magnetic field data for a location.
        /// https://reference.wolfram.com/language/ref/GeomagneticModelData.html
        ///</summary>
        corewolf::engine *GeomagneticModelData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeomagneticModelData[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the magnetic field data for the specified time and location.
        /// https://reference.wolfram.com/language/ref/GeomagneticModelData.html
        ///</summary>
        corewolf::engine *GeomagneticModelData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeomagneticModelData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the component of the magnetic field for the specified time and location.
        /// https://reference.wolfram.com/language/ref/GeomagneticModelData.html
        ///</summary>
        corewolf::engine *GeomagneticModelData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeomagneticModelData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a GeoGraphics primitive that represents a marker at the current $GeoLocation.
        /// https://reference.wolfram.com/language/ref/GeoMarker.html
        ///</summary>
        corewolf::engine *GeoMarker(const std::string &name = "")
        {
            return this->execute("GeoMarker[]", name);
        }

        ///< summary>
        /// is a GeoGraphics primitive that represents a marker at the location loc.
        /// https://reference.wolfram.com/language/ref/GeoMarker.html
        ///</summary>
        corewolf::engine *GeoMarker(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoMarker[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a GeoGraphics primitive that represents markers at locations loci.
        /// https://reference.wolfram.com/language/ref/GeoMarker.html
        ///</summary>
        corewolf::engine *GeoMarker(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoMarker[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// is a GeoGraphics primitive that represents a custom marker at the location loc.
        /// https://reference.wolfram.com/language/ref/GeoMarker.html
        ///</summary>
        corewolf::engine *GeoMarker(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoMarker[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a GeoGraphics primitive that represents custom markers at locations loci.
        /// https://reference.wolfram.com/language/ref/GeoMarker.html
        ///</summary>
        corewolf::engine *GeoMarker(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoMarker[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the assertion that the geometric const std::string &obj satisfies prop.
        /// https://reference.wolfram.com/language/ref/GeometricAssertion.html
        ///</summary>
        corewolf::engine *GeometricAssertion(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeometricAssertion[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the assertion that the obji satisfy prop.
        /// https://reference.wolfram.com/language/ref/GeometricAssertion.html
        ///</summary>
        corewolf::engine *GeometricAssertion(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeometricAssertion[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the assertion that objs satisfies each of the propi.
        /// https://reference.wolfram.com/language/ref/GeometricAssertion.html
        ///</summary>
        corewolf::engine *GeometricAssertion(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("GeometricAssertion[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a geometric Brownian motion process with drift μ, volatility σ, and initial value x0.
        /// https://reference.wolfram.com/language/ref/GeometricBrownianMotionProcess.html
        ///</summary>
        corewolf::engine *GeometricBrownianMotionProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeometricBrownianMotionProcess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a geometric distribution with probability parameter p.
        /// https://reference.wolfram.com/language/ref/GeometricDistribution.html
        ///</summary>
        corewolf::engine *GeometricDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeometricDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the geometric mean of the values in list.
        /// https://reference.wolfram.com/language/ref/GeometricMean.html
        ///</summary>
        corewolf::engine *GeometricMean(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeometricMean[" + arg0 + "]", name);
        }

        ///< summary>
        /// filters data by replacing every value by the geometric mean value in its range-r neighborhood.
        /// https://reference.wolfram.com/language/ref/GeometricMeanFilter.html
        ///</summary>
        corewolf::engine *GeometricMeanFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeometricMeanFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses ri for filtering the dimension in data.
        /// https://reference.wolfram.com/language/ref/GeometricMeanFilter.html
        ///</summary>
        corewolf::engine *GeometricMeanFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GeometricMeanFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds positive values of variables vars that minimize the posynomial objective subject to posynomial constraints cons.
        /// https://reference.wolfram.com/language/ref/GeometricOptimization.html
        ///</summary>
        corewolf::engine *GeometricOptimization(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeometricOptimization[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds the positive vector x=y that minimizes  subject to inequality constraints  and linear equality constraints .
        /// https://reference.wolfram.com/language/ref/GeometricOptimization.html
        ///</summary>
        corewolf::engine *GeometricOptimization(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("GeometricOptimization[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// specifies what solution property "prop" should be returned.
        /// https://reference.wolfram.com/language/ref/GeometricOptimization.html
        ///</summary>
        corewolf::engine *GeometricOptimization(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeometricOptimization[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an abstract 2D geometric scene defined by the hypotheses hypi in terms of the symbolic points pi.
        /// https://reference.wolfram.com/language/ref/GeometricScene.html
        ///</summary>
        corewolf::engine *GeometricScene(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GeometricScene[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a scene whose hypotheses depend on the symbolic scalar quantities ki.
        /// https://reference.wolfram.com/language/ref/GeometricScene.html
        ///</summary>
        corewolf::engine *GeometricScene(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeometricScene[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a scene together with some conclusions coni about it.
        /// https://reference.wolfram.com/language/ref/GeometricScene.html
        ///</summary>
        corewolf::engine *GeometricScene(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("GeometricScene[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// combines several scene instances into one scene object.
        /// https://reference.wolfram.com/language/ref/GeometricScene.html
        ///</summary>
        corewolf::engine *GeometricScene(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeometricScene[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a symbolic representation of a step in the definition of a geometric scene, in which the hypotheses hypi are introduced.
        /// https://reference.wolfram.com/language/ref/GeometricStep.html
        ///</summary>
        corewolf::engine *GeometricStep(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeometricStep[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// labels the step with label when displaying an instance of the geometric scene.
        /// https://reference.wolfram.com/language/ref/GeometricStep.html
        ///</summary>
        corewolf::engine *GeometricStep(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeometricStep[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether the geometric const std::string &obj satisfies prop.
        /// https://reference.wolfram.com/language/ref/GeometricTest.html
        ///</summary>
        corewolf::engine *GeometricTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeometricTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether the obji satisfy prop.
        /// https://reference.wolfram.com/language/ref/GeometricTest.html
        ///</summary>
        corewolf::engine *GeometricTest(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeometricTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether objs satisfy each of the propi.
        /// https://reference.wolfram.com/language/ref/GeometricTest.html
        ///</summary>
        corewolf::engine *GeometricTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("GeometricTest[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents the result of applying the transformation function tfun to the geometric objects corresponding to the primitives g.
        /// https://reference.wolfram.com/language/ref/GeometricTransformation.html
        ///</summary>
        corewolf::engine *GeometricTransformation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeometricTransformation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// effectively replaces every point r by m.r+v.
        /// https://reference.wolfram.com/language/ref/GeometricTransformation.html
        ///</summary>
        corewolf::engine *GeometricTransformation(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GeometricTransformation[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns the geographic entity of type enttype closest to the geo location loc.
        /// https://reference.wolfram.com/language/ref/GeoNearest.html
        ///</summary>
        corewolf::engine *GeoNearest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoNearest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the nearest of the regi.
        /// https://reference.wolfram.com/language/ref/GeoNearest.html
        ///</summary>
        corewolf::engine *GeoNearest(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoNearest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns n nearest values.
        /// https://reference.wolfram.com/language/ref/GeoNearest.html
        ///</summary>
        corewolf::engine *GeoNearest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeoNearest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns up to n matches within a radius r of loc.
        /// https://reference.wolfram.com/language/ref/GeoNearest.html
        ///</summary>
        corewolf::engine *GeoNearest(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("GeoNearest[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the property prop about the orientation of the Earth on the given date.
        /// https://reference.wolfram.com/language/ref/GeoOrientationData.html
        ///</summary>
        corewolf::engine *GeoOrientationData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoOrientationData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified variant of the property prop on the given date.
        /// https://reference.wolfram.com/language/ref/GeoOrientationData.html
        ///</summary>
        corewolf::engine *GeoOrientationData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeoOrientationData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a GeoGraphics primitive that represents a path of type pathtype between locations loc1 and loc2.
        /// https://reference.wolfram.com/language/ref/GeoPath.html
        ///</summary>
        corewolf::engine *GeoPath(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoPath[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a disjoint collection of paths of type pathtype.
        /// https://reference.wolfram.com/language/ref/GeoPath.html
        ///</summary>
        corewolf::engine *GeoPath(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeoPath[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a GeoGraphics primitive that represents a filled polygon whose boundary is formed by geodesic segments between locations loci and loci+1.
        /// https://reference.wolfram.com/language/ref/GeoPolygon.html
        ///</summary>
        corewolf::engine *GeoPolygon(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoPolygon[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// specifies which of the two sides of each boundary polyi is in the interior of the geo polygon.
        /// https://reference.wolfram.com/language/ref/GeoPolygon.html
        ///</summary>
        corewolf::engine *GeoPolygon(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoPolygon[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a geo polygon whose boundary is formed by geo paths of type pathtype.
        /// https://reference.wolfram.com/language/ref/GeoPolygon.html
        ///</summary>
        corewolf::engine *GeoPolygon(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeoPolygon[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a geodetic position with latitude lat and longitude lon.
        /// https://reference.wolfram.com/language/ref/GeoPosition.html
        ///</summary>
        corewolf::engine *GeoPosition(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoPosition[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a geodetic position referring to the specified datum.
        /// https://reference.wolfram.com/language/ref/GeoPosition.html
        ///</summary>
        corewolf::engine *GeoPosition(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoPosition[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an array of geodetic positions.
        /// https://reference.wolfram.com/language/ref/GeoPosition.html
        ///</summary>
        corewolf::engine *GeoPosition(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeoPosition[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the geodetic position of the specified geographical entity.
        /// https://reference.wolfram.com/language/ref/GeoPosition.html
        ///</summary>
        corewolf::engine *GeoPosition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoPosition[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a position with local Cartesian coordinates {east,north,up} in a reference system centered at the position p.
        /// https://reference.wolfram.com/language/ref/GeoPositionENU.html
        ///</summary>
        corewolf::engine *GeoPositionENU(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoPositionENU[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an array of positions.
        /// https://reference.wolfram.com/language/ref/GeoPositionENU.html
        ///</summary>
        corewolf::engine *GeoPositionENU(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeoPositionENU[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the Cartesian position with respect to p of the specified geographical entity.
        /// https://reference.wolfram.com/language/ref/GeoPositionENU.html
        ///</summary>
        corewolf::engine *GeoPositionENU(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoPositionENU[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a position in a Cartesian geocentric coordinate system.
        /// https://reference.wolfram.com/language/ref/GeoPositionXYZ.html
        ///</summary>
        corewolf::engine *GeoPositionXYZ(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoPositionXYZ[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a point referred to the specified datum.
        /// https://reference.wolfram.com/language/ref/GeoPositionXYZ.html
        ///</summary>
        corewolf::engine *GeoPositionXYZ(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoPositionXYZ[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an array of points in a Cartesian geocentric coordinate system.
        /// https://reference.wolfram.com/language/ref/GeoPositionXYZ.html
        ///</summary>
        corewolf::engine *GeoPositionXYZ(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeoPositionXYZ[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the Cartesian geocentric position of the given geographical entity.
        /// https://reference.wolfram.com/language/ref/GeoPositionXYZ.html
        ///</summary>
        corewolf::engine *GeoPositionXYZ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoPositionXYZ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the specified cartographic projection.
        /// https://reference.wolfram.com/language/ref/GeoProjectionData.html
        ///</summary>
        corewolf::engine *GeoProjectionData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoProjectionData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the complete options for the default form of the specified projection.
        /// https://reference.wolfram.com/language/ref/GeoProjectionData.html
        ///</summary>
        corewolf::engine *GeoProjectionData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoProjectionData[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a plot in which the geographic regions regi are colored according to the values vali.
        /// https://reference.wolfram.com/language/ref/GeoRegionValuePlot.html
        ///</summary>
        corewolf::engine *GeoRegionValuePlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoRegionValuePlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// uses a collection of regions regi from regions with corresponding values vali from values.
        /// https://reference.wolfram.com/language/ref/GeoRegionValuePlot.html
        ///</summary>
        corewolf::engine *GeoRegionValuePlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoRegionValuePlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots a smooth kernel histogram of the geo locations locs.
        /// https://reference.wolfram.com/language/ref/GeoSmoothHistogram.html
        ///</summary>
        corewolf::engine *GeoSmoothHistogram(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoSmoothHistogram[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots a smooth kernel histogram with estimator specification espec.
        /// https://reference.wolfram.com/language/ref/GeoSmoothHistogram.html
        ///</summary>
        corewolf::engine *GeoSmoothHistogram(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoSmoothHistogram[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// plots the distribution function dfun.
        /// https://reference.wolfram.com/language/ref/GeoSmoothHistogram.html
        ///</summary>
        corewolf::engine *GeoSmoothHistogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GeoSmoothHistogram[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a stream plot from the field of geo vectors vecs.
        /// https://reference.wolfram.com/language/ref/GeoStreamPlot.html
        ///</summary>
        corewolf::engine *GeoStreamPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoStreamPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a separate set of streams for each vecsi.
        /// https://reference.wolfram.com/language/ref/GeoStreamPlot.html
        ///</summary>
        corewolf::engine *GeoStreamPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoStreamPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// displays faces of polygons and other filled geo objects using mapstyle.
        /// https://reference.wolfram.com/language/ref/GeoStyling.html
        ///</summary>
        corewolf::engine *GeoStyling(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoStyling[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses mapstyle with the given graphics directive applied.
        /// https://reference.wolfram.com/language/ref/GeoStyling.html
        ///</summary>
        corewolf::engine *GeoStyling(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoStyling[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a geographic const std::string &obj with qualifier qual.
        /// https://reference.wolfram.com/language/ref/GeoVariant.html
        ///</summary>
        corewolf::engine *GeoVariant(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoVariant[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a horizontal two-dimensional vector of magnitude m and bearing α at geo location loc.
        /// https://reference.wolfram.com/language/ref/GeoVector.html
        ///</summary>
        corewolf::engine *GeoVector(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoVector[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a collection of vectors veci at respective geo locations loci.
        /// https://reference.wolfram.com/language/ref/GeoVector.html
        ///</summary>
        corewolf::engine *GeoVector(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoVector[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a horizontal two-dimensional vector of components ve and vn in an orthonormal frame tangent to the Earth at geo location loc.
        /// https://reference.wolfram.com/language/ref/GeoVectorENU.html
        ///</summary>
        corewolf::engine *GeoVectorENU(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoVectorENU[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a collection of vectors veci at respective geo locations loci.
        /// https://reference.wolfram.com/language/ref/GeoVectorENU.html
        ///</summary>
        corewolf::engine *GeoVectorENU(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoVectorENU[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a vector plot from the field of geo vectors vecs.
        /// https://reference.wolfram.com/language/ref/GeoVectorPlot.html
        ///</summary>
        corewolf::engine *GeoVectorPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoVectorPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a separate set of vectors for each vecsi.
        /// https://reference.wolfram.com/language/ref/GeoVectorPlot.html
        ///</summary>
        corewolf::engine *GeoVectorPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoVectorPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a three-dimensional vector of Cartesian components vX, vY, vZ in an orthonormal frame parallel to the geocentric frame, at location loc.
        /// https://reference.wolfram.com/language/ref/GeoVectorXYZ.html
        ///</summary>
        corewolf::engine *GeoVectorXYZ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoVectorXYZ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a collection of vectors veci at respective geo locations loci.
        /// https://reference.wolfram.com/language/ref/GeoVectorXYZ.html
        ///</summary>
        corewolf::engine *GeoVectorXYZ(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoVectorXYZ[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// is a two-dimensional GeoGraphics primitive that represents the region on the surface of the Earth visible from the point of coordinates lat,lon and height h above the reference ellipsoid.
        /// https://reference.wolfram.com/language/ref/GeoVisibleRegion.html
        ///</summary>
        corewolf::engine *GeoVisibleRegion(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoVisibleRegion[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the region visible from the position pos.
        /// https://reference.wolfram.com/language/ref/GeoVisibleRegion.html
        ///</summary>
        corewolf::engine *GeoVisibleRegion(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoVisibleRegion[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a one-dimensional GeoGraphics primitive that represents the boundary of the region on the surface of the Earth visible from the point of coordinates lat,lon and height h above the reference ellipsoid.
        /// https://reference.wolfram.com/language/ref/GeoVisibleRegionBoundary.html
        ///</summary>
        corewolf::engine *GeoVisibleRegionBoundary(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GeoVisibleRegionBoundary[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the boundary of the region visible from the position pos.
        /// https://reference.wolfram.com/language/ref/GeoVisibleRegionBoundary.html
        ///</summary>
        corewolf::engine *GeoVisibleRegionBoundary(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoVisibleRegionBoundary[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if the location loc is contained within the region reg, and False otherwise.
        /// https://reference.wolfram.com/language/ref/GeoWithinQ.html
        ///</summary>
        corewolf::engine *GeoWithinQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GeoWithinQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of GeoWithinQ that can be applied to a location.
        /// https://reference.wolfram.com/language/ref/GeoWithinQ.html
        ///</summary>
        corewolf::engine *GeoWithinQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GeoWithinQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as expr, evaluating funi[value,velocity] whenever "gesturei" occurs within the screen space occupied by expr.
        /// https://reference.wolfram.com/language/ref/GestureHandler.html
        ///</summary>
        corewolf::engine *GestureHandler(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GestureHandler[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the setting corresponding to the variable "var" in the operating system environment.
        /// https://reference.wolfram.com/language/ref/GetEnvironment.html
        ///</summary>
        corewolf::engine *GetEnvironment(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GetEnvironment[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of rules, corresponding to specified environment variables.
        /// https://reference.wolfram.com/language/ref/GetEnvironment.html
        ///</summary>
        corewolf::engine *GetEnvironment(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GetEnvironment[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives information about all existing settings in the operating system environment.
        /// https://reference.wolfram.com/language/ref/GetEnvironment.html
        ///</summary>
        corewolf::engine *GetEnvironment(const std::string &name = "")
        {
            return this->execute("GetEnvironment[]", name);
        }

        ///< summary>
        /// represents a Gibbs point process with density μ and pair-potential function ϕ in .
        /// https://reference.wolfram.com/language/ref/GibbsPointProcess.html
        ///</summary>
        corewolf::engine *GibbsPointProcess(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GibbsPointProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the global clustering coefficient of the graph g.
        /// https://reference.wolfram.com/language/ref/GlobalClusteringCoefficient.html
        ///</summary>
        corewolf::engine *GlobalClusteringCoefficient(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GlobalClusteringCoefficient[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GlobalClusteringCoefficient.html
        ///</summary>
        corewolf::engine *GlobalClusteringCoefficient(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GlobalClusteringCoefficient[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a Gompertz distribution with scale parameter λ and frailty parameter ξ.
        /// https://reference.wolfram.com/language/ref/GompertzMakehamDistribution.html
        ///</summary>
        corewolf::engine *GompertzMakehamDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GompertzMakehamDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Gompertz–Makeham distribution with parameters λ, ξ, θ, and α.
        /// https://reference.wolfram.com/language/ref/GompertzMakehamDistribution.html
        ///</summary>
        corewolf::engine *GompertzMakehamDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("GompertzMakehamDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// is a three-dimensional graphics directive specifying that surfaces that follow are to be drawn with a warm color facing toward the light and a cool color facing away.
        /// https://reference.wolfram.com/language/ref/GoochShading.html
        ///</summary>
        corewolf::engine *GoochShading(const std::string &name = "")
        {
            return this->execute("GoochShading[]", name);
        }

        ///< summary>
        /// uses cool and warm colors obtained by blending col with slate Blue and Orange.
        /// https://reference.wolfram.com/language/ref/GoochShading.html
        ///</summary>
        corewolf::engine *GoochShading(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GoochShading[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the cool color ccol and the warm color wcol.
        /// https://reference.wolfram.com/language/ref/GoochShading.html
        ///</summary>
        corewolf::engine *GoochShading(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GoochShading[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Goodman–Kruskal  coefficient for the vectors v1 and v2.
        /// https://reference.wolfram.com/language/ref/GoodmanKruskalGamma.html
        ///</summary>
        corewolf::engine *GoodmanKruskalGamma(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GoodmanKruskalGamma[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Goodman–Kruskal  coefficients for the matrix m.
        /// https://reference.wolfram.com/language/ref/GoodmanKruskalGamma.html
        ///</summary>
        corewolf::engine *GoodmanKruskalGamma(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GoodmanKruskalGamma[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the   coefficient for the multivariate symbolic distribution dist.
        /// https://reference.wolfram.com/language/ref/GoodmanKruskalGamma.html
        ///</summary>
        corewolf::engine *GoodmanKruskalGamma(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GoodmanKruskalGamma[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether the vectors v1 and v2 are independent.
        /// https://reference.wolfram.com/language/ref/GoodmanKruskalGammaTest.html
        ///</summary>
        corewolf::engine *GoodmanKruskalGammaTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GoodmanKruskalGammaTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// scans for Label[tag], and transfers control to that point.
        /// https://reference.wolfram.com/language/ref/Goto.html
        ///</summary>
        corewolf::engine *Goto(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Goto[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a three‐dimensional graphics directive that specifies that faces of polygons and other filled graphics objects are to be drawn to reflect as a smooth surface using a normal‐vector average shading.
        /// https://reference.wolfram.com/language/ref/GouraudShading.html
        ///</summary>
        corewolf::engine *GouraudShading(const std::string &name = "")
        {
            return this->execute("GouraudShading[]", name);
        }

        ///< summary>
        /// uses the attenuation factor d for the diffuse light.
        /// https://reference.wolfram.com/language/ref/GouraudShading.html
        ///</summary>
        corewolf::engine *GouraudShading(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GouraudShading[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the attenuation factor s for the specular light.
        /// https://reference.wolfram.com/language/ref/GouraudShading.html
        ///</summary>
        corewolf::engine *GouraudShading(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GouraudShading[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the attenuation factor a for the ambient light.
        /// https://reference.wolfram.com/language/ref/GouraudShading.html
        ///</summary>
        corewolf::engine *GouraudShading(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GouraudShading[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the gradient .
        /// https://reference.wolfram.com/language/ref/Grad.html
        ///</summary>
        corewolf::engine *Grad(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Grad[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the gradient in the coordinates chart.
        /// https://reference.wolfram.com/language/ref/Grad.html
        ///</summary>
        corewolf::engine *Grad(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Grad[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the magnitude of the gradient of data, computed using discrete derivatives of a Gaussian of sample radius r.
        /// https://reference.wolfram.com/language/ref/GradientFilter.html
        ///</summary>
        corewolf::engine *GradientFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GradientFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses a Gaussian with standard deviation σ.
        /// https://reference.wolfram.com/language/ref/GradientFilter.html
        ///</summary>
        corewolf::engine *GradientFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GradientFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a MeshRegion whose gradient best fits the normals at points p1,p2,….
        /// https://reference.wolfram.com/language/ref/GradientFittedMesh.html
        ///</summary>
        corewolf::engine *GradientFittedMesh(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GradientFittedMesh[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the local orientation parallel to the gradient of data, computed using discrete derivatives of a Gaussian of pixel radius r, returning values between  and .
        /// https://reference.wolfram.com/language/ref/GradientOrientationFilter.html
        ///</summary>
        corewolf::engine *GradientOrientationFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GradientOrientationFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses a Gaussian with standard deviation σ.
        /// https://reference.wolfram.com/language/ref/GradientOrientationFilter.html
        ///</summary>
        corewolf::engine *GradientOrientationFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GradientOrientationFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// attempts to parse input according to the grammar defined by grammar.
        /// https://reference.wolfram.com/language/ref/GrammarApply.html
        ///</summary>
        corewolf::engine *GrammarApply(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GrammarApply[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents grammar rules to be deployed to a cloud const std::string &that implements the grammar in a form suitable for use with functions like GrammarApply and Interpreter.
        /// https://reference.wolfram.com/language/ref/GrammarRules.html
        ///</summary>
        corewolf::engine *GrammarRules(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GrammarRules[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses grammar definitions defs.
        /// https://reference.wolfram.com/language/ref/GrammarRules.html
        ///</summary>
        corewolf::engine *GrammarRules(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GrammarRules[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a grammar rules pattern const std::string &that represents any input of the specified form.
        /// https://reference.wolfram.com/language/ref/GrammarToken.html
        ///</summary>
        corewolf::engine *GrammarToken(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GrammarToken[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields a graph with edges ej.
        /// https://reference.wolfram.com/language/ref/Graph.html
        ///</summary>
        corewolf::engine *Graph(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Graph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// yields the graph with vertices vi and edges ej.
        /// https://reference.wolfram.com/language/ref/Graph.html
        ///</summary>
        corewolf::engine *Graph(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Graph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields a graph from data.
        /// https://reference.wolfram.com/language/ref/Graph.html
        ///</summary>
        corewolf::engine *Graph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Graph[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a graph with vertices and edges from the graph g and represented as a 3D plot.
        /// https://reference.wolfram.com/language/ref/Graph3D.html
        ///</summary>
        corewolf::engine *Graph3D(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Graph3D[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a graph with edges ej and represented as a 3D plot.
        /// https://reference.wolfram.com/language/ref/Graph3D.html
        ///</summary>
        corewolf::engine *Graph3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Graph3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// creates a graph with vertices vi and edges ej.
        /// https://reference.wolfram.com/language/ref/Graph3D.html
        ///</summary>
        corewolf::engine *Graph3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Graph3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the assortativity coefficient of a graph g using vertex degrees.
        /// https://reference.wolfram.com/language/ref/GraphAssortativity.html
        ///</summary>
        corewolf::engine *GraphAssortativity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphAssortativity[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the assortativity coefficient of the graph g using vertex property "prop".
        /// https://reference.wolfram.com/language/ref/GraphAssortativity.html
        ///</summary>
        corewolf::engine *GraphAssortativity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphAssortativity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the assortativity coefficient of the graph g with respect to the vertex partition {{vi 1,vi 2,…},…}.
        /// https://reference.wolfram.com/language/ref/GraphAssortativity.html
        ///</summary>
        corewolf::engine *GraphAssortativity(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GraphAssortativity[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphAssortativity.html
        ///</summary>
        corewolf::engine *GraphAssortativity(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphAssortativity[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the automorphism group of a graph g.
        /// https://reference.wolfram.com/language/ref/GraphAutomorphismGroup.html
        ///</summary>
        corewolf::engine *GraphAutomorphismGroup(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphAutomorphismGroup[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphAutomorphismGroup.html
        ///</summary>
        corewolf::engine *GraphAutomorphismGroup(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GraphAutomorphismGroup[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the set of vertices with minimum eccentricity in the graph g.
        /// https://reference.wolfram.com/language/ref/GraphCenter.html
        ///</summary>
        corewolf::engine *GraphCenter(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphCenter[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphCenter.html
        ///</summary>
        corewolf::engine *GraphCenter(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GraphCenter[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the graph complement of the graph g.
        /// https://reference.wolfram.com/language/ref/GraphComplement.html
        ///</summary>
        corewolf::engine *GraphComplement(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphComplement[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphComplement.html
        ///</summary>
        corewolf::engine *GraphComplement(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GraphComplement[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a graph with the specified name.
        /// https://reference.wolfram.com/language/ref/GraphData.html
        ///</summary>
        corewolf::engine *GraphData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the property for the specified graph entity.
        /// https://reference.wolfram.com/language/ref/GraphData.html
        ///</summary>
        corewolf::engine *GraphData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the graph density of the graph g.
        /// https://reference.wolfram.com/language/ref/GraphDensity.html
        ///</summary>
        corewolf::engine *GraphDensity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphDensity[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphDensity.html
        ///</summary>
        corewolf::engine *GraphDensity(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GraphDensity[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the greatest distance between any pair of vertices in the graph g.
        /// https://reference.wolfram.com/language/ref/GraphDiameter.html
        ///</summary>
        corewolf::engine *GraphDiameter(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphDiameter[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphDiameter.html
        ///</summary>
        corewolf::engine *GraphDiameter(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GraphDiameter[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the graph difference of the graphs g1 and g2.
        /// https://reference.wolfram.com/language/ref/GraphDifference.html
        ///</summary>
        corewolf::engine *GraphDifference(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphDifference[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphDifference.html
        ///</summary>
        corewolf::engine *GraphDifference(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphDifference[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the graph disjoint union of the graphs g1 and g2.
        /// https://reference.wolfram.com/language/ref/GraphDisjointUnion.html
        ///</summary>
        corewolf::engine *GraphDisjointUnion(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphDisjointUnion[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the disjoint union of g1, g2, ….
        /// https://reference.wolfram.com/language/ref/GraphDisjointUnion.html
        ///</summary>
        corewolf::engine *GraphDisjointUnion(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GraphDisjointUnion[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphDisjointUnion.html
        ///</summary>
        corewolf::engine *GraphDisjointUnion(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphDisjointUnion[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the distance from source vertex s to target vertex t in the graph g.
        /// https://reference.wolfram.com/language/ref/GraphDistance.html
        ///</summary>
        corewolf::engine *GraphDistance(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GraphDistance[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the distance from s to all vertices of the graph g.
        /// https://reference.wolfram.com/language/ref/GraphDistance.html
        ///</summary>
        corewolf::engine *GraphDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphDistance.html
        ///</summary>
        corewolf::engine *GraphDistance(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphDistance[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the matrix of distances between vertices for the graph g.
        /// https://reference.wolfram.com/language/ref/GraphDistanceMatrix.html
        ///</summary>
        corewolf::engine *GraphDistanceMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphDistanceMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the matrix of distances between vertices of maximal distance d in the graph g.
        /// https://reference.wolfram.com/language/ref/GraphDistanceMatrix.html
        ///</summary>
        corewolf::engine *GraphDistanceMatrix(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphDistanceMatrix[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphDistanceMatrix.html
        ///</summary>
        corewolf::engine *GraphDistanceMatrix(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphDistanceMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives coordinates of the vertices of the graph g.
        /// https://reference.wolfram.com/language/ref/GraphEmbedding.html
        ///</summary>
        corewolf::engine *GraphEmbedding(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphEmbedding[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives coordinates of the vertices of the graph g using the embedding "emb".
        /// https://reference.wolfram.com/language/ref/GraphEmbedding.html
        ///</summary>
        corewolf::engine *GraphEmbedding(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphEmbedding[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives coordinates in dimension dim of the vertices of the graph g using the embedding "emb".
        /// https://reference.wolfram.com/language/ref/GraphEmbedding.html
        ///</summary>
        corewolf::engine *GraphEmbedding(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GraphEmbedding[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the set of vertices with maximum vertex degree in the underlying simple graph of g.
        /// https://reference.wolfram.com/language/ref/GraphHub.html
        ///</summary>
        corewolf::engine *GraphHub(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphHub[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the set of vertices with maximum vertex in-degree.
        /// https://reference.wolfram.com/language/ref/GraphHub.html
        ///</summary>
        corewolf::engine *GraphHub(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphHub[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphHub.html
        ///</summary>
        corewolf::engine *GraphHub(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphHub[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a two-dimensional graphical image.
        /// https://reference.wolfram.com/language/ref/Graphics.html
        ///</summary>
        corewolf::engine *Graphics(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Graphics[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a three-dimensional graphical image.
        /// https://reference.wolfram.com/language/ref/Graphics3D.html
        ///</summary>
        corewolf::engine *Graphics3D(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Graphics3D[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a graphic in which the gi are laid out in a column, with g1 above g2, etc.
        /// https://reference.wolfram.com/language/ref/GraphicsColumn.html
        ///</summary>
        corewolf::engine *GraphicsColumn(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GraphicsColumn[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// aligns each element horizontally in the specified way.
        /// https://reference.wolfram.com/language/ref/GraphicsColumn.html
        ///</summary>
        corewolf::engine *GraphicsColumn(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphicsColumn[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// leaves the specified spacing between successive elements.
        /// https://reference.wolfram.com/language/ref/GraphicsColumn.html
        ///</summary>
        corewolf::engine *GraphicsColumn(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GraphicsColumn[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a graphics complex in which coordinates given as integers i in graphics primitives in data are taken to be pti.
        /// https://reference.wolfram.com/language/ref/GraphicsComplex.html
        ///</summary>
        corewolf::engine *GraphicsComplex(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphicsComplex[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a graphic in which the gij are laid out in a two-dimensional grid.
        /// https://reference.wolfram.com/language/ref/GraphicsGrid.html
        ///</summary>
        corewolf::engine *GraphicsGrid(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GraphicsGrid[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a collection of graphics objects grouped together for purposes of interactive selection in a notebook.
        /// https://reference.wolfram.com/language/ref/GraphicsGroup.html
        ///</summary>
        corewolf::engine *GraphicsGroup(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GraphicsGroup[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a graphic in which the gi are laid out in a row.
        /// https://reference.wolfram.com/language/ref/GraphicsRow.html
        ///</summary>
        corewolf::engine *GraphicsRow(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GraphicsRow[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// leaves the specified spacing between successive elements.
        /// https://reference.wolfram.com/language/ref/GraphicsRow.html
        ///</summary>
        corewolf::engine *GraphicsRow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphicsRow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the graph intersection of the graphs g1 and g2.
        /// https://reference.wolfram.com/language/ref/GraphIntersection.html
        ///</summary>
        corewolf::engine *GraphIntersection(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphIntersection[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the graph intersection of g1, g2, … .
        /// https://reference.wolfram.com/language/ref/GraphIntersection.html
        ///</summary>
        corewolf::engine *GraphIntersection(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GraphIntersection[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphIntersection.html
        ///</summary>
        corewolf::engine *GraphIntersection(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphIntersection[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the graph join of the graphs g1 and g2.
        /// https://reference.wolfram.com/language/ref/GraphJoin.html
        ///</summary>
        corewolf::engine *GraphJoin(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphJoin[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the link efficiency of the graph g.
        /// https://reference.wolfram.com/language/ref/GraphLinkEfficiency.html
        ///</summary>
        corewolf::engine *GraphLinkEfficiency(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphLinkEfficiency[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphLinkEfficiency.html
        ///</summary>
        corewolf::engine *GraphLinkEfficiency(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GraphLinkEfficiency[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives vertices that are maximally distant to at least one vertex in the graph g.
        /// https://reference.wolfram.com/language/ref/GraphPeriphery.html
        ///</summary>
        corewolf::engine *GraphPeriphery(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphPeriphery[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphPeriphery.html
        ///</summary>
        corewolf::engine *GraphPeriphery(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GraphPeriphery[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a plot of the graph g.
        /// https://reference.wolfram.com/language/ref/GraphPlot.html
        ///</summary>
        corewolf::engine *GraphPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a plot of the graph with edges ei.
        /// https://reference.wolfram.com/language/ref/GraphPlot.html
        ///</summary>
        corewolf::engine *GraphPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GraphPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a 3D plot of the graph g.
        /// https://reference.wolfram.com/language/ref/GraphPlot3D.html
        ///</summary>
        corewolf::engine *GraphPlot3D(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphPlot3D[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a 3D plot of the graph with edges ei.
        /// https://reference.wolfram.com/language/ref/GraphPlot3D.html
        ///</summary>
        corewolf::engine *GraphPlot3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GraphPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the graph-n power of the graph g.
        /// https://reference.wolfram.com/language/ref/GraphPower.html
        ///</summary>
        corewolf::engine *GraphPower(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphPower[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphPower.html
        ///</summary>
        corewolf::engine *GraphPower(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphPower[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Cartesian product of the graphs g1 and g2.
        /// https://reference.wolfram.com/language/ref/GraphProduct.html
        ///</summary>
        corewolf::engine *GraphProduct(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphProduct[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the product of type "op" for the graphs g1 and g2
        /// https://reference.wolfram.com/language/ref/GraphProduct.html
        ///</summary>
        corewolf::engine *GraphProduct(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GraphProduct[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the distribution of the property expr where the random variable x follows the graph distribution gdist.
        /// https://reference.wolfram.com/language/ref/GraphPropertyDistribution.html
        ///</summary>
        corewolf::engine *GraphPropertyDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphPropertyDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the distribution where x1, x2, … are independent and follow the graph distributions gdist1, gdist2, ….
        /// https://reference.wolfram.com/language/ref/GraphPropertyDistribution.html
        ///</summary>
        corewolf::engine *GraphPropertyDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GraphPropertyDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if g is a valid Graph const std::string &and False otherwise.
        /// https://reference.wolfram.com/language/ref/GraphQ.html
        ///</summary>
        corewolf::engine *GraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the minimum eccentricity of the vertices in the graph g.
        /// https://reference.wolfram.com/language/ref/GraphRadius.html
        ///</summary>
        corewolf::engine *GraphRadius(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphRadius[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphRadius.html
        ///</summary>
        corewolf::engine *GraphRadius(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GraphRadius[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the reciprocity of a graph g.
        /// https://reference.wolfram.com/language/ref/GraphReciprocity.html
        ///</summary>
        corewolf::engine *GraphReciprocity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphReciprocity[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphReciprocity.html
        ///</summary>
        corewolf::engine *GraphReciprocity(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GraphReciprocity[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the graph sum of the graphs g1 and g2.
        /// https://reference.wolfram.com/language/ref/GraphSum.html
        ///</summary>
        corewolf::engine *GraphSum(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphSum[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// constructs a tree from the tree graph g.
        /// https://reference.wolfram.com/language/ref/GraphTree.html
        ///</summary>
        corewolf::engine *GraphTree(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GraphTree[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies what vertex to use as the root.
        /// https://reference.wolfram.com/language/ref/GraphTree.html
        ///</summary>
        corewolf::engine *GraphTree(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphTree[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies h to each vertex to get the corresponding data and ordering of subtrees.
        /// https://reference.wolfram.com/language/ref/GraphTree.html
        ///</summary>
        corewolf::engine *GraphTree(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GraphTree[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the graph union of the graphs g1 and g2.
        /// https://reference.wolfram.com/language/ref/GraphUnion.html
        ///</summary>
        corewolf::engine *GraphUnion(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphUnion[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the graph union of g1, g2, ….
        /// https://reference.wolfram.com/language/ref/GraphUnion.html
        ///</summary>
        corewolf::engine *GraphUnion(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GraphUnion[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/GraphUnion.html
        ///</summary>
        corewolf::engine *GraphUnion(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GraphUnion[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a color in the grayscale color space with gray level g.
        /// https://reference.wolfram.com/language/ref/GrayLevel.html
        ///</summary>
        corewolf::engine *GrayLevel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GrayLevel[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies opacity a.
        /// https://reference.wolfram.com/language/ref/GrayLevel.html
        ///</summary>
        corewolf::engine *GrayLevel(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GrayLevel[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/GreaterEqualLess.html
        ///</summary>
        corewolf::engine *GreaterEqualLess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GreaterEqualLess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is an operator form that yields x≥y when applied to an expression x.
        /// https://reference.wolfram.com/language/ref/GreaterEqualThan.html
        ///</summary>
        corewolf::engine *GreaterEqualThan(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GreaterEqualThan[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/GreaterFullEqual.html
        ///</summary>
        corewolf::engine *GreaterFullEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GreaterFullEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/GreaterGreater.html
        ///</summary>
        corewolf::engine *GreaterGreater(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GreaterGreater[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/GreaterLess.html
        ///</summary>
        corewolf::engine *GreaterLess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GreaterLess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/GreaterSlantEqual.html
        ///</summary>
        corewolf::engine *GreaterSlantEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GreaterSlantEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is an operator form that yields x>y when applied to an expression x.
        /// https://reference.wolfram.com/language/ref/GreaterThan.html
        ///</summary>
        corewolf::engine *GreaterThan(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GreaterThan[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/GreaterTilde.html
        ///</summary>
        corewolf::engine *GreaterTilde(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GreaterTilde[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a Green's function for the linear differential operator ℒ with boundary conditions ℬ in the range xmin to xmax.
        /// https://reference.wolfram.com/language/ref/GreenFunction.html
        ///</summary>
        corewolf::engine *GreenFunction(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("GreenFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives a Green's function for the linear partial differential operator ℒ over the region Ω.
        /// https://reference.wolfram.com/language/ref/GreenFunction.html
        ///</summary>
        corewolf::engine *GreenFunction(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("GreenFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// gives a Green's function for the linear time-dependent operator ℒ in the range xmin to xmax.
        /// https://reference.wolfram.com/language/ref/GreenFunction.html
        ///</summary>
        corewolf::engine *GreenFunction(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::vector<std::string> &arg4, const std::string &name = "")
        {
            return this->execute("GreenFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + "]", name);
        }

        ///< summary>
        /// gives a Green's function for the linear time-dependent operator ℒ over the region Ω.
        /// https://reference.wolfram.com/language/ref/GreenFunction.html
        ///</summary>
        corewolf::engine *GreenFunction(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::vector<std::string> &arg4, const std::string &name = "")
        {
            return this->execute("GreenFunction[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + "]", name);
        }

        ///< summary>
        /// is an const std::string &that formats with the exprij arranged in a two-dimensional grid.
        /// https://reference.wolfram.com/language/ref/Grid.html
        ///</summary>
        corewolf::engine *Grid(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Grid[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is a low-level box construct that represents a two-dimensional grid of boxes or strings in notebook expressions.
        /// https://reference.wolfram.com/language/ref/GridBox.html
        ///</summary>
        corewolf::engine *GridBox(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GridBox[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the grid graph with m×n vertices .
        /// https://reference.wolfram.com/language/ref/GridGraph.html
        ///</summary>
        corewolf::engine *GridGraph(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GridGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// creates a video in which each frame is a grid of frames of all vi at the corresponding time.
        /// https://reference.wolfram.com/language/ref/GridVideo.html
        ///</summary>
        corewolf::engine *GridVideo(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("GridVideo[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of polynomials that form a Gröbner basis for the set of polynomials polyi.
        /// https://reference.wolfram.com/language/ref/GroebnerBasis.html
        ///</summary>
        corewolf::engine *GroebnerBasis(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GroebnerBasis[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds a Gröbner basis in which the yi have been eliminated.
        /// https://reference.wolfram.com/language/ref/GroebnerBasis.html
        ///</summary>
        corewolf::engine *GroebnerBasis(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("GroebnerBasis[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives an association that groups the elemi into lists associated with distinct keys f[elemi].
        /// https://reference.wolfram.com/language/ref/GroupBy.html
        ///</summary>
        corewolf::engine *GroupBy(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GroupBy[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// groups into nested associations using fsi at level i.
        /// https://reference.wolfram.com/language/ref/GroupBy.html
        ///</summary>
        corewolf::engine *GroupBy(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GroupBy[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// applies the function red to reduce lists of values that are generated.
        /// https://reference.wolfram.com/language/ref/GroupBy.html
        ///</summary>
        corewolf::engine *GroupBy(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GroupBy[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of GroupBy that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/GroupBy.html
        ///</summary>
        corewolf::engine *GroupBy(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GroupBy[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the centralizer of the element g in group.
        /// https://reference.wolfram.com/language/ref/GroupCentralizer.html
        ///</summary>
        corewolf::engine *GroupCentralizer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GroupCentralizer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the element of group determined by the word w in the generators of group.
        /// https://reference.wolfram.com/language/ref/GroupElementFromWord.html
        ///</summary>
        corewolf::engine *GroupElementFromWord(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GroupElementFromWord[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the position of the element g in the list of elements of group.
        /// https://reference.wolfram.com/language/ref/GroupElementPosition.html
        ///</summary>
        corewolf::engine *GroupElementPosition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GroupElementPosition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the list of positions of the elements g1,…,gn in group.
        /// https://reference.wolfram.com/language/ref/GroupElementPosition.html
        ///</summary>
        corewolf::engine *GroupElementPosition(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GroupElementPosition[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns True if the const std::string &g is an element of group and False otherwise.
        /// https://reference.wolfram.com/language/ref/GroupElementQ.html
        ///</summary>
        corewolf::engine *GroupElementQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GroupElementQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the list of all elements of group.
        /// https://reference.wolfram.com/language/ref/GroupElements.html
        ///</summary>
        corewolf::engine *GroupElements(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GroupElements[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the elements numbered r1,…,rk in group in the standard order.
        /// https://reference.wolfram.com/language/ref/GroupElements.html
        ///</summary>
        corewolf::engine *GroupElements(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GroupElements[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// decomposes the group element g as a product of generators of group.
        /// https://reference.wolfram.com/language/ref/GroupElementToWord.html
        ///</summary>
        corewolf::engine *GroupElementToWord(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GroupElementToWord[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a list of generators of group.
        /// https://reference.wolfram.com/language/ref/GroupGenerators.html
        ///</summary>
        corewolf::engine *GroupGenerators(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GroupGenerators[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of all possible groupings of 1,…,n taken k at a time.
        /// https://reference.wolfram.com/language/ref/Groupings.html
        ///</summary>
        corewolf::engine *Groupings(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Groupings[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives all possible groupings of a1,…,an taken k at a time.
        /// https://reference.wolfram.com/language/ref/Groupings.html
        ///</summary>
        corewolf::engine *Groupings(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Groupings[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the combination of all possible groupings of each of the lists ai,bi,… taken k at a time.
        /// https://reference.wolfram.com/language/ref/Groupings.html
        ///</summary>
        corewolf::engine *Groupings(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Groupings[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives all possible groupings in which the function fi is applied to ki elements.
        /// https://reference.wolfram.com/language/ref/Groupings.html
        ///</summary>
        corewolf::engine *Groupings(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Groupings[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// allows at most mi occurrences in a given grouping of fi applied to ki elements.
        /// https://reference.wolfram.com/language/ref/Groupings.html
        ///</summary>
        corewolf::engine *Groupings(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Groupings[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// wraps the function h around each grouping generated.
        /// https://reference.wolfram.com/language/ref/Groupings.html
        ///</summary>
        corewolf::engine *Groupings(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Groupings[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multiplication table of group as an array.
        /// https://reference.wolfram.com/language/ref/GroupMultiplicationTable.html
        ///</summary>
        corewolf::engine *GroupMultiplicationTable(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GroupMultiplicationTable[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the orbits of the points pi under the action of the elements of group.
        /// https://reference.wolfram.com/language/ref/GroupOrbits.html
        ///</summary>
        corewolf::engine *GroupOrbits(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GroupOrbits[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds the orbits under the group action given by a function f.
        /// https://reference.wolfram.com/language/ref/GroupOrbits.html
        ///</summary>
        corewolf::engine *GroupOrbits(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GroupOrbits[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the number of elements of group.
        /// https://reference.wolfram.com/language/ref/GroupOrder.html
        ///</summary>
        corewolf::engine *GroupOrder(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GroupOrder[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the subgroup of group for which the images of the points pi are still in the list {p1,…,pn}.
        /// https://reference.wolfram.com/language/ref/GroupSetwiseStabilizer.html
        ///</summary>
        corewolf::engine *GroupSetwiseStabilizer(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GroupSetwiseStabilizer[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns the setwise stabilizer subgroup under the action given by the function f.
        /// https://reference.wolfram.com/language/ref/GroupSetwiseStabilizer.html
        ///</summary>
        corewolf::engine *GroupSetwiseStabilizer(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GroupSetwiseStabilizer[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the subgroup of elements of group that move none of the points p1, …, pn.
        /// https://reference.wolfram.com/language/ref/GroupStabilizer.html
        ///</summary>
        corewolf::engine *GroupStabilizer(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GroupStabilizer[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns the stabilizer subgroup under the action given by the function f.
        /// https://reference.wolfram.com/language/ref/GroupStabilizer.html
        ///</summary>
        corewolf::engine *GroupStabilizer(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GroupStabilizer[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns a list of successive stabilizers in group of the points in a base of group.
        /// https://reference.wolfram.com/language/ref/GroupStabilizerChain.html
        ///</summary>
        corewolf::engine *GroupStabilizerChain(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("GroupStabilizerChain[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a segmentation from image by growing each markeri.
        /// https://reference.wolfram.com/language/ref/GrowCutComponents.html
        ///</summary>
        corewolf::engine *GrowCutComponents(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("GrowCutComponents[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Gudermannian function .
        /// https://reference.wolfram.com/language/ref/Gudermannian.html
        ///</summary>
        corewolf::engine *Gudermannian(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Gudermannian[" + arg0 + "]", name);
        }

        ///< summary>
        /// filters image using the guide image guide over range-r neighborhoods with pixel-value regularizer ϵ.
        /// https://reference.wolfram.com/language/ref/GuidedFilter.html
        ///</summary>
        corewolf::engine *GuidedFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("GuidedFilter[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// filters image so as to reduce noise, using image as the guide.
        /// https://reference.wolfram.com/language/ref/GuidedFilter.html
        ///</summary>
        corewolf::engine *GuidedFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("GuidedFilter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Gumbel distribution with location parameter α and scale parameter β.
        /// https://reference.wolfram.com/language/ref/GumbelDistribution.html
        ///</summary>
        corewolf::engine *GumbelDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("GumbelDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Gumbel distribution with location parameter 0 and scale parameter 1.
        /// https://reference.wolfram.com/language/ref/GumbelDistribution.html
        ///</summary>
        corewolf::engine *GumbelDistribution(const std::string &name = "")
        {
            return this->execute("GumbelDistribution[]", name);
        }

        ///< summary>
        /// represents a Haar wavelet.
        /// https://reference.wolfram.com/language/ref/HaarWavelet.html
        ///</summary>
        corewolf::engine *HaarWavelet(const std::string &name = "")
        {
            return this->execute("HaarWavelet[]", name);
        }

        ///< summary>
        /// returns an n×n Hadamard matrix.
        /// https://reference.wolfram.com/language/ref/HadamardMatrix.html
        ///</summary>
        corewolf::engine *HadamardMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HadamardMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the half-line from the point p1 through p2.
        /// https://reference.wolfram.com/language/ref/HalfLine.html
        ///</summary>
        corewolf::engine *HalfLine(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("HalfLine[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the half-line from the point p in the direction v.
        /// https://reference.wolfram.com/language/ref/HalfLine.html
        ///</summary>
        corewolf::engine *HalfLine(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HalfLine[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a half-normal distribution with scale inversely proportional to parameter θ.
        /// https://reference.wolfram.com/language/ref/HalfNormalDistribution.html
        ///</summary>
        corewolf::engine *HalfNormalDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HalfNormalDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the half-plane bounded by the line through p1 and p2 and extended in the direction w.
        /// https://reference.wolfram.com/language/ref/HalfPlane.html
        ///</summary>
        corewolf::engine *HalfPlane(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HalfPlane[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the half-plane bounded by the line through p along v and extended in the direction w.
        /// https://reference.wolfram.com/language/ref/HalfPlane.html
        ///</summary>
        corewolf::engine *HalfPlane(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HalfPlane[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the half-space of points  such that .
        /// https://reference.wolfram.com/language/ref/HalfSpace.html
        ///</summary>
        corewolf::engine *HalfSpace(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HalfSpace[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a three-dimensional graphics directive specifying that surfaces that follow are to be drawn with a base pattern of dots.
        /// https://reference.wolfram.com/language/ref/HalftoneShading.html
        ///</summary>
        corewolf::engine *HalftoneShading(const std::string &name = "")
        {
            return this->execute("HalftoneShading[]", name);
        }

        ///< summary>
        /// uses the density d of shading.
        /// https://reference.wolfram.com/language/ref/HalftoneShading.html
        ///</summary>
        corewolf::engine *HalftoneShading(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HalftoneShading[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses a fixed pattern of "shape" with the specified color col and density d.
        /// https://reference.wolfram.com/language/ref/HalftoneShading.html
        ///</summary>
        corewolf::engine *HalftoneShading(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HalftoneShading[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is Hamiltonian, and False otherwise.
        /// https://reference.wolfram.com/language/ref/HamiltonianGraphQ.html
        ///</summary>
        corewolf::engine *HamiltonianGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HamiltonianGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Hamming distance between strings, vectors or biomolecular sequences u and v.
        /// https://reference.wolfram.com/language/ref/HammingDistance.html
        ///</summary>
        corewolf::engine *HammingDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HammingDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Hamming window function of x.
        /// https://reference.wolfram.com/language/ref/HammingWindow.html
        ///</summary>
        corewolf::engine *HammingWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HammingWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Hankel function of the first kind .
        /// https://reference.wolfram.com/language/ref/HankelH1.html
        ///</summary>
        corewolf::engine *HankelH1(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HankelH1[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Hankel function of the second kind .
        /// https://reference.wolfram.com/language/ref/HankelH2.html
        ///</summary>
        corewolf::engine *HankelH2(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HankelH2[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the n×n Hankel matrix with first row and first column being successive integers.
        /// https://reference.wolfram.com/language/ref/HankelMatrix.html
        ///</summary>
        corewolf::engine *HankelMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HankelMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Hankel matrix whose first column consists of elements c1, c2, ….
        /// https://reference.wolfram.com/language/ref/HankelMatrix.html
        ///</summary>
        corewolf::engine *HankelMatrix(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("HankelMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Hankel matrix with elements ci down the first column, and ri across the last row.
        /// https://reference.wolfram.com/language/ref/HankelMatrix.html
        ///</summary>
        corewolf::engine *HankelMatrix(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("HankelMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Hankel transform of order 0 for expr.
        /// https://reference.wolfram.com/language/ref/HankelTransform.html
        ///</summary>
        corewolf::engine *HankelTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HankelTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Hankel transform of order ν for expr.
        /// https://reference.wolfram.com/language/ref/HankelTransform.html
        ///</summary>
        corewolf::engine *HankelTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("HankelTransform[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a Hann–Poisson window function of x.
        /// https://reference.wolfram.com/language/ref/HannPoissonWindow.html
        ///</summary>
        corewolf::engine *HannPoissonWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HannPoissonWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the parameter α.
        /// https://reference.wolfram.com/language/ref/HannPoissonWindow.html
        ///</summary>
        corewolf::engine *HannPoissonWindow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HannPoissonWindow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Hann window function of x.
        /// https://reference.wolfram.com/language/ref/HannWindow.html
        ///</summary>
        corewolf::engine *HannWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HannWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the parameter α.
        /// https://reference.wolfram.com/language/ref/HannWindow.html
        ///</summary>
        corewolf::engine *HannWindow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HannWindow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the sporadic simple Harada–Norton group .
        /// https://reference.wolfram.com/language/ref/HaradaNortonGroupHN.html
        ///</summary>
        corewolf::engine *HaradaNortonGroupHN(const std::string &name = "")
        {
            return this->execute("HaradaNortonGroupHN[]", name);
        }

        ///< summary>
        /// generates the minimal k-connected graph on n vertices .
        /// https://reference.wolfram.com/language/ref/HararyGraph.html
        ///</summary>
        corewolf::engine *HararyGraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HararyGraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a hard-core point process with constant intensity μ and hard-core radius rh in .
        /// https://reference.wolfram.com/language/ref/HardcorePointProcess.html
        ///</summary>
        corewolf::engine *HardcorePointProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HardcorePointProcess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the harmonic mean of the values in list.
        /// https://reference.wolfram.com/language/ref/HarmonicMean.html
        ///</summary>
        corewolf::engine *HarmonicMean(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HarmonicMean[" + arg0 + "]", name);
        }

        ///< summary>
        /// filters data by replacing every value by the harmonic mean value in its range-r neighborhood.
        /// https://reference.wolfram.com/language/ref/HarmonicMeanFilter.html
        ///</summary>
        corewolf::engine *HarmonicMeanFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HarmonicMeanFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses ri for filtering the dimension in data.
        /// https://reference.wolfram.com/language/ref/HarmonicMeanFilter.html
        ///</summary>
        corewolf::engine *HarmonicMeanFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("HarmonicMeanFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the n harmonic number .
        /// https://reference.wolfram.com/language/ref/HarmonicNumber.html
        ///</summary>
        corewolf::engine *HarmonicNumber(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HarmonicNumber[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the harmonic number  of order r.
        /// https://reference.wolfram.com/language/ref/HarmonicNumber.html
        ///</summary>
        corewolf::engine *HarmonicNumber(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HarmonicNumber[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an integer hash code for the expression expr.
        /// https://reference.wolfram.com/language/ref/Hash.html
        ///</summary>
        corewolf::engine *Hash(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Hash[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an integer hash digest of the specified type for expr.
        /// https://reference.wolfram.com/language/ref/Hash.html
        ///</summary>
        corewolf::engine *Hash(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Hash[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a hash code in the specified format.
        /// https://reference.wolfram.com/language/ref/Hash.html
        ///</summary>
        corewolf::engine *Hash(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Hash[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a two-dimensional graphics directive that specifies that faces of polygons and other filled graphics objects are to be drawn using closely spaced parallel lines.
        /// https://reference.wolfram.com/language/ref/HatchFilling.html
        ///</summary>
        corewolf::engine *HatchFilling(const std::string &name = "")
        {
            return this->execute("HatchFilling[]", name);
        }

        ///< summary>
        /// uses the specified line hatching "name".
        /// https://reference.wolfram.com/language/ref/HatchFilling.html
        ///</summary>
        corewolf::engine *HatchFilling(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HatchFilling[" + arg0 + "]", name);
        }

        ///< summary>
        /// draws parallel lines with absolute thickness r.
        /// https://reference.wolfram.com/language/ref/HatchFilling.html
        ///</summary>
        corewolf::engine *HatchFilling(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HatchFilling[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// draws parallel lines with gaps of absolute thickness d.
        /// https://reference.wolfram.com/language/ref/HatchFilling.html
        ///</summary>
        corewolf::engine *HatchFilling(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HatchFilling[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a three-dimensional graphics directive specifying that objects that follow are to be drawn with closely spaced parallel lines.
        /// https://reference.wolfram.com/language/ref/HatchShading.html
        ///</summary>
        corewolf::engine *HatchShading(const std::string &name = "")
        {
            return this->execute("HatchShading[]", name);
        }

        ///< summary>
        /// uses the density d of shading.
        /// https://reference.wolfram.com/language/ref/HatchShading.html
        ///</summary>
        corewolf::engine *HatchShading(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HatchShading[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses lines with the specified color col and density d.
        /// https://reference.wolfram.com/language/ref/HatchShading.html
        ///</summary>
        corewolf::engine *HatchShading(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HatchShading[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the haversine function .
        /// https://reference.wolfram.com/language/ref/Haversine.html
        ///</summary>
        corewolf::engine *Haversine(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Haversine[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the hazard function for the distribution dist evaluated at x.
        /// https://reference.wolfram.com/language/ref/HazardFunction.html
        ///</summary>
        corewolf::engine *HazardFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HazardFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the multivariate hazard function for the distribution dist evaluated at {x1,x2,…}.
        /// https://reference.wolfram.com/language/ref/HazardFunction.html
        ///</summary>
        corewolf::engine *HazardFunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("HazardFunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the hazard function as a pure function.
        /// https://reference.wolfram.com/language/ref/HazardFunction.html
        ///</summary>
        corewolf::engine *HazardFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HazardFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the head of expr.
        /// https://reference.wolfram.com/language/ref/Head.html
        ///</summary>
        corewolf::engine *Head(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Head[" + arg0 + "]", name);
        }

        ///< summary>
        /// wraps the result with h.
        /// https://reference.wolfram.com/language/ref/Head.html
        ///</summary>
        corewolf::engine *Head(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Head[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a thermal heat flux boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/HeatFluxValue.html
        ///</summary>
        corewolf::engine *HeatFluxValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HeatFluxValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a thermal heat flux boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/HeatFluxValue.html
        ///</summary>
        corewolf::engine *HeatFluxValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("HeatFluxValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a thermal insulation boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/HeatInsulationValue.html
        ///</summary>
        corewolf::engine *HeatInsulationValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HeatInsulationValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a thermal insulation boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/HeatInsulationValue.html
        ///</summary>
        corewolf::engine *HeatInsulationValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("HeatInsulationValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a thermal outflow boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/HeatOutflowValue.html
        ///</summary>
        corewolf::engine *HeatOutflowValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HeatOutflowValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a thermal outflow boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/HeatOutflowValue.html
        ///</summary>
        corewolf::engine *HeatOutflowValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("HeatOutflowValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a thermal radiation boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/HeatRadiationValue.html
        ///</summary>
        corewolf::engine *HeatRadiationValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HeatRadiationValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a thermal radiation boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/HeatRadiationValue.html
        ///</summary>
        corewolf::engine *HeatRadiationValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("HeatRadiationValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a thermal symmetry boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/HeatSymmetryValue.html
        ///</summary>
        corewolf::engine *HeatSymmetryValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HeatSymmetryValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a thermal symmetry boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/HeatSymmetryValue.html
        ///</summary>
        corewolf::engine *HeatSymmetryValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("HeatSymmetryValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a thermal surface boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/HeatTemperatureCondition.html
        ///</summary>
        corewolf::engine *HeatTemperatureCondition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HeatTemperatureCondition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a thermal surface boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/HeatTemperatureCondition.html
        ///</summary>
        corewolf::engine *HeatTemperatureCondition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("HeatTemperatureCondition[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// yields a heat transfer PDE term with variables vars and parameters pars.
        /// https://reference.wolfram.com/language/ref/HeatTransferPDEComponent.html
        ///</summary>
        corewolf::engine *HeatTransferPDEComponent(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HeatTransferPDEComponent[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a thermal transfer boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/HeatTransferValue.html
        ///</summary>
        corewolf::engine *HeatTransferValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HeatTransferValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a thermal transfer boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/HeatTransferValue.html
        ///</summary>
        corewolf::engine *HeatTransferValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("HeatTransferValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents the triangle distribution  which is nonzero for .
        /// https://reference.wolfram.com/language/ref/HeavisideLambda.html
        ///</summary>
        corewolf::engine *HeavisideLambda(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HeavisideLambda[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the multidimensional triangle distribution  which is nonzero for .
        /// https://reference.wolfram.com/language/ref/HeavisideLambda.html
        ///</summary>
        corewolf::engine *HeavisideLambda(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HeavisideLambda[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the box distribution , equal to 1 for  and 0 for .
        /// https://reference.wolfram.com/language/ref/HeavisidePi.html
        ///</summary>
        corewolf::engine *HeavisidePi(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HeavisidePi[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the multidimensional box distribution  which is 1 if all .
        /// https://reference.wolfram.com/language/ref/HeavisidePi.html
        ///</summary>
        corewolf::engine *HeavisidePi(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HeavisidePi[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the Heaviside theta function , equal to 0 for  and 1 for .
        /// https://reference.wolfram.com/language/ref/HeavisideTheta.html
        ///</summary>
        corewolf::engine *HeavisideTheta(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HeavisideTheta[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the multidimensional Heaviside theta function, which is 1 only if all of the xi are positive.
        /// https://reference.wolfram.com/language/ref/HeavisideTheta.html
        ///</summary>
        corewolf::engine *HeavisideTheta(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HeavisideTheta[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the sporadic simple Held group .
        /// https://reference.wolfram.com/language/ref/HeldGroupHe.html
        ///</summary>
        corewolf::engine *HeldGroupHe(const std::string &name = "")
        {
            return this->execute("HeldGroupHe[]", name);
        }

        ///< summary>
        /// yields a Helmholtz PDE term  with model variables vars and model parameters pars.
        /// https://reference.wolfram.com/language/ref/HelmholtzPDEComponent.html
        ///</summary>
        corewolf::engine *HelmholtzPDEComponent(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HelmholtzPDEComponent[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Hermite normal form decomposition of an integer matrix .
        /// https://reference.wolfram.com/language/ref/HermiteDecomposition.html
        ///</summary>
        corewolf::engine *HermiteDecomposition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HermiteDecomposition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Hermite polynomial .
        /// https://reference.wolfram.com/language/ref/HermiteH.html
        ///</summary>
        corewolf::engine *HermiteH(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HermiteH[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the symmetry of a Hermitian matrix.
        /// https://reference.wolfram.com/language/ref/Hermitian.html
        ///</summary>
        corewolf::engine *Hermitian(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Hermitian[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives True if m is explicitly Hermitian, and False otherwise.
        /// https://reference.wolfram.com/language/ref/HermitianMatrixQ.html
        ///</summary>
        corewolf::engine *HermitianMatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HermitianMatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Hessenberg decomposition of a numerical matrix m.
        /// https://reference.wolfram.com/language/ref/HessenbergDecomposition.html
        ///</summary>
        corewolf::engine *HessenbergDecomposition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HessenbergDecomposition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the bi-confluent Heun function.
        /// https://reference.wolfram.com/language/ref/HeunB.html
        ///</summary>
        corewolf::engine *HeunB(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("HeunB[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// gives the -derivative of the HeunB function.
        /// https://reference.wolfram.com/language/ref/HeunBPrime.html
        ///</summary>
        corewolf::engine *HeunBPrime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("HeunBPrime[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// gives the confluent Heun function.
        /// https://reference.wolfram.com/language/ref/HeunC.html
        ///</summary>
        corewolf::engine *HeunC(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("HeunC[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// gives the -derivative of the HeunC function.
        /// https://reference.wolfram.com/language/ref/HeunCPrime.html
        ///</summary>
        corewolf::engine *HeunCPrime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("HeunCPrime[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// gives the double-confluent Heun function.
        /// https://reference.wolfram.com/language/ref/HeunD.html
        ///</summary>
        corewolf::engine *HeunD(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("HeunD[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// gives the -derivative of the HeunD function.
        /// https://reference.wolfram.com/language/ref/HeunDPrime.html
        ///</summary>
        corewolf::engine *HeunDPrime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("HeunDPrime[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// gives the general Heun function.
        /// https://reference.wolfram.com/language/ref/HeunG.html
        ///</summary>
        corewolf::engine *HeunG(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &arg6, const std::string &name = "")
        {
            return this->execute("HeunG[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + ", " + arg6 + "]", name);
        }

        ///< summary>
        /// gives the -derivative of the HeunG function.
        /// https://reference.wolfram.com/language/ref/HeunGPrime.html
        ///</summary>
        corewolf::engine *HeunGPrime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &arg6, const std::string &name = "")
        {
            return this->execute("HeunGPrime[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + ", " + arg6 + "]", name);
        }

        ///< summary>
        /// gives the tri-confluent Heun function.
        /// https://reference.wolfram.com/language/ref/HeunT.html
        ///</summary>
        corewolf::engine *HeunT(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("HeunT[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// gives the -derivative of the HeunT function.
        /// https://reference.wolfram.com/language/ref/HeunTPrime.html
        ///</summary>
        corewolf::engine *HeunTPrime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("HeunTPrime[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// represents a filled hexahedron with corners p1, p2, …, p8.
        /// https://reference.wolfram.com/language/ref/Hexahedron.html
        ///</summary>
        corewolf::engine *Hexahedron(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Hexahedron[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a collection of hexahedra.
        /// https://reference.wolfram.com/language/ref/Hexahedron.html
        ///</summary>
        corewolf::engine *Hexahedron(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Hexahedron[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a discrete-time, finite-state hidden Markov process with transition matrix m, emission matrix em, and initial hidden state i0.
        /// https://reference.wolfram.com/language/ref/HiddenMarkovProcess.html
        ///</summary>
        corewolf::engine *HiddenMarkovProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HiddenMarkovProcess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a hidden Markov process with emission distributions disti.
        /// https://reference.wolfram.com/language/ref/HiddenMarkovProcess.html
        ///</summary>
        corewolf::engine *HiddenMarkovProcess(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("HiddenMarkovProcess[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// displays a highlighted version of expr.
        /// https://reference.wolfram.com/language/ref/Highlighted.html
        ///</summary>
        corewolf::engine *Highlighted(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Highlighted[" + arg0 + "]", name);
        }

        ///< summary>
        /// highlights the ai that can be vertices, edges, or subgraphs of g.
        /// https://reference.wolfram.com/language/ref/HighlightGraph.html
        ///</summary>
        corewolf::engine *HighlightGraph(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("HighlightGraph[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/HighlightGraph.html
        ///</summary>
        corewolf::engine *HighlightGraph(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HighlightGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// highlights the specified region of interest roi in image.
        /// https://reference.wolfram.com/language/ref/HighlightImage.html
        ///</summary>
        corewolf::engine *HighlightImage(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HighlightImage[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// highlights several regions of interest roii.
        /// https://reference.wolfram.com/language/ref/HighlightImage.html
        ///</summary>
        corewolf::engine *HighlightImage(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("HighlightImage[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// applies the styling bgstyle to the complement of all the regions of interest.
        /// https://reference.wolfram.com/language/ref/HighlightImage.html
        ///</summary>
        corewolf::engine *HighlightImage(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HighlightImage[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// highlights the cells specified by cellspeci in the mesh region mr.
        /// https://reference.wolfram.com/language/ref/HighlightMesh.html
        ///</summary>
        corewolf::engine *HighlightMesh(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("HighlightMesh[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// applies a highpass filter with a cutoff frequency ωc to an array of data.
        /// https://reference.wolfram.com/language/ref/HighpassFilter.html
        ///</summary>
        corewolf::engine *HighpassFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HighpassFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses a filter kernel of length n.
        /// https://reference.wolfram.com/language/ref/HighpassFilter.html
        ///</summary>
        corewolf::engine *HighpassFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HighpassFilter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies a smoothing window wfun to the filter kernel.
        /// https://reference.wolfram.com/language/ref/HighpassFilter.html
        ///</summary>
        corewolf::engine *HighpassFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("HighpassFilter[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents the sporadic simple Higman–Sims group .
        /// https://reference.wolfram.com/language/ref/HigmanSimsGroupHS.html
        ///</summary>
        corewolf::engine *HigmanSimsGroupHS(const std::string &name = "")
        {
            return this->execute("HigmanSimsGroupHS[]", name);
        }

        ///< summary>
        /// gives the line segments representing the n-step Hilbert curve.
        /// https://reference.wolfram.com/language/ref/HilbertCurve.html
        ///</summary>
        corewolf::engine *HilbertCurve(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HilbertCurve[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the n-step Hilbert curve in dimension d.
        /// https://reference.wolfram.com/language/ref/HilbertCurve.html
        ///</summary>
        corewolf::engine *HilbertCurve(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HilbertCurve[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies a Hilbert filter with a cutoff frequency ωc to an array of data.
        /// https://reference.wolfram.com/language/ref/HilbertFilter.html
        ///</summary>
        corewolf::engine *HilbertFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HilbertFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses a filter kernel of length n.
        /// https://reference.wolfram.com/language/ref/HilbertFilter.html
        ///</summary>
        corewolf::engine *HilbertFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HilbertFilter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies a smoothing window wfun to the filter kernel.
        /// https://reference.wolfram.com/language/ref/HilbertFilter.html
        ///</summary>
        corewolf::engine *HilbertFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("HilbertFilter[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the n×n Hilbert matrix with elements of the form .
        /// https://reference.wolfram.com/language/ref/HilbertMatrix.html
        ///</summary>
        corewolf::engine *HilbertMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HilbertMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the m×n Hilbert matrix.
        /// https://reference.wolfram.com/language/ref/HilbertMatrix.html
        ///</summary>
        corewolf::engine *HilbertMatrix(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("HilbertMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots a histogram of the values xi.
        /// https://reference.wolfram.com/language/ref/Histogram.html
        ///</summary>
        corewolf::engine *Histogram(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Histogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots a histogram with bin width specification bspec.
        /// https://reference.wolfram.com/language/ref/Histogram.html
        ///</summary>
        corewolf::engine *Histogram(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Histogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// plots a histogram with bin heights computed according to the specification hspec.
        /// https://reference.wolfram.com/language/ref/Histogram.html
        ///</summary>
        corewolf::engine *Histogram(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Histogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// plots a 3D histogram of the values {xi,yi}.
        /// https://reference.wolfram.com/language/ref/Histogram3D.html
        ///</summary>
        corewolf::engine *Histogram3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Histogram3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots a 3D histogram with bins specified by bspec.
        /// https://reference.wolfram.com/language/ref/Histogram3D.html
        ///</summary>
        corewolf::engine *Histogram3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Histogram3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// plots a 3D histogram with bin heights computed according to the specification hspec.
        /// https://reference.wolfram.com/language/ref/Histogram3D.html
        ///</summary>
        corewolf::engine *Histogram3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Histogram3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// plots 3D histograms for multiple datasets datai.
        /// https://reference.wolfram.com/language/ref/Histogram3D.html
        ///</summary>
        corewolf::engine *Histogram3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Histogram3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the probability distribution corresponding to a histogram of the data values xi.
        /// https://reference.wolfram.com/language/ref/HistogramDistribution.html
        ///</summary>
        corewolf::engine *HistogramDistribution(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("HistogramDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a multivariate histogram distribution based on data values {xi,yi,…}.
        /// https://reference.wolfram.com/language/ref/HistogramDistribution.html
        ///</summary>
        corewolf::engine *HistogramDistribution(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("HistogramDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a histogram distribution with bins specified by bspec.
        /// https://reference.wolfram.com/language/ref/HistogramDistribution.html
        ///</summary>
        corewolf::engine *HistogramDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HistogramDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of bins and histogram heights of the values xi.
        /// https://reference.wolfram.com/language/ref/HistogramList.html
        ///</summary>
        corewolf::engine *HistogramList(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("HistogramList[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of bins and histogram heights of the values {xi,yi,…}.
        /// https://reference.wolfram.com/language/ref/HistogramList.html
        ///</summary>
        corewolf::engine *HistogramList(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("HistogramList[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of bins and histogram heights with bins specified by bspec.
        /// https://reference.wolfram.com/language/ref/HistogramList.html
        ///</summary>
        corewolf::engine *HistogramList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HistogramList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of bins and histogram heights with bin heights computed according to the specification hspec.
        /// https://reference.wolfram.com/language/ref/HistogramList.html
        ///</summary>
        corewolf::engine *HistogramList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HistogramList[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// estimates the histogram point density function  for point data pdata.
        /// https://reference.wolfram.com/language/ref/HistogramPointDensity.html
        ///</summary>
        corewolf::engine *HistogramPointDensity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HistogramPointDensity[" + arg0 + "]", name);
        }

        ///< summary>
        /// estimates the histogram point density function  with histogram bins specified by bspec.
        /// https://reference.wolfram.com/language/ref/HistogramPointDensity.html
        ///</summary>
        corewolf::engine *HistogramPointDensity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HistogramPointDensity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// estimates the histogram point density function  for binned data bdata.
        /// https://reference.wolfram.com/language/ref/HistogramPointDensity.html
        ///</summary>
        corewolf::engine *HistogramPointDensity(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HistogramPointDensity[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// transforms pixel values of image so that its histogram is nearly flat.
        /// https://reference.wolfram.com/language/ref/HistogramTransform.html
        ///</summary>
        corewolf::engine *HistogramTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HistogramTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// modifies pixel values of image so that its histogram would have nearly the same distribution as ref.
        /// https://reference.wolfram.com/language/ref/HistogramTransform.html
        ///</summary>
        corewolf::engine *HistogramTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HistogramTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses n equally spaced quantiles.
        /// https://reference.wolfram.com/language/ref/HistogramTransform.html
        ///</summary>
        corewolf::engine *HistogramTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HistogramTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// transforms values xi.
        /// https://reference.wolfram.com/language/ref/HistogramTransform.html
        ///</summary>
        corewolf::engine *HistogramTransform(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HistogramTransform[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a function  so that the transformed values  are distributed nearly uniformly.
        /// https://reference.wolfram.com/language/ref/HistogramTransformInterpolation.html
        ///</summary>
        corewolf::engine *HistogramTransformInterpolation(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("HistogramTransformInterpolation[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// finds  so that  are distributed with distribution ref.
        /// https://reference.wolfram.com/language/ref/HistogramTransformInterpolation.html
        ///</summary>
        corewolf::engine *HistogramTransformInterpolation(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HistogramTransformInterpolation[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a function with n equally spaced quantiles.
        /// https://reference.wolfram.com/language/ref/HistogramTransformInterpolation.html
        ///</summary>
        corewolf::engine *HistogramTransformInterpolation(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HistogramTransformInterpolation[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds a function that reshapes the histogram of image.
        /// https://reference.wolfram.com/language/ref/HistogramTransformInterpolation.html
        ///</summary>
        corewolf::engine *HistogramTransformInterpolation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HistogramTransformInterpolation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the historical period entity.
        /// https://reference.wolfram.com/language/ref/HistoricalPeriodData.html
        ///</summary>
        corewolf::engine *HistoricalPeriodData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HistoricalPeriodData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified historical period entities.
        /// https://reference.wolfram.com/language/ref/HistoricalPeriodData.html
        ///</summary>
        corewolf::engine *HistoricalPeriodData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HistoricalPeriodData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/HistoricalPeriodData.html
        ///</summary>
        corewolf::engine *HistoricalPeriodData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HistoricalPeriodData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the hit-or-miss transform of image with respect to the composite structuring element ker.
        /// https://reference.wolfram.com/language/ref/HitMissTransform.html
        ///</summary>
        corewolf::engine *HitMissTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HitMissTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the union of the hit-or-miss transforms for all the structuring elements keri.
        /// https://reference.wolfram.com/language/ref/HitMissTransform.html
        ///</summary>
        corewolf::engine *HitMissTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("HitMissTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// treats values above t as foreground.
        /// https://reference.wolfram.com/language/ref/HitMissTransform.html
        ///</summary>
        corewolf::engine *HitMissTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HitMissTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of authority and hub centralities for the vertices in the graph g.
        /// https://reference.wolfram.com/language/ref/HITSCentrality.html
        ///</summary>
        corewolf::engine *HITSCentrality(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HITSCentrality[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/HITSCentrality.html
        ///</summary>
        corewolf::engine *HITSCentrality(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("HITSCentrality[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the Hjorth distribution with location parameter m, scale parameter s, and shape parameter f.
        /// https://reference.wolfram.com/language/ref/HjorthDistribution.html
        ///</summary>
        corewolf::engine *HjorthDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HjorthDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Hodge dual of the tensor
        /// https://reference.wolfram.com/language/ref/HodgeDual.html
        ///</summary>
        corewolf::engine *HodgeDual(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HodgeDual[" + arg0 + "]", name);
        }

        ///< summary>
        /// dualizes tensor in the slots with dimension dim
        /// https://reference.wolfram.com/language/ref/HodgeDual.html
        ///</summary>
        corewolf::engine *HodgeDual(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HodgeDual[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// dualizes tensor in the given slots.
        /// https://reference.wolfram.com/language/ref/HodgeDual.html
        ///</summary>
        corewolf::engine *HodgeDual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HodgeDual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives Hoeffding's dependence measure  for the vectors v1 and v2.
        /// https://reference.wolfram.com/language/ref/HoeffdingD.html
        ///</summary>
        corewolf::engine *HoeffdingD(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HoeffdingD[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives Hoeffding's dependence measure  for the matrix m.
        /// https://reference.wolfram.com/language/ref/HoeffdingD.html
        ///</summary>
        corewolf::engine *HoeffdingD(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HoeffdingD[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the  element of  for the multivariate symbolic distribution dist.
        /// https://reference.wolfram.com/language/ref/HoeffdingD.html
        ///</summary>
        corewolf::engine *HoeffdingD(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HoeffdingD[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether the vectors v1 and v2 are independent.
        /// https://reference.wolfram.com/language/ref/HoeffdingDTest.html
        ///</summary>
        corewolf::engine *HoeffdingDTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HoeffdingDTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// maintains expr in an unevaluated form.
        /// https://reference.wolfram.com/language/ref/Hold.html
        ///</summary>
        corewolf::engine *Hold(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Hold[" + arg0 + "]", name);
        }

        ///< summary>
        /// shields expr completely from the standard Wolfram Language evaluation process, preventing even upvalues associated with expr from being used.
        /// https://reference.wolfram.com/language/ref/HoldComplete.html
        ///</summary>
        corewolf::engine *HoldComplete(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HoldComplete[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints as the expression expr, with expr maintained in an unevaluated form.
        /// https://reference.wolfram.com/language/ref/HoldForm.html
        ///</summary>
        corewolf::engine *HoldForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HoldForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// is equivalent to expr for pattern matching, but maintains expr in an unevaluated form.
        /// https://reference.wolfram.com/language/ref/HoldPattern.html
        ///</summary>
        corewolf::engine *HoldPattern(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HoldPattern[" + arg0 + "]", name);
        }

        ///< summary>
        /// draws a linear gauge showing value in a range of 0 to 1.
        /// https://reference.wolfram.com/language/ref/HorizontalGauge.html
        ///</summary>
        corewolf::engine *HorizontalGauge(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HorizontalGauge[" + arg0 + "]", name);
        }

        ///< summary>
        /// draws a linear gauge showing value in a range of min to max.
        /// https://reference.wolfram.com/language/ref/HorizontalGauge.html
        ///</summary>
        corewolf::engine *HorizontalGauge(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("HorizontalGauge[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// allows value to be set interactively using the gauge.
        /// https://reference.wolfram.com/language/ref/HorizontalGauge.html
        ///</summary>
        corewolf::engine *HorizontalGauge(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HorizontalGauge[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// draws a gauge showing multiple values.
        /// https://reference.wolfram.com/language/ref/HorizontalGauge.html
        ///</summary>
        corewolf::engine *HorizontalGauge(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HorizontalGauge[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// puts the polynomial poly in Horner form.
        /// https://reference.wolfram.com/language/ref/HornerForm.html
        ///</summary>
        corewolf::engine *HornerForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HornerForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// puts poly in Horner form with respect to the variable or variable list vars.
        /// https://reference.wolfram.com/language/ref/HornerForm.html
        ///</summary>
        corewolf::engine *HornerForm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HornerForm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// puts poly1/poly2 in Horner form using the variables or variable lists vars1 and vars2 for poly1 and poly2, respectively.
        /// https://reference.wolfram.com/language/ref/HornerForm.html
        ///</summary>
        corewolf::engine *HornerForm(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HornerForm[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the IP address for the host with the specified name.
        /// https://reference.wolfram.com/language/ref/HostLookup.html
        ///</summary>
        corewolf::engine *HostLookup(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HostLookup[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a specified property of the host.
        /// https://reference.wolfram.com/language/ref/HostLookup.html
        ///</summary>
        corewolf::engine *HostLookup(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HostLookup[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents Hotelling's  distribution with dimensionality parameter p and m degrees of freedom.
        /// https://reference.wolfram.com/language/ref/HotellingTSquareDistribution.html
        ///</summary>
        corewolf::engine *HotellingTSquareDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HotellingTSquareDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Hoyt distribution with shape parameter q and spread parameter ω.
        /// https://reference.wolfram.com/language/ref/HoytDistribution.html
        ///</summary>
        corewolf::engine *HoytDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HoytDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is an const std::string &that represents an error response to an HTTP request, with specified error code.
        /// https://reference.wolfram.com/language/ref/HTTPErrorResponse.html
        ///</summary>
        corewolf::engine *HTTPErrorResponse(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HTTPErrorResponse[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an HTTP redirect to the specified uri.
        /// https://reference.wolfram.com/language/ref/HTTPRedirect.html
        ///</summary>
        corewolf::engine *HTTPRedirect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HTTPRedirect[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an HTTP redirect to uri with the specified metadata.
        /// https://reference.wolfram.com/language/ref/HTTPRedirect.html
        ///</summary>
        corewolf::engine *HTTPRedirect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HTTPRedirect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an HTTP request for the specified URL.
        /// https://reference.wolfram.com/language/ref/HTTPRequest.html
        ///</summary>
        corewolf::engine *HTTPRequest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HTTPRequest[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an HTTP request for the specified URL with additional elements such as headers given by assoc.
        /// https://reference.wolfram.com/language/ref/HTTPRequest.html
        ///</summary>
        corewolf::engine *HTTPRequest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HTTPRequest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property of the current HTTP request.
        /// https://reference.wolfram.com/language/ref/HTTPRequestData.html
        ///</summary>
        corewolf::engine *HTTPRequestData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HTTPRequestData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an association with values of properties of the current HTTP request.
        /// https://reference.wolfram.com/language/ref/HTTPRequestData.html
        ///</summary>
        corewolf::engine *HTTPRequestData(const std::string &name = "")
        {
            return this->execute("HTTPRequestData[]", name);
        }

        ///< summary>
        /// is an const std::string &that represents a successful response to an HTTP request, with the specified body and default metadata.
        /// https://reference.wolfram.com/language/ref/HTTPResponse.html
        ///</summary>
        corewolf::engine *HTTPResponse(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HTTPResponse[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a response to an HTTP request, including the specified body and metadata.
        /// https://reference.wolfram.com/language/ref/HTTPResponse.html
        ///</summary>
        corewolf::engine *HTTPResponse(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HTTPResponse[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a color in the HSB color space with hue h.
        /// https://reference.wolfram.com/language/ref/Hue.html
        ///</summary>
        corewolf::engine *Hue(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Hue[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies colors in terms of hue, saturation and brightness.
        /// https://reference.wolfram.com/language/ref/Hue.html
        ///</summary>
        corewolf::engine *Hue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Hue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// specifies opacity a.
        /// https://reference.wolfram.com/language/ref/Hue.html
        ///</summary>
        corewolf::engine *Hue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Hue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// returns the range of values within one standard deviation of the mean for all properties of human growth at the specification spec.
        /// https://reference.wolfram.com/language/ref/HumanGrowthData.html
        ///</summary>
        corewolf::engine *HumanGrowthData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HumanGrowthData[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the range of values within one standard deviation of the mean of a property for the specification spec.
        /// https://reference.wolfram.com/language/ref/HumanGrowthData.html
        ///</summary>
        corewolf::engine *HumanGrowthData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HumanGrowthData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value at a specific index of a property for spec at the specified percentile.
        /// https://reference.wolfram.com/language/ref/HumanGrowthData.html
        ///</summary>
        corewolf::engine *HumanGrowthData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HumanGrowthData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/HumpDownHump.html
        ///</summary>
        corewolf::engine *HumpDownHump(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HumpDownHump[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x≏y≏….
        /// https://reference.wolfram.com/language/ref/HumpEqual.html
        ///</summary>
        corewolf::engine *HumpEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HumpEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Hurwitz–Lerch transcendent .
        /// https://reference.wolfram.com/language/ref/HurwitzLerchPhi.html
        ///</summary>
        corewolf::engine *HurwitzLerchPhi(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HurwitzLerchPhi[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Hurwitz zeta function .
        /// https://reference.wolfram.com/language/ref/HurwitzZeta.html
        ///</summary>
        corewolf::engine *HurwitzZeta(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("HurwitzZeta[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a hyperbolic distribution with location parameter μ, scale parameter δ, shape parameter α, and skewness parameter β.
        /// https://reference.wolfram.com/language/ref/HyperbolicDistribution.html
        ///</summary>
        corewolf::engine *HyperbolicDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("HyperbolicDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a generalized hyperbolic distribution with shape parameter λ.
        /// https://reference.wolfram.com/language/ref/HyperbolicDistribution.html
        ///</summary>
        corewolf::engine *HyperbolicDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("HyperbolicDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// gives the n-dimensional hypercube graph .
        /// https://reference.wolfram.com/language/ref/HypercubeGraph.html
        ///</summary>
        corewolf::engine *HypercubeGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HypercubeGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an m-phase hyperexponential distribution with phase probabilities αi and rates λi.
        /// https://reference.wolfram.com/language/ref/HyperexponentialDistribution.html
        ///</summary>
        corewolf::engine *HyperexponentialDistribution(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("HyperexponentialDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the hyperfactorial function .
        /// https://reference.wolfram.com/language/ref/Hyperfactorial.html
        ///</summary>
        corewolf::engine *Hyperfactorial(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Hyperfactorial[" + arg0 + "]", name);
        }

        ///< summary>
        /// is the confluent hypergeometric function .
        /// https://reference.wolfram.com/language/ref/Hypergeometric0F1.html
        ///</summary>
        corewolf::engine *Hypergeometric0F1(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Hypergeometric0F1[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is the regularized confluent hypergeometric function .
        /// https://reference.wolfram.com/language/ref/Hypergeometric0F1Regularized.html
        ///</summary>
        corewolf::engine *Hypergeometric0F1Regularized(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Hypergeometric0F1Regularized[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is the Kummer confluent hypergeometric function .
        /// https://reference.wolfram.com/language/ref/Hypergeometric1F1.html
        ///</summary>
        corewolf::engine *Hypergeometric1F1(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Hypergeometric1F1[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is the regularized confluent hypergeometric function .
        /// https://reference.wolfram.com/language/ref/Hypergeometric1F1Regularized.html
        ///</summary>
        corewolf::engine *Hypergeometric1F1Regularized(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Hypergeometric1F1Regularized[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is the hypergeometric function .
        /// https://reference.wolfram.com/language/ref/Hypergeometric2F1.html
        ///</summary>
        corewolf::engine *Hypergeometric2F1(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Hypergeometric2F1[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// is the regularized hypergeometric function .
        /// https://reference.wolfram.com/language/ref/Hypergeometric2F1Regularized.html
        ///</summary>
        corewolf::engine *Hypergeometric2F1Regularized(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Hypergeometric2F1Regularized[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a hypergeometric distribution.
        /// https://reference.wolfram.com/language/ref/HypergeometricDistribution.html
        ///</summary>
        corewolf::engine *HypergeometricDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HypergeometricDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is the generalized hypergeometric function .
        /// https://reference.wolfram.com/language/ref/HypergeometricPFQ.html
        ///</summary>
        corewolf::engine *HypergeometricPFQ(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HypergeometricPFQ[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is the regularized generalized hypergeometric function .
        /// https://reference.wolfram.com/language/ref/HypergeometricPFQRegularized.html
        ///</summary>
        corewolf::engine *HypergeometricPFQRegularized(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HypergeometricPFQRegularized[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is the confluent hypergeometric function .
        /// https://reference.wolfram.com/language/ref/HypergeometricU.html
        ///</summary>
        corewolf::engine *HypergeometricU(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("HypergeometricU[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a hyperlink that jumps to the specified URI when clicked.
        /// https://reference.wolfram.com/language/ref/Hyperlink.html
        ///</summary>
        corewolf::engine *Hyperlink(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Hyperlink[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a hyperlink to be displayed as label.
        /// https://reference.wolfram.com/language/ref/Hyperlink.html
        ///</summary>
        corewolf::engine *Hyperlink(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Hyperlink[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the hyperplane with normal n passing through the point p.
        /// https://reference.wolfram.com/language/ref/Hyperplane.html
        ///</summary>
        corewolf::engine *Hyperplane(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Hyperplane[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an m-phase hypoexponential distribution with rates λ1, …, λm.
        /// https://reference.wolfram.com/language/ref/HypoexponentialDistribution.html
        ///</summary>
        corewolf::engine *HypoexponentialDistribution(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("HypoexponentialDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents hypothesis test data such as generated by DistributionFitTest, AndersonDarlingTest, etc.
        /// https://reference.wolfram.com/language/ref/HypothesisTestData.html
        ///</summary>
        corewolf::engine *HypothesisTestData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("HypothesisTestData[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates an icon of the specified type assuming the value given.
        /// https://reference.wolfram.com/language/ref/IconData.html
        ///</summary>
        corewolf::engine *IconData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IconData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an iconized form that can be used to stand in for expr in notebook input.
        /// https://reference.wolfram.com/language/ref/Iconize.html
        ///</summary>
        corewolf::engine *Iconize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Iconize[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays with the specified name in the icon.
        /// https://reference.wolfram.com/language/ref/Iconize.html
        ///</summary>
        corewolf::engine *Iconize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Iconize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a regular icosahedron centered at the origin with unit edge length.
        /// https://reference.wolfram.com/language/ref/Icosahedron.html
        ///</summary>
        corewolf::engine *Icosahedron(const std::string &name = "")
        {
            return this->execute("Icosahedron[]", name);
        }

        ///< summary>
        /// represents an icosahedron with edge length l.
        /// https://reference.wolfram.com/language/ref/Icosahedron.html
        ///</summary>
        corewolf::engine *Icosahedron(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Icosahedron[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an icosahedron rotated by an angle θ with respect to the z axis and angle ϕ with respect to the y axis.
        /// https://reference.wolfram.com/language/ref/Icosahedron.html
        ///</summary>
        corewolf::engine *Icosahedron(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Icosahedron[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives expr (the identity operation).
        /// https://reference.wolfram.com/language/ref/Identity.html
        ///</summary>
        corewolf::engine *Identity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Identity[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the nn identity matrix.
        /// https://reference.wolfram.com/language/ref/IdentityMatrix.html
        ///</summary>
        corewolf::engine *IdentityMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IdentityMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives t if condition evaluates to True, and f if it evaluates to False.
        /// https://reference.wolfram.com/language/ref/If.html
        ///</summary>
        corewolf::engine *If(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("If[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives u if condition evaluates to neither True nor False.
        /// https://reference.wolfram.com/language/ref/If.html
        ///</summary>
        corewolf::engine *If(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("If[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// is a pattern const std::string &that, for purposes of pattern matching, ignores occurrences of Inactive in both patt and the expression being matched.
        /// https://reference.wolfram.com/language/ref/IgnoringInactive.html
        ///</summary>
        corewolf::engine *IgnoringInactive(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IgnoringInactive[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the imaginary part of the complex number .
        /// https://reference.wolfram.com/language/ref/Im.html
        ///</summary>
        corewolf::engine *Im(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Im[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a raster image with pixel values given by the array data.
        /// https://reference.wolfram.com/language/ref/Image.html
        ///</summary>
        corewolf::engine *Image(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Image[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an image that uses the specified options.
        /// https://reference.wolfram.com/language/ref/Image.html
        ///</summary>
        corewolf::engine *Image(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Image[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a 3D image with pixel values given by the array data.
        /// https://reference.wolfram.com/language/ref/Image3D.html
        ///</summary>
        corewolf::engine *Image3D(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Image3D[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a 3D image from a list of 2D images.
        /// https://reference.wolfram.com/language/ref/Image3D.html
        ///</summary>
        corewolf::engine *Image3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Image3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// creates a 3D image of the specified data type.
        /// https://reference.wolfram.com/language/ref/Image3D.html
        ///</summary>
        corewolf::engine *Image3D(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Image3D[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// takes a 3D image and returns a 2D image of maximum projection onto the - plane.
        /// https://reference.wolfram.com/language/ref/Image3DProjection.html
        ///</summary>
        corewolf::engine *Image3DProjection(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Image3DProjection[" + arg0 + "]", name);
        }

        ///< summary>
        /// performs a projection in the direction specified by dir.
        /// https://reference.wolfram.com/language/ref/Image3DProjection.html
        ///</summary>
        corewolf::engine *Image3DProjection(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Image3DProjection[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies the projection mode.
        /// https://reference.wolfram.com/language/ref/Image3DProjection.html
        ///</summary>
        corewolf::engine *Image3DProjection(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Image3DProjection[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of 2D images corresponding to the slices in the Image3D const std::string &image.
        /// https://reference.wolfram.com/language/ref/Image3DSlices.html
        ///</summary>
        corewolf::engine *Image3DSlices(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Image3DSlices[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the n slice as a 2D image.
        /// https://reference.wolfram.com/language/ref/Image3DSlices.html
        ///</summary>
        corewolf::engine *Image3DSlices(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Image3DSlices[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// extracts the specified slices si.
        /// https://reference.wolfram.com/language/ref/Image3DSlices.html
        ///</summary>
        corewolf::engine *Image3DSlices(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Image3DSlices[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// takes slices in dimension d.
        /// https://reference.wolfram.com/language/ref/Image3DSlices.html
        ///</summary>
        corewolf::engine *Image3DSlices(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Image3DSlices[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives an image in which each pixel represents a sum of all pixels below and to the left of that pixel in image.
        /// https://reference.wolfram.com/language/ref/ImageAccumulate.html
        ///</summary>
        corewolf::engine *ImageAccumulate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageAccumulate[" + arg0 + "]", name);
        }

        ///< summary>
        /// adds an amount x to each channel value in image.
        /// https://reference.wolfram.com/language/ref/ImageAdd.html
        ///</summary>
        corewolf::engine *ImageAdd(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageAdd[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// adds all expri to image, where each expri can be either an image, a number, or a color value.
        /// https://reference.wolfram.com/language/ref/ImageAdd.html
        ///</summary>
        corewolf::engine *ImageAdd(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ImageAdd[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// adjusts the levels in image, rescaling them to cover the range 0 to 1.
        /// https://reference.wolfram.com/language/ref/ImageAdjust.html
        ///</summary>
        corewolf::engine *ImageAdjust(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageAdjust[" + arg0 + "]", name);
        }

        ///< summary>
        /// adjusts the image according to the correction specification corr.
        /// https://reference.wolfram.com/language/ref/ImageAdjust.html
        ///</summary>
        corewolf::engine *ImageAdjust(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageAdjust[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// first rescales so that the range of input values inmin to inmax is mapped to 0 to 1.
        /// https://reference.wolfram.com/language/ref/ImageAdjust.html
        ///</summary>
        corewolf::engine *ImageAdjust(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ImageAdjust[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// rescales so that the range of input values inmin to inmax is mapped to outmin to outmax.
        /// https://reference.wolfram.com/language/ref/ImageAdjust.html
        ///</summary>
        corewolf::engine *ImageAdjust(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("ImageAdjust[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// returns a version of image that is aligned with the reference image ref.
        /// https://reference.wolfram.com/language/ref/ImageAlign.html
        ///</summary>
        corewolf::engine *ImageAlign(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageAlign[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the result of aligning each of the imagei with the reference image ref.
        /// https://reference.wolfram.com/language/ref/ImageAlign.html
        ///</summary>
        corewolf::engine *ImageAlign(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImageAlign[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses image1 as the reference image.
        /// https://reference.wolfram.com/language/ref/ImageAlign.html
        ///</summary>
        corewolf::engine *ImageAlign(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ImageAlign[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// applies the function f to the list of channel values for each pixel in image.
        /// https://reference.wolfram.com/language/ref/ImageApply.html
        ///</summary>
        corewolf::engine *ImageApply(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageApply[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f to the sequence of corresponding pixel values taken from each imagei.
        /// https://reference.wolfram.com/language/ref/ImageApply.html
        ///</summary>
        corewolf::engine *ImageApply(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImageApply[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// applies the function f to the list of channel values for each pixel in image, giving the row and column index of each pixel as a second argument to f.
        /// https://reference.wolfram.com/language/ref/ImageApplyIndexed.html
        ///</summary>
        corewolf::engine *ImageApplyIndexed(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageApplyIndexed[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f to the sequence of corresponding pixel values taken from each imagei, giving the corresponding row and column index of pixels as the last argument to f.
        /// https://reference.wolfram.com/language/ref/ImageApplyIndexed.html
        ///</summary>
        corewolf::engine *ImageApplyIndexed(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImageApplyIndexed[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the ratio of height to width for image.
        /// https://reference.wolfram.com/language/ref/ImageAspectRatio.html
        ///</summary>
        corewolf::engine *ImageAspectRatio(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageAspectRatio[" + arg0 + "]", name);
        }

        ///< summary>
        /// assembles a single image from an array of images.
        /// https://reference.wolfram.com/language/ref/ImageAssemble.html
        ///</summary>
        corewolf::engine *ImageAssemble(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ImageAssemble[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// assembles images using the fitting method.
        /// https://reference.wolfram.com/language/ref/ImageAssemble.html
        ///</summary>
        corewolf::engine *ImageAssemble(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ImageAssemble[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a net layer that applies random image transformations to produce images of height h and width w.
        /// https://reference.wolfram.com/language/ref/ImageAugmentationLayer.html
        ///</summary>
        corewolf::engine *ImageAugmentationLayer(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ImageAugmentationLayer[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives an association of lists of bounding boxes for each identified category of objects in image.
        /// https://reference.wolfram.com/language/ref/ImageBoundingBoxes.html
        ///</summary>
        corewolf::engine *ImageBoundingBoxes(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageBoundingBoxes[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of bounding boxes for subimages identified as an instance of the specified category.
        /// https://reference.wolfram.com/language/ref/ImageBoundingBoxes.html
        ///</summary>
        corewolf::engine *ImageBoundingBoxes(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageBoundingBoxes[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// opens a graphical user interface for capturing images from connected cameras.
        /// https://reference.wolfram.com/language/ref/ImageCapture.html
        ///</summary>
        corewolf::engine *ImageCapture(const std::string &name = "")
        {
            return this->execute("ImageCapture[]", name);
        }

        ///< summary>
        /// gives an association of lists of subimages for each identified category of objects in image.
        /// https://reference.wolfram.com/language/ref/ImageCases.html
        ///</summary>
        corewolf::engine *ImageCases(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageCases[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of subimages identified as an instance of the specified category.
        /// https://reference.wolfram.com/language/ref/ImageCases.html
        ///</summary>
        corewolf::engine *ImageCases(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageCases[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an association with lists of subimages identified as being instances of each of the categoryi.
        /// https://reference.wolfram.com/language/ref/ImageCases.html
        ///</summary>
        corewolf::engine *ImageCases(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImageCases[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the number of channels present in the data for the Image or Image3D const std::string &image.
        /// https://reference.wolfram.com/language/ref/ImageChannels.html
        ///</summary>
        corewolf::engine *ImageChannels(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageChannels[" + arg0 + "]", name);
        }

        ///< summary>
        /// clips all channel values in image to lie in the default range.
        /// https://reference.wolfram.com/language/ref/ImageClip.html
        ///</summary>
        corewolf::engine *ImageClip(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageClip[" + arg0 + "]", name);
        }

        ///< summary>
        /// clips channel values to lie in the range from min to max.
        /// https://reference.wolfram.com/language/ref/ImageClip.html
        ///</summary>
        corewolf::engine *ImageClip(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImageClip[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives vmin for values below min and vmax for values above max.
        /// https://reference.wolfram.com/language/ref/ImageClip.html
        ///</summary>
        corewolf::engine *ImageClip(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ImageClip[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// creates a collage of images imagei.
        /// https://reference.wolfram.com/language/ref/ImageCollage.html
        ///</summary>
        corewolf::engine *ImageCollage(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ImageCollage[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// also creates a collage of images imagei based on their corresponding weights wi.
        /// https://reference.wolfram.com/language/ref/ImageCollage.html
        ///</summary>
        corewolf::engine *ImageCollage(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageCollage[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// also creates a collage of images imagei based on their corresponding weights wi.
        /// https://reference.wolfram.com/language/ref/ImageCollage.html
        ///</summary>
        corewolf::engine *ImageCollage(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImageCollage[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses the fitting method to create the collage.
        /// https://reference.wolfram.com/language/ref/ImageCollage.html
        ///</summary>
        corewolf::engine *ImageCollage(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageCollage[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the name of the color space of image.
        /// https://reference.wolfram.com/language/ref/ImageColorSpace.html
        ///</summary>
        corewolf::engine *ImageColorSpace(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageColorSpace[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the result of overlaying overlay onto image.
        /// https://reference.wolfram.com/language/ref/ImageCompose.html
        ///</summary>
        corewolf::engine *ImageCompose(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageCompose[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the result of alpha blending overlay into image using blending fraction α.
        /// https://reference.wolfram.com/language/ref/ImageCompose.html
        ///</summary>
        corewolf::engine *ImageCompose(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImageCompose[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// places the center of overlay at position pos in image.
        /// https://reference.wolfram.com/language/ref/ImageCompose.html
        ///</summary>
        corewolf::engine *ImageCompose(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageCompose[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// places the point opos in overlay at position pos in image.
        /// https://reference.wolfram.com/language/ref/ImageCompose.html
        ///</summary>
        corewolf::engine *ImageCompose(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ImageCompose[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// uses the compositing fractions fk and the specified compositing mode.
        /// https://reference.wolfram.com/language/ref/ImageCompose.html
        ///</summary>
        corewolf::engine *ImageCompose(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::vector<std::string> &arg4, const std::string &name = "")
        {
            return this->execute("ImageCompose[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + "]", name);
        }

        ///< summary>
        /// returns True if an instance of the specified category is detected in image.
        /// https://reference.wolfram.com/language/ref/ImageContainsQ.html
        ///</summary>
        corewolf::engine *ImageContainsQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageContainsQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns True if at least one instance of each of the categoryi is detected in image.
        /// https://reference.wolfram.com/language/ref/ImageContainsQ.html
        ///</summary>
        corewolf::engine *ImageContainsQ(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImageContainsQ[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a dataset of identified entities in image.
        /// https://reference.wolfram.com/language/ref/ImageContents.html
        ///</summary>
        corewolf::engine *ImageContents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageContents[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a dataset that only contains entities in the specified category.
        /// https://reference.wolfram.com/language/ref/ImageContents.html
        ///</summary>
        corewolf::engine *ImageContents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageContents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// includes the properties prop for each identified object.
        /// https://reference.wolfram.com/language/ref/ImageContents.html
        ///</summary>
        corewolf::engine *ImageContents(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageContents[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the convolution of image with kernel ker.
        /// https://reference.wolfram.com/language/ref/ImageConvolve.html
        ///</summary>
        corewolf::engine *ImageConvolve(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageConvolve[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the n×n co-occurrence matrix for image.
        /// https://reference.wolfram.com/language/ref/ImageCooccurrence.html
        ///</summary>
        corewolf::engine *ImageCooccurrence(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageCooccurrence[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes a co-occurrence matrix for arbitrary spatial relationships specified by a kernel ker.
        /// https://reference.wolfram.com/language/ref/ImageCooccurrence.html
        ///</summary>
        corewolf::engine *ImageCooccurrence(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageCooccurrence[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds corners in image and returns their coordinates.
        /// https://reference.wolfram.com/language/ref/ImageCorners.html
        ///</summary>
        corewolf::engine *ImageCorners(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageCorners[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds corners at a pixel range r.
        /// https://reference.wolfram.com/language/ref/ImageCorners.html
        ///</summary>
        corewolf::engine *ImageCorners(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageCorners[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses a threshold t for selecting corners.
        /// https://reference.wolfram.com/language/ref/ImageCorners.html
        ///</summary>
        corewolf::engine *ImageCorners(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageCorners[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns corners that are at least d+1 pixels apart.
        /// https://reference.wolfram.com/language/ref/ImageCorners.html
        ///</summary>
        corewolf::engine *ImageCorners(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ImageCorners[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the correlation of image with kernel ker.
        /// https://reference.wolfram.com/language/ref/ImageCorrelate.html
        ///</summary>
        corewolf::engine *ImageCorrelate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageCorrelate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes a generalized correlation in which the function f is used in place of Dot.
        /// https://reference.wolfram.com/language/ref/ImageCorrelate.html
        ///</summary>
        corewolf::engine *ImageCorrelate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageCorrelate[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds a set of matching interest points in image1 and image2 and returns their pixel coordinates.
        /// https://reference.wolfram.com/language/ref/ImageCorrespondingPoints.html
        ///</summary>
        corewolf::engine *ImageCorrespondingPoints(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageCorrespondingPoints[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// crops image by removing borders of uniform color.
        /// https://reference.wolfram.com/language/ref/ImageCrop.html
        ///</summary>
        corewolf::engine *ImageCrop(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageCrop[" + arg0 + "]", name);
        }

        ///< summary>
        /// crops image based on the size specification size.
        /// https://reference.wolfram.com/language/ref/ImageCrop.html
        ///</summary>
        corewolf::engine *ImageCrop(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageCrop[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// crops image by removing pixels from sides specified by spec.
        /// https://reference.wolfram.com/language/ref/ImageCrop.html
        ///</summary>
        corewolf::engine *ImageCrop(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageCrop[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the array of pixel values in an Image or Image3D const std::string &image.
        /// https://reference.wolfram.com/language/ref/ImageData.html
        ///</summary>
        corewolf::engine *ImageData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the array of pixel values converted to the specified type.
        /// https://reference.wolfram.com/language/ref/ImageData.html
        ///</summary>
        corewolf::engine *ImageData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a deconvolution of image using kernel ker.
        /// https://reference.wolfram.com/language/ref/ImageDeconvolve.html
        ///</summary>
        corewolf::engine *ImageDeconvolve(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageDeconvolve[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reconstructs a color image using the specified color filter array cfa.
        /// https://reference.wolfram.com/language/ref/ImageDemosaic.html
        ///</summary>
        corewolf::engine *ImageDemosaic(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageDemosaic[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// aligns the top-left pixel of the pattern with the {row,col} pixel of image.
        /// https://reference.wolfram.com/language/ref/ImageDemosaic.html
        ///</summary>
        corewolf::engine *ImageDemosaic(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ImageDemosaic[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives an image in which each pixel is the absolute difference of the corresponding pixels in image1 and image2.
        /// https://reference.wolfram.com/language/ref/ImageDifference.html
        ///</summary>
        corewolf::engine *ImageDifference(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageDifference[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the pixel dimensions of an Image or Image3D const std::string &image.
        /// https://reference.wolfram.com/language/ref/ImageDimensions.html
        ///</summary>
        corewolf::engine *ImageDimensions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageDimensions[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives estimated horizontal and vertical displacements between consecutive images.
        /// https://reference.wolfram.com/language/ref/ImageDisplacements.html
        ///</summary>
        corewolf::engine *ImageDisplacements(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ImageDisplacements[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// uses flow as an initial estimate for displacement between image1 and image2.
        /// https://reference.wolfram.com/language/ref/ImageDisplacements.html
        ///</summary>
        corewolf::engine *ImageDisplacements(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageDisplacements[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a distance measure between image1 and image2.
        /// https://reference.wolfram.com/language/ref/ImageDistance.html
        ///</summary>
        corewolf::engine *ImageDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// places the center of image2 at position pos in image1.
        /// https://reference.wolfram.com/language/ref/ImageDistance.html
        ///</summary>
        corewolf::engine *ImageDistance(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageDistance[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// places the point pos2 of image2 at position pos1 in image1.
        /// https://reference.wolfram.com/language/ref/ImageDistance.html
        ///</summary>
        corewolf::engine *ImageDistance(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ImageDistance[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// applies the specified image effect to image.
        /// https://reference.wolfram.com/language/ref/ImageEffect.html
        ///</summary>
        corewolf::engine *ImageEffect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageEffect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses parameters params.
        /// https://reference.wolfram.com/language/ref/ImageEffect.html
        ///</summary>
        corewolf::engine *ImageEffect(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImageEffect[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// combines differently exposed images imagei of the same scene into a single image with overall good exposure.
        /// https://reference.wolfram.com/language/ref/ImageExposureCombine.html
        ///</summary>
        corewolf::engine *ImageExposureCombine(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ImageExposureCombine[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// creates a low or a high dynamic range image based on the specified mode.
        /// https://reference.wolfram.com/language/ref/ImageExposureCombine.html
        ///</summary>
        corewolf::engine *ImageExposureCombine(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageExposureCombine[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tracks features from image1 through imagen.
        /// https://reference.wolfram.com/language/ref/ImageFeatureTrack.html
        ///</summary>
        corewolf::engine *ImageFeatureTrack(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ImageFeatureTrack[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// tracks features starting from the initial set of points pts in image1.
        /// https://reference.wolfram.com/language/ref/ImageFeatureTrack.html
        ///</summary>
        corewolf::engine *ImageFeatureTrack(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageFeatureTrack[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies the function f to the list of channel values for each pixel of the image stored in inputfile and stores the result in outputfile.
        /// https://reference.wolfram.com/language/ref/ImageFileApply.html
        ///</summary>
        corewolf::engine *ImageFileApply(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageFileApply[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies the function f to the range r neighborhood of each pixel in each channel of the image stored in inputfile and stores the result in outputfile.
        /// https://reference.wolfram.com/language/ref/ImageFileFilter.html
        ///</summary>
        corewolf::engine *ImageFileFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ImageFileFilter[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// applies the function f to the list of channel values for each pixel of the image stored in inputfile.
        /// https://reference.wolfram.com/language/ref/ImageFileScan.html
        ///</summary>
        corewolf::engine *ImageFileScan(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageFileScan[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies the function f to the range-r neighborhood of each pixel in each channel of image.
        /// https://reference.wolfram.com/language/ref/ImageFilter.html
        ///</summary>
        corewolf::engine *ImageFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageFilter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// combines differently focused images imagei of the same scene to obtain a single well-focused image.
        /// https://reference.wolfram.com/language/ref/ImageFocusCombine.html
        ///</summary>
        corewolf::engine *ImageFocusCombine(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ImageFocusCombine[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// finds a segmentation of image, returning an integer matrix in which positive integers label different components.
        /// https://reference.wolfram.com/language/ref/ImageForestingComponents.html
        ///</summary>
        corewolf::engine *ImageForestingComponents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageForestingComponents[" + arg0 + "]", name);
        }

        ///< summary>
        /// tries to find a segmentation into components that include pixels indicated by marker.
        /// https://reference.wolfram.com/language/ref/ImageForestingComponents.html
        ///</summary>
        corewolf::engine *ImageForestingComponents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageForestingComponents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds components that are connected at a pixel scale given by r.
        /// https://reference.wolfram.com/language/ref/ImageForestingComponents.html
        ///</summary>
        corewolf::engine *ImageForestingComponents(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageForestingComponents[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives an image in which each pixel at position f[{x,y}] corresponds to the position {x,y} in image.
        /// https://reference.wolfram.com/language/ref/ImageForwardTransformation.html
        ///</summary>
        corewolf::engine *ImageForwardTransformation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageForwardTransformation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an image of the specified size.
        /// https://reference.wolfram.com/language/ref/ImageForwardTransformation.html
        ///</summary>
        corewolf::engine *ImageForwardTransformation(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageForwardTransformation[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the content of image in the form of scalable vector graphics.
        /// https://reference.wolfram.com/language/ref/ImageGraphics.html
        ///</summary>
        corewolf::engine *ImageGraphics(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageGraphics[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses up to n colors for the vector graphics.
        /// https://reference.wolfram.com/language/ref/ImageGraphics.html
        ///</summary>
        corewolf::engine *ImageGraphics(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageGraphics[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// plots a histogram of the pixel levels for each channel in image.
        /// https://reference.wolfram.com/language/ref/ImageHistogram.html
        ///</summary>
        corewolf::engine *ImageHistogram(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageHistogram[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses bin specification bspec.
        /// https://reference.wolfram.com/language/ref/ImageHistogram.html
        ///</summary>
        corewolf::engine *ImageHistogram(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageHistogram[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// plots the histogram of the pixel values in the given range.
        /// https://reference.wolfram.com/language/ref/ImageHistogram.html
        ///</summary>
        corewolf::engine *ImageHistogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageHistogram[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields the result of attempting to identify what image is a picture of.
        /// https://reference.wolfram.com/language/ref/ImageIdentify.html
        ///</summary>
        corewolf::engine *ImageIdentify(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageIdentify[" + arg0 + "]", name);
        }

        ///< summary>
        /// restricts the identification of image to objects within the specified category.
        /// https://reference.wolfram.com/language/ref/ImageIdentify.html
        ///</summary>
        corewolf::engine *ImageIdentify(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageIdentify[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of up to n possible identifications.
        /// https://reference.wolfram.com/language/ref/ImageIdentify.html
        ///</summary>
        corewolf::engine *ImageIdentify(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageIdentify[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the specified property for each identification.
        /// https://reference.wolfram.com/language/ref/ImageIdentify.html
        ///</summary>
        corewolf::engine *ImageIdentify(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ImageIdentify[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives True if image appears to be an instance of the const std::string &obj, and gives False otherwise.
        /// https://reference.wolfram.com/language/ref/ImageInstanceQ.html
        ///</summary>
        corewolf::engine *ImageInstanceQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageInstanceQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// assumes that the image is of something in the category cat.
        /// https://reference.wolfram.com/language/ref/ImageInstanceQ.html
        ///</summary>
        corewolf::engine *ImageInstanceQ(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageInstanceQ[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds key features in image and returns their coordinates.
        /// https://reference.wolfram.com/language/ref/ImageKeypoints.html
        ///</summary>
        corewolf::engine *ImageKeypoints(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageKeypoints[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the specified property prop for each keypoint.
        /// https://reference.wolfram.com/language/ref/ImageKeypoints.html
        ///</summary>
        corewolf::engine *ImageKeypoints(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageKeypoints[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of pixel values and counts for each channel in image.
        /// https://reference.wolfram.com/language/ref/ImageLevels.html
        ///</summary>
        corewolf::engine *ImageLevels(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageLevels[" + arg0 + "]", name);
        }

        ///< summary>
        /// bins pixel values using bin specification bspec.
        /// https://reference.wolfram.com/language/ref/ImageLevels.html
        ///</summary>
        corewolf::engine *ImageLevels(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageLevels[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives counts for bins in the given range.
        /// https://reference.wolfram.com/language/ref/ImageLevels.html
        ///</summary>
        corewolf::engine *ImageLevels(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageLevels[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds line segments in image and returns the coordinates of their endpoints.
        /// https://reference.wolfram.com/language/ref/ImageLines.html
        ///</summary>
        corewolf::engine *ImageLines(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageLines[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the threshold t for selecting image lines.
        /// https://reference.wolfram.com/language/ref/ImageLines.html
        ///</summary>
        corewolf::engine *ImageLines(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageLines[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the parameter d to control the distinctness of the detected lines.
        /// https://reference.wolfram.com/language/ref/ImageLines.html
        ///</summary>
        corewolf::engine *ImageLines(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageLines[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a HighlightImage specification that represents a marker at position pos.
        /// https://reference.wolfram.com/language/ref/ImageMarker.html
        ///</summary>
        corewolf::engine *ImageMarker(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageMarker[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a custom marker at position pos.
        /// https://reference.wolfram.com/language/ref/ImageMarker.html
        ///</summary>
        corewolf::engine *ImageMarker(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageMarker[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents multiple marker positions posi.
        /// https://reference.wolfram.com/language/ref/ImageMarker.html
        ///</summary>
        corewolf::engine *ImageMarker(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageMarker[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of property "prop" for the entire image.
        /// https://reference.wolfram.com/language/ref/ImageMeasurements.html
        ///</summary>
        corewolf::engine *ImageMeasurements(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageMeasurements[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the values in the specified output format.
        /// https://reference.wolfram.com/language/ref/ImageMeasurements.html
        ///</summary>
        corewolf::engine *ImageMeasurements(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageMeasurements[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns measurements for all imagei.
        /// https://reference.wolfram.com/language/ref/ImageMeasurements.html
        ///</summary>
        corewolf::engine *ImageMeasurements(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageMeasurements[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the foreground region in image as a BoundaryMeshRegion object.
        /// https://reference.wolfram.com/language/ref/ImageMesh.html
        ///</summary>
        corewolf::engine *ImageMesh(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageMesh[" + arg0 + "]", name);
        }

        ///< summary>
        /// multiplies each channel value in image by a factor x.
        /// https://reference.wolfram.com/language/ref/ImageMultiply.html
        ///</summary>
        corewolf::engine *ImageMultiply(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageMultiply[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// multiplies all expri with image, where each expri can be either an image, a number, or a color value.
        /// https://reference.wolfram.com/language/ref/ImageMultiply.html
        ///</summary>
        corewolf::engine *ImageMultiply(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ImageMultiply[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// pads image on all sides with m background pixels.
        /// https://reference.wolfram.com/language/ref/ImagePad.html
        ///</summary>
        corewolf::engine *ImagePad(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImagePad[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// pads image on all sides using the value or method specified by padding.
        /// https://reference.wolfram.com/language/ref/ImagePad.html
        ///</summary>
        corewolf::engine *ImagePad(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImagePad[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// pads image with the specified numbers of pixels on each side.
        /// https://reference.wolfram.com/language/ref/ImagePad.html
        ///</summary>
        corewolf::engine *ImagePad(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ImagePad[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// pads a 3D image with the specified numbers of pixels.
        /// https://reference.wolfram.com/language/ref/ImagePad.html
        ///</summary>
        corewolf::engine *ImagePad(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("ImagePad[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// partitions an image into an array of ss-pixel subimages.
        /// https://reference.wolfram.com/language/ref/ImagePartition.html
        ///</summary>
        corewolf::engine *ImagePartition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImagePartition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// partitions an image into an array of subimages of pixel width w and pixel height h.
        /// https://reference.wolfram.com/language/ref/ImagePartition.html
        ///</summary>
        corewolf::engine *ImagePartition(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImagePartition[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses pixel offsets dw and dh.
        /// https://reference.wolfram.com/language/ref/ImagePartition.html
        ///</summary>
        corewolf::engine *ImagePartition(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ImagePartition[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// shows the squared magnitude of the discrete Fourier transform (power spectrum) of image.
        /// https://reference.wolfram.com/language/ref/ImagePeriodogram.html
        ///</summary>
        corewolf::engine *ImagePeriodogram(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImagePeriodogram[" + arg0 + "]", name);
        }

        ///< summary>
        /// shows the average of power spectra of non-overlapping partitions of size n×n.
        /// https://reference.wolfram.com/language/ref/ImagePeriodogram.html
        ///</summary>
        corewolf::engine *ImagePeriodogram(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImagePeriodogram[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses partitions with offset d.
        /// https://reference.wolfram.com/language/ref/ImagePeriodogram.html
        ///</summary>
        corewolf::engine *ImagePeriodogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImagePeriodogram[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies a smoothing window wfun to each partition.
        /// https://reference.wolfram.com/language/ref/ImagePeriodogram.html
        ///</summary>
        corewolf::engine *ImagePeriodogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ImagePeriodogram[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// pads partitions with zeros to length m prior to the computation of the transform.
        /// https://reference.wolfram.com/language/ref/ImagePeriodogram.html
        ///</summary>
        corewolf::engine *ImagePeriodogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("ImagePeriodogram[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// applies a linear fractional transform specified by a matrix m to the positions of each pixel in image.
        /// https://reference.wolfram.com/language/ref/ImagePerspectiveTransformation.html
        ///</summary>
        corewolf::engine *ImagePerspectiveTransformation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImagePerspectiveTransformation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an image of the specified size.
        /// https://reference.wolfram.com/language/ref/ImagePerspectiveTransformation.html
        ///</summary>
        corewolf::engine *ImagePerspectiveTransformation(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImagePerspectiveTransformation[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives an association of image positions for each identified category of objects in image.
        /// https://reference.wolfram.com/language/ref/ImagePosition.html
        ///</summary>
        corewolf::engine *ImagePosition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImagePosition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of image positions for subimages identified as instances of the specified category.
        /// https://reference.wolfram.com/language/ref/ImagePosition.html
        ///</summary>
        corewolf::engine *ImagePosition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImagePosition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a Gaussian image pyramid formed from image.
        /// https://reference.wolfram.com/language/ref/ImagePyramid.html
        ///</summary>
        corewolf::engine *ImagePyramid(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImagePyramid[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a Gaussian or Laplacian pyramid depending of the specified pyrtype.
        /// https://reference.wolfram.com/language/ref/ImagePyramid.html
        ///</summary>
        corewolf::engine *ImagePyramid(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImagePyramid[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns up to n levels of the pyramid.
        /// https://reference.wolfram.com/language/ref/ImagePyramid.html
        ///</summary>
        corewolf::engine *ImagePyramid(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImagePyramid[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns pyramid levels down to image dimensions given by size.
        /// https://reference.wolfram.com/language/ref/ImagePyramid.html
        ///</summary>
        corewolf::engine *ImagePyramid(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ImagePyramid[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// returns a pyramid with successive levels downsampled by factor s.
        /// https://reference.wolfram.com/language/ref/ImagePyramid.html
        ///</summary>
        corewolf::engine *ImagePyramid(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ImagePyramid[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// applies f to all images in the ImagePyramid const std::string &pyr.
        /// https://reference.wolfram.com/language/ref/ImagePyramidApply.html
        ///</summary>
        corewolf::engine *ImagePyramidApply(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImagePyramidApply[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f to the sequence of corresponding levels taken from each pyri.
        /// https://reference.wolfram.com/language/ref/ImagePyramidApply.html
        ///</summary>
        corewolf::engine *ImagePyramidApply(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImagePyramidApply[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if image has the form of a valid Image or Image3D object, and False otherwise.
        /// https://reference.wolfram.com/language/ref/ImageQ.html
        ///</summary>
        corewolf::engine *ImageQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// recolors pixels in image specified by region using the specified color.
        /// https://reference.wolfram.com/language/ref/ImageRecolor.html
        ///</summary>
        corewolf::engine *ImageRecolor(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageRecolor[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// recolors multiple regions.
        /// https://reference.wolfram.com/language/ref/ImageRecolor.html
        ///</summary>
        corewolf::engine *ImageRecolor(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImageRecolor[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// reverses image by top-bottom mirror reflection.
        /// https://reference.wolfram.com/language/ref/ImageReflect.html
        ///</summary>
        corewolf::engine *ImageReflect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageReflect[" + arg0 + "]", name);
        }

        ///< summary>
        /// reverses image by reflecting it so that the specified side goes to the opposite side.
        /// https://reference.wolfram.com/language/ref/ImageReflect.html
        ///</summary>
        corewolf::engine *ImageReflect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageReflect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a resized version of image that is width pixels wide.
        /// https://reference.wolfram.com/language/ref/ImageResize.html
        ///</summary>
        corewolf::engine *ImageResize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageResize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a resized version of image with a maximum pixel width or height given by size.
        /// https://reference.wolfram.com/language/ref/ImageResize.html
        ///</summary>
        corewolf::engine *ImageResize(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImageResize[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// attempts to restyle image so as to follow the graphical style of sample.
        /// https://reference.wolfram.com/language/ref/ImageRestyle.html
        ///</summary>
        corewolf::engine *ImageRestyle(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageRestyle[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// attempts to restyle image using a blend of the graphical styles of the samplei.
        /// https://reference.wolfram.com/language/ref/ImageRestyle.html
        ///</summary>
        corewolf::engine *ImageRestyle(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImageRestyle[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// rotates image by 90° about its center in the - plane.
        /// https://reference.wolfram.com/language/ref/ImageRotate.html
        ///</summary>
        corewolf::engine *ImageRotate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageRotate[" + arg0 + "]", name);
        }

        ///< summary>
        /// rotates image by θ radians.
        /// https://reference.wolfram.com/language/ref/ImageRotate.html
        ///</summary>
        corewolf::engine *ImageRotate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageRotate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// rotates a 3D image around the 3D vector w.
        /// https://reference.wolfram.com/language/ref/ImageRotate.html
        ///</summary>
        corewolf::engine *ImageRotate(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImageRotate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives an image of the specified size.
        /// https://reference.wolfram.com/language/ref/ImageRotate.html
        ///</summary>
        corewolf::engine *ImageRotate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageRotate[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns a saliency map for image.
        /// https://reference.wolfram.com/language/ref/ImageSaliencyFilter.html
        ///</summary>
        corewolf::engine *ImageSaliencyFilter(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageSaliencyFilter[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the position of a graphical const std::string &in terms of coordinates scaled to run from 0 to 1 across the whole image region in each direction.
        /// https://reference.wolfram.com/language/ref/ImageScaled.html
        ///</summary>
        corewolf::engine *ImageScaled(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ImageScaled[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a position obtained by starting at ordinary coordinates {x0,y0}, then moving by an image‐scaled offset {dx,dy}.
        /// https://reference.wolfram.com/language/ref/ImageScaled.html
        ///</summary>
        corewolf::engine *ImageScaled(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImageScaled[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates f applied to each pixel of image in turn.
        /// https://reference.wolfram.com/language/ref/ImageScan.html
        ///</summary>
        corewolf::engine *ImageScan(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageScan[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a composed image from an unordered list of imagei.
        /// https://reference.wolfram.com/language/ref/ImageStitch.html
        ///</summary>
        corewolf::engine *ImageStitch(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ImageStitch[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns a stitched image from a matrix of images imageij, according to their array position.
        /// https://reference.wolfram.com/language/ref/ImageStitch.html
        ///</summary>
        corewolf::engine *ImageStitch(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImageStitch[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// subtracts a constant amount x from each channel value in image.
        /// https://reference.wolfram.com/language/ref/ImageSubtract.html
        ///</summary>
        corewolf::engine *ImageSubtract(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageSubtract[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// subtracts all expri from image, where each expri can be either an image, a number, or a color value.
        /// https://reference.wolfram.com/language/ref/ImageSubtract.html
        ///</summary>
        corewolf::engine *ImageSubtract(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ImageSubtract[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives an image consisting of the first n rows of image.
        /// https://reference.wolfram.com/language/ref/ImageTake.html
        ///</summary>
        corewolf::engine *ImageTake(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageTake[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives rows row1 through row2.
        /// https://reference.wolfram.com/language/ref/ImageTake.html
        ///</summary>
        corewolf::engine *ImageTake(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImageTake[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the image that spans row1 to row2 and col1 to col2.
        /// https://reference.wolfram.com/language/ref/ImageTake.html
        ///</summary>
        corewolf::engine *ImageTake(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ImageTake[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the 3D image consisting of the specified slices, rows, and columns.
        /// https://reference.wolfram.com/language/ref/ImageTake.html
        ///</summary>
        corewolf::engine *ImageTake(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("ImageTake[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// gives an image in which each pixel at position p corresponds to the position f[p] in image.
        /// https://reference.wolfram.com/language/ref/ImageTransformation.html
        ///</summary>
        corewolf::engine *ImageTransformation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageTransformation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an image of the specified size.
        /// https://reference.wolfram.com/language/ref/ImageTransformation.html
        ///</summary>
        corewolf::engine *ImageTransformation(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageTransformation[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the smallest subimage of image that includes the specified region of interest roi.
        /// https://reference.wolfram.com/language/ref/ImageTrim.html
        ///</summary>
        corewolf::engine *ImageTrim(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageTrim[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// adds a margin of size r back to the resulting image.
        /// https://reference.wolfram.com/language/ref/ImageTrim.html
        ///</summary>
        corewolf::engine *ImageTrim(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageTrim[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// extracts multiple subimages specified by roii from image.
        /// https://reference.wolfram.com/language/ref/ImageTrim.html
        ///</summary>
        corewolf::engine *ImageTrim(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageTrim[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the underlying type of values used for each pixel element in the Image or Image3D const std::string &image.
        /// https://reference.wolfram.com/language/ref/ImageType.html
        ///</summary>
        corewolf::engine *ImageType(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageType[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the interpolated value of image at position pos.
        /// https://reference.wolfram.com/language/ref/ImageValue.html
        ///</summary>
        corewolf::engine *ImageValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value converted to the specified type.
        /// https://reference.wolfram.com/language/ref/ImageValue.html
        ///</summary>
        corewolf::engine *ImageValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns a list of pixel positions in image that exactly match the value val.
        /// https://reference.wolfram.com/language/ref/ImageValuePositions.html
        ///</summary>
        corewolf::engine *ImageValuePositions(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageValuePositions[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns all pixel positions that have values within a distance d from val.
        /// https://reference.wolfram.com/language/ref/ImageValuePositions.html
        ///</summary>
        corewolf::engine *ImageValuePositions(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImageValuePositions[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// plots the chrominance of image.
        /// https://reference.wolfram.com/language/ref/ImageVectorscopePlot.html
        ///</summary>
        corewolf::engine *ImageVectorscopePlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageVectorscopePlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots the waveform of image.
        /// https://reference.wolfram.com/language/ref/ImageWaveformPlot.html
        ///</summary>
        corewolf::engine *ImageWaveformPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImageWaveformPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots the waveform of image in colorspace.
        /// https://reference.wolfram.com/language/ref/ImageWaveformPlot.html
        ///</summary>
        corewolf::engine *ImageWaveformPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImageWaveformPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the partial derivative , assuming that the variable y represents an implicit function defined by the equation eqn.
        /// https://reference.wolfram.com/language/ref/ImplicitD.html
        ///</summary>
        corewolf::engine *ImplicitD(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ImplicitD[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the partial derivative , assuming that the variable y represents an implicit function defined by the equation eqn.
        /// https://reference.wolfram.com/language/ref/ImplicitD.html
        ///</summary>
        corewolf::engine *ImplicitD(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ImplicitD[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the partial derivative , assuming that the variables y1,…,yk represent implicit functions defined by the system of equations eqn1∧…∧eqnk.
        /// https://reference.wolfram.com/language/ref/ImplicitD.html
        ///</summary>
        corewolf::engine *ImplicitD(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ImplicitD[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the multiple derivative .
        /// https://reference.wolfram.com/language/ref/ImplicitD.html
        ///</summary>
        corewolf::engine *ImplicitD(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("ImplicitD[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// gives the partial derivative .
        /// https://reference.wolfram.com/language/ref/ImplicitD.html
        ///</summary>
        corewolf::engine *ImplicitD(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("ImplicitD[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// gives the multiple partial derivative .
        /// https://reference.wolfram.com/language/ref/ImplicitD.html
        ///</summary>
        corewolf::engine *ImplicitD(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::vector<std::string> &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("ImplicitD[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// represents a region in  that satisfies the conditions cond.
        /// https://reference.wolfram.com/language/ref/ImplicitRegion.html
        ///</summary>
        corewolf::engine *ImplicitRegion(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ImplicitRegion[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents the logical implication .
        /// https://reference.wolfram.com/language/ref/Implies.html
        ///</summary>
        corewolf::engine *Implies(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Implies[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// imports data from source, returning a Wolfram Language representation of it.
        /// https://reference.wolfram.com/language/ref/Import.html
        ///</summary>
        corewolf::engine *Import(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Import[" + arg0 + "]", name);
        }

        ///< summary>
        /// takes the file to be in the specified format "fmt".
        /// https://reference.wolfram.com/language/ref/Import.html
        ///</summary>
        corewolf::engine *Import(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Import[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the specified options.
        /// https://reference.wolfram.com/language/ref/Import.html
        ///</summary>
        corewolf::engine *Import(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Import[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// imports data in the specified format from a ByteArray object.
        /// https://reference.wolfram.com/language/ref/ImportByteArray.html
        ///</summary>
        corewolf::engine *ImportByteArray(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImportByteArray[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// attempts to determine the format automatically.
        /// https://reference.wolfram.com/language/ref/ImportByteArray.html
        ///</summary>
        corewolf::engine *ImportByteArray(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImportByteArray[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a piece of imported data that has no special representation in the Wolfram Language.
        /// https://reference.wolfram.com/language/ref/ImportedObject.html
        ///</summary>
        corewolf::engine *ImportedObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImportedObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// imports data in the specified format from a string.
        /// https://reference.wolfram.com/language/ref/ImportString.html
        ///</summary>
        corewolf::engine *ImportString(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImportString[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// attempts to determine the format of the string from its contents.
        /// https://reference.wolfram.com/language/ref/ImportString.html
        ///</summary>
        corewolf::engine *ImportString(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ImportString[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the improvement importances for all components in the ReliabilityDistribution rdist at time t.
        /// https://reference.wolfram.com/language/ref/ImprovementImportance.html
        ///</summary>
        corewolf::engine *ImprovementImportance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ImprovementImportance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a global const std::string &that is assigned to have a delayed value of the n input line.
        /// https://reference.wolfram.com/language/ref/In.html
        ///</summary>
        corewolf::engine *In(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("In[" + arg0 + "]", name);
        }

        ///< summary>
        /// replaces all instances of f with Inactive[f] for symbols f used as heads in expr.
        /// https://reference.wolfram.com/language/ref/Inactivate.html
        ///</summary>
        corewolf::engine *Inactivate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Inactivate[" + arg0 + "]", name);
        }

        ///< summary>
        /// inactivates all symbols in expr that match the pattern patt.
        /// https://reference.wolfram.com/language/ref/Inactivate.html
        ///</summary>
        corewolf::engine *Inactivate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Inactivate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is an inactive form of f.
        /// https://reference.wolfram.com/language/ref/Inactive.html
        ///</summary>
        corewolf::engine *Inactive(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Inactive[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the graph with incidence matrix m.
        /// https://reference.wolfram.com/language/ref/IncidenceGraph.html
        ///</summary>
        corewolf::engine *IncidenceGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IncidenceGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the graph with vertices vi and incidence matrix m.
        /// https://reference.wolfram.com/language/ref/IncidenceGraph.html
        ///</summary>
        corewolf::engine *IncidenceGraph(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IncidenceGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of edges incident to vertex v.
        /// https://reference.wolfram.com/language/ref/IncidenceList.html
        ///</summary>
        corewolf::engine *IncidenceList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IncidenceList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of incident edges d steps away.
        /// https://reference.wolfram.com/language/ref/IncidenceList.html
        ///</summary>
        corewolf::engine *IncidenceList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("IncidenceList[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/IncidenceList.html
        ///</summary>
        corewolf::engine *IncidenceList(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IncidenceList[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the vertex-edge incidence matrix of the graph g.
        /// https://reference.wolfram.com/language/ref/IncidenceMatrix.html
        ///</summary>
        corewolf::engine *IncidenceMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IncidenceMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/IncidenceMatrix.html
        ///</summary>
        corewolf::engine *IncidenceMatrix(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("IncidenceMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives True if m is explicitly indefinite, and False otherwise.
        /// https://reference.wolfram.com/language/ref/IndefiniteMatrixQ.html
        ///</summary>
        corewolf::engine *IndefiniteMatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IndefiniteMatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the vectors v1 and v2 are independent.
        /// https://reference.wolfram.com/language/ref/IndependenceTest.html
        ///</summary>
        corewolf::engine *IndependenceTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IndependenceTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if the edge list elist is an independent edge set of the graph g, and False otherwise.
        /// https://reference.wolfram.com/language/ref/IndependentEdgeSetQ.html
        ///</summary>
        corewolf::engine *IndependentEdgeSetQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IndependentEdgeSetQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a physical quantity string with no relationship to other physical quantities used in QuantityVariable.
        /// https://reference.wolfram.com/language/ref/IndependentPhysicalQuantity.html
        ///</summary>
        corewolf::engine *IndependentPhysicalQuantity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IndependentPhysicalQuantity[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a unit string with no relationship to other units within a Quantity.
        /// https://reference.wolfram.com/language/ref/IndependentUnit.html
        ///</summary>
        corewolf::engine *IndependentUnit(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IndependentUnit[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the base dimension dim associated with an independent physical quantity or unit.
        /// https://reference.wolfram.com/language/ref/IndependentUnitDimension.html
        ///</summary>
        corewolf::engine *IndependentUnitDimension(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IndependentUnitDimension[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if the vertex list vlist is an independent vertex set in the graph g, and False otherwise.
        /// https://reference.wolfram.com/language/ref/IndependentVertexSetQ.html
        ///</summary>
        corewolf::engine *IndependentVertexSetQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IndependentVertexSetQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the component of expr with index i and formats as expri.
        /// https://reference.wolfram.com/language/ref/Indexed.html
        ///</summary>
        corewolf::engine *Indexed(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Indexed[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the component with indices i, j, … and formats as expri,j,….
        /// https://reference.wolfram.com/language/ref/Indexed.html
        ///</summary>
        corewolf::engine *Indexed(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Indexed[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// sets tags of edges in the graph g to their edge indices.
        /// https://reference.wolfram.com/language/ref/IndexEdgeTaggedGraph.html
        ///</summary>
        corewolf::engine *IndexEdgeTaggedGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IndexEdgeTaggedGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// sets tags of edges to r,r+1,…
        /// https://reference.wolfram.com/language/ref/IndexEdgeTaggedGraph.html
        ///</summary>
        corewolf::engine *IndexEdgeTaggedGraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IndexEdgeTaggedGraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces the vertices of the graph g by its vertex indices.
        /// https://reference.wolfram.com/language/ref/IndexGraph.html
        ///</summary>
        corewolf::engine *IndexGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IndexGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// replaces the vertices with integers r,  r+1, ….
        /// https://reference.wolfram.com/language/ref/IndexGraph.html
        ///</summary>
        corewolf::engine *IndexGraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IndexGraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/IndexGraph.html
        ///</summary>
        corewolf::engine *IndexGraph(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IndexGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates an "InertExpression", returning a new "InertExpression" in compiled code.
        /// https://reference.wolfram.com/language/ref/InertEvaluate.html
        ///</summary>
        corewolf::engine *InertEvaluate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InertEvaluate[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates an inert expression in compiled code.
        /// https://reference.wolfram.com/language/ref/InertExpression.html
        ///</summary>
        corewolf::engine *InertExpression(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InertExpression[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if expr is an inexact real or complex number, and returns False otherwise.
        /// https://reference.wolfram.com/language/ref/InexactNumberQ.html
        ///</summary>
        corewolf::engine *InexactNumberQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InexactNumberQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the infinite straight line passing through the points p1 and p2.
        /// https://reference.wolfram.com/language/ref/InfiniteLine.html
        ///</summary>
        corewolf::engine *InfiniteLine(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("InfiniteLine[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the infinite straight line passing through the point p in the direction v.
        /// https://reference.wolfram.com/language/ref/InfiniteLine.html
        ///</summary>
        corewolf::engine *InfiniteLine(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InfiniteLine[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an infinite line passing through the points pi.
        /// https://reference.wolfram.com/language/ref/InfiniteLineThrough.html
        ///</summary>
        corewolf::engine *InfiniteLineThrough(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("InfiniteLineThrough[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the plane passing through the points p1, p2, and p3.
        /// https://reference.wolfram.com/language/ref/InfinitePlane.html
        ///</summary>
        corewolf::engine *InfinitePlane(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("InfinitePlane[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the plane passing through the point p in the directions v1 and v2.
        /// https://reference.wolfram.com/language/ref/InfinitePlane.html
        ///</summary>
        corewolf::engine *InfinitePlane(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("InfinitePlane[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// prints with f[e1,e2,…] given in default infix form: e1~f~e2~f~e3….
        /// https://reference.wolfram.com/language/ref/Infix.html
        ///</summary>
        corewolf::engine *Infix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Infix[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints with arguments separated by h: e1 h e2 h e3….
        /// https://reference.wolfram.com/language/ref/Infix.html
        ///</summary>
        corewolf::engine *Infix(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Infix[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// attempts to adjust the specified quantity purchasing power to targetdate.
        /// https://reference.wolfram.com/language/ref/InflationAdjust.html
        ///</summary>
        corewolf::engine *InflationAdjust(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InflationAdjust[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the current year as targetdate.
        /// https://reference.wolfram.com/language/ref/InflationAdjust.html
        ///</summary>
        corewolf::engine *InflationAdjust(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InflationAdjust[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives information about the expression expr.
        /// https://reference.wolfram.com/language/ref/Information.html
        ///</summary>
        corewolf::engine *Information(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Information[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the property prop for expr.
        /// https://reference.wolfram.com/language/ref/Information.html
        ///</summary>
        corewolf::engine *Information(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Information[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives information about all of the expri.
        /// https://reference.wolfram.com/language/ref/Information.html
        ///</summary>
        corewolf::engine *Information(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Information[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an inhomogeneous Poisson point process with density function  in .
        /// https://reference.wolfram.com/language/ref/InhomogeneousPoissonPointProcess.html
        ///</summary>
        corewolf::engine *InhomogeneousPoissonPointProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InhomogeneousPoissonPointProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an inhomogeneous Poisson process with intensity λ[t] given as a function of t.
        /// https://reference.wolfram.com/language/ref/InhomogeneousPoissonProcess.html
        ///</summary>
        corewolf::engine *InhomogeneousPoissonProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InhomogeneousPoissonProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the persistent const std::string &where InitializationValue[sym,loc] is stored.
        /// https://reference.wolfram.com/language/ref/InitializationObject.html
        ///</summary>
        corewolf::engine *InitializationObject(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InitializationObject[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of all persistent initialization objects in all locations in $PersistencePath.
        /// https://reference.wolfram.com/language/ref/InitializationObjects.html
        ///</summary>
        corewolf::engine *InitializationObjects(const std::string &name = "")
        {
            return this->execute("InitializationObjects[]", name);
        }

        ///< summary>
        /// gives all persistent initialization objects for symbols matching the string pattern "patt".
        /// https://reference.wolfram.com/language/ref/InitializationObjects.html
        ///</summary>
        corewolf::engine *InitializationObjects(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InitializationObjects[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives all matching persistent initialization objects in the persistence location loc.
        /// https://reference.wolfram.com/language/ref/InitializationObjects.html
        ///</summary>
        corewolf::engine *InitializationObjects(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InitializationObjects[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives all matching persistent initialization objects in all the loci.
        /// https://reference.wolfram.com/language/ref/InitializationObjects.html
        ///</summary>
        corewolf::engine *InitializationObjects(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("InitializationObjects[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents the settable persistent value with which the symbol sym will be initialized.
        /// https://reference.wolfram.com/language/ref/InitializationValue.html
        ///</summary>
        corewolf::engine *InitializationValue(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InitializationValue[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies the persistence locations to search for a possible initialization value.
        /// https://reference.wolfram.com/language/ref/InitializationValue.html
        ///</summary>
        corewolf::engine *InitializationValue(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("InitializationValue[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// initializes the symbol sym from persistent values on the default persistence path.
        /// https://reference.wolfram.com/language/ref/Initialize.html
        ///</summary>
        corewolf::engine *Initialize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Initialize[" + arg0 + "]", name);
        }

        ///< summary>
        /// initializes the symbol sym from persistent values on the persistence path {loc1,…}.
        /// https://reference.wolfram.com/language/ref/Initialize.html
        ///</summary>
        corewolf::engine *Initialize(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Initialize[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is a generalization of Dot in which f plays the role of multiplication and g of addition.
        /// https://reference.wolfram.com/language/ref/Inner.html
        ///</summary>
        corewolf::engine *Inner(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Inner[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the inner polygon of the polygon poly.
        /// https://reference.wolfram.com/language/ref/InnerPolygon.html
        ///</summary>
        corewolf::engine *InnerPolygon(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InnerPolygon[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the inner polyhedron of the polyhedron poly.
        /// https://reference.wolfram.com/language/ref/InnerPolyhedron.html
        ///</summary>
        corewolf::engine *InnerPolyhedron(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InnerPolyhedron[" + arg0 + "]", name);
        }

        ///< summary>
        /// retouches parts of image that correspond to nonzero elements in region.
        /// https://reference.wolfram.com/language/ref/Inpaint.html
        ///</summary>
        corewolf::engine *Inpaint(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Inpaint[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// interactively reads in one Wolfram Language expression.
        /// https://reference.wolfram.com/language/ref/Input.html
        ///</summary>
        corewolf::engine *Input(const std::string &name = "")
        {
            return this->execute("Input[]", name);
        }

        ///< summary>
        /// requests input, displaying prompt as a "prompt".
        /// https://reference.wolfram.com/language/ref/Input.html
        ///</summary>
        corewolf::engine *Input(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Input[" + arg0 + "]", name);
        }

        ///< summary>
        /// in a notebook front end uses init as the initial contents of the input field.
        /// https://reference.wolfram.com/language/ref/Input.html
        ///</summary>
        corewolf::engine *Input(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Input[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a blank editable input field.
        /// https://reference.wolfram.com/language/ref/InputField.html
        ///</summary>
        corewolf::engine *InputField(const std::string &name = "")
        {
            return this->execute("InputField[]", name);
        }

        ///< summary>
        /// represents an editable input field that currently contains the expression x.
        /// https://reference.wolfram.com/language/ref/InputField.html
        ///</summary>
        corewolf::engine *InputField(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InputField[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an input field whose contents are taken to be a string.
        /// https://reference.wolfram.com/language/ref/InputField.html
        ///</summary>
        corewolf::engine *InputField(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InputField[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// prints as a version of expr suitable for input to the Wolfram Language.
        /// https://reference.wolfram.com/language/ref/InputForm.html
        ///</summary>
        corewolf::engine *InputForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InputForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a WSTP packet that contains in string the name to be assigned to the next input.
        /// https://reference.wolfram.com/language/ref/InputNamePacket.html
        ///</summary>
        corewolf::engine *InputNamePacket(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InputNamePacket[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the current notebook into which keyboard input in the front end will be directed.
        /// https://reference.wolfram.com/language/ref/InputNotebook.html
        ///</summary>
        corewolf::engine *InputNotebook(const std::string &name = "")
        {
            return this->execute("InputNotebook[]", name);
        }

        ///< summary>
        /// is a WSTP packet that indicates a prompt for input as generated by Input.
        /// https://reference.wolfram.com/language/ref/InputPacket.html
        ///</summary>
        corewolf::engine *InputPacket(const std::string &name = "")
        {
            return this->execute("InputPacket[]", name);
        }

        ///< summary>
        /// is an const std::string &that represents an input stream for functions such as Read and Find.
        /// https://reference.wolfram.com/language/ref/InputStream.html
        ///</summary>
        corewolf::engine *InputStream(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InputStream[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// interactively reads in a character string.
        /// https://reference.wolfram.com/language/ref/InputString.html
        ///</summary>
        corewolf::engine *InputString(const std::string &name = "")
        {
            return this->execute("InputString[]", name);
        }

        ///< summary>
        /// requests input, displaying prompt as a "prompt".
        /// https://reference.wolfram.com/language/ref/InputString.html
        ///</summary>
        corewolf::engine *InputString(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InputString[" + arg0 + "]", name);
        }

        ///< summary>
        /// in a notebook front end uses init as the initial contents of the input field.
        /// https://reference.wolfram.com/language/ref/InputString.html
        ///</summary>
        corewolf::engine *InputString(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InputString[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a WSTP packet that requests input in string form.
        /// https://reference.wolfram.com/language/ref/InputStringPacket.html
        ///</summary>
        corewolf::engine *InputStringPacket(const std::string &name = "")
        {
            return this->execute("InputStringPacket[]", name);
        }

        ///< summary>
        /// inserts elem at position n in list. If n is negative, the position is counted from the end.
        /// https://reference.wolfram.com/language/ref/Insert.html
        ///</summary>
        corewolf::engine *Insert(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Insert[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// inserts elem at position {i,j,…} in expr.
        /// https://reference.wolfram.com/language/ref/Insert.html
        ///</summary>
        corewolf::engine *Insert(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Insert[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// inserts elem at several positions.
        /// https://reference.wolfram.com/language/ref/Insert.html
        ///</summary>
        corewolf::engine *Insert(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("Insert[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// represents an operator form of Insert that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/Insert.html
        ///</summary>
        corewolf::engine *Insert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Insert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// inserts newline characters into string to make a string in which no line is longer than 78 characters.
        /// https://reference.wolfram.com/language/ref/InsertLinebreaks.html
        ///</summary>
        corewolf::engine *InsertLinebreaks(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InsertLinebreaks[" + arg0 + "]", name);
        }

        ///< summary>
        /// inserts newline characters to make no line longer than n characters.
        /// https://reference.wolfram.com/language/ref/InsertLinebreaks.html
        ///</summary>
        corewolf::engine *InsertLinebreaks(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InsertLinebreaks[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an const std::string &obj inset in a graphic.
        /// https://reference.wolfram.com/language/ref/Inset.html
        ///</summary>
        corewolf::engine *Inset(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Inset[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies that the inset should be placed at position pos in the graphic.
        /// https://reference.wolfram.com/language/ref/Inset.html
        ///</summary>
        corewolf::engine *Inset(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Inset[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// aligns the inset so that position opos in the const std::string &lies at position pos in the enclosing graphic.
        /// https://reference.wolfram.com/language/ref/Inset.html
        ///</summary>
        corewolf::engine *Inset(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Inset[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// specifies the size of the inset in the coordinate system of the enclosing graphic.
        /// https://reference.wolfram.com/language/ref/Inset.html
        ///</summary>
        corewolf::engine *Inset(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Inset[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// specifies that the axes of the inset should be oriented in directions dirs.
        /// https://reference.wolfram.com/language/ref/Inset.html
        ///</summary>
        corewolf::engine *Inset(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("Inset[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// gives the sphere that can be inscribed in the simplex defined by points pi in .
        /// https://reference.wolfram.com/language/ref/Insphere.html
        ///</summary>
        corewolf::engine *Insphere(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Insphere[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the insphere of a polyhedron or polygon poly.
        /// https://reference.wolfram.com/language/ref/Insphere.html
        ///</summary>
        corewolf::engine *Insphere(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Insphere[" + arg0 + "]", name);
        }

        ///< summary>
        /// starts a WSTP-compatible external program and installs Wolfram Language definitions to call functions in it.
        /// https://reference.wolfram.com/language/ref/Install.html
        ///</summary>
        corewolf::engine *Install(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Install[" + arg0 + "]", name);
        }

        ///< summary>
        /// installs the web service operations in the WSDL description at the URL given.
        /// https://reference.wolfram.com/language/ref/InstallService.html
        ///</summary>
        corewolf::engine *InstallService(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InstallService[" + arg0 + "]", name);
        }

        ///< summary>
        /// installs web service operations, creating functions in the specified context.
        /// https://reference.wolfram.com/language/ref/InstallService.html
        ///</summary>
        corewolf::engine *InstallService(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InstallService[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a global const std::string &that is assigned to be the text of the n input line.
        /// https://reference.wolfram.com/language/ref/InString.html
        ///</summary>
        corewolf::engine *InString(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InString[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of the decimal digits in the integer n.
        /// https://reference.wolfram.com/language/ref/IntegerDigits.html
        ///</summary>
        corewolf::engine *IntegerDigits(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IntegerDigits[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of the base b digits in the integer n.
        /// https://reference.wolfram.com/language/ref/IntegerDigits.html
        ///</summary>
        corewolf::engine *IntegerDigits(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IntegerDigits[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// pads the list on the left with zeros to give a list of length len.
        /// https://reference.wolfram.com/language/ref/IntegerDigits.html
        ///</summary>
        corewolf::engine *IntegerDigits(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("IntegerDigits[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the highest power of b that divides n.
        /// https://reference.wolfram.com/language/ref/IntegerExponent.html
        ///</summary>
        corewolf::engine *IntegerExponent(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IntegerExponent[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the number of digits in the base 10 representation of the integer n.
        /// https://reference.wolfram.com/language/ref/IntegerLength.html
        ///</summary>
        corewolf::engine *IntegerLength(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IntegerLength[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number of digits in the base b representation of n.
        /// https://reference.wolfram.com/language/ref/IntegerLength.html
        ///</summary>
        corewolf::engine *IntegerLength(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IntegerLength[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a string containing the full English name of the integer n.
        /// https://reference.wolfram.com/language/ref/IntegerName.html
        ///</summary>
        corewolf::engine *IntegerName(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IntegerName[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a string conforming to the given qualifications.
        /// https://reference.wolfram.com/language/ref/IntegerName.html
        ///</summary>
        corewolf::engine *IntegerName(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IntegerName[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the integer part of x.
        /// https://reference.wolfram.com/language/ref/IntegerPart.html
        ///</summary>
        corewolf::engine *IntegerPart(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IntegerPart[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of all possible ways to partition the integer n into smaller integers.
        /// https://reference.wolfram.com/language/ref/IntegerPartitions.html
        ///</summary>
        corewolf::engine *IntegerPartitions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IntegerPartitions[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives partitions into at most k integers.
        /// https://reference.wolfram.com/language/ref/IntegerPartitions.html
        ///</summary>
        corewolf::engine *IntegerPartitions(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IntegerPartitions[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives partitions into exactly k integers.
        /// https://reference.wolfram.com/language/ref/IntegerPartitions.html
        ///</summary>
        corewolf::engine *IntegerPartitions(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("IntegerPartitions[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives partitions involving only the si.
        /// https://reference.wolfram.com/language/ref/IntegerPartitions.html
        ///</summary>
        corewolf::engine *IntegerPartitions(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("IntegerPartitions[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// limits the result to the first m partitions.
        /// https://reference.wolfram.com/language/ref/IntegerPartitions.html
        ///</summary>
        corewolf::engine *IntegerPartitions(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("IntegerPartitions[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives True if expr is an integer, and False otherwise.
        /// https://reference.wolfram.com/language/ref/IntegerQ.html
        ///</summary>
        corewolf::engine *IntegerQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IntegerQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the integer whose digits are reversed with respect to those of the integer n.
        /// https://reference.wolfram.com/language/ref/IntegerReverse.html
        ///</summary>
        corewolf::engine *IntegerReverse(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IntegerReverse[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the integer whose digits in base b are reversed with respect to those of n.
        /// https://reference.wolfram.com/language/ref/IntegerReverse.html
        ///</summary>
        corewolf::engine *IntegerReverse(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IntegerReverse[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the integer with reversed digits after padding n with zeros on the left to have len digits.
        /// https://reference.wolfram.com/language/ref/IntegerReverse.html
        ///</summary>
        corewolf::engine *IntegerReverse(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("IntegerReverse[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a string consisting of the decimal digits in the integer n.
        /// https://reference.wolfram.com/language/ref/IntegerString.html
        ///</summary>
        corewolf::engine *IntegerString(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IntegerString[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a string consisting of the base-b digits in the integer n.
        /// https://reference.wolfram.com/language/ref/IntegerString.html
        ///</summary>
        corewolf::engine *IntegerString(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IntegerString[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// pads the string on the left with zero digits to give a string of length len.
        /// https://reference.wolfram.com/language/ref/IntegerString.html
        ///</summary>
        corewolf::engine *IntegerString(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("IntegerString[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the indefinite integral .
        /// https://reference.wolfram.com/language/ref/Integrate.html
        ///</summary>
        corewolf::engine *Integrate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Integrate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the definite integral .
        /// https://reference.wolfram.com/language/ref/Integrate.html
        ///</summary>
        corewolf::engine *Integrate(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Integrate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the multiple integral .
        /// https://reference.wolfram.com/language/ref/Integrate.html
        ///</summary>
        corewolf::engine *Integrate(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Integrate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// changes the variable in integral to the new variable u using the transformation trans.
        /// https://reference.wolfram.com/language/ref/IntegrateChangeVariables.html
        ///</summary>
        corewolf::engine *IntegrateChangeVariables(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("IntegrateChangeVariables[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// changes the variables to the new variables u, v, ….
        /// https://reference.wolfram.com/language/ref/IntegrateChangeVariables.html
        ///</summary>
        corewolf::engine *IntegrateChangeVariables(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("IntegrateChangeVariables[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// makes a chart showing prices and volume for each date.
        /// https://reference.wolfram.com/language/ref/InteractiveTradingChart.html
        ///</summary>
        corewolf::engine *InteractiveTradingChart(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("InteractiveTradingChart[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a financial chart for the financial entity "name" over the daterange.
        /// https://reference.wolfram.com/language/ref/InteractiveTradingChart.html
        ///</summary>
        corewolf::engine *InteractiveTradingChart(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("InteractiveTradingChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a financial chart with indicators ind1, ind2, … .
        /// https://reference.wolfram.com/language/ref/InteractiveTradingChart.html
        ///</summary>
        corewolf::engine *InteractiveTradingChart(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("InteractiveTradingChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is a construct that behaves as if it were expri when it is in an interface environment with width sizei.
        /// https://reference.wolfram.com/language/ref/InterfaceSwitched.html
        ///</summary>
        corewolf::engine *InterfaceSwitched(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InterfaceSwitched[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// behaves as if it were expri when the value of the interface parameter param corresponds to keyi.
        /// https://reference.wolfram.com/language/ref/InterfaceSwitched.html
        ///</summary>
        corewolf::engine *InterfaceSwitched(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("InterfaceSwitched[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// yields the internally balanced decomposition of the state-space model ssm.
        /// https://reference.wolfram.com/language/ref/InternallyBalancedDecomposition.html
        ///</summary>
        corewolf::engine *InternallyBalancedDecomposition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InternallyBalancedDecomposition[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an approximate function whose values are found by interpolation.
        /// https://reference.wolfram.com/language/ref/InterpolatingFunction.html
        ///</summary>
        corewolf::engine *InterpolatingFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InterpolatingFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// constructs an interpolating polynomial in x which reproduces the function values  at successive integer values 1, 2, … of .
        /// https://reference.wolfram.com/language/ref/InterpolatingPolynomial.html
        ///</summary>
        corewolf::engine *InterpolatingPolynomial(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InterpolatingPolynomial[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// constructs an interpolating polynomial for the function values  corresponding to  values .
        /// https://reference.wolfram.com/language/ref/InterpolatingPolynomial.html
        ///</summary>
        corewolf::engine *InterpolatingPolynomial(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InterpolatingPolynomial[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// constructs a multidimensional interpolating polynomial in the variables x, y, ….
        /// https://reference.wolfram.com/language/ref/InterpolatingPolynomial.html
        ///</summary>
        corewolf::engine *InterpolatingPolynomial(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("InterpolatingPolynomial[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// constructs an interpolating polynomial that reproduces derivatives as well as function values.
        /// https://reference.wolfram.com/language/ref/InterpolatingPolynomial.html
        ///</summary>
        corewolf::engine *InterpolatingPolynomial(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("InterpolatingPolynomial[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// constructs an interpolation of the function values fi, assumed to correspond to x values 1, 2, … .
        /// https://reference.wolfram.com/language/ref/Interpolation.html
        ///</summary>
        corewolf::engine *Interpolation(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Interpolation[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// constructs an interpolation of the function values fi corresponding to x values xi.
        /// https://reference.wolfram.com/language/ref/Interpolation.html
        ///</summary>
        corewolf::engine *Interpolation(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Interpolation[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// find an interpolation of data at the point x.
        /// https://reference.wolfram.com/language/ref/Interpolation.html
        ///</summary>
        corewolf::engine *Interpolation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Interpolation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an const std::string &that displays as e, but is interpreted as the unevaluated form of expr if supplied as input.
        /// https://reference.wolfram.com/language/ref/Interpretation.html
        ///</summary>
        corewolf::engine *Interpretation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Interpretation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// allows local variables x, y, … in e and expr.
        /// https://reference.wolfram.com/language/ref/Interpretation.html
        ///</summary>
        corewolf::engine *Interpretation(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Interpretation[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a low-level box construct that displays as boxes but is interpreted on input as expr.
        /// https://reference.wolfram.com/language/ref/InterpretationBox.html
        ///</summary>
        corewolf::engine *InterpretationBox(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InterpretationBox[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an interpreter const std::string &that can be applied to an input to try to interpret it as an const std::string &of the specified form.
        /// https://reference.wolfram.com/language/ref/Interpreter.html
        ///</summary>
        corewolf::engine *Interpreter(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Interpreter[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the interpreted const std::string &only if applying test to it yields True; otherwise it returns a Failure object.
        /// https://reference.wolfram.com/language/ref/Interpreter.html
        ///</summary>
        corewolf::engine *Interpreter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Interpreter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the result of applying the function fail if the test fails.
        /// https://reference.wolfram.com/language/ref/Interpreter.html
        ///</summary>
        corewolf::engine *Interpreter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Interpreter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the difference between the upper and lower quartiles for the elements in list.
        /// https://reference.wolfram.com/language/ref/InterquartileRange.html
        ///</summary>
        corewolf::engine *InterquartileRange(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InterquartileRange[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates an interrupt.
        /// https://reference.wolfram.com/language/ref/Interrupt.html
        ///</summary>
        corewolf::engine *Interrupt(const std::string &name = "")
        {
            return this->execute("Interrupt[]", name);
        }

        ///< summary>
        /// represents an entity class containing all the entities common to all classi.
        /// https://reference.wolfram.com/language/ref/IntersectedEntityClass.html
        ///</summary>
        corewolf::engine *IntersectedEntityClass(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("IntersectedEntityClass[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields True if list1 and list2 have at least one element in common, and False otherwise.
        /// https://reference.wolfram.com/language/ref/IntersectingQ.html
        ///</summary>
        corewolf::engine *IntersectingQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IntersectingQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of IntersectingQ that can be applied to another list.
        /// https://reference.wolfram.com/language/ref/IntersectingQ.html
        ///</summary>
        corewolf::engine *IntersectingQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IntersectingQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a sorted list of the elements common to all the listi.
        /// https://reference.wolfram.com/language/ref/Intersection.html
        ///</summary>
        corewolf::engine *Intersection(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Intersection[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the range of values between min and max.
        /// https://reference.wolfram.com/language/ref/Interval.html
        ///</summary>
        corewolf::engine *Interval(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Interval[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the union of the ranges min1 to max1, min2 to max2, ….
        /// https://reference.wolfram.com/language/ref/Interval.html
        ///</summary>
        corewolf::engine *Interval(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Interval[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the interval representing all points common to each of the intervali.
        /// https://reference.wolfram.com/language/ref/IntervalIntersection.html
        ///</summary>
        corewolf::engine *IntervalIntersection(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("IntervalIntersection[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives True if the number x lies within the specified interval, and False otherwise.
        /// https://reference.wolfram.com/language/ref/IntervalMemberQ.html
        ///</summary>
        corewolf::engine *IntervalMemberQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IntervalMemberQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of IntervalMemberQ that can be applied to a number.
        /// https://reference.wolfram.com/language/ref/IntervalMemberQ.html
        ///</summary>
        corewolf::engine *IntervalMemberQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IntervalMemberQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a slider with setting {xmin,xmax} in the range 0 to 1.
        /// https://reference.wolfram.com/language/ref/IntervalSlider.html
        ///</summary>
        corewolf::engine *IntervalSlider(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("IntervalSlider[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// takes the setting to be the dynamically updated current value of int, with the value of int being reset if the slider is moved.
        /// https://reference.wolfram.com/language/ref/IntervalSlider.html
        ///</summary>
        corewolf::engine *IntervalSlider(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IntervalSlider[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a slider with range min to max.
        /// https://reference.wolfram.com/language/ref/IntervalSlider.html
        ///</summary>
        corewolf::engine *IntervalSlider(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("IntervalSlider[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives an interval containing the set of all points in any of the intervali.
        /// https://reference.wolfram.com/language/ref/IntervalUnion.html
        ///</summary>
        corewolf::engine *IntervalUnion(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("IntervalUnion[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the inverse of a square matrix m.
        /// https://reference.wolfram.com/language/ref/Inverse.html
        ///</summary>
        corewolf::engine *Inverse(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Inverse[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the inverse of the regularized incomplete beta function.
        /// https://reference.wolfram.com/language/ref/InverseBetaRegularized.html
        ///</summary>
        corewolf::engine *InverseBetaRegularized(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseBetaRegularized[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the inverse bilateral Laplace transform of expr.
        /// https://reference.wolfram.com/language/ref/InverseBilateralLaplaceTransform.html
        ///</summary>
        corewolf::engine *InverseBilateralLaplaceTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseBilateralLaplaceTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional inverse bilateral Laplace transform of expr.
        /// https://reference.wolfram.com/language/ref/InverseBilateralLaplaceTransform.html
        ///</summary>
        corewolf::engine *InverseBilateralLaplaceTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("InverseBilateralLaplaceTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the inverse bilateral Z transform of expr.
        /// https://reference.wolfram.com/language/ref/InverseBilateralZTransform.html
        ///</summary>
        corewolf::engine *InverseBilateralZTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseBilateralZTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional inverse bilateral Z transform of expr.
        /// https://reference.wolfram.com/language/ref/InverseBilateralZTransform.html
        ///</summary>
        corewolf::engine *InverseBilateralZTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("InverseBilateralZTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the inverse of the cumulative distribution function for the distribution dist as a function of the variable q.
        /// https://reference.wolfram.com/language/ref/InverseCDF.html
        ///</summary>
        corewolf::engine *InverseCDF(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseCDF[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an inverse  distribution with ν degrees of freedom.
        /// https://reference.wolfram.com/language/ref/InverseChiSquareDistribution.html
        ///</summary>
        corewolf::engine *InverseChiSquareDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InverseChiSquareDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a scaled inverse  distribution with ν degrees of freedom and scale ξ.
        /// https://reference.wolfram.com/language/ref/InverseChiSquareDistribution.html
        ///</summary>
        corewolf::engine *InverseChiSquareDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseChiSquareDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the inverse continuous wavelet transform of a ContinuousWaveletData const std::string &cwd.
        /// https://reference.wolfram.com/language/ref/InverseContinuousWaveletTransform.html
        ///</summary>
        corewolf::engine *InverseContinuousWaveletTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InverseContinuousWaveletTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the inverse transform using the wavelet wave.
        /// https://reference.wolfram.com/language/ref/InverseContinuousWaveletTransform.html
        ///</summary>
        corewolf::engine *InverseContinuousWaveletTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseContinuousWaveletTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the inverse transform from the wavelet coefficients specified by octvoc.
        /// https://reference.wolfram.com/language/ref/InverseContinuousWaveletTransform.html
        ///</summary>
        corewolf::engine *InverseContinuousWaveletTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseContinuousWaveletTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the inverse distance transform of image, returning the result as a binary image.
        /// https://reference.wolfram.com/language/ref/InverseDistanceTransform.html
        ///</summary>
        corewolf::engine *InverseDistanceTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InverseDistanceTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the parameter m corresponding to the nome q in an elliptic function.
        /// https://reference.wolfram.com/language/ref/InverseEllipticNomeQ.html
        ///</summary>
        corewolf::engine *InverseEllipticNomeQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InverseEllipticNomeQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the inverse error function obtained as the solution for z in .
        /// https://reference.wolfram.com/language/ref/InverseErf.html
        ///</summary>
        corewolf::engine *InverseErf(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InverseErf[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the inverse complementary error function obtained as the solution for z in .
        /// https://reference.wolfram.com/language/ref/InverseErfc.html
        ///</summary>
        corewolf::engine *InverseErfc(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InverseErfc[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds the discrete inverse Fourier transform of a list of complex numbers.
        /// https://reference.wolfram.com/language/ref/InverseFourier.html
        ///</summary>
        corewolf::engine *InverseFourier(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InverseFourier[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the specified positions of the discrete inverse Fourier transform.
        /// https://reference.wolfram.com/language/ref/InverseFourier.html
        ///</summary>
        corewolf::engine *InverseFourier(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("InverseFourier[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the symbolic inverse Fourier cosine transform of expr.
        /// https://reference.wolfram.com/language/ref/InverseFourierCosTransform.html
        ///</summary>
        corewolf::engine *InverseFourierCosTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseFourierCosTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional inverse Fourier cosine transform of expr.
        /// https://reference.wolfram.com/language/ref/InverseFourierCosTransform.html
        ///</summary>
        corewolf::engine *InverseFourierCosTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("InverseFourierCosTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the inverse discrete-time Fourier transform of expr.
        /// https://reference.wolfram.com/language/ref/InverseFourierSequenceTransform.html
        ///</summary>
        corewolf::engine *InverseFourierSequenceTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseFourierSequenceTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional inverse Fourier sequence transform.
        /// https://reference.wolfram.com/language/ref/InverseFourierSequenceTransform.html
        ///</summary>
        corewolf::engine *InverseFourierSequenceTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("InverseFourierSequenceTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the symbolic inverse Fourier sine transform of expr.
        /// https://reference.wolfram.com/language/ref/InverseFourierSinTransform.html
        ///</summary>
        corewolf::engine *InverseFourierSinTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseFourierSinTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional inverse Fourier sine transform of expr.
        /// https://reference.wolfram.com/language/ref/InverseFourierSinTransform.html
        ///</summary>
        corewolf::engine *InverseFourierSinTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("InverseFourierSinTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the symbolic inverse Fourier transform of expr.
        /// https://reference.wolfram.com/language/ref/InverseFourierTransform.html
        ///</summary>
        corewolf::engine *InverseFourierTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseFourierTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional inverse Fourier transform of expr.
        /// https://reference.wolfram.com/language/ref/InverseFourierTransform.html
        ///</summary>
        corewolf::engine *InverseFourierTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("InverseFourierTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents the inverse of the function f, defined so that InverseFunction[f][y] gives the value of x for which f[x] is equal to y.
        /// https://reference.wolfram.com/language/ref/InverseFunction.html
        ///</summary>
        corewolf::engine *InverseFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InverseFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the inverse with respect to the n  argument when there are tot arguments in all.
        /// https://reference.wolfram.com/language/ref/InverseFunction.html
        ///</summary>
        corewolf::engine *InverseFunction(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseFunction[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an inverse gamma distribution with shape parameter α and scale parameter β.
        /// https://reference.wolfram.com/language/ref/InverseGammaDistribution.html
        ///</summary>
        corewolf::engine *InverseGammaDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseGammaDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a generalized inverse gamma distribution with shape parameters α and γ, scale parameter β, and location parameter μ.
        /// https://reference.wolfram.com/language/ref/InverseGammaDistribution.html
        ///</summary>
        corewolf::engine *InverseGammaDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("InverseGammaDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the inverse of the regularized incomplete gamma function.
        /// https://reference.wolfram.com/language/ref/InverseGammaRegularized.html
        ///</summary>
        corewolf::engine *InverseGammaRegularized(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseGammaRegularized[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an inverse Gaussian distribution with mean μ and scale parameter λ.
        /// https://reference.wolfram.com/language/ref/InverseGaussianDistribution.html
        ///</summary>
        corewolf::engine *InverseGaussianDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseGaussianDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a generalized inverse Gaussian distribution with parameters μ, λ, and θ.
        /// https://reference.wolfram.com/language/ref/InverseGaussianDistribution.html
        ///</summary>
        corewolf::engine *InverseGaussianDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseGaussianDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the inverse Gudermannian function .
        /// https://reference.wolfram.com/language/ref/InverseGudermannian.html
        ///</summary>
        corewolf::engine *InverseGudermannian(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InverseGudermannian[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the inverse Hankel transform of order 0 for expr.
        /// https://reference.wolfram.com/language/ref/InverseHankelTransform.html
        ///</summary>
        corewolf::engine *InverseHankelTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseHankelTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the inverse Hankel transform of order ν for expr.
        /// https://reference.wolfram.com/language/ref/InverseHankelTransform.html
        ///</summary>
        corewolf::engine *InverseHankelTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("InverseHankelTransform[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the inverse haversine function .
        /// https://reference.wolfram.com/language/ref/InverseHaversine.html
        ///</summary>
        corewolf::engine *InverseHaversine(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InverseHaversine[" + arg0 + "]", name);
        }

        ///< summary>
        /// reconstructs an image from an ImagePyramid const std::string &pyr.
        /// https://reference.wolfram.com/language/ref/InverseImagePyramid.html
        ///</summary>
        corewolf::engine *InverseImagePyramid(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InverseImagePyramid[" + arg0 + "]", name);
        }

        ///< summary>
        /// assumes the specified pyramid type pyrtype.
        /// https://reference.wolfram.com/language/ref/InverseImagePyramid.html
        ///</summary>
        corewolf::engine *InverseImagePyramid(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseImagePyramid[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reconstructs up to pyramid level n.
        /// https://reference.wolfram.com/language/ref/InverseImagePyramid.html
        ///</summary>
        corewolf::engine *InverseImagePyramid(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseImagePyramid[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// reconstructs up to the smallest pyramid level larger than the specified size.
        /// https://reference.wolfram.com/language/ref/InverseImagePyramid.html
        ///</summary>
        corewolf::engine *InverseImagePyramid(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("InverseImagePyramid[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the inverse Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/InverseJacobiCD.html
        ///</summary>
        corewolf::engine *InverseJacobiCD(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseJacobiCD[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the inverse Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/InverseJacobiCN.html
        ///</summary>
        corewolf::engine *InverseJacobiCN(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseJacobiCN[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the inverse Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/InverseJacobiCS.html
        ///</summary>
        corewolf::engine *InverseJacobiCS(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseJacobiCS[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the inverse Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/InverseJacobiDC.html
        ///</summary>
        corewolf::engine *InverseJacobiDC(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseJacobiDC[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the inverse Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/InverseJacobiDN.html
        ///</summary>
        corewolf::engine *InverseJacobiDN(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseJacobiDN[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the inverse Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/InverseJacobiDS.html
        ///</summary>
        corewolf::engine *InverseJacobiDS(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseJacobiDS[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the inverse Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/InverseJacobiNC.html
        ///</summary>
        corewolf::engine *InverseJacobiNC(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseJacobiNC[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the inverse Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/InverseJacobiND.html
        ///</summary>
        corewolf::engine *InverseJacobiND(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseJacobiND[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the inverse Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/InverseJacobiNS.html
        ///</summary>
        corewolf::engine *InverseJacobiNS(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseJacobiNS[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the inverse Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/InverseJacobiSC.html
        ///</summary>
        corewolf::engine *InverseJacobiSC(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseJacobiSC[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the inverse Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/InverseJacobiSD.html
        ///</summary>
        corewolf::engine *InverseJacobiSD(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseJacobiSD[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the inverse Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/InverseJacobiSN.html
        ///</summary>
        corewolf::engine *InverseJacobiSN(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseJacobiSN[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the symbolic inverse Laplace transform of F[s] in the variable s as f[t] in the variable t.
        /// https://reference.wolfram.com/language/ref/InverseLaplaceTransform.html
        ///</summary>
        corewolf::engine *InverseLaplaceTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseLaplaceTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the numeric inverse Laplace transform at the numerical value .
        /// https://reference.wolfram.com/language/ref/InverseLaplaceTransform.html
        ///</summary>
        corewolf::engine *InverseLaplaceTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseLaplaceTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional inverse Laplace transform of F[s1,…,sn].
        /// https://reference.wolfram.com/language/ref/InverseLaplaceTransform.html
        ///</summary>
        corewolf::engine *InverseLaplaceTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("InverseLaplaceTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the inverse Mellin transform of expr.
        /// https://reference.wolfram.com/language/ref/InverseMellinTransform.html
        ///</summary>
        corewolf::engine *InverseMellinTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseMellinTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the inverse of permutation perm.
        /// https://reference.wolfram.com/language/ref/InversePermutation.html
        ///</summary>
        corewolf::engine *InversePermutation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InversePermutation[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the inverse discrete Radon transform of image.
        /// https://reference.wolfram.com/language/ref/InverseRadon.html
        ///</summary>
        corewolf::engine *InverseRadon(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InverseRadon[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies the width w and the height h of the resulting image.
        /// https://reference.wolfram.com/language/ref/InverseRadon.html
        ///</summary>
        corewolf::engine *InverseRadon(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("InverseRadon[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the inverse Radon transform of expr.
        /// https://reference.wolfram.com/language/ref/InverseRadonTransform.html
        ///</summary>
        corewolf::engine *InverseRadonTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("InverseRadonTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// takes the series s, and gives a series for the inverse of the function represented by s.
        /// https://reference.wolfram.com/language/ref/InverseSeries.html
        ///</summary>
        corewolf::engine *InverseSeries(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InverseSeries[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the variable x in the inverse series.
        /// https://reference.wolfram.com/language/ref/InverseSeries.html
        ///</summary>
        corewolf::engine *InverseSeries(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseSeries[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reconstructs the signal from short-time Fourier data.
        /// https://reference.wolfram.com/language/ref/InverseShortTimeFourier.html
        ///</summary>
        corewolf::engine *InverseShortTimeFourier(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InverseShortTimeFourier[" + arg0 + "]", name);
        }

        ///< summary>
        /// assumes the spectrogram data was computed with partitions of length n.
        /// https://reference.wolfram.com/language/ref/InverseShortTimeFourier.html
        ///</summary>
        corewolf::engine *InverseShortTimeFourier(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseShortTimeFourier[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// assumes partitions with offset d.
        /// https://reference.wolfram.com/language/ref/InverseShortTimeFourier.html
        ///</summary>
        corewolf::engine *InverseShortTimeFourier(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseShortTimeFourier[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// assumes a smoothing window wfun was applied to each partition.
        /// https://reference.wolfram.com/language/ref/InverseShortTimeFourier.html
        ///</summary>
        corewolf::engine *InverseShortTimeFourier(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("InverseShortTimeFourier[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// reconstructs the signal from the magnitude spectrogram data.
        /// https://reference.wolfram.com/language/ref/InverseSpectrogram.html
        ///</summary>
        corewolf::engine *InverseSpectrogram(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InverseSpectrogram[" + arg0 + "]", name);
        }

        ///< summary>
        /// assumes the spectrogram data was computed with partitions of length n.
        /// https://reference.wolfram.com/language/ref/InverseSpectrogram.html
        ///</summary>
        corewolf::engine *InverseSpectrogram(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseSpectrogram[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// assumes partitions with offset d.
        /// https://reference.wolfram.com/language/ref/InverseSpectrogram.html
        ///</summary>
        corewolf::engine *InverseSpectrogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseSpectrogram[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// assumes a smoothing window wfun was applied to each partition.
        /// https://reference.wolfram.com/language/ref/InverseSpectrogram.html
        ///</summary>
        corewolf::engine *InverseSpectrogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("InverseSpectrogram[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the inverse of the survival function for the distribution dist as a function of the variable q.
        /// https://reference.wolfram.com/language/ref/InverseSurvivalFunction.html
        ///</summary>
        corewolf::engine *InverseSurvivalFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseSurvivalFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the inverse transformed region , where reg is a region and f is a function.
        /// https://reference.wolfram.com/language/ref/InverseTransformedRegion.html
        ///</summary>
        corewolf::engine *InverseTransformedRegion(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseTransformedRegion[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the inverse wavelet transform of a DiscreteWaveletData const std::string &dwd.
        /// https://reference.wolfram.com/language/ref/InverseWaveletTransform.html
        ///</summary>
        corewolf::engine *InverseWaveletTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("InverseWaveletTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the inverse transform using the wavelet wave.
        /// https://reference.wolfram.com/language/ref/InverseWaveletTransform.html
        ///</summary>
        corewolf::engine *InverseWaveletTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseWaveletTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the inverse transform from the wavelet coefficients specified by wind.
        /// https://reference.wolfram.com/language/ref/InverseWaveletTransform.html
        ///</summary>
        corewolf::engine *InverseWaveletTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseWaveletTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a value of u for which the Weierstrass function  is equal to p.
        /// https://reference.wolfram.com/language/ref/InverseWeierstrassP.html
        ///</summary>
        corewolf::engine *InverseWeierstrassP(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("InverseWeierstrassP[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an inverse Wishart matrix distribution with ν degrees of freedom and covariance matrix Σ.
        /// https://reference.wolfram.com/language/ref/InverseWishartMatrixDistribution.html
        ///</summary>
        corewolf::engine *InverseWishartMatrixDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("InverseWishartMatrixDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the inverse Z transform of expr.
        /// https://reference.wolfram.com/language/ref/InverseZTransform.html
        ///</summary>
        corewolf::engine *InverseZTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("InverseZTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multiple inverse Z transform of expr.
        /// https://reference.wolfram.com/language/ref/InverseZTransform.html
        ///</summary>
        corewolf::engine *InverseZTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("InverseZTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// displays as space that is the same size as the formatted version of expr.
        /// https://reference.wolfram.com/language/ref/Invisible.html
        ///</summary>
        corewolf::engine *Invisible(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Invisible[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a symbolic representation of an IPv4 or IPv6 IP address.
        /// https://reference.wolfram.com/language/ref/IPAddress.html
        ///</summary>
        corewolf::engine *IPAddress(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IPAddress[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether poly is an irreducible polynomial over the rationals.
        /// https://reference.wolfram.com/language/ref/IrreduciblePolynomialQ.html
        ///</summary>
        corewolf::engine *IrreduciblePolynomialQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IrreduciblePolynomialQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether poly is irreducible modulo a prime p.
        /// https://reference.wolfram.com/language/ref/IrreduciblePolynomialQ.html
        ///</summary>
        corewolf::engine *IrreduciblePolynomialQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IrreduciblePolynomialQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the island entity.
        /// https://reference.wolfram.com/language/ref/IslandData.html
        ///</summary>
        corewolf::engine *IslandData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IslandData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified island entities.
        /// https://reference.wolfram.com/language/ref/IslandData.html
        ///</summary>
        corewolf::engine *IslandData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IslandData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/IslandData.html
        ///</summary>
        corewolf::engine *IslandData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("IslandData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a rational isolating interval for the algebraic number a.
        /// https://reference.wolfram.com/language/ref/IsolatingInterval.html
        ///</summary>
        corewolf::engine *IsolatingInterval(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("IsolatingInterval[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an isolating interval of width at most dx.
        /// https://reference.wolfram.com/language/ref/IsolatingInterval.html
        ///</summary>
        corewolf::engine *IsolatingInterval(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IsolatingInterval[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if the graphs g1 and g2 are isomorphic, and False otherwise.
        /// https://reference.wolfram.com/language/ref/IsomorphicGraphQ.html
        ///</summary>
        corewolf::engine *IsomorphicGraphQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IsomorphicGraphQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if the graph g1 is isomorphic to a subgraph of the graph g2.
        /// https://reference.wolfram.com/language/ref/IsomorphicSubgraphQ.html
        ///</summary>
        corewolf::engine *IsomorphicSubgraphQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IsomorphicSubgraphQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the isotope with atomic number Z and mass number A.
        /// https://reference.wolfram.com/language/ref/IsotopeData.html
        ///</summary>
        corewolf::engine *IsotopeData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IsotopeData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the property for the named isotope.
        /// https://reference.wolfram.com/language/ref/IsotopeData.html
        ///</summary>
        corewolf::engine *IsotopeData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("IsotopeData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an item within constructs such as Grid, Overlay, and Manipulate that displays with expr as the content, and with the specified options applied to the region containing expr.
        /// https://reference.wolfram.com/language/ref/Item.html
        ///</summary>
        corewolf::engine *Item(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Item[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an Ito process , where .
        /// https://reference.wolfram.com/language/ref/ItoProcess.html
        ///</summary>
        corewolf::engine *ItoProcess(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ItoProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses initial condition .
        /// https://reference.wolfram.com/language/ref/ItoProcess.html
        ///</summary>
        corewolf::engine *ItoProcess(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ItoProcess[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses a Wiener process , with covariance Σ.
        /// https://reference.wolfram.com/language/ref/ItoProcess.html
        ///</summary>
        corewolf::engine *ItoProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ItoProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// converts proc to a standard Ito process whenever possible.
        /// https://reference.wolfram.com/language/ref/ItoProcess.html
        ///</summary>
        corewolf::engine *ItoProcess(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ItoProcess[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an Ito process specified by a stochastic differential equation sdeqns, output expression expr, with state x and time t, driven by w following the process dproc.
        /// https://reference.wolfram.com/language/ref/ItoProcess.html
        ///</summary>
        corewolf::engine *ItoProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("ItoProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// gives the Jaccard dissimilarity between Boolean vectors u and v.
        /// https://reference.wolfram.com/language/ref/JaccardDissimilarity.html
        ///</summary>
        corewolf::engine *JaccardDissimilarity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JaccardDissimilarity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the amplitude  for Jacobi elliptic functions.
        /// https://reference.wolfram.com/language/ref/JacobiAmplitude.html
        ///</summary>
        corewolf::engine *JacobiAmplitude(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JacobiAmplitude[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/JacobiCD.html
        ///</summary>
        corewolf::engine *JacobiCD(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JacobiCD[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/JacobiCN.html
        ///</summary>
        corewolf::engine *JacobiCN(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JacobiCN[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/JacobiCS.html
        ///</summary>
        corewolf::engine *JacobiCS(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JacobiCS[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/JacobiDC.html
        ///</summary>
        corewolf::engine *JacobiDC(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JacobiDC[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/JacobiDN.html
        ///</summary>
        corewolf::engine *JacobiDN(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JacobiDN[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/JacobiDS.html
        ///</summary>
        corewolf::engine *JacobiDS(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JacobiDS[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Jacobi epsilon function .
        /// https://reference.wolfram.com/language/ref/JacobiEpsilon.html
        ///</summary>
        corewolf::engine *JacobiEpsilon(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JacobiEpsilon[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/JacobiNC.html
        ///</summary>
        corewolf::engine *JacobiNC(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JacobiNC[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/JacobiND.html
        ///</summary>
        corewolf::engine *JacobiND(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JacobiND[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/JacobiNS.html
        ///</summary>
        corewolf::engine *JacobiNS(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JacobiNS[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Jacobi polynomial .
        /// https://reference.wolfram.com/language/ref/JacobiP.html
        ///</summary>
        corewolf::engine *JacobiP(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("JacobiP[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/JacobiSC.html
        ///</summary>
        corewolf::engine *JacobiSC(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JacobiSC[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/JacobiSD.html
        ///</summary>
        corewolf::engine *JacobiSD(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JacobiSD[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Jacobi elliptic function .
        /// https://reference.wolfram.com/language/ref/JacobiSN.html
        ///</summary>
        corewolf::engine *JacobiSN(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JacobiSN[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Jacobi symbol .
        /// https://reference.wolfram.com/language/ref/JacobiSymbol.html
        ///</summary>
        corewolf::engine *JacobiSymbol(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JacobiSymbol[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Jacobi zeta function .
        /// https://reference.wolfram.com/language/ref/JacobiZeta.html
        ///</summary>
        corewolf::engine *JacobiZeta(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JacobiZeta[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Jacobi zeta function .
        /// https://reference.wolfram.com/language/ref/JacobiZN.html
        ///</summary>
        corewolf::engine *JacobiZN(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JacobiZN[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the sporadic simple Janko group .
        /// https://reference.wolfram.com/language/ref/JankoGroupJ1.html
        ///</summary>
        corewolf::engine *JankoGroupJ1(const std::string &name = "")
        {
            return this->execute("JankoGroupJ1[]", name);
        }

        ///< summary>
        /// represents the sporadic simple Janko group .
        /// https://reference.wolfram.com/language/ref/JankoGroupJ2.html
        ///</summary>
        corewolf::engine *JankoGroupJ2(const std::string &name = "")
        {
            return this->execute("JankoGroupJ2[]", name);
        }

        ///< summary>
        /// represents the sporadic simple Janko group .
        /// https://reference.wolfram.com/language/ref/JankoGroupJ3.html
        ///</summary>
        corewolf::engine *JankoGroupJ3(const std::string &name = "")
        {
            return this->execute("JankoGroupJ3[]", name);
        }

        ///< summary>
        /// represents the sporadic simple Janko group .
        /// https://reference.wolfram.com/language/ref/JankoGroupJ4.html
        ///</summary>
        corewolf::engine *JankoGroupJ4(const std::string &name = "")
        {
            return this->execute("JankoGroupJ4[]", name);
        }

        ///< summary>
        /// tests whether data is normally distributed using the Jarque–Bera ALM test.
        /// https://reference.wolfram.com/language/ref/JarqueBeraALMTest.html
        ///</summary>
        corewolf::engine *JarqueBeraALMTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("JarqueBeraALMTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/JarqueBeraALMTest.html
        ///</summary>
        corewolf::engine *JarqueBeraALMTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JarqueBeraALMTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a bounded Johnson distribution with shape parameters γ, δ, location parameter μ, and scale parameter σ.
        /// https://reference.wolfram.com/language/ref/JohnsonDistribution.html
        ///</summary>
        corewolf::engine *JohnsonDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("JohnsonDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// concatenates lists or other expressions that share the same head.
        /// https://reference.wolfram.com/language/ref/Join.html
        ///</summary>
        corewolf::engine *Join(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Join[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// joins the objects at level n in each of the listi.
        /// https://reference.wolfram.com/language/ref/Join.html
        ///</summary>
        corewolf::engine *Join(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Join[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives a list of associations obtained by joining those pairs of associations ai and bj in which the values associated with key are the same.
        /// https://reference.wolfram.com/language/ref/JoinAcross.html
        ///</summary>
        corewolf::engine *JoinAcross(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("JoinAcross[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// joins pairs of associations only when the values associated with all keys keyi are the same.
        /// https://reference.wolfram.com/language/ref/JoinAcross.html
        ///</summary>
        corewolf::engine *JoinAcross(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("JoinAcross[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses joinspec to determine when to allow associations that contain missing elements to be generated.
        /// https://reference.wolfram.com/language/ref/JoinAcross.html
        ///</summary>
        corewolf::engine *JoinAcross(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("JoinAcross[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a curve consisting of segment1 followed by segment2 etc.
        /// https://reference.wolfram.com/language/ref/JoinedCurve.html
        ///</summary>
        corewolf::engine *JoinedCurve(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("JoinedCurve[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// is a graphics directive that specifies what type of joins should be used to connect segments of lines, tubes, edges, and related primitives.
        /// https://reference.wolfram.com/language/ref/JoinForm.html
        ///</summary>
        corewolf::engine *JoinForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("JoinForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields the Jordan decomposition of a square matrix m. The result is a list {s,j} where s is a similarity matrix and j is the Jordan canonical form of m.
        /// https://reference.wolfram.com/language/ref/JordanDecomposition.html
        ///</summary>
        corewolf::engine *JordanDecomposition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("JordanDecomposition[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields the Jordan decomposition of the state-space model ssm.
        /// https://reference.wolfram.com/language/ref/JordanModelDecomposition.html
        ///</summary>
        corewolf::engine *JordanModelDecomposition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("JordanModelDecomposition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the current number of days since noon on November 24, 4714 BCE in the GMT time zone.
        /// https://reference.wolfram.com/language/ref/JulianDate.html
        ///</summary>
        corewolf::engine *JulianDate(const std::string &name = "")
        {
            return this->execute("JulianDate[]", name);
        }

        ///< summary>
        /// gives the number of days for the specified date.
        /// https://reference.wolfram.com/language/ref/JulianDate.html
        ///</summary>
        corewolf::engine *JulianDate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("JulianDate[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the variant for the specified date.
        /// https://reference.wolfram.com/language/ref/JulianDate.html
        ///</summary>
        corewolf::engine *JulianDate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JulianDate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Böttcher coordinate of z with respect to the quadratic Julia set Jc.
        /// https://reference.wolfram.com/language/ref/JuliaSetBoettcher.html
        ///</summary>
        corewolf::engine *JuliaSetBoettcher(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JuliaSetBoettcher[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the number of iterations, beginning with the complex number , of the function  needed to determine whether p is in the Julia set of f.
        /// https://reference.wolfram.com/language/ref/JuliaSetIterationCount.html
        ///</summary>
        corewolf::engine *JuliaSetIterationCount(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("JuliaSetIterationCount[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the number of iterations, beginning with the complex number , of the function  needed to determine whether p is in the Julia set of .
        /// https://reference.wolfram.com/language/ref/JuliaSetIterationCount.html
        ///</summary>
        corewolf::engine *JuliaSetIterationCount(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JuliaSetIterationCount[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a list of the number of iterations required to determine whether each member of {p1,p2,…} is in the Julia set of f.
        /// https://reference.wolfram.com/language/ref/JuliaSetIterationCount.html
        ///</summary>
        corewolf::engine *JuliaSetIterationCount(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("JuliaSetIterationCount[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// returns a list of the number of iterations required to determine whether each member of {p1,p2,…} is in the Julia set of .
        /// https://reference.wolfram.com/language/ref/JuliaSetIterationCount.html
        ///</summary>
        corewolf::engine *JuliaSetIterationCount(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("JuliaSetIterationCount[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots the Julia set of the rational function f of the variable z.
        /// https://reference.wolfram.com/language/ref/JuliaSetPlot.html
        ///</summary>
        corewolf::engine *JuliaSetPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JuliaSetPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// plots the Julia set of the function .
        /// https://reference.wolfram.com/language/ref/JuliaSetPlot.html
        ///</summary>
        corewolf::engine *JuliaSetPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("JuliaSetPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a list of coordinates approximating the real and imaginary parts of the complex numbers in the Julia set of the rational function f of the variable z.
        /// https://reference.wolfram.com/language/ref/JuliaSetPoints.html
        ///</summary>
        corewolf::engine *JuliaSetPoints(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("JuliaSetPoints[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a list of coordinates of points approximating the Julia set of the function .
        /// https://reference.wolfram.com/language/ref/JuliaSetPoints.html
        ///</summary>
        corewolf::engine *JuliaSetPoints(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("JuliaSetPoints[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes a Kagi chart with prices pi at date datei.
        /// https://reference.wolfram.com/language/ref/KagiChart.html
        ///</summary>
        corewolf::engine *KagiChart(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("KagiChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a Kagi chart of closing prices for the financial entity "name" over the date range daterange.
        /// https://reference.wolfram.com/language/ref/KagiChart.html
        ///</summary>
        corewolf::engine *KagiChart(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("KagiChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a Kagi chart with reversal threshold rt.
        /// https://reference.wolfram.com/language/ref/KagiChart.html
        ///</summary>
        corewolf::engine *KagiChart(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KagiChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Kaiser–Bessel window function of x.
        /// https://reference.wolfram.com/language/ref/KaiserBesselWindow.html
        ///</summary>
        corewolf::engine *KaiserBesselWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KaiserBesselWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Kaiser window function of x.
        /// https://reference.wolfram.com/language/ref/KaiserWindow.html
        ///</summary>
        corewolf::engine *KaiserWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KaiserWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the parameter α.
        /// https://reference.wolfram.com/language/ref/KaiserWindow.html
        ///</summary>
        corewolf::engine *KaiserWindow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KaiserWindow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// constructs the Kalman estimator for the StateSpaceModel ssm with process and measurement noise covariance matrices w and v.
        /// https://reference.wolfram.com/language/ref/KalmanEstimator.html
        ///</summary>
        corewolf::engine *KalmanEstimator(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("KalmanEstimator[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// specifies sensors as the noisy measurements of ssm.
        /// https://reference.wolfram.com/language/ref/KalmanEstimator.html
        ///</summary>
        corewolf::engine *KalmanEstimator(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("KalmanEstimator[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// filters data using the time series model given by tproc.
        /// https://reference.wolfram.com/language/ref/KalmanFilter.html
        ///</summary>
        corewolf::engine *KalmanFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KalmanFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Karhunen–Loeve transform {{b1,b2,…},m} of the numerical arrays {a1,a2,…}, where m.aibi.
        /// https://reference.wolfram.com/language/ref/KarhunenLoeveDecomposition.html
        ///</summary>
        corewolf::engine *KarhunenLoeveDecomposition(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("KarhunenLoeveDecomposition[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// uses the inverse of the matrix m for transforming bi to ai.
        /// https://reference.wolfram.com/language/ref/KarhunenLoeveDecomposition.html
        ///</summary>
        corewolf::engine *KarhunenLoeveDecomposition(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KarhunenLoeveDecomposition[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a binary tree with n vertices.
        /// https://reference.wolfram.com/language/ref/KaryTree.html
        ///</summary>
        corewolf::engine *KaryTree(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KaryTree[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a k-ary tree with n vertices.
        /// https://reference.wolfram.com/language/ref/KaryTree.html
        ///</summary>
        corewolf::engine *KaryTree(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KaryTree[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of Katz centralities for the vertices in the graph g and weight α.
        /// https://reference.wolfram.com/language/ref/KatzCentrality.html
        ///</summary>
        corewolf::engine *KatzCentrality(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KatzCentrality[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of Katz centralities using weight α and initial centralities β.
        /// https://reference.wolfram.com/language/ref/KatzCentrality.html
        ///</summary>
        corewolf::engine *KatzCentrality(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("KatzCentrality[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/KatzCentrality.html
        ///</summary>
        corewolf::engine *KatzCentrality(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KatzCentrality[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the k-core components of the underlying simple graph of g.
        /// https://reference.wolfram.com/language/ref/KCoreComponents.html
        ///</summary>
        corewolf::engine *KCoreComponents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KCoreComponents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the k-core components with vertex in-degrees at least k.
        /// https://reference.wolfram.com/language/ref/KCoreComponents.html
        ///</summary>
        corewolf::engine *KCoreComponents(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("KCoreComponents[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/KCoreComponents.html
        ///</summary>
        corewolf::engine *KCoreComponents(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KCoreComponents[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a K distribution with shape parameters ν and w.
        /// https://reference.wolfram.com/language/ref/KDistribution.html
        ///</summary>
        corewolf::engine *KDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the k-edge-connected components of the graph g.
        /// https://reference.wolfram.com/language/ref/KEdgeConnectedComponents.html
        ///</summary>
        corewolf::engine *KEdgeConnectedComponents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KEdgeConnectedComponents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the k-edge-connected components that include at least one of the vertices v1, v2, ….
        /// https://reference.wolfram.com/language/ref/KEdgeConnectedComponents.html
        ///</summary>
        corewolf::engine *KEdgeConnectedComponents(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("KEdgeConnectedComponents[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/KEdgeConnectedComponents.html
        ///</summary>
        corewolf::engine *KEdgeConnectedComponents(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KEdgeConnectedComponents[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is k-edge-connected and False otherwise.
        /// https://reference.wolfram.com/language/ref/KEdgeConnectedGraphQ.html
        ///</summary>
        corewolf::engine *KEdgeConnectedGraphQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KEdgeConnectedGraphQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Kelvin function .
        /// https://reference.wolfram.com/language/ref/KelvinBei.html
        ///</summary>
        corewolf::engine *KelvinBei(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KelvinBei[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Kelvin function .
        /// https://reference.wolfram.com/language/ref/KelvinBei.html
        ///</summary>
        corewolf::engine *KelvinBei(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KelvinBei[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Kelvin function .
        /// https://reference.wolfram.com/language/ref/KelvinBer.html
        ///</summary>
        corewolf::engine *KelvinBer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KelvinBer[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Kelvin function .
        /// https://reference.wolfram.com/language/ref/KelvinBer.html
        ///</summary>
        corewolf::engine *KelvinBer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KelvinBer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Kelvin function .
        /// https://reference.wolfram.com/language/ref/KelvinKei.html
        ///</summary>
        corewolf::engine *KelvinKei(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KelvinKei[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Kelvin function .
        /// https://reference.wolfram.com/language/ref/KelvinKei.html
        ///</summary>
        corewolf::engine *KelvinKei(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KelvinKei[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Kelvin function .
        /// https://reference.wolfram.com/language/ref/KelvinKer.html
        ///</summary>
        corewolf::engine *KelvinKer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KelvinKer[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Kelvin function .
        /// https://reference.wolfram.com/language/ref/KelvinKer.html
        ///</summary>
        corewolf::engine *KelvinKer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KelvinKer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives Kendall's rank correlation coefficient  for the vectors v1 and v2.
        /// https://reference.wolfram.com/language/ref/KendallTau.html
        ///</summary>
        corewolf::engine *KendallTau(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KendallTau[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives Kendall's rank correlation coefficients  for the matrix m.
        /// https://reference.wolfram.com/language/ref/KendallTau.html
        ///</summary>
        corewolf::engine *KendallTau(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KendallTau[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the  Kendall rank correlation for the multivariate symbolic distribution dist.
        /// https://reference.wolfram.com/language/ref/KendallTau.html
        ///</summary>
        corewolf::engine *KendallTau(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("KendallTau[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether the vectors v1 and v2 are independent.
        /// https://reference.wolfram.com/language/ref/KendallTauTest.html
        ///</summary>
        corewolf::engine *KendallTauTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KendallTauTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies a kernel that can be used for RemoteEvaluate or LaunchKernels.
        /// https://reference.wolfram.com/language/ref/KernelConfiguration.html
        ///</summary>
        corewolf::engine *KernelConfiguration(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KernelConfiguration[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a function to be evaluated in the Wolfram Engine kernel, even when it is called inside compiled code.
        /// https://reference.wolfram.com/language/ref/KernelFunction.html
        ///</summary>
        corewolf::engine *KernelFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KernelFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a kernel mixture distribution based on the data values xi.
        /// https://reference.wolfram.com/language/ref/KernelMixtureDistribution.html
        ///</summary>
        corewolf::engine *KernelMixtureDistribution(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("KernelMixtureDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a multivariate kernel mixture distribution based on data values {xi,yi,…}.
        /// https://reference.wolfram.com/language/ref/KernelMixtureDistribution.html
        ///</summary>
        corewolf::engine *KernelMixtureDistribution(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("KernelMixtureDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a kernel mixture distribution with bandwidth bw.
        /// https://reference.wolfram.com/language/ref/KernelMixtureDistribution.html
        ///</summary>
        corewolf::engine *KernelMixtureDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KernelMixtureDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a kernel mixture distribution with bandwidth bw and smoothing kernel ker.
        /// https://reference.wolfram.com/language/ref/KernelMixtureDistribution.html
        ///</summary>
        corewolf::engine *KernelMixtureDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("KernelMixtureDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a kernel available for parallel computing.
        /// https://reference.wolfram.com/language/ref/KernelObject.html
        ///</summary>
        corewolf::engine *KernelObject(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("KernelObject[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the list of running kernels available for parallel computing.
        /// https://reference.wolfram.com/language/ref/Kernels.html
        ///</summary>
        corewolf::engine *Kernels(const std::string &name = "")
        {
            return this->execute("Kernels[]", name);
        }

        ///< summary>
        /// represents a key used to access a value in an association.
        /// https://reference.wolfram.com/language/ref/Key.html
        ///</summary>
        corewolf::engine *Key(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Key[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates an association in which only elements whose keys appear in assocall but not in any of the associ are retained.
        /// https://reference.wolfram.com/language/ref/KeyComplement.html
        ///</summary>
        corewolf::engine *KeyComplement(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("KeyComplement[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// yields an association from which elements with keys keyi have been dropped.
        /// https://reference.wolfram.com/language/ref/KeyDrop.html
        ///</summary>
        corewolf::engine *KeyDrop(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("KeyDrop[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of associations.
        /// https://reference.wolfram.com/language/ref/KeyDrop.html
        ///</summary>
        corewolf::engine *KeyDrop(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KeyDrop[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of KeyDrop that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/KeyDrop.html
        ///</summary>
        corewolf::engine *KeyDrop(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KeyDrop[" + arg0 + "]", name);
        }

        ///< summary>
        /// changes the association a by dropping the element with the specified key.
        /// https://reference.wolfram.com/language/ref/KeyDropFrom.html
        ///</summary>
        corewolf::engine *KeyDropFrom(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KeyDropFrom[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// drops the elements with keys keyi.
        /// https://reference.wolfram.com/language/ref/KeyDropFrom.html
        ///</summary>
        corewolf::engine *KeyDropFrom(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("KeyDropFrom[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns True if the specified key exists in the association assoc, and False otherwise.
        /// https://reference.wolfram.com/language/ref/KeyExistsQ.html
        ///</summary>
        corewolf::engine *KeyExistsQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KeyExistsQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of KeyExistsQ that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/KeyExistsQ.html
        ///</summary>
        corewolf::engine *KeyExistsQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KeyExistsQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if no key in the association assoc matches form, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/KeyFreeQ.html
        ///</summary>
        corewolf::engine *KeyFreeQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KeyFreeQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of KeyFreeQ that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/KeyFreeQ.html
        ///</summary>
        corewolf::engine *KeyFreeQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KeyFreeQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a list of associations in which only elements whose keys appear in all the associ are retained.
        /// https://reference.wolfram.com/language/ref/KeyIntersection.html
        ///</summary>
        corewolf::engine *KeyIntersection(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("KeyIntersection[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// maps f over the keys in an association, giving f[key1]val1,f[key2]val2,….
        /// https://reference.wolfram.com/language/ref/KeyMap.html
        ///</summary>
        corewolf::engine *KeyMap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("KeyMap[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an operator form of KeyMap that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/KeyMap.html
        ///</summary>
        corewolf::engine *KeyMap(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KeyMap[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if a key in the association assoc matches form, and False otherwise.
        /// https://reference.wolfram.com/language/ref/KeyMemberQ.html
        ///</summary>
        corewolf::engine *KeyMemberQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KeyMemberQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of KeyMemberQ that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/KeyMemberQ.html
        ///</summary>
        corewolf::engine *KeyMemberQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KeyMemberQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of the keys keyi in an association.
        /// https://reference.wolfram.com/language/ref/Keys.html
        ///</summary>
        corewolf::engine *Keys(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Keys[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of the keyi in a list of rules.
        /// https://reference.wolfram.com/language/ref/Keys.html
        ///</summary>
        corewolf::engine *Keys(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Keys[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of keys in expr, wrapping each of them with head h before evaluation.
        /// https://reference.wolfram.com/language/ref/Keys.html
        ///</summary>
        corewolf::engine *Keys(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Keys[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// selects elements in the association assoc for which crit applied to their keys is True.
        /// https://reference.wolfram.com/language/ref/KeySelect.html
        ///</summary>
        corewolf::engine *KeySelect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KeySelect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of KeySelect that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/KeySelect.html
        ///</summary>
        corewolf::engine *KeySelect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KeySelect[" + arg0 + "]", name);
        }

        ///< summary>
        /// orders the elements of an association by sorting its keys.
        /// https://reference.wolfram.com/language/ref/KeySort.html
        ///</summary>
        corewolf::engine *KeySort(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KeySort[" + arg0 + "]", name);
        }

        ///< summary>
        /// orders the elements of an association using the ordering function p.
        /// https://reference.wolfram.com/language/ref/KeySort.html
        ///</summary>
        corewolf::engine *KeySort(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KeySort[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sorts the elements of an association in the order defined by applying f to each of their keys.
        /// https://reference.wolfram.com/language/ref/KeySortBy.html
        ///</summary>
        corewolf::engine *KeySortBy(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KeySortBy[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of KeySortBy that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/KeySortBy.html
        ///</summary>
        corewolf::engine *KeySortBy(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KeySortBy[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields an association containing only the elements with keys keyi.
        /// https://reference.wolfram.com/language/ref/KeyTake.html
        ///</summary>
        corewolf::engine *KeyTake(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("KeyTake[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of associations.
        /// https://reference.wolfram.com/language/ref/KeyTake.html
        ///</summary>
        corewolf::engine *KeyTake(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KeyTake[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of KeyTake that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/KeyTake.html
        ///</summary>
        corewolf::engine *KeyTake(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("KeyTake[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a list of associations in which each association has the union of the keys of the associ, padding by inserting values of Missing[…] if necessary.
        /// https://reference.wolfram.com/language/ref/KeyUnion.html
        ///</summary>
        corewolf::engine *KeyUnion(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("KeyUnion[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// uses f[key] as the value associated with a missing key.
        /// https://reference.wolfram.com/language/ref/KeyUnion.html
        ///</summary>
        corewolf::engine *KeyUnion(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KeyUnion[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list {f[key1,val1],f[key2,val2],…}.
        /// https://reference.wolfram.com/language/ref/KeyValueMap.html
        ///</summary>
        corewolf::engine *KeyValueMap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("KeyValueMap[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an operator form of KeyValueMap that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/KeyValueMap.html
        ///</summary>
        corewolf::engine *KeyValueMap(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KeyValueMap[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a pattern const std::string &that represents an association or list of rules that includes elements matching each of the patti.
        /// https://reference.wolfram.com/language/ref/KeyValuePattern.html
        ///</summary>
        corewolf::engine *KeyValuePattern(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("KeyValuePattern[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// kills the external process represented by the ProcessObject proc.
        /// https://reference.wolfram.com/language/ref/KillProcess.html
        ///</summary>
        corewolf::engine *KillProcess(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KillProcess[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the graph with Kirchhoff matrix kmat.
        /// https://reference.wolfram.com/language/ref/KirchhoffGraph.html
        ///</summary>
        corewolf::engine *KirchhoffGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KirchhoffGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the graph with vertices vi and Kirchhoff matrix kmat.
        /// https://reference.wolfram.com/language/ref/KirchhoffGraph.html
        ///</summary>
        corewolf::engine *KirchhoffGraph(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KirchhoffGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Kirchhoff matrix of the graph g.
        /// https://reference.wolfram.com/language/ref/KirchhoffMatrix.html
        ///</summary>
        corewolf::engine *KirchhoffMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KirchhoffMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/KirchhoffMatrix.html
        ///</summary>
        corewolf::engine *KirchhoffMatrix(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("KirchhoffMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Klein invariant modular elliptic function .
        /// https://reference.wolfram.com/language/ref/KleinInvariantJ.html
        ///</summary>
        corewolf::engine *KleinInvariantJ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KleinInvariantJ[" + arg0 + "]", name);
        }

        ///< summary>
        /// solves the knapsack problem of finding the maximum number of items associated with each of the costi, subject to the constraint that the total cost is not larger than maxtotalcost.
        /// https://reference.wolfram.com/language/ref/KnapsackSolve.html
        ///</summary>
        corewolf::engine *KnapsackSolve(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KnapsackSolve[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a number of items that maximizes the total payoff, while satisfying the constraint on the total cost.
        /// https://reference.wolfram.com/language/ref/KnapsackSolve.html
        ///</summary>
        corewolf::engine *KnapsackSolve(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("KnapsackSolve[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds a result that gives a total payoff not larger than maxtotalpayoff.
        /// https://reference.wolfram.com/language/ref/KnapsackSolve.html
        ///</summary>
        corewolf::engine *KnapsackSolve(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("KnapsackSolve[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// labels each type of item and gives the result as an association.
        /// https://reference.wolfram.com/language/ref/KnapsackSolve.html
        ///</summary>
        corewolf::engine *KnapsackSolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("KnapsackSolve[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a Knight's tour graph on an mn chessboard.
        /// https://reference.wolfram.com/language/ref/KnightTourGraph.html
        ///</summary>
        corewolf::engine *KnightTourGraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KnightTourGraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified property for a knot.
        /// https://reference.wolfram.com/language/ref/KnotData.html
        ///</summary>
        corewolf::engine *KnotData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KnotData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an image of the knot.
        /// https://reference.wolfram.com/language/ref/KnotData.html
        ///</summary>
        corewolf::engine *KnotData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KnotData[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if expr is a canonical unit, and False otherwise.
        /// https://reference.wolfram.com/language/ref/KnownUnitQ.html
        ///</summary>
        corewolf::engine *KnownUnitQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KnownUnitQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the line segments representing the n-step Koch curve.
        /// https://reference.wolfram.com/language/ref/KochCurve.html
        ///</summary>
        corewolf::engine *KochCurve(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KochCurve[" + arg0 + "]", name);
        }

        ///< summary>
        /// takes a series of steps of unit length at successive relative angles θi.
        /// https://reference.wolfram.com/language/ref/KochCurve.html
        ///</summary>
        corewolf::engine *KochCurve(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("KochCurve[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// takes successive steps of lengths proportional to ri.
        /// https://reference.wolfram.com/language/ref/KochCurve.html
        ///</summary>
        corewolf::engine *KochCurve(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("KochCurve[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// tests whether data is normally distributed using the Kolmogorov–Smirnov test.
        /// https://reference.wolfram.com/language/ref/KolmogorovSmirnovTest.html
        ///</summary>
        corewolf::engine *KolmogorovSmirnovTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KolmogorovSmirnovTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether data is distributed according to dist using the Kolmogorov–Smirnov test.
        /// https://reference.wolfram.com/language/ref/KolmogorovSmirnovTest.html
        ///</summary>
        corewolf::engine *KolmogorovSmirnovTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KolmogorovSmirnovTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/KolmogorovSmirnovTest.html
        ///</summary>
        corewolf::engine *KolmogorovSmirnovTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("KolmogorovSmirnovTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Kronecker delta , equal to 1 if all the  are equal, and 0 otherwise.
        /// https://reference.wolfram.com/language/ref/KroneckerDelta.html
        ///</summary>
        corewolf::engine *KroneckerDelta(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("KroneckerDelta[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields the Kronecker decomposition of a descriptor state-space model ssm.
        /// https://reference.wolfram.com/language/ref/KroneckerModelDecomposition.html
        ///</summary>
        corewolf::engine *KroneckerModelDecomposition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KroneckerModelDecomposition[" + arg0 + "]", name);
        }

        ///< summary>
        /// constructs the Kronecker product of the arrays mi.
        /// https://reference.wolfram.com/language/ref/KroneckerProduct.html
        ///</summary>
        corewolf::engine *KroneckerProduct(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("KroneckerProduct[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Kronecker symbol .
        /// https://reference.wolfram.com/language/ref/KroneckerSymbol.html
        ///</summary>
        corewolf::engine *KroneckerSymbol(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KroneckerSymbol[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether data is normally distributed using the Kuiper test.
        /// https://reference.wolfram.com/language/ref/KuiperTest.html
        ///</summary>
        corewolf::engine *KuiperTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("KuiperTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether data is distributed according to dist using the Kuiper test.
        /// https://reference.wolfram.com/language/ref/KuiperTest.html
        ///</summary>
        corewolf::engine *KuiperTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KuiperTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/KuiperTest.html
        ///</summary>
        corewolf::engine *KuiperTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("KuiperTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Kumaraswamy distribution with shape parameters α and β.
        /// https://reference.wolfram.com/language/ref/KumaraswamyDistribution.html
        ///</summary>
        corewolf::engine *KumaraswamyDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KumaraswamyDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the coefficient of kurtosis for the elements in list.
        /// https://reference.wolfram.com/language/ref/Kurtosis.html
        ///</summary>
        corewolf::engine *Kurtosis(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Kurtosis[" + arg0 + "]", name);
        }

        ///< summary>
        /// computes for each element p in data the variance of the values in the four (r+1)×(r+1) squares that have p as a corner, and replaces p with the mean of the values of the square with least variance.
        /// https://reference.wolfram.com/language/ref/KuwaharaFilter.html
        ///</summary>
        corewolf::engine *KuwaharaFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KuwaharaFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the k-vertex-connected components of the graph g.
        /// https://reference.wolfram.com/language/ref/KVertexConnectedComponents.html
        ///</summary>
        corewolf::engine *KVertexConnectedComponents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KVertexConnectedComponents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the k-vertex-connected components that include at least one of the vertices v1, v2, … .
        /// https://reference.wolfram.com/language/ref/KVertexConnectedComponents.html
        ///</summary>
        corewolf::engine *KVertexConnectedComponents(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("KVertexConnectedComponents[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is k-vertex-connected and False otherwise.
        /// https://reference.wolfram.com/language/ref/KVertexConnectedGraphQ.html
        ///</summary>
        corewolf::engine *KVertexConnectedGraphQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("KVertexConnectedGraphQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a color in the Lab color space with lightness l and color components a and b.
        /// https://reference.wolfram.com/language/ref/LABColor.html
        ///</summary>
        corewolf::engine *LABColor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LABColor[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// specifies opacity α.
        /// https://reference.wolfram.com/language/ref/LABColor.html
        ///</summary>
        corewolf::engine *LABColor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("LABColor[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// returns a color from an HTML color name etc.
        /// https://reference.wolfram.com/language/ref/LABColor.html
        ///</summary>
        corewolf::engine *LABColor(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LABColor[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a point in a compound expression to which control can be transferred using Goto.
        /// https://reference.wolfram.com/language/ref/Label.html
        ///</summary>
        corewolf::engine *Label(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Label[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays expr labeled with lbl.
        /// https://reference.wolfram.com/language/ref/Labeled.html
        ///</summary>
        corewolf::engine *Labeled(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Labeled[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// places lbl at a position specified by pos.
        /// https://reference.wolfram.com/language/ref/Labeled.html
        ///</summary>
        corewolf::engine *Labeled(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Labeled[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// places the lbli at positions posi.
        /// https://reference.wolfram.com/language/ref/Labeled.html
        ///</summary>
        corewolf::engine *Labeled(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Labeled[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// places the lbli at the bottom, left, top, and right, respectively.
        /// https://reference.wolfram.com/language/ref/Labeled.html
        ///</summary>
        corewolf::engine *Labeled(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Labeled[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Laguerre polynomial .
        /// https://reference.wolfram.com/language/ref/LaguerreL.html
        ///</summary>
        corewolf::engine *LaguerreL(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LaguerreL[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the generalized Laguerre polynomial .
        /// https://reference.wolfram.com/language/ref/LaguerreL.html
        ///</summary>
        corewolf::engine *LaguerreL(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LaguerreL[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the lake entity.
        /// https://reference.wolfram.com/language/ref/LakeData.html
        ///</summary>
        corewolf::engine *LakeData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LakeData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified lake entities.
        /// https://reference.wolfram.com/language/ref/LakeData.html
        ///</summary>
        corewolf::engine *LakeData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LakeData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/LakeData.html
        ///</summary>
        corewolf::engine *LakeData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LakeData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the lambda components of the graph g.
        /// https://reference.wolfram.com/language/ref/LambdaComponents.html
        ///</summary>
        corewolf::engine *LambdaComponents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LambdaComponents[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the lambda components that include at least one of the vertices {v1,v2,…}.
        /// https://reference.wolfram.com/language/ref/LambdaComponents.html
        ///</summary>
        corewolf::engine *LambdaComponents(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LambdaComponents[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/LambdaComponents.html
        ///</summary>
        corewolf::engine *LambdaComponents(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LambdaComponents[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the  Lamé function  of order  with elliptic parameter .
        /// https://reference.wolfram.com/language/ref/LameC.html
        ///</summary>
        corewolf::engine *LameC(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("LameC[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the -derivative of the  Lamé function  of order  with elliptic parameter .
        /// https://reference.wolfram.com/language/ref/LameCPrime.html
        ///</summary>
        corewolf::engine *LameCPrime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("LameCPrime[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the  Lamé eigenvalue  of order  with elliptic parameter  for the function LameC[ν,j,z,m].
        /// https://reference.wolfram.com/language/ref/LameEigenvalueA.html
        ///</summary>
        corewolf::engine *LameEigenvalueA(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LameEigenvalueA[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the  Lamé eigenvalue  of order  with elliptic parameter  for the Lamé function LameS[ν,j,z,m].
        /// https://reference.wolfram.com/language/ref/LameEigenvalueB.html
        ///</summary>
        corewolf::engine *LameEigenvalueB(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LameEigenvalueB[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the  Lamé function  of order  with elliptic parameter .
        /// https://reference.wolfram.com/language/ref/LameS.html
        ///</summary>
        corewolf::engine *LameS(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("LameS[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the -derivative of the  Lamé function  of order  with elliptic parameter .
        /// https://reference.wolfram.com/language/ref/LameSPrime.html
        ///</summary>
        corewolf::engine *LameSPrime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("LameSPrime[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the lamina entity.
        /// https://reference.wolfram.com/language/ref/LaminaData.html
        ///</summary>
        corewolf::engine *LaminaData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LaminaData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified lamina entities.
        /// https://reference.wolfram.com/language/ref/LaminaData.html
        ///</summary>
        corewolf::engine *LaminaData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LaminaData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/LaminaData.html
        ///</summary>
        corewolf::engine *LaminaData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LaminaData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Lanczos window function of x.
        /// https://reference.wolfram.com/language/ref/LanczosWindow.html
        ///</summary>
        corewolf::engine *LanczosWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LanczosWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Landau distribution with location parameter μ and scale parameter σ.
        /// https://reference.wolfram.com/language/ref/LandauDistribution.html
        ///</summary>
        corewolf::engine *LandauDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LandauDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Landau distribution with location parameter 0 and scale parameter 1.
        /// https://reference.wolfram.com/language/ref/LandauDistribution.html
        ///</summary>
        corewolf::engine *LandauDistribution(const std::string &name = "")
        {
            return this->execute("LandauDistribution[]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the language entity.
        /// https://reference.wolfram.com/language/ref/LanguageData.html
        ///</summary>
        corewolf::engine *LanguageData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LanguageData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified language entities.
        /// https://reference.wolfram.com/language/ref/LanguageData.html
        ///</summary>
        corewolf::engine *LanguageData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LanguageData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/LanguageData.html
        ///</summary>
        corewolf::engine *LanguageData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LanguageData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// attempts to determine what human language text in string is in, predominantly.
        /// https://reference.wolfram.com/language/ref/LanguageIdentify.html
        ///</summary>
        corewolf::engine *LanguageIdentify(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LanguageIdentify[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Laplace double-exponential distribution with mean μ and scale parameter β.
        /// https://reference.wolfram.com/language/ref/LaplaceDistribution.html
        ///</summary>
        corewolf::engine *LaplaceDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LaplaceDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Laplace double-exponential distribution with mean 0 and scale parameter 1.
        /// https://reference.wolfram.com/language/ref/LaplaceDistribution.html
        ///</summary>
        corewolf::engine *LaplaceDistribution(const std::string &name = "")
        {
            return this->execute("LaplaceDistribution[]", name);
        }

        ///< summary>
        /// gives the symbolic Laplace transform of f[t] in the variable t and returns a transform F[s] in the variable s.
        /// https://reference.wolfram.com/language/ref/LaplaceTransform.html
        ///</summary>
        corewolf::engine *LaplaceTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LaplaceTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the numeric Laplace transform at the numerical value .
        /// https://reference.wolfram.com/language/ref/LaplaceTransform.html
        ///</summary>
        corewolf::engine *LaplaceTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LaplaceTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional Laplace transform of f[t1,…,tn].
        /// https://reference.wolfram.com/language/ref/LaplaceTransform.html
        ///</summary>
        corewolf::engine *LaplaceTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("LaplaceTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Laplacian .
        /// https://reference.wolfram.com/language/ref/Laplacian.html
        ///</summary>
        corewolf::engine *Laplacian(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Laplacian[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Laplacian in the given coordinates chart.
        /// https://reference.wolfram.com/language/ref/Laplacian.html
        ///</summary>
        corewolf::engine *Laplacian(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Laplacian[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// convolves data with a radius-r Laplacian kernel.
        /// https://reference.wolfram.com/language/ref/LaplacianFilter.html
        ///</summary>
        corewolf::engine *LaplacianFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LaplacianFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses radius ri at level i in data.
        /// https://reference.wolfram.com/language/ref/LaplacianFilter.html
        ///</summary>
        corewolf::engine *LaplacianFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LaplacianFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// convolves data with a Laplacian of Gaussian kernel of pixel radius r.
        /// https://reference.wolfram.com/language/ref/LaplacianGaussianFilter.html
        ///</summary>
        corewolf::engine *LaplacianGaussianFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LaplacianGaussianFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// convolves data with a Laplacian of Gaussian kernel of radius r and standard deviation σ.
        /// https://reference.wolfram.com/language/ref/LaplacianGaussianFilter.html
        ///</summary>
        corewolf::engine *LaplacianGaussianFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LaplacianGaussianFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a Laplacian term  with model variables vars.
        /// https://reference.wolfram.com/language/ref/LaplacianPDETerm.html
        ///</summary>
        corewolf::engine *LaplacianPDETerm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LaplacianPDETerm[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the last element in expr.
        /// https://reference.wolfram.com/language/ref/Last.html
        ///</summary>
        corewolf::engine *Last(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Last[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the last element if there are any elements, or def otherwise.
        /// https://reference.wolfram.com/language/ref/Last.html
        ///</summary>
        corewolf::engine *Last(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Last[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the latitude in degrees of a geographic position specified by pos.
        /// https://reference.wolfram.com/language/ref/Latitude.html
        ///</summary>
        corewolf::engine *Latitude(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Latitude[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the latitude referring to the specified geodetic datum.
        /// https://reference.wolfram.com/language/ref/Latitude.html
        ///</summary>
        corewolf::engine *Latitude(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Latitude[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the latitude and longitude in degrees of a geographic position specified by pos.
        /// https://reference.wolfram.com/language/ref/LatitudeLongitude.html
        ///</summary>
        corewolf::engine *LatitudeLongitude(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LatitudeLongitude[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the latitude and longitude referring to the specified geodetic datum.
        /// https://reference.wolfram.com/language/ref/LatitudeLongitude.html
        ///</summary>
        corewolf::engine *LatitudeLongitude(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LatitudeLongitude[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified property for a lattice.
        /// https://reference.wolfram.com/language/ref/LatticeData.html
        ///</summary>
        corewolf::engine *LatticeData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LatticeData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of named lattices of dimension n.
        /// https://reference.wolfram.com/language/ref/LatticeData.html
        ///</summary>
        corewolf::engine *LatticeData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LatticeData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a reduced basis for the set of vectors vi.
        /// https://reference.wolfram.com/language/ref/LatticeReduce.html
        ///</summary>
        corewolf::engine *LatticeReduce(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LatticeReduce[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// launches all currently configured parallel subkernels.
        /// https://reference.wolfram.com/language/ref/LaunchKernels.html
        ///</summary>
        corewolf::engine *LaunchKernels(const std::string &name = "")
        {
            return this->execute("LaunchKernels[]", name);
        }

        ///< summary>
        /// launches n local subkernels on the current computer.
        /// https://reference.wolfram.com/language/ref/LaunchKernels.html
        ///</summary>
        corewolf::engine *LaunchKernels(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LaunchKernels[" + arg0 + "]", name);
        }

        ///< summary>
        /// launches the kernels keri.
        /// https://reference.wolfram.com/language/ref/LaunchKernels.html
        ///</summary>
        corewolf::engine *LaunchKernels(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LaunchKernels[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a layered plot of the graph g.
        /// https://reference.wolfram.com/language/ref/LayeredGraphPlot.html
        ///</summary>
        corewolf::engine *LayeredGraphPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LayeredGraphPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a layered plot of the graph with edges ej.
        /// https://reference.wolfram.com/language/ref/LayeredGraphPlot.html
        ///</summary>
        corewolf::engine *LayeredGraphPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LayeredGraphPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// places the dominant vertex v in the plot at position pos.
        /// https://reference.wolfram.com/language/ref/LayeredGraphPlot.html
        ///</summary>
        corewolf::engine *LayeredGraphPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LayeredGraphPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a 3D layered plot of the graph g.
        /// https://reference.wolfram.com/language/ref/LayeredGraphPlot3D.html
        ///</summary>
        corewolf::engine *LayeredGraphPlot3D(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LayeredGraphPlot3D[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a 3D layered plot of the graph with edges ei.
        /// https://reference.wolfram.com/language/ref/LayeredGraphPlot3D.html
        ///</summary>
        corewolf::engine *LayeredGraphPlot3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LayeredGraphPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// places the dominant vertex v in the plot at position pos.
        /// https://reference.wolfram.com/language/ref/LayeredGraphPlot3D.html
        ///</summary>
        corewolf::engine *LayeredGraphPlot3D(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LayeredGraphPlot3D[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a color in the LCH color space with lightness l, chroma c and hue h.
        /// https://reference.wolfram.com/language/ref/LCHColor.html
        ///</summary>
        corewolf::engine *LCHColor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LCHColor[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// specifies opacity a.
        /// https://reference.wolfram.com/language/ref/LCHColor.html
        ///</summary>
        corewolf::engine *LCHColor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("LCHColor[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// returns a color from an HTML color name etc.
        /// https://reference.wolfram.com/language/ref/LCHColor.html
        ///</summary>
        corewolf::engine *LCHColor(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LCHColor[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the least common multiple of the ni.
        /// https://reference.wolfram.com/language/ref/LCM.html
        ///</summary>
        corewolf::engine *LCM(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LCM[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the total number of indivisible subexpressions in expr.
        /// https://reference.wolfram.com/language/ref/LeafCount.html
        ///</summary>
        corewolf::engine *LeafCount(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LeafCount[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a repeated calendar element caused by a leap period.
        /// https://reference.wolfram.com/language/ref/LeapVariant.html
        ///</summary>
        corewolf::engine *LeapVariant(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LeapVariant[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if the year corresponding to date is a leap year.
        /// https://reference.wolfram.com/language/ref/LeapYearQ.html
        ///</summary>
        corewolf::engine *LeapYearQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LeapYearQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a LearnedDistribution[…] that attempts to represent an underlying distribution for the examples given.
        /// https://reference.wolfram.com/language/ref/LearnDistribution.html
        ///</summary>
        corewolf::engine *LearnDistribution(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LearnDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a distribution generated by LearnDistribution.
        /// https://reference.wolfram.com/language/ref/LearnedDistribution.html
        ///</summary>
        corewolf::engine *LearnedDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LearnedDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds an x that solves the linear least-squares problem for the matrix equation m.x==b.
        /// https://reference.wolfram.com/language/ref/LeastSquares.html
        ///</summary>
        corewolf::engine *LeastSquares(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LeastSquares[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a k-band finite impulse response (FIR) filter kernel of length n designed using a least squares method, given the specified frequencies ωi and amplitudes ai.
        /// https://reference.wolfram.com/language/ref/LeastSquaresFilterKernel.html
        ///</summary>
        corewolf::engine *LeastSquaresFilterKernel(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeastSquaresFilterKernel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses the full filter specification {"type",spec}.
        /// https://reference.wolfram.com/language/ref/LeastSquaresFilterKernel.html
        ///</summary>
        corewolf::engine *LeastSquaresFilterKernel(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LeastSquaresFilterKernel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftArrow.html
        ///</summary>
        corewolf::engine *LeftArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftArrowBar.html
        ///</summary>
        corewolf::engine *LeftArrowBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftArrowBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftArrowRightArrow.html
        ///</summary>
        corewolf::engine *LeftArrowRightArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftArrowRightArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftDownTeeVector.html
        ///</summary>
        corewolf::engine *LeftDownTeeVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftDownTeeVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftDownVector.html
        ///</summary>
        corewolf::engine *LeftDownVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftDownVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftDownVectorBar.html
        ///</summary>
        corewolf::engine *LeftDownVectorBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftDownVectorBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftRightArrow.html
        ///</summary>
        corewolf::engine *LeftRightArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftRightArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftRightVector.html
        ///</summary>
        corewolf::engine *LeftRightVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftRightVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftTee.html
        ///</summary>
        corewolf::engine *LeftTee(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LeftTee[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftTeeArrow.html
        ///</summary>
        corewolf::engine *LeftTeeArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftTeeArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftTeeVector.html
        ///</summary>
        corewolf::engine *LeftTeeVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftTeeVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftTriangle.html
        ///</summary>
        corewolf::engine *LeftTriangle(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftTriangle[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftTriangleBar.html
        ///</summary>
        corewolf::engine *LeftTriangleBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftTriangleBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftTriangleEqual.html
        ///</summary>
        corewolf::engine *LeftTriangleEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftTriangleEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftUpDownVector.html
        ///</summary>
        corewolf::engine *LeftUpDownVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftUpDownVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftUpTeeVector.html
        ///</summary>
        corewolf::engine *LeftUpTeeVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftUpTeeVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftUpVector.html
        ///</summary>
        corewolf::engine *LeftUpVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftUpVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftUpVectorBar.html
        ///</summary>
        corewolf::engine *LeftUpVectorBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftUpVectorBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftVector.html
        ///</summary>
        corewolf::engine *LeftVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LeftVectorBar.html
        ///</summary>
        corewolf::engine *LeftVectorBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LeftVectorBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays expr with legend leg.
        /// https://reference.wolfram.com/language/ref/Legended.html
        ///</summary>
        corewolf::engine *Legended(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Legended[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Legendre polynomial .
        /// https://reference.wolfram.com/language/ref/LegendreP.html
        ///</summary>
        corewolf::engine *LegendreP(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LegendreP[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the associated Legendre polynomial .
        /// https://reference.wolfram.com/language/ref/LegendreP.html
        ///</summary>
        corewolf::engine *LegendreP(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LegendreP[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Legendre function of the second kind .
        /// https://reference.wolfram.com/language/ref/LegendreQ.html
        ///</summary>
        corewolf::engine *LegendreQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LegendreQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the associated Legendre function of the second kind .
        /// https://reference.wolfram.com/language/ref/LegendreQ.html
        ///</summary>
        corewolf::engine *LegendreQ(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LegendreQ[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the number of elements in expr.
        /// https://reference.wolfram.com/language/ref/Length.html
        ///</summary>
        corewolf::engine *Length(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Length[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number of contiguous elements ei starting at the beginning of list for which crit[ei] is True.
        /// https://reference.wolfram.com/language/ref/LengthWhile.html
        ///</summary>
        corewolf::engine *LengthWhile(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LengthWhile[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Lerch transcendent Φ(z,s,a).
        /// https://reference.wolfram.com/language/ref/LerchPhi.html
        ///</summary>
        corewolf::engine *LerchPhi(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LerchPhi[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LessEqualGreater.html
        ///</summary>
        corewolf::engine *LessEqualGreater(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LessEqualGreater[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is an operator form that yields x≤y when applied to an expression x.
        /// https://reference.wolfram.com/language/ref/LessEqualThan.html
        ///</summary>
        corewolf::engine *LessEqualThan(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LessEqualThan[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LessFullEqual.html
        ///</summary>
        corewolf::engine *LessFullEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LessFullEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LessGreater.html
        ///</summary>
        corewolf::engine *LessGreater(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LessGreater[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LessLess.html
        ///</summary>
        corewolf::engine *LessLess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LessLess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LessSlantEqual.html
        ///</summary>
        corewolf::engine *LessSlantEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LessSlantEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is an operator form that yields x<y when applied to an expression x.
        /// https://reference.wolfram.com/language/ref/LessThan.html
        ///</summary>
        corewolf::engine *LessThan(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LessThan[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LessTilde.html
        ///</summary>
        corewolf::engine *LessTilde(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LessTilde[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives an association whose keys are the distinct letters in string, and whose values give the number of times those letters appear in string.
        /// https://reference.wolfram.com/language/ref/LetterCounts.html
        ///</summary>
        corewolf::engine *LetterCounts(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LetterCounts[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives counts of the distinct n-grams consisting of runs of n letters in string.
        /// https://reference.wolfram.com/language/ref/LetterCounts.html
        ///</summary>
        corewolf::engine *LetterCounts(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LetterCounts[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// allows the characters ci to appear in n-grams, in addition to ordinary letters.
        /// https://reference.wolfram.com/language/ref/LetterCounts.html
        ///</summary>
        corewolf::engine *LetterCounts(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("LetterCounts[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the position of the character c in the English alphabet.
        /// https://reference.wolfram.com/language/ref/LetterNumber.html
        ///</summary>
        corewolf::engine *LetterNumber(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LetterNumber[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the position of c in the alphabet specified by alpha.
        /// https://reference.wolfram.com/language/ref/LetterNumber.html
        ///</summary>
        corewolf::engine *LetterNumber(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LetterNumber[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if all the characters in the string are letters, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/LetterQ.html
        ///</summary>
        corewolf::engine *LetterQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LetterQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of all subexpressions of expr on levels specified by levelspec.
        /// https://reference.wolfram.com/language/ref/Level.html
        ///</summary>
        corewolf::engine *Level(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Level[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f to the sequence of subexpressions.
        /// https://reference.wolfram.com/language/ref/Level.html
        ///</summary>
        corewolf::engine *Level(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Level[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether the variance of data is 1.
        /// https://reference.wolfram.com/language/ref/LeveneTest.html
        ///</summary>
        corewolf::engine *LeveneTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LeveneTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the variances of data1, data2, … are equal.
        /// https://reference.wolfram.com/language/ref/LeveneTest.html
        ///</summary>
        corewolf::engine *LeveneTest(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LeveneTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/LeveneTest.html
        ///</summary>
        corewolf::engine *LeveneTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LeveneTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the d-dimensional Levi-Civita totally antisymmetric tensor.
        /// https://reference.wolfram.com/language/ref/LeviCivitaTensor.html
        ///</summary>
        corewolf::engine *LeviCivitaTensor(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LeviCivitaTensor[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Lévy distribution with location parameter μ and dispersion parameter σ.
        /// https://reference.wolfram.com/language/ref/LevyDistribution.html
        ///</summary>
        corewolf::engine *LevyDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LevyDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives Order[ai,bi] for the first non-coinciding pair ai,bi of elements, and 0 if the lists are identical.
        /// https://reference.wolfram.com/language/ref/LexicographicOrder.html
        ///</summary>
        corewolf::engine *LexicographicOrder(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LexicographicOrder[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses the ordering function p to compare ai with bi.
        /// https://reference.wolfram.com/language/ref/LexicographicOrder.html
        ///</summary>
        corewolf::engine *LexicographicOrder(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LexicographicOrder[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form that compares lists when applied to {a1,a2,…}, {b1,b2,…}.
        /// https://reference.wolfram.com/language/ref/LexicographicOrder.html
        ///</summary>
        corewolf::engine *LexicographicOrder(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LexicographicOrder[" + arg0 + "]", name);
        }

        ///< summary>
        /// sorts the list of expressions ei in lexicographic order.
        /// https://reference.wolfram.com/language/ref/LexicographicSort.html
        ///</summary>
        corewolf::engine *LexicographicSort(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LexicographicSort[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// compares elements of the ei expressions using the ordering function p.
        /// https://reference.wolfram.com/language/ref/LexicographicSort.html
        ///</summary>
        corewolf::engine *LexicographicSort(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LexicographicSort[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies the data type for a LibraryFunction argument or result to be datatype.
        /// https://reference.wolfram.com/language/ref/LibraryDataType.html
        ///</summary>
        corewolf::engine *LibraryDataType(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LibraryDataType[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies an element type etype for data structures.
        /// https://reference.wolfram.com/language/ref/LibraryDataType.html
        ///</summary>
        corewolf::engine *LibraryDataType(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LibraryDataType[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies an array depth d for array data types.
        /// https://reference.wolfram.com/language/ref/LibraryDataType.html
        ///</summary>
        corewolf::engine *LibraryDataType(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LibraryDataType[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a function that has been loaded from a Wolfram Library.
        /// https://reference.wolfram.com/language/ref/LibraryFunction.html
        ///</summary>
        corewolf::engine *LibraryFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LibraryFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a function declaration that exposes the library function extName with the type type from the library lib, for use in compiled code.
        /// https://reference.wolfram.com/language/ref/LibraryFunctionDeclaration.html
        ///</summary>
        corewolf::engine *LibraryFunctionDeclaration(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LibraryFunctionDeclaration[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// assumes that the library will be loaded by the time the function is compiled.
        /// https://reference.wolfram.com/language/ref/LibraryFunctionDeclaration.html
        ///</summary>
        corewolf::engine *LibraryFunctionDeclaration(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LibraryFunctionDeclaration[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an error returned from a LibraryFunction.
        /// https://reference.wolfram.com/language/ref/LibraryFunctionError.html
        ///</summary>
        corewolf::engine *LibraryFunctionError(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LibraryFunctionError[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns information about a LibraryFunction.
        /// https://reference.wolfram.com/language/ref/LibraryFunctionInformation.html
        ///</summary>
        corewolf::engine *LibraryFunctionInformation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LibraryFunctionInformation[" + arg0 + "]", name);
        }

        ///< summary>
        /// loads Wolfram Library lib and makes the library function fun available in the Wolfram Language.
        /// https://reference.wolfram.com/language/ref/LibraryFunctionLoad.html
        ///</summary>
        corewolf::engine *LibraryFunctionLoad(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("LibraryFunctionLoad[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// unloads a LibraryFunction so that it cannot be used.
        /// https://reference.wolfram.com/language/ref/LibraryFunctionUnload.html
        ///</summary>
        corewolf::engine *LibraryFunctionUnload(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LibraryFunctionUnload[" + arg0 + "]", name);
        }

        ///< summary>
        /// loads the dynamic library lib into the Wolfram System runtime.
        /// https://reference.wolfram.com/language/ref/LibraryLoad.html
        ///</summary>
        corewolf::engine *LibraryLoad(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LibraryLoad[" + arg0 + "]", name);
        }

        ///< summary>
        /// unloads all functions that have been loaded from a Wolfram Library, then it unloads the library.
        /// https://reference.wolfram.com/language/ref/LibraryUnload.html
        ///</summary>
        corewolf::engine *LibraryUnload(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LibraryUnload[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an on-demand license entitlement.
        /// https://reference.wolfram.com/language/ref/LicenseEntitlementObject.html
        ///</summary>
        corewolf::engine *LicenseEntitlementObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LicenseEntitlementObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of on-demand license entitlements owned by you.
        /// https://reference.wolfram.com/language/ref/LicenseEntitlements.html
        ///</summary>
        corewolf::engine *LicenseEntitlements(const std::string &name = "")
        {
            return this->execute("LicenseEntitlements[]", name);
        }

        ///< summary>
        /// represents lifting-filter data used to compute forward and inverse lifting wavelet transforms.
        /// https://reference.wolfram.com/language/ref/LiftingFilterData.html
        ///</summary>
        corewolf::engine *LiftingFilterData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LiftingFilterData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the lifting wavelet transform (LWT) of an array of data.
        /// https://reference.wolfram.com/language/ref/LiftingWaveletTransform.html
        ///</summary>
        corewolf::engine *LiftingWaveletTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LiftingWaveletTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the lifting wavelet transform using the wavelet wave.
        /// https://reference.wolfram.com/language/ref/LiftingWaveletTransform.html
        ///</summary>
        corewolf::engine *LiftingWaveletTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LiftingWaveletTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the lifting wavelet transform using r levels of refinement.
        /// https://reference.wolfram.com/language/ref/LiftingWaveletTransform.html
        ///</summary>
        corewolf::engine *LiftingWaveletTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LiftingWaveletTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a lighter version of the specified color.
        /// https://reference.wolfram.com/language/ref/Lighter.html
        ///</summary>
        corewolf::engine *Lighter(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Lighter[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a version of the specified color lightened by a fraction f.
        /// https://reference.wolfram.com/language/ref/Lighter.html
        ///</summary>
        corewolf::engine *Lighter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Lighter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the likelihood function for observations x1, x2, … from the distribution dist.
        /// https://reference.wolfram.com/language/ref/Likelihood.html
        ///</summary>
        corewolf::engine *Likelihood(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Likelihood[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the likelihood function for the observations xi at time ti from the process proc.
        /// https://reference.wolfram.com/language/ref/Likelihood.html
        ///</summary>
        corewolf::engine *Likelihood(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Likelihood[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the limit xx*f(x).
        /// https://reference.wolfram.com/language/ref/Limit.html
        ///</summary>
        corewolf::engine *Limit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Limit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the nested limit ⋯ f (x1,…,xn).
        /// https://reference.wolfram.com/language/ref/Limit.html
        ///</summary>
        corewolf::engine *Limit(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Limit[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a Lindley distribution with shape parameter δ.
        /// https://reference.wolfram.com/language/ref/LindleyDistribution.html
        ///</summary>
        corewolf::engine *LindleyDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LindleyDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the line segments joining a sequence for points pi.
        /// https://reference.wolfram.com/language/ref/Line.html
        ///</summary>
        corewolf::engine *Line(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Line[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a collection of lines.
        /// https://reference.wolfram.com/language/ref/Line.html
        ///</summary>
        corewolf::engine *Line(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Line[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds values of variables vars that minimize the linear fractional objective f subject to linear constraints cons.
        /// https://reference.wolfram.com/language/ref/LinearFractionalOptimization.html
        ///</summary>
        corewolf::engine *LinearFractionalOptimization(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LinearFractionalOptimization[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds a vector  that minimizes the linear fractional function  subject to the linear inequality constraints .
        /// https://reference.wolfram.com/language/ref/LinearFractionalOptimization.html
        ///</summary>
        corewolf::engine *LinearFractionalOptimization(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LinearFractionalOptimization[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// includes the linear equality constraints .
        /// https://reference.wolfram.com/language/ref/LinearFractionalOptimization.html
        ///</summary>
        corewolf::engine *LinearFractionalOptimization(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("LinearFractionalOptimization[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// takes  to be in the domain domi, where domi is Integers or Reals.
        /// https://reference.wolfram.com/language/ref/LinearFractionalOptimization.html
        ///</summary>
        corewolf::engine *LinearFractionalOptimization(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("LinearFractionalOptimization[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// specifies what solution property "prop" should be returned.
        /// https://reference.wolfram.com/language/ref/LinearFractionalOptimization.html
        ///</summary>
        corewolf::engine *LinearFractionalOptimization(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LinearFractionalOptimization[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a TransformationFunction that represents a linear fractional transformation defined by the homogeneous matrix m.
        /// https://reference.wolfram.com/language/ref/LinearFractionalTransform.html
        ///</summary>
        corewolf::engine *LinearFractionalTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LinearFractionalTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a linear fractional transformation that maps  to .
        /// https://reference.wolfram.com/language/ref/LinearFractionalTransform.html
        ///</summary>
        corewolf::engine *LinearFractionalTransform(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LinearFractionalTransform[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// is a two-dimensional graphics directive specifying that faces of polygons and other filled graphics objects are to be drawn using a progressive transition between colors coli along a straight horizontal line.
        /// https://reference.wolfram.com/language/ref/LinearGradientFilling.html
        ///</summary>
        corewolf::engine *LinearGradientFilling(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LinearGradientFilling[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// draws along the straight line with a direction dir.
        /// https://reference.wolfram.com/language/ref/LinearGradientFilling.html
        ///</summary>
        corewolf::engine *LinearGradientFilling(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LinearGradientFilling[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the specified padding when drawing beyond the boundary positions pos1 and posn.
        /// https://reference.wolfram.com/language/ref/LinearGradientFilling.html
        ///</summary>
        corewolf::engine *LinearGradientFilling(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LinearGradientFilling[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns an image with values linearly changing from left to right based on gradient color gcol.
        /// https://reference.wolfram.com/language/ref/LinearGradientImage.html
        ///</summary>
        corewolf::engine *LinearGradientImage(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LinearGradientImage[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a linear gradient image of the specified size.
        /// https://reference.wolfram.com/language/ref/LinearGradientImage.html
        ///</summary>
        corewolf::engine *LinearGradientImage(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LinearGradientImage[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an image converted to the specified type.
        /// https://reference.wolfram.com/language/ref/LinearGradientImage.html
        ///</summary>
        corewolf::engine *LinearGradientImage(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LinearGradientImage[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents data of an AffineStateSpaceModel linearized by functions such as FeedbackLinearize and StateTransformationLinearize using transformation of variables.
        /// https://reference.wolfram.com/language/ref/LinearizingTransformationData.html
        ///</summary>
        corewolf::engine *LinearizingTransformationData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LinearizingTransformationData[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a trainable, fully connected net layer that computes  with output vector of size n.
        /// https://reference.wolfram.com/language/ref/LinearLayer.html
        ///</summary>
        corewolf::engine *LinearLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LinearLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a layer that outputs an array of dimensions n1×n2×….
        /// https://reference.wolfram.com/language/ref/LinearLayer.html
        ///</summary>
        corewolf::engine *LinearLayer(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LinearLayer[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// leaves the dimensions of the output array to be inferred from context.
        /// https://reference.wolfram.com/language/ref/LinearLayer.html
        ///</summary>
        corewolf::engine *LinearLayer(const std::string &name = "")
        {
            return this->execute("LinearLayer[]", name);
        }

        ///< summary>
        /// includes options for initial weights and other parameters.
        /// https://reference.wolfram.com/language/ref/LinearLayer.html
        ///</summary>
        corewolf::engine *LinearLayer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LinearLayer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// constructs a linear model of the form  that fits the yi for successive x values 1, 2, ….
        /// https://reference.wolfram.com/language/ref/LinearModelFit.html
        ///</summary>
        corewolf::engine *LinearModelFit(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LinearModelFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// constructs a linear model of the form  where the fi depend on the variables xk.
        /// https://reference.wolfram.com/language/ref/LinearModelFit.html
        ///</summary>
        corewolf::engine *LinearModelFit(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("LinearModelFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// constructs a linear model from the design matrix m and response vector v.
        /// https://reference.wolfram.com/language/ref/LinearModelFit.html
        ///</summary>
        corewolf::engine *LinearModelFit(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LinearModelFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// finds values of variables vars that minimize the linear objective f subject to linear constraints cons.
        /// https://reference.wolfram.com/language/ref/LinearOptimization.html
        ///</summary>
        corewolf::engine *LinearOptimization(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LinearOptimization[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds a real vector x that minimizes the linear objective  subject to the linear inequality constraints .
        /// https://reference.wolfram.com/language/ref/LinearOptimization.html
        ///</summary>
        corewolf::engine *LinearOptimization(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LinearOptimization[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// includes the linear equality constraints .
        /// https://reference.wolfram.com/language/ref/LinearOptimization.html
        ///</summary>
        corewolf::engine *LinearOptimization(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("LinearOptimization[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// takes xi to be in the domain domi, where domi is Integers or Reals.
        /// https://reference.wolfram.com/language/ref/LinearOptimization.html
        ///</summary>
        corewolf::engine *LinearOptimization(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("LinearOptimization[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// specifies what solution property "prop" should be returned.
        /// https://reference.wolfram.com/language/ref/LinearOptimization.html
        ///</summary>
        corewolf::engine *LinearOptimization(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LinearOptimization[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the sequence of length n obtained by iterating the linear recurrence with kernel ker starting with initial values init.
        /// https://reference.wolfram.com/language/ref/LinearRecurrence.html
        ///</summary>
        corewolf::engine *LinearRecurrence(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LinearRecurrence[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the n term.
        /// https://reference.wolfram.com/language/ref/LinearRecurrence.html
        ///</summary>
        corewolf::engine *LinearRecurrence(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("LinearRecurrence[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// finds an x that solves the matrix equation m.x==b.
        /// https://reference.wolfram.com/language/ref/LinearSolve.html
        ///</summary>
        corewolf::engine *LinearSolve(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LinearSolve[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a LinearSolveFunction[…] that can be applied repeatedly to different b.
        /// https://reference.wolfram.com/language/ref/LinearSolve.html
        ///</summary>
        corewolf::engine *LinearSolve(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LinearSolve[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a function for providing solutions to a matrix equation.
        /// https://reference.wolfram.com/language/ref/LinearSolveFunction.html
        ///</summary>
        corewolf::engine *LinearSolveFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LinearSolveFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// makes a line break chart with prices pi at date datei.
        /// https://reference.wolfram.com/language/ref/LineBreakChart.html
        ///</summary>
        corewolf::engine *LineBreakChart(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LineBreakChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a line break chart of closing prices for the financial entity "name" over the date range daterange.
        /// https://reference.wolfram.com/language/ref/LineBreakChart.html
        ///</summary>
        corewolf::engine *LineBreakChart(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LineBreakChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a line break chart where n bars in a row cause a reversal.
        /// https://reference.wolfram.com/language/ref/LineBreakChart.html
        ///</summary>
        corewolf::engine *LineBreakChart(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LineBreakChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the line graph of the graph g.
        /// https://reference.wolfram.com/language/ref/LineGraph.html
        ///</summary>
        corewolf::engine *LineGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LineGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/LineGraph.html
        ///</summary>
        corewolf::engine *LineGraph(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LineGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a line integral convolution plot of image convolved with the vector field {vx,vy} as a function of x and y.
        /// https://reference.wolfram.com/language/ref/LineIntegralConvolutionPlot.html
        ///</summary>
        corewolf::engine *LineIntegralConvolutionPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("LineIntegralConvolutionPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates a legend that associates color coli with label lbli.
        /// https://reference.wolfram.com/language/ref/LineLegend.html
        ///</summary>
        corewolf::engine *LineLegend(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LineLegend[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a legend with placeholder labels for the colors coli.
        /// https://reference.wolfram.com/language/ref/LineLegend.html
        ///</summary>
        corewolf::engine *LineLegend(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LineLegend[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a legend with inherited colors within visualization functions.
        /// https://reference.wolfram.com/language/ref/LineLegend.html
        ///</summary>
        corewolf::engine *LineLegend(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LineLegend[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// activates a WSTP connection, waiting for the program at the other end to respond.
        /// https://reference.wolfram.com/language/ref/LinkActivate.html
        ///</summary>
        corewolf::engine *LinkActivate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LinkActivate[" + arg0 + "]", name);
        }

        ///< summary>
        /// closes an open WSTP connection.
        /// https://reference.wolfram.com/language/ref/LinkClose.html
        ///</summary>
        corewolf::engine *LinkClose(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LinkClose[" + arg0 + "]", name);
        }

        ///< summary>
        /// connects to a WSTP link created by another program.
        /// https://reference.wolfram.com/language/ref/LinkConnect.html
        ///</summary>
        corewolf::engine *LinkConnect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LinkConnect[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a WSTP link with the specified name for another program to connect to.
        /// https://reference.wolfram.com/language/ref/LinkCreate.html
        ///</summary>
        corewolf::engine *LinkCreate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LinkCreate[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a WSTP link and picks an unused name for the link.
        /// https://reference.wolfram.com/language/ref/LinkCreate.html
        ///</summary>
        corewolf::engine *LinkCreate(const std::string &name = "")
        {
            return this->execute("LinkCreate[]", name);
        }

        ///< summary>
        /// sends an interrupt to the program at the other end of the specified WSTP connection.
        /// https://reference.wolfram.com/language/ref/LinkInterrupt.html
        ///</summary>
        corewolf::engine *LinkInterrupt(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LinkInterrupt[" + arg0 + "]", name);
        }

        ///< summary>
        /// starts the external program prog and opens a WSTP connection to it.
        /// https://reference.wolfram.com/language/ref/LinkLaunch.html
        ///</summary>
        corewolf::engine *LinkLaunch(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LinkLaunch[" + arg0 + "]", name);
        }

        ///< summary>
        /// is an const std::string &that represents an active WSTP connection for functions such as LinkRead and LinkWrite.
        /// https://reference.wolfram.com/language/ref/LinkObject.html
        ///</summary>
        corewolf::engine *LinkObject(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LinkObject[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of the patterns for which definitions were set up when the external program associated with the specified WSTP connection was installed.
        /// https://reference.wolfram.com/language/ref/LinkPatterns.html
        ///</summary>
        corewolf::engine *LinkPatterns(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LinkPatterns[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the link-rank centralities for edges in the graph g and weight α.
        /// https://reference.wolfram.com/language/ref/LinkRankCentrality.html
        ///</summary>
        corewolf::engine *LinkRankCentrality(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LinkRankCentrality[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the link-rank centralities, using weight α and initial vertex page-rank centralities β.
        /// https://reference.wolfram.com/language/ref/LinkRankCentrality.html
        ///</summary>
        corewolf::engine *LinkRankCentrality(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LinkRankCentrality[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/LinkRankCentrality.html
        ///</summary>
        corewolf::engine *LinkRankCentrality(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LinkRankCentrality[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reads one expression from the specified WSTP connection.
        /// https://reference.wolfram.com/language/ref/LinkRead.html
        ///</summary>
        corewolf::engine *LinkRead(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LinkRead[" + arg0 + "]", name);
        }

        ///< summary>
        /// wraps h around the expression read before evaluating it.
        /// https://reference.wolfram.com/language/ref/LinkRead.html
        ///</summary>
        corewolf::engine *LinkRead(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LinkRead[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether there is an expression ready to read from the specified WSTP connection.
        /// https://reference.wolfram.com/language/ref/LinkReadyQ.html
        ///</summary>
        corewolf::engine *LinkReadyQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LinkReadyQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// waits for up to t seconds to see if an expression becomes ready to read.
        /// https://reference.wolfram.com/language/ref/LinkReadyQ.html
        ///</summary>
        corewolf::engine *LinkReadyQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LinkReadyQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests all the linki in parallel, returning as soon as any of them are ready to read from.
        /// https://reference.wolfram.com/language/ref/LinkReadyQ.html
        ///</summary>
        corewolf::engine *LinkReadyQ(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LinkReadyQ[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of all WSTP connections that are currently open.
        /// https://reference.wolfram.com/language/ref/Links.html
        ///</summary>
        corewolf::engine *Links(const std::string &name = "")
        {
            return this->execute("Links[]", name);
        }

        ///< summary>
        /// lists only links whose names match the specified string pattern.
        /// https://reference.wolfram.com/language/ref/Links.html
        ///</summary>
        corewolf::engine *Links(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Links[" + arg0 + "]", name);
        }

        ///< summary>
        /// writes expr to the specified WSTP connection.
        /// https://reference.wolfram.com/language/ref/LinkWrite.html
        ///</summary>
        corewolf::engine *LinkWrite(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LinkWrite[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Liouville function .
        /// https://reference.wolfram.com/language/ref/LiouvilleLambda.html
        ///</summary>
        corewolf::engine *LiouvilleLambda(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LiouvilleLambda[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates an animation whose frames are the successive expri.
        /// https://reference.wolfram.com/language/ref/ListAnimate.html
        ///</summary>
        corewolf::engine *ListAnimate(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListAnimate[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// displays fps frames per second.
        /// https://reference.wolfram.com/language/ref/ListAnimate.html
        ///</summary>
        corewolf::engine *ListAnimate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ListAnimate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a contour plot from an array of values fij.
        /// https://reference.wolfram.com/language/ref/ListContourPlot.html
        ///</summary>
        corewolf::engine *ListContourPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ListContourPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates a contour plot from a three-dimensional array of values.
        /// https://reference.wolfram.com/language/ref/ListContourPlot3D.html
        ///</summary>
        corewolf::engine *ListContourPlot3D(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ListContourPlot3D[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a contour plot from values defined at specified points in three‐dimensional space.
        /// https://reference.wolfram.com/language/ref/ListContourPlot3D.html
        ///</summary>
        corewolf::engine *ListContourPlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListContourPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// forms the convolution of the kernel ker with list.
        /// https://reference.wolfram.com/language/ref/ListConvolve.html
        ///</summary>
        corewolf::engine *ListConvolve(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ListConvolve[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// forms the cyclic convolution in which the k element of ker is aligned with each element in list.
        /// https://reference.wolfram.com/language/ref/ListConvolve.html
        ///</summary>
        corewolf::engine *ListConvolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ListConvolve[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// forms the cyclic convolution whose first element contains list[[1]]ker[[kL]] and whose last element contains list[[-1]]ker[[kR]].
        /// https://reference.wolfram.com/language/ref/ListConvolve.html
        ///</summary>
        corewolf::engine *ListConvolve(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ListConvolve[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// forms the convolution in which list is padded at each end with repetitions of the element p.
        /// https://reference.wolfram.com/language/ref/ListConvolve.html
        ///</summary>
        corewolf::engine *ListConvolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ListConvolve[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// forms the convolution in which list is padded at each end with cyclic repetitions of the pi.
        /// https://reference.wolfram.com/language/ref/ListConvolve.html
        ///</summary>
        corewolf::engine *ListConvolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("ListConvolve[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// forms a generalized convolution in which g is used in place of Times and h in place of Plus.
        /// https://reference.wolfram.com/language/ref/ListConvolve.html
        ///</summary>
        corewolf::engine *ListConvolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("ListConvolve[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// forms a convolution using elements at level lev in ker and list.
        /// https://reference.wolfram.com/language/ref/ListConvolve.html
        ///</summary>
        corewolf::engine *ListConvolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &arg6, const std::string &name = "")
        {
            return this->execute("ListConvolve[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + ", " + arg6 + "]", name);
        }

        ///< summary>
        /// forms the correlation of the kernel ker with list.
        /// https://reference.wolfram.com/language/ref/ListCorrelate.html
        ///</summary>
        corewolf::engine *ListCorrelate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ListCorrelate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// forms the cyclic correlation in which the k element of ker is aligned with each element in list.
        /// https://reference.wolfram.com/language/ref/ListCorrelate.html
        ///</summary>
        corewolf::engine *ListCorrelate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ListCorrelate[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// forms the cyclic correlation whose first element contains list[[1]]ker[[kL]] and whose last element contains list[[-1]]ker[[kR]].
        /// https://reference.wolfram.com/language/ref/ListCorrelate.html
        ///</summary>
        corewolf::engine *ListCorrelate(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ListCorrelate[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// forms the correlation in which list is padded at each end with repetitions of the element p.
        /// https://reference.wolfram.com/language/ref/ListCorrelate.html
        ///</summary>
        corewolf::engine *ListCorrelate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ListCorrelate[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// forms the correlation in which list is padded at each end with cyclic repetitions of the pi.
        /// https://reference.wolfram.com/language/ref/ListCorrelate.html
        ///</summary>
        corewolf::engine *ListCorrelate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("ListCorrelate[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// forms a generalized correlation in which g is used in place of Times and h in place of Plus.
        /// https://reference.wolfram.com/language/ref/ListCorrelate.html
        ///</summary>
        corewolf::engine *ListCorrelate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("ListCorrelate[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// forms a correlation using elements at level lev in ker and list.
        /// https://reference.wolfram.com/language/ref/ListCorrelate.html
        ///</summary>
        corewolf::engine *ListCorrelate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &arg6, const std::string &name = "")
        {
            return this->execute("ListCorrelate[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + ", " + arg6 + "]", name);
        }

        ///< summary>
        /// plots a curve that corresponds to a smooth path through the specified points.
        /// https://reference.wolfram.com/language/ref/ListCurvePathPlot.html
        ///</summary>
        corewolf::engine *ListCurvePathPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListCurvePathPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a deconvolution of list using kernel ker.
        /// https://reference.wolfram.com/language/ref/ListDeconvolve.html
        ///</summary>
        corewolf::engine *ListDeconvolve(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ListDeconvolve[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a smooth density plot from an array of values fij.
        /// https://reference.wolfram.com/language/ref/ListDensityPlot.html
        ///</summary>
        corewolf::engine *ListDensityPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ListDensityPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates a smooth density plot from an array of values.
        /// https://reference.wolfram.com/language/ref/ListDensityPlot3D.html
        ///</summary>
        corewolf::engine *ListDensityPlot3D(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ListDensityPlot3D[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a density plot with values fi at the specified points {xi,yi,zi}.
        /// https://reference.wolfram.com/language/ref/ListDensityPlot3D.html
        ///</summary>
        corewolf::engine *ListDensityPlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListDensityPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the discrete-time Fourier transform (DTFT) of a list as a function of the parameter ω.
        /// https://reference.wolfram.com/language/ref/ListFourierSequenceTransform.html
        ///</summary>
        corewolf::engine *ListFourierSequenceTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ListFourierSequenceTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// places the first element of list at integer time k on the infinite time axis.
        /// https://reference.wolfram.com/language/ref/ListFourierSequenceTransform.html
        ///</summary>
        corewolf::engine *ListFourierSequenceTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ListFourierSequenceTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional discrete-time Fourier transform
        /// https://reference.wolfram.com/language/ref/ListFourierSequenceTransform.html
        ///</summary>
        corewolf::engine *ListFourierSequenceTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ListFourierSequenceTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// constructs an InterpolatingFunction const std::string &that represents an approximate function that interpolates the array of values given.
        /// https://reference.wolfram.com/language/ref/ListInterpolation.html
        ///</summary>
        corewolf::engine *ListInterpolation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ListInterpolation[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies the domain of the grid from which the values in array are assumed to come.
        /// https://reference.wolfram.com/language/ref/ListInterpolation.html
        ///</summary>
        corewolf::engine *ListInterpolation(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ListInterpolation[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates a line integral convolution plot of image convolved with the vector field defined by an array of vector field values.
        /// https://reference.wolfram.com/language/ref/ListLineIntegralConvolutionPlot.html
        ///</summary>
        corewolf::engine *ListLineIntegralConvolutionPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListLineIntegralConvolutionPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a line integral convolution plot of white noise convolved with the vector field defined by array.
        /// https://reference.wolfram.com/language/ref/ListLineIntegralConvolutionPlot.html
        ///</summary>
        corewolf::engine *ListLineIntegralConvolutionPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ListLineIntegralConvolutionPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a line integral convolution plot of image convolved with the vector field defined by vectors {vxi,vyi} at specified points {xi,yi}.
        /// https://reference.wolfram.com/language/ref/ListLineIntegralConvolutionPlot.html
        ///</summary>
        corewolf::engine *ListLineIntegralConvolutionPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListLineIntegralConvolutionPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots a line through the points {1,y1},{2,y2},….
        /// https://reference.wolfram.com/language/ref/ListLinePlot.html
        ///</summary>
        corewolf::engine *ListLinePlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListLinePlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots a line through a list of points with specific x and y positions.
        /// https://reference.wolfram.com/language/ref/ListLinePlot.html
        ///</summary>
        corewolf::engine *ListLinePlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListLinePlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots a curve through the 3D points {xi,yi,zi}.
        /// https://reference.wolfram.com/language/ref/ListLinePlot3D.html
        ///</summary>
        corewolf::engine *ListLinePlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("ListLinePlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// plots each row {zi1,zi2,…,zin} as a curve in the  direction, with successive curves stacked in the  direction.
        /// https://reference.wolfram.com/language/ref/ListLinePlot3D.html
        ///</summary>
        corewolf::engine *ListLinePlot3D(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ListLinePlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// plots curves through multiple sets of {x,y,z} points.
        /// https://reference.wolfram.com/language/ref/ListLinePlot3D.html
        ///</summary>
        corewolf::engine *ListLinePlot3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListLinePlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a log-linear plot of the yi, assumed to correspond to x coordinates 1, 2, ….
        /// https://reference.wolfram.com/language/ref/ListLogLinearPlot.html
        ///</summary>
        corewolf::engine *ListLogLinearPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListLogLinearPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a log-linear plot of the specified list of x and y values.
        /// https://reference.wolfram.com/language/ref/ListLogLinearPlot.html
        ///</summary>
        corewolf::engine *ListLogLinearPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListLogLinearPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a log-log plot of the yi, assumed to correspond to x coordinates 1, 2, ….
        /// https://reference.wolfram.com/language/ref/ListLogLogPlot.html
        ///</summary>
        corewolf::engine *ListLogLogPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListLogLogPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a log-log plot of the specified list of x and y values.
        /// https://reference.wolfram.com/language/ref/ListLogLogPlot.html
        ///</summary>
        corewolf::engine *ListLogLogPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListLogLogPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a log plot of the yi, assumed to correspond to x coordinates 1, 2, ….
        /// https://reference.wolfram.com/language/ref/ListLogPlot.html
        ///</summary>
        corewolf::engine *ListLogPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListLogPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a log plot of the specified list of x and y values.
        /// https://reference.wolfram.com/language/ref/ListLogPlot.html
        ///</summary>
        corewolf::engine *ListLogPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListLogPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a list pane with setting list that can contain possible values vali.
        /// https://reference.wolfram.com/language/ref/ListPicker.html
        ///</summary>
        corewolf::engine *ListPicker(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListPicker[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is a low-level box structure that represents a list pane control.
        /// https://reference.wolfram.com/language/ref/ListPickerBox.html
        ///</summary>
        corewolf::engine *ListPickerBox(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListPickerBox[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// creates an const std::string &that plays as a sound whose amplitude is given by the sequence of levels ai.
        /// https://reference.wolfram.com/language/ref/ListPlay.html
        ///</summary>
        corewolf::engine *ListPlay(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListPlay[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots points {1,y1},{2,y2},….
        /// https://reference.wolfram.com/language/ref/ListPlot.html
        ///</summary>
        corewolf::engine *ListPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a 2D scatter plot of points with coordinates {xi,yi}.
        /// https://reference.wolfram.com/language/ref/ListPlot.html
        ///</summary>
        corewolf::engine *ListPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ListPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates a surface representing an array of height values fij.
        /// https://reference.wolfram.com/language/ref/ListPlot3D.html
        ///</summary>
        corewolf::engine *ListPlot3D(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ListPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// plots the surfaces corresponding to each of the datai.
        /// https://reference.wolfram.com/language/ref/ListPlot3D.html
        ///</summary>
        corewolf::engine *ListPlot3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a 3D scatter plot of points with coordinates {xi,yi,zi}.
        /// https://reference.wolfram.com/language/ref/ListPointPlot3D.html
        ///</summary>
        corewolf::engine *ListPointPlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListPointPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a 3D scatter plot of points with a 2D array of height values.
        /// https://reference.wolfram.com/language/ref/ListPointPlot3D.html
        ///</summary>
        corewolf::engine *ListPointPlot3D(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ListPointPlot3D[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots several collections of points, by default in different colors.
        /// https://reference.wolfram.com/language/ref/ListPointPlot3D.html
        ///</summary>
        corewolf::engine *ListPointPlot3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListPointPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots points equally spaced in angle at radii ri.
        /// https://reference.wolfram.com/language/ref/ListPolarPlot.html
        ///</summary>
        corewolf::engine *ListPolarPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListPolarPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots points at polar coordinates θi, ri.
        /// https://reference.wolfram.com/language/ref/ListPolarPlot.html
        ///</summary>
        corewolf::engine *ListPolarPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListPolarPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives True if the head of expr is List, and False otherwise.
        /// https://reference.wolfram.com/language/ref/ListQ.html
        ///</summary>
        corewolf::engine *ListQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ListQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a contour plot of the three-dimensional array of values sliced to the surface surf.
        /// https://reference.wolfram.com/language/ref/ListSliceContourPlot3D.html
        ///</summary>
        corewolf::engine *ListSliceContourPlot3D(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ListSliceContourPlot3D[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a slice contour plot for the values fi at points {xi,yi,zi}.
        /// https://reference.wolfram.com/language/ref/ListSliceContourPlot3D.html
        ///</summary>
        corewolf::engine *ListSliceContourPlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ListSliceContourPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates slice contour plots over several slices surf1, surf2, ….
        /// https://reference.wolfram.com/language/ref/ListSliceContourPlot3D.html
        ///</summary>
        corewolf::engine *ListSliceContourPlot3D(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListSliceContourPlot3D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a density plot of the three-dimensional array of values sliced to the surface surf.
        /// https://reference.wolfram.com/language/ref/ListSliceDensityPlot3D.html
        ///</summary>
        corewolf::engine *ListSliceDensityPlot3D(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ListSliceDensityPlot3D[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a slice density plot for the values fi at points {xi,yi,zi}.
        /// https://reference.wolfram.com/language/ref/ListSliceDensityPlot3D.html
        ///</summary>
        corewolf::engine *ListSliceDensityPlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ListSliceDensityPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates slice density plots over several slices surf1, surf2, ….
        /// https://reference.wolfram.com/language/ref/ListSliceDensityPlot3D.html
        ///</summary>
        corewolf::engine *ListSliceDensityPlot3D(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListSliceDensityPlot3D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a vector plot from a 3D array of vector field values over the slice surface surf.
        /// https://reference.wolfram.com/language/ref/ListSliceVectorPlot3D.html
        ///</summary>
        corewolf::engine *ListSliceVectorPlot3D(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ListSliceVectorPlot3D[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a slice vector plot over several surfaces surf1, surf2, ….
        /// https://reference.wolfram.com/language/ref/ListSliceVectorPlot3D.html
        ///</summary>
        corewolf::engine *ListSliceVectorPlot3D(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListSliceVectorPlot3D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots the values y1, y2, … in steps at points 1, 2, ….
        /// https://reference.wolfram.com/language/ref/ListStepPlot.html
        ///</summary>
        corewolf::engine *ListStepPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListStepPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots the values y1, y2, … in steps at points x1, x2, ….
        /// https://reference.wolfram.com/language/ref/ListStepPlot.html
        ///</summary>
        corewolf::engine *ListStepPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListStepPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots using steps specified by step.
        /// https://reference.wolfram.com/language/ref/ListStepPlot.html
        ///</summary>
        corewolf::engine *ListStepPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ListStepPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a stream density plot from a 2D array of vector and scalar field values {{vxij,vyij},sij}.
        /// https://reference.wolfram.com/language/ref/ListStreamDensityPlot.html
        ///</summary>
        corewolf::engine *ListStreamDensityPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ListStreamDensityPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a stream density plot from vector and scalar field values {{vxi,vyi},si} given at specified points {xi,yi}.
        /// https://reference.wolfram.com/language/ref/ListStreamDensityPlot.html
        ///</summary>
        corewolf::engine *ListStreamDensityPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListStreamDensityPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots data for several vector and scalar fields.
        /// https://reference.wolfram.com/language/ref/ListStreamDensityPlot.html
        ///</summary>
        corewolf::engine *ListStreamDensityPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListStreamDensityPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a stream plot from an array of vector field values.
        /// https://reference.wolfram.com/language/ref/ListStreamPlot.html
        ///</summary>
        corewolf::engine *ListStreamPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ListStreamPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a stream plot from vector field values {vxi,vyi} given at specified points {xi,yi}.
        /// https://reference.wolfram.com/language/ref/ListStreamPlot.html
        ///</summary>
        corewolf::engine *ListStreamPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListStreamPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots data for several vector fields.
        /// https://reference.wolfram.com/language/ref/ListStreamPlot.html
        ///</summary>
        corewolf::engine *ListStreamPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListStreamPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots streamlines for the vector field given as an array of vectors.
        /// https://reference.wolfram.com/language/ref/ListStreamPlot3D.html
        ///</summary>
        corewolf::engine *ListStreamPlot3D(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ListStreamPlot3D[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots a three-dimensional surface constructed to fit the specified points.
        /// https://reference.wolfram.com/language/ref/ListSurfacePlot3D.html
        ///</summary>
        corewolf::engine *ListSurfacePlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListSurfacePlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a vector plot from a 2D array of vector and scalar field values {{vxij,vyij},sij}.
        /// https://reference.wolfram.com/language/ref/ListVectorDensityPlot.html
        ///</summary>
        corewolf::engine *ListVectorDensityPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ListVectorDensityPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a vector plot from vector and scalar field values {{vxi,vyi},si} given at specified points {xi,yi}.
        /// https://reference.wolfram.com/language/ref/ListVectorDensityPlot.html
        ///</summary>
        corewolf::engine *ListVectorDensityPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListVectorDensityPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots data for several vector and scalar fields.
        /// https://reference.wolfram.com/language/ref/ListVectorDensityPlot.html
        ///</summary>
        corewolf::engine *ListVectorDensityPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListVectorDensityPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a displacement plot from an array of vector displacements {vxij,vyij}.
        /// https://reference.wolfram.com/language/ref/ListVectorDisplacementPlot.html
        ///</summary>
        corewolf::engine *ListVectorDisplacementPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::vector<std::string> &arg4, const std::string &arg5, const std::vector<std::string> &arg6, const std::string &name = "")
        {
            return this->execute("ListVectorDisplacementPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + ", " + arg5 + ", " + std::to_string('{') + engine::_print_vector(arg6) + "}" + "]", name);
        }

        ///< summary>
        /// generates a displacement plot from displacements {vxi,vyi} at point {xi,yi}.
        /// https://reference.wolfram.com/language/ref/ListVectorDisplacementPlot.html
        ///</summary>
        corewolf::engine *ListVectorDisplacementPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::vector<std::string> &arg4, const std::string &name = "")
        {
            return this->execute("ListVectorDisplacementPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + "]", name);
        }

        ///< summary>
        /// uses the scalar values si at point {xi,yi} to color the displaced region.
        /// https://reference.wolfram.com/language/ref/ListVectorDisplacementPlot.html
        ///</summary>
        corewolf::engine *ListVectorDisplacementPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ListVectorDisplacementPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// plots the displacement over the region reg.
        /// https://reference.wolfram.com/language/ref/ListVectorDisplacementPlot.html
        ///</summary>
        corewolf::engine *ListVectorDisplacementPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ListVectorDisplacementPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a displacement plot from an array of vector displacements {vxij,vyij,vzij}.
        /// https://reference.wolfram.com/language/ref/ListVectorDisplacementPlot3D.html
        ///</summary>
        corewolf::engine *ListVectorDisplacementPlot3D(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::vector<std::string> &arg4, const std::string &arg5, const std::vector<std::string> &arg6, const std::string &name = "")
        {
            return this->execute("ListVectorDisplacementPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + ", " + arg5 + ", " + std::to_string('{') + engine::_print_vector(arg6) + "}" + "]", name);
        }

        ///< summary>
        /// generates a displacement plot from displacements {vxi,vyi,vzi} at point {xi,yi,zi}.
        /// https://reference.wolfram.com/language/ref/ListVectorDisplacementPlot3D.html
        ///</summary>
        corewolf::engine *ListVectorDisplacementPlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::vector<std::string> &arg4, const std::string &name = "")
        {
            return this->execute("ListVectorDisplacementPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + "]", name);
        }

        ///< summary>
        /// plots the displacement over the region reg.
        /// https://reference.wolfram.com/language/ref/ListVectorDisplacementPlot3D.html
        ///</summary>
        corewolf::engine *ListVectorDisplacementPlot3D(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ListVectorDisplacementPlot3D[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a vector plot from an array of vector field values.
        /// https://reference.wolfram.com/language/ref/ListVectorPlot.html
        ///</summary>
        corewolf::engine *ListVectorPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ListVectorPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a vector plot from vector field values {vxi,vyi} given at specified points {xi,yi}.
        /// https://reference.wolfram.com/language/ref/ListVectorPlot.html
        ///</summary>
        corewolf::engine *ListVectorPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ListVectorPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots data for several vector fields.
        /// https://reference.wolfram.com/language/ref/ListVectorPlot.html
        ///</summary>
        corewolf::engine *ListVectorPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListVectorPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a 3D vector plot from a 3D array of vector field values.
        /// https://reference.wolfram.com/language/ref/ListVectorPlot3D.html
        ///</summary>
        corewolf::engine *ListVectorPlot3D(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ListVectorPlot3D[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots data for several vector fields.
        /// https://reference.wolfram.com/language/ref/ListVectorPlot3D.html
        ///</summary>
        corewolf::engine *ListVectorPlot3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ListVectorPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Z transform of list as a function of z.
        /// https://reference.wolfram.com/language/ref/ListZTransform.html
        ///</summary>
        corewolf::engine *ListZTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ListZTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// places the first element of list at integer time k on the infinite time axis.
        /// https://reference.wolfram.com/language/ref/ListZTransform.html
        ///</summary>
        corewolf::engine *ListZTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ListZTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional Z transform.
        /// https://reference.wolfram.com/language/ref/ListZTransform.html
        ///</summary>
        corewolf::engine *ListZTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ListZTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a literal value x for use as a type.
        /// https://reference.wolfram.com/language/ref/LiteralType.html
        ///</summary>
        corewolf::engine *LiteralType(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LiteralType[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a binary image from image by replacing values above the mean of the range-r neighborhood with 1 and others with 0.
        /// https://reference.wolfram.com/language/ref/LocalAdaptiveBinarize.html
        ///</summary>
        corewolf::engine *LocalAdaptiveBinarize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LocalAdaptiveBinarize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces values above  with 1 and others with 0, where  and  are the local mean and standard deviation.
        /// https://reference.wolfram.com/language/ref/LocalAdaptiveBinarize.html
        ///</summary>
        corewolf::engine *LocalAdaptiveBinarize(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("LocalAdaptiveBinarize[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// caches a cloud const std::string &in a local object.
        /// https://reference.wolfram.com/language/ref/LocalCache.html
        ///</summary>
        corewolf::engine *LocalCache(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LocalCache[" + arg0 + "]", name);
        }

        ///< summary>
        /// caches the contents of obj in the specified local object.
        /// https://reference.wolfram.com/language/ref/LocalCache.html
        ///</summary>
        corewolf::engine *LocalCache(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LocalCache[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of local clustering coefficients of all vertices in the graph g.
        /// https://reference.wolfram.com/language/ref/LocalClusteringCoefficient.html
        ///</summary>
        corewolf::engine *LocalClusteringCoefficient(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LocalClusteringCoefficient[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the local clustering coefficient of the vertex v in the graph g.
        /// https://reference.wolfram.com/language/ref/LocalClusteringCoefficient.html
        ///</summary>
        corewolf::engine *LocalClusteringCoefficient(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LocalClusteringCoefficient[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/LocalClusteringCoefficient.html
        ///</summary>
        corewolf::engine *LocalClusteringCoefficient(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LocalClusteringCoefficient[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the result of evaluating expr using your current default local Wolfram Language kernel.
        /// https://reference.wolfram.com/language/ref/LocalEvaluate.html
        ///</summary>
        corewolf::engine *LocalEvaluate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LocalEvaluate[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the result of evaluating expr using the kernel specified by ker.
        /// https://reference.wolfram.com/language/ref/LocalEvaluate.html
        ///</summary>
        corewolf::engine *LocalEvaluate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LocalEvaluate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the results of evaluating expr using each of the kernels keri.
        /// https://reference.wolfram.com/language/ref/LocalEvaluate.html
        ///</summary>
        corewolf::engine *LocalEvaluate(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LocalEvaluate[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// wraps the head h around the result produced before returning it.
        /// https://reference.wolfram.com/language/ref/LocalEvaluate.html
        ///</summary>
        corewolf::engine *LocalEvaluate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LocalEvaluate[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a new anonymous local object.
        /// https://reference.wolfram.com/language/ref/LocalObject.html
        ///</summary>
        corewolf::engine *LocalObject(const std::string &name = "")
        {
            return this->execute("LocalObject[]", name);
        }

        ///< summary>
        /// represents a local const std::string &with a given file path.
        /// https://reference.wolfram.com/language/ref/LocalObject.html
        ///</summary>
        corewolf::engine *LocalObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LocalObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a local const std::string &relative to the base lbase.
        /// https://reference.wolfram.com/language/ref/LocalObject.html
        ///</summary>
        corewolf::engine *LocalObject(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LocalObject[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of local objects in your current local base directory.
        /// https://reference.wolfram.com/language/ref/LocalObjects.html
        ///</summary>
        corewolf::engine *LocalObjects(const std::string &name = "")
        {
            return this->execute("LocalObjects[]", name);
        }

        ///< summary>
        /// gives a list of local objects in the local directory dir.
        /// https://reference.wolfram.com/language/ref/LocalObjects.html
        ///</summary>
        corewolf::engine *LocalObjects(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LocalObjects[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a net layer that normalizes its input by averaging across neighboring input channels.
        /// https://reference.wolfram.com/language/ref/LocalResponseNormalizationLayer.html
        ///</summary>
        corewolf::engine *LocalResponseNormalizationLayer(const std::string &name = "")
        {
            return this->execute("LocalResponseNormalizationLayer[]", name);
        }

        ///< summary>
        /// submits a task to evaluate expr in a separate kernel.
        /// https://reference.wolfram.com/language/ref/LocalSubmit.html
        ///</summary>
        corewolf::engine *LocalSubmit(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LocalSubmit[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a symbol whose value is persistently stored in the local file system.
        /// https://reference.wolfram.com/language/ref/LocalSymbol.html
        ///</summary>
        corewolf::engine *LocalSymbol(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LocalSymbol[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a DateObject corresponding to the current local time at the current geo location.
        /// https://reference.wolfram.com/language/ref/LocalTime.html
        ///</summary>
        corewolf::engine *LocalTime(const std::string &name = "")
        {
            return this->execute("LocalTime[]", name);
        }

        ///< summary>
        /// gives the current local time at the geo location specified by loc.
        /// https://reference.wolfram.com/language/ref/LocalTime.html
        ///</summary>
        corewolf::engine *LocalTime(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LocalTime[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the local time corresponding to the date const std::string &time at the geo location loc.
        /// https://reference.wolfram.com/language/ref/LocalTime.html
        ///</summary>
        corewolf::engine *LocalTime(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LocalTime[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses func to determine what to return for extended geographic regions.
        /// https://reference.wolfram.com/language/ref/LocalTime.html
        ///</summary>
        corewolf::engine *LocalTime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LocalTime[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the current time zone for the current geo location.
        /// https://reference.wolfram.com/language/ref/LocalTimeZone.html
        ///</summary>
        corewolf::engine *LocalTimeZone(const std::string &name = "")
        {
            return this->execute("LocalTimeZone[]", name);
        }

        ///< summary>
        /// gives the current time zone for the geo location specified by loc.
        /// https://reference.wolfram.com/language/ref/LocalTimeZone.html
        ///</summary>
        corewolf::engine *LocalTimeZone(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LocalTimeZone[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the time zone for the geo location loc on the specified date.
        /// https://reference.wolfram.com/language/ref/LocalTimeZone.html
        ///</summary>
        corewolf::engine *LocalTimeZone(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LocalTimeZone[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified property of the time zone.
        /// https://reference.wolfram.com/language/ref/LocalTimeZone.html
        ///</summary>
        corewolf::engine *LocalTimeZone(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LocalTimeZone[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether the means or medians of the datai are equal.
        /// https://reference.wolfram.com/language/ref/LocationEquivalenceTest.html
        ///</summary>
        corewolf::engine *LocationEquivalenceTest(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LocationEquivalenceTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/LocationEquivalenceTest.html
        ///</summary>
        corewolf::engine *LocationEquivalenceTest(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LocationEquivalenceTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether the mean or median of the data is zero.
        /// https://reference.wolfram.com/language/ref/LocationTest.html
        ///</summary>
        corewolf::engine *LocationTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LocationTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the means or medians of data1 and data2 are equal.
        /// https://reference.wolfram.com/language/ref/LocationTest.html
        ///</summary>
        corewolf::engine *LocationTest(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LocationTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// tests a location measure against μ0.
        /// https://reference.wolfram.com/language/ref/LocationTest.html
        ///</summary>
        corewolf::engine *LocationTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LocationTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/LocationTest.html
        ///</summary>
        corewolf::engine *LocationTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LocationTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a locator const std::string &at position {x,y} in a graphic.
        /// https://reference.wolfram.com/language/ref/Locator.html
        ///</summary>
        corewolf::engine *Locator(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Locator[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// takes the position to be the dynamically updated current value of pos, with this value being reset if the locator const std::string &is moved.
        /// https://reference.wolfram.com/language/ref/Locator.html
        ///</summary>
        corewolf::engine *Locator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Locator[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays obj as the locator object.
        /// https://reference.wolfram.com/language/ref/Locator.html
        ///</summary>
        corewolf::engine *Locator(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Locator[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a pane with a locator at position {x,y} and background back.
        /// https://reference.wolfram.com/language/ref/LocatorPane.html
        ///</summary>
        corewolf::engine *LocatorPane(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LocatorPane[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// takes the locator position to be the dynamically updated current value of pt, with the value of pt being reset if the locator is moved.
        /// https://reference.wolfram.com/language/ref/LocatorPane.html
        ///</summary>
        corewolf::engine *LocatorPane(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LocatorPane[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies the range of coordinates for the locator.
        /// https://reference.wolfram.com/language/ref/LocatorPane.html
        ///</summary>
        corewolf::engine *LocatorPane(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("LocatorPane[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// uses jumps dx, dy.
        /// https://reference.wolfram.com/language/ref/LocatorPane.html
        ///</summary>
        corewolf::engine *LocatorPane(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::vector<std::string> &arg4, const std::string &name = "")
        {
            return this->execute("LocatorPane[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + "]", name);
        }

        ///< summary>
        /// gives the natural logarithm of z (logarithm to base ).
        /// https://reference.wolfram.com/language/ref/Log.html
        ///</summary>
        corewolf::engine *Log(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Log[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the logarithm to base b.
        /// https://reference.wolfram.com/language/ref/Log.html
        ///</summary>
        corewolf::engine *Log(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Log[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the base-10 logarithm of x.
        /// https://reference.wolfram.com/language/ref/Log10.html
        ///</summary>
        corewolf::engine *Log10(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Log10[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the base-2 logarithm of x.
        /// https://reference.wolfram.com/language/ref/Log2.html
        ///</summary>
        corewolf::engine *Log2(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Log2[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the logarithm of the Barnes G-function .
        /// https://reference.wolfram.com/language/ref/LogBarnesG.html
        ///</summary>
        corewolf::engine *LogBarnesG(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LogBarnesG[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the logarithm of the gamma function .
        /// https://reference.wolfram.com/language/ref/LogGamma.html
        ///</summary>
        corewolf::engine *LogGamma(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LogGamma[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a log-gamma distribution with shape parameters α and β and location parameter μ.
        /// https://reference.wolfram.com/language/ref/LogGammaDistribution.html
        ///</summary>
        corewolf::engine *LogGammaDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LogGammaDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// expands out logical combinations of equations, inequalities, and other functions.
        /// https://reference.wolfram.com/language/ref/LogicalExpand.html
        ///</summary>
        corewolf::engine *LogicalExpand(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LogicalExpand[" + arg0 + "]", name);
        }

        ///< summary>
        /// is the logarithmic integral function .
        /// https://reference.wolfram.com/language/ref/LogIntegral.html
        ///</summary>
        corewolf::engine *LogIntegral(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LogIntegral[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a logistic distribution with mean μ and scale parameter β.
        /// https://reference.wolfram.com/language/ref/LogisticDistribution.html
        ///</summary>
        corewolf::engine *LogisticDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LogisticDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a logistic distribution with mean 0 and scale parameter 1.
        /// https://reference.wolfram.com/language/ref/LogisticDistribution.html
        ///</summary>
        corewolf::engine *LogisticDistribution(const std::string &name = "")
        {
            return this->execute("LogisticDistribution[]", name);
        }

        ///< summary>
        /// gives the logistic sigmoid function.
        /// https://reference.wolfram.com/language/ref/LogisticSigmoid.html
        ///</summary>
        corewolf::engine *LogisticSigmoid(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LogisticSigmoid[" + arg0 + "]", name);
        }

        ///< summary>
        /// constructs a binomial logistic regression model of the form  that fits the yi for successive x values 1, 2, ….
        /// https://reference.wolfram.com/language/ref/LogitModelFit.html
        ///</summary>
        corewolf::engine *LogitModelFit(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LogitModelFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// constructs a binomial logistic regression model of the form  where the fi depend on the variables xk.
        /// https://reference.wolfram.com/language/ref/LogitModelFit.html
        ///</summary>
        corewolf::engine *LogitModelFit(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("LogitModelFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// constructs a binomial logistic regression model from the design matrix m and response vector v.
        /// https://reference.wolfram.com/language/ref/LogitModelFit.html
        ///</summary>
        corewolf::engine *LogitModelFit(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LogitModelFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the log‐likelihood function for observations x1, x2, … from the distribution dist.
        /// https://reference.wolfram.com/language/ref/LogLikelihood.html
        ///</summary>
        corewolf::engine *LogLikelihood(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LogLikelihood[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the log-likelihood function for the observations xi at time ti from the process proc.
        /// https://reference.wolfram.com/language/ref/LogLikelihood.html
        ///</summary>
        corewolf::engine *LogLikelihood(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("LogLikelihood[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates a log-linear plot of f as a function of x from xmin to xmax.
        /// https://reference.wolfram.com/language/ref/LogLinearPlot.html
        ///</summary>
        corewolf::engine *LogLinearPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LogLinearPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots several functions fi.
        /// https://reference.wolfram.com/language/ref/LogLinearPlot.html
        ///</summary>
        corewolf::engine *LogLinearPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LogLinearPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots fi with features defined by the symbolic wrapper w.
        /// https://reference.wolfram.com/language/ref/LogLinearPlot.html
        ///</summary>
        corewolf::engine *LogLinearPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LogLinearPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// takes the variable x to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/LogLinearPlot.html
        ///</summary>
        corewolf::engine *LogLinearPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LogLinearPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a log-logistic distribution with shape parameter γ and scale parameter σ.
        /// https://reference.wolfram.com/language/ref/LogLogisticDistribution.html
        ///</summary>
        corewolf::engine *LogLogisticDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LogLogisticDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a log-log plot of f as a function of x from xmin to xmax.
        /// https://reference.wolfram.com/language/ref/LogLogPlot.html
        ///</summary>
        corewolf::engine *LogLogPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LogLogPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots several functions fi.
        /// https://reference.wolfram.com/language/ref/LogLogPlot.html
        ///</summary>
        corewolf::engine *LogLogPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LogLogPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots fi with features defined by the symbolic wrapper w.
        /// https://reference.wolfram.com/language/ref/LogLogPlot.html
        ///</summary>
        corewolf::engine *LogLogPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LogLogPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// takes the variable x to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/LogLogPlot.html
        ///</summary>
        corewolf::engine *LogLogPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LogLogPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a log-multinormal distribution with parameters μ and Σ.
        /// https://reference.wolfram.com/language/ref/LogMultinormalDistribution.html
        ///</summary>
        corewolf::engine *LogMultinormalDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LogMultinormalDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a lognormal distribution derived from a normal distribution with mean μ and standard deviation σ.
        /// https://reference.wolfram.com/language/ref/LogNormalDistribution.html
        ///</summary>
        corewolf::engine *LogNormalDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LogNormalDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a log plot of f as a function of x from xmin to xmax.
        /// https://reference.wolfram.com/language/ref/LogPlot.html
        ///</summary>
        corewolf::engine *LogPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LogPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots several functions fi.
        /// https://reference.wolfram.com/language/ref/LogPlot.html
        ///</summary>
        corewolf::engine *LogPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LogPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots fi with features defined by the symbolic wrapper w.
        /// https://reference.wolfram.com/language/ref/LogPlot.html
        ///</summary>
        corewolf::engine *LogPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LogPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// takes the variable x to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/LogPlot.html
        ///</summary>
        corewolf::engine *LogPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LogPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests for equal hazard rates among the datai using a log-rank type test.
        /// https://reference.wolfram.com/language/ref/LogRankTest.html
        ///</summary>
        corewolf::engine *LogRankTest(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("LogRankTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// performs a weighted log-rank test with weights wspec.
        /// https://reference.wolfram.com/language/ref/LogRankTest.html
        ///</summary>
        corewolf::engine *LogRankTest(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LogRankTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/LogRankTest.html
        ///</summary>
        corewolf::engine *LogRankTest(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LogRankTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a logarithmic series distribution with parameter θ.
        /// https://reference.wolfram.com/language/ref/LogSeriesDistribution.html
        ///</summary>
        corewolf::engine *LogSeriesDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LogSeriesDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a pattern const std::string &that matches the longest sequence consistent with the pattern p.
        /// https://reference.wolfram.com/language/ref/Longest.html
        ///</summary>
        corewolf::engine *Longest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Longest[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds the longest sequence of contiguous or disjoint elements common to the strings, lists or biomolecular sequences s1 and s2.
        /// https://reference.wolfram.com/language/ref/LongestCommonSequence.html
        ///</summary>
        corewolf::engine *LongestCommonSequence(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LongestCommonSequence[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the longest sequence of contiguous or disjoint elements common to the strings, lists or biomolecular sequences s1 and s2 and returns their positions.
        /// https://reference.wolfram.com/language/ref/LongestCommonSequencePositions.html
        ///</summary>
        corewolf::engine *LongestCommonSequencePositions(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LongestCommonSequencePositions[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the longest contiguous subsequence of elements common to the strings, biomolecular sequences or lists s1 and s2.
        /// https://reference.wolfram.com/language/ref/LongestCommonSubsequence.html
        ///</summary>
        corewolf::engine *LongestCommonSubsequence(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LongestCommonSubsequence[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the longest contiguous subsequence of elements common to the strings, biomolecular sequences or lists s1 and s2 and returns their positions {pos1,pos2} in s1 and s2.
        /// https://reference.wolfram.com/language/ref/LongestCommonSubsequencePositions.html
        ///</summary>
        corewolf::engine *LongestCommonSubsequencePositions(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LongestCommonSubsequencePositions[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the longest ordered sequence of contiguous or disjoint elements in list.
        /// https://reference.wolfram.com/language/ref/LongestOrderedSequence.html
        ///</summary>
        corewolf::engine *LongestOrderedSequence(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LongestOrderedSequence[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds the longest ordered sequence using the ordering function p.
        /// https://reference.wolfram.com/language/ref/LongestOrderedSequence.html
        ///</summary>
        corewolf::engine *LongestOrderedSequence(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LongestOrderedSequence[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the longitude in degrees of a geographic position specified by pos.
        /// https://reference.wolfram.com/language/ref/Longitude.html
        ///</summary>
        corewolf::engine *Longitude(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Longitude[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the longitude referring to the specified geodetic datum.
        /// https://reference.wolfram.com/language/ref/Longitude.html
        ///</summary>
        corewolf::engine *Longitude(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Longitude[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LongLeftArrow.html
        ///</summary>
        corewolf::engine *LongLeftArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LongLeftArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LongLeftRightArrow.html
        ///</summary>
        corewolf::engine *LongLeftRightArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LongLeftRightArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LongRightArrow.html
        ///</summary>
        corewolf::engine *LongRightArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LongRightArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a trainable recurrent layer that takes a sequence of vectors and produces a sequence of vectors, each of size n.
        /// https://reference.wolfram.com/language/ref/LongShortTermMemoryLayer.html
        ///</summary>
        corewolf::engine *LongShortTermMemoryLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LongShortTermMemoryLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// includes options for weights and other parameters.
        /// https://reference.wolfram.com/language/ref/LongShortTermMemoryLayer.html
        ///</summary>
        corewolf::engine *LongShortTermMemoryLayer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LongShortTermMemoryLayer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// looks up the value associated with key in the association assoc; if the key is not present, Missing["KeyAbsent",key] is returned.
        /// https://reference.wolfram.com/language/ref/Lookup.html
        ///</summary>
        corewolf::engine *Lookup(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Lookup[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the values associated with the keyi.
        /// https://reference.wolfram.com/language/ref/Lookup.html
        ///</summary>
        corewolf::engine *Lookup(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Lookup[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list corresponding to the value of key in each associ.
        /// https://reference.wolfram.com/language/ref/Lookup.html
        ///</summary>
        corewolf::engine *Lookup(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Lookup[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives default if the key is not present.
        /// https://reference.wolfram.com/language/ref/Lookup.html
        ///</summary>
        corewolf::engine *Lookup(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Lookup[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// looks up the values associated with keys, wrapping each of then with head h before evaluation.
        /// https://reference.wolfram.com/language/ref/Lookup.html
        ///</summary>
        corewolf::engine *Lookup(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Lookup[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an operator form of Lookup that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/Lookup.html
        ///</summary>
        corewolf::engine *Lookup(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Lookup[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if the graph g has no self-loops, and False otherwise.
        /// https://reference.wolfram.com/language/ref/LoopFreeGraphQ.html
        ///</summary>
        corewolf::engine *LoopFreeGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LoopFreeGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if all the characters in the string are lowercase letters, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/LowerCaseQ.html
        ///</summary>
        corewolf::engine *LowerCaseQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LowerCaseQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LowerLeftArrow.html
        ///</summary>
        corewolf::engine *LowerLeftArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LowerLeftArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/LowerRightArrow.html
        ///</summary>
        corewolf::engine *LowerRightArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LowerRightArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a matrix in which all but the lower triangular elements of m are replaced with zeros.
        /// https://reference.wolfram.com/language/ref/LowerTriangularize.html
        ///</summary>
        corewolf::engine *LowerTriangularize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LowerTriangularize[" + arg0 + "]", name);
        }

        ///< summary>
        /// replaces with zeros only the elements above the k subdiagonal of m.
        /// https://reference.wolfram.com/language/ref/LowerTriangularize.html
        ///</summary>
        corewolf::engine *LowerTriangularize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LowerTriangularize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts the lower triangular matrix lmat to a structured array.
        /// https://reference.wolfram.com/language/ref/LowerTriangularMatrix.html
        ///</summary>
        corewolf::engine *LowerTriangularMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LowerTriangularMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if m is lower triangular, and False otherwise.
        /// https://reference.wolfram.com/language/ref/LowerTriangularMatrixQ.html
        ///</summary>
        corewolf::engine *LowerTriangularMatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LowerTriangularMatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if m is lower triangular starting down from the k diagonal, and False otherwise.
        /// https://reference.wolfram.com/language/ref/LowerTriangularMatrixQ.html
        ///</summary>
        corewolf::engine *LowerTriangularMatrixQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LowerTriangularMatrixQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies a lowpass filter with a cutoff frequency ωc to an array of data.
        /// https://reference.wolfram.com/language/ref/LowpassFilter.html
        ///</summary>
        corewolf::engine *LowpassFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LowpassFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses a filter kernel of length n.
        /// https://reference.wolfram.com/language/ref/LowpassFilter.html
        ///</summary>
        corewolf::engine *LowpassFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LowpassFilter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies a smoothing window wfun to the filter kernel.
        /// https://reference.wolfram.com/language/ref/LowpassFilter.html
        ///</summary>
        corewolf::engine *LowpassFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("LowpassFilter[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the optimal estimator gain matrix for the StateSpaceModel ssm, with process and measurement noise covariance matrices w and v.
        /// https://reference.wolfram.com/language/ref/LQEstimatorGains.html
        ///</summary>
        corewolf::engine *LQEstimatorGains(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LQEstimatorGains[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// specifies sensors as the noisy measurements of ssm.
        /// https://reference.wolfram.com/language/ref/LQEstimatorGains.html
        ///</summary>
        corewolf::engine *LQEstimatorGains(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LQEstimatorGains[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the optimal output feedback controller for the stochastic system specification sspec with noise covariance matrices cvs that minimize a cost function with weights wts.
        /// https://reference.wolfram.com/language/ref/LQGRegulator.html
        ///</summary>
        corewolf::engine *LQGRegulator(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LQGRegulator[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the property "prop".
        /// https://reference.wolfram.com/language/ref/LQGRegulator.html
        ///</summary>
        corewolf::engine *LQGRegulator(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LQGRegulator[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the state feedback gains for the system specification sspec that minimizes an output cost function with weights wts.
        /// https://reference.wolfram.com/language/ref/LQOutputRegulatorGains.html
        ///</summary>
        corewolf::engine *LQOutputRegulatorGains(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LQOutputRegulatorGains[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the state feedback gains for the system specification sspec that minimizes a cost function with weights wts.
        /// https://reference.wolfram.com/language/ref/LQRegulatorGains.html
        ///</summary>
        corewolf::engine *LQRegulatorGains(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LQRegulatorGains[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Lucas number .
        /// https://reference.wolfram.com/language/ref/LucasL.html
        ///</summary>
        corewolf::engine *LucasL(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LucasL[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Lucas polynomial .
        /// https://reference.wolfram.com/language/ref/LucasL.html
        ///</summary>
        corewolf::engine *LucasL(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LucasL[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Luccio–Sami components of the graph g.
        /// https://reference.wolfram.com/language/ref/LuccioSamiComponents.html
        ///</summary>
        corewolf::engine *LuccioSamiComponents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LuccioSamiComponents[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the components that include at least one of the vertices v1, v2, … .
        /// https://reference.wolfram.com/language/ref/LuccioSamiComponents.html
        ///</summary>
        corewolf::engine *LuccioSamiComponents(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("LuccioSamiComponents[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/LuccioSamiComponents.html
        ///</summary>
        corewolf::engine *LuccioSamiComponents(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LuccioSamiComponents[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a representation of the LU decomposition of a square matrix m.
        /// https://reference.wolfram.com/language/ref/LUDecomposition.html
        ///</summary>
        corewolf::engine *LUDecomposition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LUDecomposition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the time of the next lunar eclipse.
        /// https://reference.wolfram.com/language/ref/LunarEclipse.html
        ///</summary>
        corewolf::engine *LunarEclipse(const std::string &name = "")
        {
            return this->execute("LunarEclipse[]", name);
        }

        ///< summary>
        /// gives the time for the next lunar eclipse after the specified date.
        /// https://reference.wolfram.com/language/ref/LunarEclipse.html
        ///</summary>
        corewolf::engine *LunarEclipse(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LunarEclipse[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the specified property value for the next lunar eclipse after the specified date.
        /// https://reference.wolfram.com/language/ref/LunarEclipse.html
        ///</summary>
        corewolf::engine *LunarEclipse(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LunarEclipse[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a color in the LUV color space with lightness l and color components u and v.
        /// https://reference.wolfram.com/language/ref/LUVColor.html
        ///</summary>
        corewolf::engine *LUVColor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LUVColor[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// specifies opacity a.
        /// https://reference.wolfram.com/language/ref/LUVColor.html
        ///</summary>
        corewolf::engine *LUVColor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("LUVColor[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// returns a color from an HTML color name etc.
        /// https://reference.wolfram.com/language/ref/LUVColor.html
        ///</summary>
        corewolf::engine *LUVColor(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("LUVColor[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds a solution  of the matrix Lyapunov equation .
        /// https://reference.wolfram.com/language/ref/LyapunovSolve.html
        ///</summary>
        corewolf::engine *LyapunovSolve(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LyapunovSolve[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// solves .
        /// https://reference.wolfram.com/language/ref/LyapunovSolve.html
        ///</summary>
        corewolf::engine *LyapunovSolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LyapunovSolve[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// solves .
        /// https://reference.wolfram.com/language/ref/LyapunovSolve.html
        ///</summary>
        corewolf::engine *LyapunovSolve(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("LyapunovSolve[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// solves .
        /// https://reference.wolfram.com/language/ref/LyapunovSolve.html
        ///</summary>
        corewolf::engine *LyapunovSolve(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("LyapunovSolve[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the sporadic simple Lyons group .
        /// https://reference.wolfram.com/language/ref/LyonsGroupLy.html
        ///</summary>
        corewolf::engine *LyonsGroupLy(const std::string &name = "")
        {
            return this->execute("LyonsGroupLy[]", name);
        }

        ///< summary>
        /// returns True if expr is a machine‐precision real or complex number, and returns False otherwise.
        /// https://reference.wolfram.com/language/ref/MachineNumberQ.html
        ///</summary>
        corewolf::engine *MachineNumberQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MachineNumberQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an const std::string &to be displayed with magnification r.
        /// https://reference.wolfram.com/language/ref/Magnify.html
        ///</summary>
        corewolf::engine *Magnify(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Magnify[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays with expr magnified by a fixed factor.
        /// https://reference.wolfram.com/language/ref/Magnify.html
        ///</summary>
        corewolf::engine *Magnify(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Magnify[" + arg0 + "]", name);
        }

        ///< summary>
        /// executes the mail command cmd on the target mail server connection, folder, file or item(s).
        /// https://reference.wolfram.com/language/ref/MailExecute.html
        ///</summary>
        corewolf::engine *MailExecute(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MailExecute[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a mail folder associated with an active mail server connection.
        /// https://reference.wolfram.com/language/ref/MailFolder.html
        ///</summary>
        corewolf::engine *MailFolder(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MailFolder[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an item of mail associated with an active mail server connection.
        /// https://reference.wolfram.com/language/ref/MailItem.html
        ///</summary>
        corewolf::engine *MailItem(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MailItem[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a mail receiver function that applies fun to any mail message it receives.
        /// https://reference.wolfram.com/language/ref/MailReceiverFunction.html
        ///</summary>
        corewolf::engine *MailReceiverFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MailReceiverFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// searches the specified mail folder for messages with properties matching elements in assoc.
        /// https://reference.wolfram.com/language/ref/MailSearch.html
        ///</summary>
        corewolf::engine *MailSearch(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MailSearch[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// searches the current default mail inbox.
        /// https://reference.wolfram.com/language/ref/MailSearch.html
        ///</summary>
        corewolf::engine *MailSearch(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MailSearch[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the list of unread messages in the current default mail inbox.
        /// https://reference.wolfram.com/language/ref/MailSearch.html
        ///</summary>
        corewolf::engine *MailSearch(const std::string &name = "")
        {
            return this->execute("MailSearch[]", name);
        }

        ///< summary>
        /// connects to your default incoming mail server.
        /// https://reference.wolfram.com/language/ref/MailServerConnect.html
        ///</summary>
        corewolf::engine *MailServerConnect(const std::string &name = "")
        {
            return this->execute("MailServerConnect[]", name);
        }

        ///< summary>
        /// connects to the specified incoming mail server "server".
        /// https://reference.wolfram.com/language/ref/MailServerConnect.html
        ///</summary>
        corewolf::engine *MailServerConnect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MailServerConnect[" + arg0 + "]", name);
        }

        ///< summary>
        /// connects using the specified user ID userid.
        /// https://reference.wolfram.com/language/ref/MailServerConnect.html
        ///</summary>
        corewolf::engine *MailServerConnect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MailServerConnect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// connects using userid and password.
        /// https://reference.wolfram.com/language/ref/MailServerConnect.html
        ///</summary>
        corewolf::engine *MailServerConnect(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MailServerConnect[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a symbolic representation of a connection to an incoming mail server.
        /// https://reference.wolfram.com/language/ref/MailServerConnection.html
        ///</summary>
        corewolf::engine *MailServerConnection(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MailServerConnection[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if the majority of the ei are True, and False if the majority are False.
        /// https://reference.wolfram.com/language/ref/Majority.html
        ///</summary>
        corewolf::engine *Majority(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Majority[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is the low‐level function used in Wolfram System sessions to convert expressions into boxes.
        /// https://reference.wolfram.com/language/ref/MakeBoxes.html
        ///</summary>
        corewolf::engine *MakeBoxes(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MakeBoxes[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is the function to convert expr to StandardForm boxes.
        /// https://reference.wolfram.com/language/ref/MakeBoxes.html
        ///</summary>
        corewolf::engine *MakeBoxes(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MakeBoxes[" + arg0 + "]", name);
        }

        ///< summary>
        /// is the low‐level function used in Wolfram System sessions to construct expressions from boxes.
        /// https://reference.wolfram.com/language/ref/MakeExpression.html
        ///</summary>
        corewolf::engine *MakeExpression(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MakeExpression[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the positive integer ID associated with expr if it is a managed library expression and $Failed otherwise.
        /// https://reference.wolfram.com/language/ref/ManagedLibraryExpressionID.html
        ///</summary>
        corewolf::engine *ManagedLibraryExpressionID(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ManagedLibraryExpressionID[" + arg0 + "]", name);
        }

        ///< summary>
        /// only returns the ID if expr is associated with the registered manager having name mname.
        /// https://reference.wolfram.com/language/ref/ManagedLibraryExpressionID.html
        ///</summary>
        corewolf::engine *ManagedLibraryExpressionID(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ManagedLibraryExpressionID[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns True if expr is a managed library expression and False otherwise.
        /// https://reference.wolfram.com/language/ref/ManagedLibraryExpressionQ.html
        ///</summary>
        corewolf::engine *ManagedLibraryExpressionQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ManagedLibraryExpressionQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// only returns True if expr is associated with the registered manager having name mname.
        /// https://reference.wolfram.com/language/ref/ManagedLibraryExpressionQ.html
        ///</summary>
        corewolf::engine *ManagedLibraryExpressionQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ManagedLibraryExpressionQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Böttcher coordinate of z with respect to the Mandelbrot set.
        /// https://reference.wolfram.com/language/ref/MandelbrotSetBoettcher.html
        ///</summary>
        corewolf::engine *MandelbrotSetBoettcher(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MandelbrotSetBoettcher[" + arg0 + "]", name);
        }

        ///< summary>
        /// estimates the distance from c to the nearest point in the Mandelbrot set.
        /// https://reference.wolfram.com/language/ref/MandelbrotSetDistance.html
        ///</summary>
        corewolf::engine *MandelbrotSetDistance(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MandelbrotSetDistance[" + arg0 + "]", name);
        }

        ///< summary>
        /// estimates the distance from c to the nearest point in the complement of the Mandelbrot set.
        /// https://reference.wolfram.com/language/ref/MandelbrotSetDistance.html
        ///</summary>
        corewolf::engine *MandelbrotSetDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MandelbrotSetDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the number of iterations of the function , beginning with , that are needed to determine whether c is in the Mandelbrot set.
        /// https://reference.wolfram.com/language/ref/MandelbrotSetIterationCount.html
        ///</summary>
        corewolf::engine *MandelbrotSetIterationCount(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MandelbrotSetIterationCount[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if z is in the Mandelbrot set, and False otherwise.
        /// https://reference.wolfram.com/language/ref/MandelbrotSetMemberQ.html
        ///</summary>
        corewolf::engine *MandelbrotSetMemberQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MandelbrotSetMemberQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots the portion of the Mandelbrot set inside the rectangle with corners zmin and zmax.
        /// https://reference.wolfram.com/language/ref/MandelbrotSetPlot.html
        ///</summary>
        corewolf::engine *MandelbrotSetPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("MandelbrotSetPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots the Mandelbrot set over a default rectangle.
        /// https://reference.wolfram.com/language/ref/MandelbrotSetPlot.html
        ///</summary>
        corewolf::engine *MandelbrotSetPlot(const std::string &name = "")
        {
            return this->execute("MandelbrotSetPlot[]", name);
        }

        ///< summary>
        /// gives the von Mangoldt function .
        /// https://reference.wolfram.com/language/ref/MangoldtLambda.html
        ///</summary>
        corewolf::engine *MangoldtLambda(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MangoldtLambda[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Manhattan or "city block" distance between vectors u and v.
        /// https://reference.wolfram.com/language/ref/ManhattanDistance.html
        ///</summary>
        corewolf::engine *ManhattanDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ManhattanDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a version of expr with controls added to allow interactive manipulation of the value of u.
        /// https://reference.wolfram.com/language/ref/Manipulate.html
        ///</summary>
        corewolf::engine *Manipulate(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Manipulate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// allows u to take on discrete values u1,u2,….
        /// https://reference.wolfram.com/language/ref/Manipulate.html
        ///</summary>
        corewolf::engine *Manipulate(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Manipulate[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// provides controls to manipulate each of the u,v,….
        /// https://reference.wolfram.com/language/ref/Manipulate.html
        ///</summary>
        corewolf::engine *Manipulate(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Manipulate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// links the controls to the specified controllers on an external device.
        /// https://reference.wolfram.com/language/ref/Manipulate.html
        ///</summary>
        corewolf::engine *Manipulate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Manipulate[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a manipulator with setting x in the range 0 to 1.
        /// https://reference.wolfram.com/language/ref/Manipulator.html
        ///</summary>
        corewolf::engine *Manipulator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Manipulator[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a manipulator with range xmin to xmax.
        /// https://reference.wolfram.com/language/ref/Manipulator.html
        ///</summary>
        corewolf::engine *Manipulator(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Manipulator[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the manned space mission entity.
        /// https://reference.wolfram.com/language/ref/MannedSpaceMissionData.html
        ///</summary>
        corewolf::engine *MannedSpaceMissionData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MannedSpaceMissionData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified manned space mission entities.
        /// https://reference.wolfram.com/language/ref/MannedSpaceMissionData.html
        ///</summary>
        corewolf::engine *MannedSpaceMissionData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MannedSpaceMissionData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/MannedSpaceMissionData.html
        ///</summary>
        corewolf::engine *MannedSpaceMissionData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MannedSpaceMissionData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether the medians of data1 and data2 are equal.
        /// https://reference.wolfram.com/language/ref/MannWhitneyTest.html
        ///</summary>
        corewolf::engine *MannWhitneyTest(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("MannWhitneyTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// tests the median difference against μ0.
        /// https://reference.wolfram.com/language/ref/MannWhitneyTest.html
        ///</summary>
        corewolf::engine *MannWhitneyTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MannWhitneyTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/MannWhitneyTest.html
        ///</summary>
        corewolf::engine *MannWhitneyTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MannWhitneyTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list containing the mantissa and exponent of a number x.
        /// https://reference.wolfram.com/language/ref/MantissaExponent.html
        ///</summary>
        corewolf::engine *MantissaExponent(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MantissaExponent[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the base‐b mantissa and exponent of x.
        /// https://reference.wolfram.com/language/ref/MantissaExponent.html
        ///</summary>
        corewolf::engine *MantissaExponent(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MantissaExponent[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// or f//@expr applies f to every subexpression in expr.
        /// https://reference.wolfram.com/language/ref/MapAll.html
        ///</summary>
        corewolf::engine *MapAll(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MapAll[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces heads at level 1 of expr by f.
        /// https://reference.wolfram.com/language/ref/MapApply.html
        ///</summary>
        corewolf::engine *MapApply(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MapApply[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of MapApply that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/MapApply.html
        ///</summary>
        corewolf::engine *MapApply(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MapApply[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies f to the element at position n in expr. If n is negative, the position is counted from the end.
        /// https://reference.wolfram.com/language/ref/MapAt.html
        ///</summary>
        corewolf::engine *MapAt(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MapAt[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies f to the part of expr at position {i,j,…}.
        /// https://reference.wolfram.com/language/ref/MapAt.html
        ///</summary>
        corewolf::engine *MapAt(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("MapAt[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// applies f to parts of expr at several positions.
        /// https://reference.wolfram.com/language/ref/MapAt.html
        ///</summary>
        corewolf::engine *MapAt(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("MapAt[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// represents an operator form of MapAt that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/MapAt.html
        ///</summary>
        corewolf::engine *MapAt(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MapAt[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f to the elements of expr, giving the part specification of each element as a second argument to f.
        /// https://reference.wolfram.com/language/ref/MapIndexed.html
        ///</summary>
        corewolf::engine *MapIndexed(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MapIndexed[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f to all parts of expr on levels specified by levelspec.
        /// https://reference.wolfram.com/language/ref/MapIndexed.html
        ///</summary>
        corewolf::engine *MapIndexed(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MapIndexed[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of MapIndexed that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/MapIndexed.html
        ///</summary>
        corewolf::engine *MapIndexed(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MapIndexed[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a moving-average process of order q with normal white noise variance v.
        /// https://reference.wolfram.com/language/ref/MAProcess.html
        ///</summary>
        corewolf::engine *MAProcess(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MAProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an MA process with initial data init.
        /// https://reference.wolfram.com/language/ref/MAProcess.html
        ///</summary>
        corewolf::engine *MAProcess(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MAProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an MA process with a constant c.
        /// https://reference.wolfram.com/language/ref/MAProcess.html
        ///</summary>
        corewolf::engine *MAProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MAProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives {f[a1,b1,…],f[a2,b2,…],…}.
        /// https://reference.wolfram.com/language/ref/MapThread.html
        ///</summary>
        corewolf::engine *MapThread(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("MapThread[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// applies f to the parts of the expri at level n.
        /// https://reference.wolfram.com/language/ref/MapThread.html
        ///</summary>
        corewolf::engine *MapThread(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MapThread[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of MapThread that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/MapThread.html
        ///</summary>
        corewolf::engine *MapThread(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MapThread[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Marchenko–Pastur distribution with asymptotic ratio  and scale parameter .
        /// https://reference.wolfram.com/language/ref/MarchenkoPasturDistribution.html
        ///</summary>
        corewolf::engine *MarchenkoPasturDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MarchenkoPasturDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Marchenko–Pastur distribution with unit scale parameter.
        /// https://reference.wolfram.com/language/ref/MarchenkoPasturDistribution.html
        ///</summary>
        corewolf::engine *MarchenkoPasturDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MarchenkoPasturDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives Marcum's Q function .
        /// https://reference.wolfram.com/language/ref/MarcumQ.html
        ///</summary>
        corewolf::engine *MarcumQ(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MarcumQ[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives Marcum's Q function .
        /// https://reference.wolfram.com/language/ref/MarcumQ.html
        ///</summary>
        corewolf::engine *MarcumQ(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("MarcumQ[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// tests whether data follows a MultinormalDistribution using the Mardia combined test.
        /// https://reference.wolfram.com/language/ref/MardiaCombinedTest.html
        ///</summary>
        corewolf::engine *MardiaCombinedTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MardiaCombinedTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/MardiaCombinedTest.html
        ///</summary>
        corewolf::engine *MardiaCombinedTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MardiaCombinedTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether data follows a MultinormalDistribution using the Mardia kurtosis test.
        /// https://reference.wolfram.com/language/ref/MardiaKurtosisTest.html
        ///</summary>
        corewolf::engine *MardiaKurtosisTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MardiaKurtosisTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/MardiaKurtosisTest.html
        ///</summary>
        corewolf::engine *MardiaKurtosisTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MardiaKurtosisTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether data follows a MultinormalDistribution using the Mardia skewness test.
        /// https://reference.wolfram.com/language/ref/MardiaSkewnessTest.html
        ///</summary>
        corewolf::engine *MardiaSkewnessTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MardiaSkewnessTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/MardiaSkewnessTest.html
        ///</summary>
        corewolf::engine *MardiaSkewnessTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MardiaSkewnessTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a univariate marginal distribution of the k coordinate from the multivariate distribution dist.
        /// https://reference.wolfram.com/language/ref/MarginalDistribution.html
        ///</summary>
        corewolf::engine *MarginalDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MarginalDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a multivariate marginal distribution of the {k1,k2,…} coordinates.
        /// https://reference.wolfram.com/language/ref/MarginalDistribution.html
        ///</summary>
        corewolf::engine *MarginalDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MarginalDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a summary of properties for the finite state Markov process mproc.
        /// https://reference.wolfram.com/language/ref/MarkovProcessProperties.html
        ///</summary>
        corewolf::engine *MarkovProcessProperties(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MarkovProcessProperties[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the specified "property" for the process mproc.
        /// https://reference.wolfram.com/language/ref/MarkovProcessProperties.html
        ///</summary>
        corewolf::engine *MarkovProcessProperties(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MarkovProcessProperties[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a mass concentration boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/MassConcentrationCondition.html
        ///</summary>
        corewolf::engine *MassConcentrationCondition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MassConcentrationCondition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a thermal surface boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/MassConcentrationCondition.html
        ///</summary>
        corewolf::engine *MassConcentrationCondition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("MassConcentrationCondition[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a mass flux boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/MassFluxValue.html
        ///</summary>
        corewolf::engine *MassFluxValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MassFluxValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a mass flux boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/MassFluxValue.html
        ///</summary>
        corewolf::engine *MassFluxValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("MassFluxValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a mass impermeable boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/MassImpermeableBoundaryValue.html
        ///</summary>
        corewolf::engine *MassImpermeableBoundaryValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MassImpermeableBoundaryValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a mass impermeable boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/MassImpermeableBoundaryValue.html
        ///</summary>
        corewolf::engine *MassImpermeableBoundaryValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("MassImpermeableBoundaryValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a mass outflow boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/MassOutflowValue.html
        ///</summary>
        corewolf::engine *MassOutflowValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MassOutflowValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a mass outflow boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/MassOutflowValue.html
        ///</summary>
        corewolf::engine *MassOutflowValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("MassOutflowValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a mass symmetry boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/MassSymmetryValue.html
        ///</summary>
        corewolf::engine *MassSymmetryValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MassSymmetryValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a mass symmetry boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/MassSymmetryValue.html
        ///</summary>
        corewolf::engine *MassSymmetryValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("MassSymmetryValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a mass transfer boundary condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/MassTransferValue.html
        ///</summary>
        corewolf::engine *MassTransferValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MassTransferValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a mass transfer boundary condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/MassTransferValue.html
        ///</summary>
        corewolf::engine *MassTransferValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("MassTransferValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// yields a mass transport PDE term with variables vars and parameters pars.
        /// https://reference.wolfram.com/language/ref/MassTransportPDEComponent.html
        ///</summary>
        corewolf::engine *MassTransportPDEComponent(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MassTransportPDEComponent[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the matching dissimilarity between Boolean vectors u and v.
        /// https://reference.wolfram.com/language/ref/MatchingDissimilarity.html
        ///</summary>
        corewolf::engine *MatchingDissimilarity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MatchingDissimilarity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns True if the pattern form matches expr, and returns False otherwise.
        /// https://reference.wolfram.com/language/ref/MatchQ.html
        ///</summary>
        corewolf::engine *MatchQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MatchQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of MatchQ that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/MatchQ.html
        ///</summary>
        corewolf::engine *MatchQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MatchQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a three-dimensional graphics directive specifying that surfaces that follow are to be drawn with the material "material" appearance.
        /// https://reference.wolfram.com/language/ref/MaterialShading.html
        ///</summary>
        corewolf::engine *MaterialShading(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MaterialShading[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the specified color col as the base color.
        /// https://reference.wolfram.com/language/ref/MaterialShading.html
        ///</summary>
        corewolf::engine *MaterialShading(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("MaterialShading[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// uses the specified parameters parms.
        /// https://reference.wolfram.com/language/ref/MaterialShading.html
        ///</summary>
        corewolf::engine *MaterialShading(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MaterialShading[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Matérn cluster point process with density μ, cluster mean λ and radius rm in .
        /// https://reference.wolfram.com/language/ref/MaternPointProcess.html
        ///</summary>
        corewolf::engine *MaternPointProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("MaternPointProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives data corresponding to property for the mathematical function specified by entity.
        /// https://reference.wolfram.com/language/ref/MathematicalFunctionData.html
        ///</summary>
        corewolf::engine *MathematicalFunctionData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MathematicalFunctionData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives data for the given entity-property pair in the format specified by annotation.
        /// https://reference.wolfram.com/language/ref/MathematicalFunctionData.html
        ///</summary>
        corewolf::engine *MathematicalFunctionData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MathematicalFunctionData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives data for the given entity-property pair with property qualifiers qual1, qual2, … set to the given values.
        /// https://reference.wolfram.com/language/ref/MathematicalFunctionData.html
        ///</summary>
        corewolf::engine *MathematicalFunctionData(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("MathematicalFunctionData[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives data corresponding to the given entity, property and annotation format, with property qualifiers qual1, qual2, … set to the given values.
        /// https://reference.wolfram.com/language/ref/MathematicalFunctionData.html
        ///</summary>
        corewolf::engine *MathematicalFunctionData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("MathematicalFunctionData[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// gives the even Mathieu function with characteristic value a and parameter q.
        /// https://reference.wolfram.com/language/ref/MathieuC.html
        ///</summary>
        corewolf::engine *MathieuC(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MathieuC[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the characteristic value  for even Mathieu functions with characteristic exponent r and parameter q.
        /// https://reference.wolfram.com/language/ref/MathieuCharacteristicA.html
        ///</summary>
        corewolf::engine *MathieuCharacteristicA(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MathieuCharacteristicA[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the characteristic value  for odd Mathieu functions with characteristic exponent r and parameter q.
        /// https://reference.wolfram.com/language/ref/MathieuCharacteristicB.html
        ///</summary>
        corewolf::engine *MathieuCharacteristicB(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MathieuCharacteristicB[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the characteristic exponent r for Mathieu functions with characteristic value a and parameter q.
        /// https://reference.wolfram.com/language/ref/MathieuCharacteristicExponent.html
        ///</summary>
        corewolf::engine *MathieuCharacteristicExponent(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MathieuCharacteristicExponent[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the derivative with respect to z of the even Mathieu function with characteristic value a and parameter q.
        /// https://reference.wolfram.com/language/ref/MathieuCPrime.html
        ///</summary>
        corewolf::engine *MathieuCPrime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MathieuCPrime[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the sporadic simple Mathieu group .
        /// https://reference.wolfram.com/language/ref/MathieuGroupM11.html
        ///</summary>
        corewolf::engine *MathieuGroupM11(const std::string &name = "")
        {
            return this->execute("MathieuGroupM11[]", name);
        }

        ///< summary>
        /// represents the sporadic simple Mathieu group .
        /// https://reference.wolfram.com/language/ref/MathieuGroupM12.html
        ///</summary>
        corewolf::engine *MathieuGroupM12(const std::string &name = "")
        {
            return this->execute("MathieuGroupM12[]", name);
        }

        ///< summary>
        /// represents the sporadic simple Mathieu group .
        /// https://reference.wolfram.com/language/ref/MathieuGroupM22.html
        ///</summary>
        corewolf::engine *MathieuGroupM22(const std::string &name = "")
        {
            return this->execute("MathieuGroupM22[]", name);
        }

        ///< summary>
        /// represents the sporadic simple Mathieu group .
        /// https://reference.wolfram.com/language/ref/MathieuGroupM23.html
        ///</summary>
        corewolf::engine *MathieuGroupM23(const std::string &name = "")
        {
            return this->execute("MathieuGroupM23[]", name);
        }

        ///< summary>
        /// represents the sporadic simple Mathieu group .
        /// https://reference.wolfram.com/language/ref/MathieuGroupM24.html
        ///</summary>
        corewolf::engine *MathieuGroupM24(const std::string &name = "")
        {
            return this->execute("MathieuGroupM24[]", name);
        }

        ///< summary>
        /// gives the odd Mathieu function with characteristic value a and parameter q.
        /// https://reference.wolfram.com/language/ref/MathieuS.html
        ///</summary>
        corewolf::engine *MathieuS(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MathieuS[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the derivative with respect to z of the odd Mathieu function with characteristic value a and parameter q.
        /// https://reference.wolfram.com/language/ref/MathieuSPrime.html
        ///</summary>
        corewolf::engine *MathieuSPrime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MathieuSPrime[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// prints as a MathML form of expr.
        /// https://reference.wolfram.com/language/ref/MathMLForm.html
        ///</summary>
        corewolf::engine *MathMLForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MathMLForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the domain of matrices of dimensions d1×d2.
        /// https://reference.wolfram.com/language/ref/Matrices.html
        ///</summary>
        corewolf::engine *Matrices(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Matrices[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the domain of matrices of dimensions d1×d2, with components in the domain dom.
        /// https://reference.wolfram.com/language/ref/Matrices.html
        ///</summary>
        corewolf::engine *Matrices(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Matrices[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the subdomain of matrices d1×d2 with symmetry sym.
        /// https://reference.wolfram.com/language/ref/Matrices.html
        ///</summary>
        corewolf::engine *Matrices(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Matrices[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the matrix exponential of m.
        /// https://reference.wolfram.com/language/ref/MatrixExp.html
        ///</summary>
        corewolf::engine *MatrixExp(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MatrixExp[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the matrix exponential of m applied to the vector v.
        /// https://reference.wolfram.com/language/ref/MatrixExp.html
        ///</summary>
        corewolf::engine *MatrixExp(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MatrixExp[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// prints with the elements of list arranged in a regular array.
        /// https://reference.wolfram.com/language/ref/MatrixForm.html
        ///</summary>
        corewolf::engine *MatrixForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MatrixForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the matrix generated by the scalar function f at the matrix argument m.
        /// https://reference.wolfram.com/language/ref/MatrixFunction.html
        ///</summary>
        corewolf::engine *MatrixFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MatrixFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the matrix logarithm of a matrix m.
        /// https://reference.wolfram.com/language/ref/MatrixLog.html
        ///</summary>
        corewolf::engine *MatrixLog(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MatrixLog[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents zero mean matrix normal distribution with row covariance matrix Σrow and column covariance matrix Σcol.
        /// https://reference.wolfram.com/language/ref/MatrixNormalDistribution.html
        ///</summary>
        corewolf::engine *MatrixNormalDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MatrixNormalDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents matrix normal distribution with mean matrix μ.
        /// https://reference.wolfram.com/language/ref/MatrixNormalDistribution.html
        ///</summary>
        corewolf::engine *MatrixNormalDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MatrixNormalDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a plot that gives a visual representation of the values of elements in a matrix.
        /// https://reference.wolfram.com/language/ref/MatrixPlot.html
        ///</summary>
        corewolf::engine *MatrixPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MatrixPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the n  matrix power of the matrix m.
        /// https://reference.wolfram.com/language/ref/MatrixPower.html
        ///</summary>
        corewolf::engine *MatrixPower(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MatrixPower[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the n matrix power of the matrix m applied to the vector v.
        /// https://reference.wolfram.com/language/ref/MatrixPower.html
        ///</summary>
        corewolf::engine *MatrixPower(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MatrixPower[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the distribution of the matrix property expr where the matrix-valued random variable x follows the matrix distribution mdist.
        /// https://reference.wolfram.com/language/ref/MatrixPropertyDistribution.html
        ///</summary>
        corewolf::engine *MatrixPropertyDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MatrixPropertyDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the distribution where x1, x2, … are independent and follow the matrix distributions mdist1, mdist2, ….
        /// https://reference.wolfram.com/language/ref/MatrixPropertyDistribution.html
        ///</summary>
        corewolf::engine *MatrixPropertyDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MatrixPropertyDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives True if expr is a list of lists or a two-dimensional SparseArray const std::string &that can represent a matrix, and gives False otherwise.
        /// https://reference.wolfram.com/language/ref/MatrixQ.html
        ///</summary>
        corewolf::engine *MatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True only if test yields True when applied to each of the matrix elements in expr.
        /// https://reference.wolfram.com/language/ref/MatrixQ.html
        ///</summary>
        corewolf::engine *MatrixQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MatrixQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the rank of the matrix m.
        /// https://reference.wolfram.com/language/ref/MatrixRank.html
        ///</summary>
        corewolf::engine *MatrixRank(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MatrixRank[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents zero mean matrix  distribution with row covariance matrix Σrow, column covariance matrix Σcol, and degrees of freedom parameter ν.
        /// https://reference.wolfram.com/language/ref/MatrixTDistribution.html
        ///</summary>
        corewolf::engine *MatrixTDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MatrixTDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents matrix  distribution with mean matrix μ.
        /// https://reference.wolfram.com/language/ref/MatrixTDistribution.html
        ///</summary>
        corewolf::engine *MatrixTDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("MatrixTDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// yields the numerically largest of the xi.
        /// https://reference.wolfram.com/language/ref/Max.html
        ///</summary>
        corewolf::engine *Max(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Max[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields the largest element of any of the lists.
        /// https://reference.wolfram.com/language/ref/Max.html
        ///</summary>
        corewolf::engine *Max(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Max[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the latest date of the datei.
        /// https://reference.wolfram.com/language/ref/MaxDate.html
        ///</summary>
        corewolf::engine *MaxDate(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("MaxDate[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the endpoint of the date interval interval.
        /// https://reference.wolfram.com/language/ref/MaxDate.html
        ///</summary>
        corewolf::engine *MaxDate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MaxDate[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the endpoint of interval as specified by granularity gran.
        /// https://reference.wolfram.com/language/ref/MaxDate.html
        ///</summary>
        corewolf::engine *MaxDate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MaxDate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a binary image in which white pixels correspond to constant extended maxima in image.
        /// https://reference.wolfram.com/language/ref/MaxDetect.html
        ///</summary>
        corewolf::engine *MaxDetect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MaxDetect[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds extended maxima where the range of values is not greater than h.
        /// https://reference.wolfram.com/language/ref/MaxDetect.html
        ///</summary>
        corewolf::engine *MaxDetect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MaxDetect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// filters data by replacing every value by the maximum value in its range-r neighborhood.
        /// https://reference.wolfram.com/language/ref/MaxFilter.html
        ///</summary>
        corewolf::engine *MaxFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MaxFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses ri for filtering the dimension in data.
        /// https://reference.wolfram.com/language/ref/MaxFilter.html
        ///</summary>
        corewolf::engine *MaxFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MaxFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns a list of the ei for which the value of f[ei] is maximal.
        /// https://reference.wolfram.com/language/ref/MaximalBy.html
        ///</summary>
        corewolf::engine *MaximalBy(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MaximalBy[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a list of the ei corresponding to the n largest f[ei].
        /// https://reference.wolfram.com/language/ref/MaximalBy.html
        ///</summary>
        corewolf::engine *MaximalBy(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MaximalBy[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of MaximalBy that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/MaximalBy.html
        ///</summary>
        corewolf::engine *MaximalBy(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MaximalBy[" + arg0 + "]", name);
        }

        ///< summary>
        /// maximizes f exactly with respect to x.
        /// https://reference.wolfram.com/language/ref/Maximize.html
        ///</summary>
        corewolf::engine *Maximize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Maximize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// maximizes f exactly with respect to x, y, ….
        /// https://reference.wolfram.com/language/ref/Maximize.html
        ///</summary>
        corewolf::engine *Maximize(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Maximize[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// maximizes f exactly subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/Maximize.html
        ///</summary>
        corewolf::engine *Maximize(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Maximize[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// constrains variables to the domain dom, typically Reals or Integers.
        /// https://reference.wolfram.com/language/ref/Maximize.html
        ///</summary>
        corewolf::engine *Maximize(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Maximize[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the max limit xx*f(x).
        /// https://reference.wolfram.com/language/ref/MaxLimit.html
        ///</summary>
        corewolf::engine *MaxLimit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MaxLimit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the nested max limit ⋯ f (x1,…,xn).
        /// https://reference.wolfram.com/language/ref/MaxLimit.html
        ///</summary>
        corewolf::engine *MaxLimit(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MaxLimit[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the maximum number of bytes used to store all data for the current Wolfram System session.
        /// https://reference.wolfram.com/language/ref/MaxMemoryUsed.html
        ///</summary>
        corewolf::engine *MaxMemoryUsed(const std::string &name = "")
        {
            return this->execute("MaxMemoryUsed[]", name);
        }

        ///< summary>
        /// gives the maximum number of bytes used during the evaluation of expr.
        /// https://reference.wolfram.com/language/ref/MaxMemoryUsed.html
        ///</summary>
        corewolf::engine *MaxMemoryUsed(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MaxMemoryUsed[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a generalized maximum extreme value distribution with location parameter μ, scale parameter σ, and shape parameter ξ.
        /// https://reference.wolfram.com/language/ref/MaxStableDistribution.html
        ///</summary>
        corewolf::engine *MaxStableDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MaxStableDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the maximum value of f with respect to x.
        /// https://reference.wolfram.com/language/ref/MaxValue.html
        ///</summary>
        corewolf::engine *MaxValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MaxValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the maximum value of f with respect to x, y, ….
        /// https://reference.wolfram.com/language/ref/MaxValue.html
        ///</summary>
        corewolf::engine *MaxValue(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MaxValue[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the maximum value of f subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/MaxValue.html
        ///</summary>
        corewolf::engine *MaxValue(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MaxValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// constrains variables to the domain dom, typically Reals or Integers.
        /// https://reference.wolfram.com/language/ref/MaxValue.html
        ///</summary>
        corewolf::engine *MaxValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MaxValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Maxwell distribution with scale parameter σ.
        /// https://reference.wolfram.com/language/ref/MaxwellDistribution.html
        ///</summary>
        corewolf::engine *MaxwellDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MaxwellDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the sporadic simple McLaughlin group .
        /// https://reference.wolfram.com/language/ref/McLaughlinGroupMcL.html
        ///</summary>
        corewolf::engine *McLaughlinGroupMcL(const std::string &name = "")
        {
            return this->execute("McLaughlinGroupMcL[]", name);
        }

        ///< summary>
        /// gives the statistical mean of the elements in list.
        /// https://reference.wolfram.com/language/ref/Mean.html
        ///</summary>
        corewolf::engine *Mean(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Mean[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a loss layer that computes the mean absolute loss between the "Input" port and "Target" port.
        /// https://reference.wolfram.com/language/ref/MeanAbsoluteLossLayer.html
        ///</summary>
        corewolf::engine *MeanAbsoluteLossLayer(const std::string &name = "")
        {
            return this->execute("MeanAbsoluteLossLayer[]", name);
        }

        ///< summary>
        /// gives an Around const std::string &describing the mean of the xi and its uncertainty.
        /// https://reference.wolfram.com/language/ref/MeanAround.html
        ///</summary>
        corewolf::engine *MeanAround(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("MeanAround[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a VectorAround const std::string &describing the means of the vectors xi and their covariance.
        /// https://reference.wolfram.com/language/ref/MeanAround.html
        ///</summary>
        corewolf::engine *MeanAround(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MeanAround[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the mean clustering coefficient of the graph g.
        /// https://reference.wolfram.com/language/ref/MeanClusteringCoefficient.html
        ///</summary>
        corewolf::engine *MeanClusteringCoefficient(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MeanClusteringCoefficient[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/MeanClusteringCoefficient.html
        ///</summary>
        corewolf::engine *MeanClusteringCoefficient(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("MeanClusteringCoefficient[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of k-mean degree connectivity for the graph g for successive k=0,1,2… .
        /// https://reference.wolfram.com/language/ref/MeanDegreeConnectivity.html
        ///</summary>
        corewolf::engine *MeanDegreeConnectivity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MeanDegreeConnectivity[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of k-mean in-degree connectivity for the graph g.
        /// https://reference.wolfram.com/language/ref/MeanDegreeConnectivity.html
        ///</summary>
        corewolf::engine *MeanDegreeConnectivity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MeanDegreeConnectivity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/MeanDegreeConnectivity.html
        ///</summary>
        corewolf::engine *MeanDegreeConnectivity(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MeanDegreeConnectivity[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the mean absolute deviation from the mean of the elements in list.
        /// https://reference.wolfram.com/language/ref/MeanDeviation.html
        ///</summary>
        corewolf::engine *MeanDeviation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MeanDeviation[" + arg0 + "]", name);
        }

        ///< summary>
        /// filters data by replacing every value by the mean value in its range-r neighborhood.
        /// https://reference.wolfram.com/language/ref/MeanFilter.html
        ///</summary>
        corewolf::engine *MeanFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MeanFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses ri for filtering the dimension in data.
        /// https://reference.wolfram.com/language/ref/MeanFilter.html
        ///</summary>
        corewolf::engine *MeanFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MeanFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the mean distance between all pairs of vertices in the graph g.
        /// https://reference.wolfram.com/language/ref/MeanGraphDistance.html
        ///</summary>
        corewolf::engine *MeanGraphDistance(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MeanGraphDistance[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/MeanGraphDistance.html
        ///</summary>
        corewolf::engine *MeanGraphDistance(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("MeanGraphDistance[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of mean neighbor degrees of vertices for the graph g.
        /// https://reference.wolfram.com/language/ref/MeanNeighborDegree.html
        ///</summary>
        corewolf::engine *MeanNeighborDegree(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MeanNeighborDegree[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of mean neighbor in-degrees.
        /// https://reference.wolfram.com/language/ref/MeanNeighborDegree.html
        ///</summary>
        corewolf::engine *MeanNeighborDegree(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MeanNeighborDegree[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/MeanNeighborDegree.html
        ///</summary>
        corewolf::engine *MeanNeighborDegree(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MeanNeighborDegree[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// estimates the mean point density  from point data pdata in the observation region reg.
        /// https://reference.wolfram.com/language/ref/MeanPointDensity.html
        ///</summary>
        corewolf::engine *MeanPointDensity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MeanPointDensity[" + arg0 + "]", name);
        }

        ///< summary>
        /// replaces each element in list by the mean of the values of all elements that differ by less than d.
        /// https://reference.wolfram.com/language/ref/MeanShift.html
        ///</summary>
        corewolf::engine *MeanShift(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MeanShift[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the list where only the specified parts pi are replaced with mean-shifted values.
        /// https://reference.wolfram.com/language/ref/MeanShift.html
        ///</summary>
        corewolf::engine *MeanShift(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("MeanShift[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// filters data by replacing every value by the mean of the pixels in a range-r neighborhood and whose value is within a distance d.
        /// https://reference.wolfram.com/language/ref/MeanShiftFilter.html
        ///</summary>
        corewolf::engine *MeanShiftFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MeanShiftFilter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses ri for filtering the dimension in data.
        /// https://reference.wolfram.com/language/ref/MeanShiftFilter.html
        ///</summary>
        corewolf::engine *MeanShiftFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MeanShiftFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a loss layer that computes the mean squared loss between its "Input" port and "Target" port.
        /// https://reference.wolfram.com/language/ref/MeanSquaredLossLayer.html
        ///</summary>
        corewolf::engine *MeanSquaredLossLayer(const std::string &name = "")
        {
            return this->execute("MeanSquaredLossLayer[]", name);
        }

        ///< summary>
        /// gives the median of the elements in list.
        /// https://reference.wolfram.com/language/ref/Median.html
        ///</summary>
        corewolf::engine *Median(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Median[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the median absolute deviation from the median of the elements in list.
        /// https://reference.wolfram.com/language/ref/MedianDeviation.html
        ///</summary>
        corewolf::engine *MedianDeviation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MedianDeviation[" + arg0 + "]", name);
        }

        ///< summary>
        /// filters image by replacing every value by the median in its range-r neighborhood.
        /// https://reference.wolfram.com/language/ref/MedianFilter.html
        ///</summary>
        corewolf::engine *MedianFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MedianFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses ri for filtering the dimension in data.
        /// https://reference.wolfram.com/language/ref/MedianFilter.html
        ///</summary>
        corewolf::engine *MedianFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MedianFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the medical test entity.
        /// https://reference.wolfram.com/language/ref/MedicalTestData.html
        ///</summary>
        corewolf::engine *MedicalTestData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MedicalTestData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified medical test entities.
        /// https://reference.wolfram.com/language/ref/MedicalTestData.html
        ///</summary>
        corewolf::engine *MedicalTestData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MedicalTestData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/MedicalTestData.html
        ///</summary>
        corewolf::engine *MedicalTestData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MedicalTestData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is the Meijer G function .
        /// https://reference.wolfram.com/language/ref/MeijerG.html
        ///</summary>
        corewolf::engine *MeijerG(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("MeijerG[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// attempts to reduce expr to a single MeijerG const std::string &as a function of x.
        /// https://reference.wolfram.com/language/ref/MeijerGReduce.html
        ///</summary>
        corewolf::engine *MeijerGReduce(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MeijerGReduce[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Meixner distribution with location parameter m, scale parameter a, skew parameter b, and shape parameter d.
        /// https://reference.wolfram.com/language/ref/MeixnerDistribution.html
        ///</summary>
        corewolf::engine *MeixnerDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("MeixnerDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the Mellin convolution with respect to x of the expressions f and g.
        /// https://reference.wolfram.com/language/ref/MellinConvolve.html
        ///</summary>
        corewolf::engine *MellinConvolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("MellinConvolve[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional Mellin convolution.
        /// https://reference.wolfram.com/language/ref/MellinConvolve.html
        ///</summary>
        corewolf::engine *MellinConvolve(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("MellinConvolve[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Mellin transform of expr.
        /// https://reference.wolfram.com/language/ref/MellinTransform.html
        ///</summary>
        corewolf::engine *MellinTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MellinTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional Mellin transform of expr.
        /// https://reference.wolfram.com/language/ref/MellinTransform.html
        ///</summary>
        corewolf::engine *MellinTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("MellinTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// returns True if an element of list matches form, and False otherwise.
        /// https://reference.wolfram.com/language/ref/MemberQ.html
        ///</summary>
        corewolf::engine *MemberQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MemberQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests all parts of list specified by levelspec.
        /// https://reference.wolfram.com/language/ref/MemberQ.html
        ///</summary>
        corewolf::engine *MemberQ(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MemberQ[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of MemberQ that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/MemberQ.html
        ///</summary>
        corewolf::engine *MemberQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MemberQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the estimated number of bytes readily available for storing additional data in the current Wolfram Language kernel session.
        /// https://reference.wolfram.com/language/ref/MemoryAvailable.html
        ///</summary>
        corewolf::engine *MemoryAvailable(const std::string &name = "")
        {
            return this->execute("MemoryAvailable[]", name);
        }

        ///< summary>
        /// evaluates expr, stopping if more than b bytes of memory are requested.
        /// https://reference.wolfram.com/language/ref/MemoryConstrained.html
        ///</summary>
        corewolf::engine *MemoryConstrained(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MemoryConstrained[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns failexpr if the memory constraint is not met.
        /// https://reference.wolfram.com/language/ref/MemoryConstrained.html
        ///</summary>
        corewolf::engine *MemoryConstrained(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MemoryConstrained[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the number of bytes currently being used to store all data in the current Wolfram Language kernel session.
        /// https://reference.wolfram.com/language/ref/MemoryInUse.html
        ///</summary>
        corewolf::engine *MemoryInUse(const std::string &name = "")
        {
            return this->execute("MemoryInUse[]", name);
        }

        ///< summary>
        /// gives the number of bytes used in the Wolfram System front end.
        /// https://reference.wolfram.com/language/ref/MemoryInUse.html
        ///</summary>
        corewolf::engine *MemoryInUse(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MemoryInUse[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a mesh region representing the n-step Menger sponge.
        /// https://reference.wolfram.com/language/ref/MengerMesh.html
        ///</summary>
        corewolf::engine *MengerMesh(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MengerMesh[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the n-step Menger sponge in dimension d.
        /// https://reference.wolfram.com/language/ref/MengerMesh.html
        ///</summary>
        corewolf::engine *MengerMesh(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MengerMesh[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a WSTP packet indicating a menu request with title string.
        /// https://reference.wolfram.com/language/ref/MenuPacket.html
        ///</summary>
        corewolf::engine *MenuPacket(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MenuPacket[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an const std::string &in which selecting the menu item with label lbli displays expri.
        /// https://reference.wolfram.com/language/ref/MenuView.html
        ///</summary>
        corewolf::engine *MenuView(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("MenuView[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes the i item be the one currently selected.
        /// https://reference.wolfram.com/language/ref/MenuView.html
        ///</summary>
        corewolf::engine *MenuView(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MenuView[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// associates values vi with successive menu items, and makes the item with value v be the one currently selected.
        /// https://reference.wolfram.com/language/ref/MenuView.html
        ///</summary>
        corewolf::engine *MenuView(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MenuView[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// merges the associations associ, using the function f to combine values with the same key.
        /// https://reference.wolfram.com/language/ref/Merge.html
        ///</summary>
        corewolf::engine *Merge(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Merge[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of Merge that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/Merge.html
        ///</summary>
        corewolf::engine *Merge(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Merge[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the n Mersenne prime exponent.
        /// https://reference.wolfram.com/language/ref/MersennePrimeExponent.html
        ///</summary>
        corewolf::engine *MersennePrimeExponent(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MersennePrimeExponent[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if n is a Mersenne prime exponent, and False otherwise.
        /// https://reference.wolfram.com/language/ref/MersennePrimeExponentQ.html
        ///</summary>
        corewolf::engine *MersennePrimeExponentQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MersennePrimeExponentQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list {c0,c1,…} of counts cd of cells of dimension d in the mesh region mreg.
        /// https://reference.wolfram.com/language/ref/MeshCellCount.html
        ///</summary>
        corewolf::engine *MeshCellCount(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MeshCellCount[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the total count of cells of dimension d.
        /// https://reference.wolfram.com/language/ref/MeshCellCount.html
        ///</summary>
        corewolf::engine *MeshCellCount(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MeshCellCount[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the cell indices for cells of dimension d in the mesh region mreg.
        /// https://reference.wolfram.com/language/ref/MeshCellIndex.html
        ///</summary>
        corewolf::engine *MeshCellIndex(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MeshCellIndex[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the cells of dimension d in the mesh region mreg.
        /// https://reference.wolfram.com/language/ref/MeshCells.html
        ///</summary>
        corewolf::engine *MeshCells(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MeshCells[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a graph of points connected by lines.
        /// https://reference.wolfram.com/language/ref/MeshConnectivityGraph.html
        ///</summary>
        corewolf::engine *MeshConnectivityGraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MeshConnectivityGraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a graph from cells of dimension d to cells of dimension e that share a cell of dimension r.
        /// https://reference.wolfram.com/language/ref/MeshConnectivityGraph.html
        ///</summary>
        corewolf::engine *MeshConnectivityGraph(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MeshConnectivityGraph[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of coordinates in the mesh region mreg.
        /// https://reference.wolfram.com/language/ref/MeshCoordinates.html
        ///</summary>
        corewolf::engine *MeshCoordinates(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MeshCoordinates[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the graphics primitives for cells of dimension d in the mesh region mreg.
        /// https://reference.wolfram.com/language/ref/MeshPrimitives.html
        ///</summary>
        corewolf::engine *MeshPrimitives(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MeshPrimitives[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields a mesh with cells mcellj, where coordinates given as integer i are taken to be pi.
        /// https://reference.wolfram.com/language/ref/MeshRegion.html
        ///</summary>
        corewolf::engine *MeshRegion(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MeshRegion[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields a mesh with cell properties defined by the symbolic wrapper wi.
        /// https://reference.wolfram.com/language/ref/MeshRegion.html
        ///</summary>
        corewolf::engine *MeshRegion(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MeshRegion[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields a mesh from a mesh region mreg with options opts.
        /// https://reference.wolfram.com/language/ref/MeshRegion.html
        ///</summary>
        corewolf::engine *MeshRegion(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MeshRegion[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if the region reg is a valid MeshRegion const std::string &and False otherwise.
        /// https://reference.wolfram.com/language/ref/MeshRegionQ.html
        ///</summary>
        corewolf::engine *MeshRegionQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MeshRegionQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints the message symbol::tag unless it has been switched off.
        /// https://reference.wolfram.com/language/ref/Message.html
        ///</summary>
        corewolf::engine *Message(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Message[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints a message, inserting the values of the ei as needed.
        /// https://reference.wolfram.com/language/ref/Message.html
        ///</summary>
        corewolf::engine *Message(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Message[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// puts up a standard message dialog that displays expr together with an OK button.
        /// https://reference.wolfram.com/language/ref/MessageDialog.html
        ///</summary>
        corewolf::engine *MessageDialog(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MessageDialog[" + arg0 + "]", name);
        }

        ///< summary>
        /// includes buttons with labels lbli that evaluate the corresponding acti if clicked.
        /// https://reference.wolfram.com/language/ref/MessageDialog.html
        ///</summary>
        corewolf::engine *MessageDialog(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MessageDialog[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is a global const std::string &assigned to be a list of the names of messages generated during the processing of the n input line.
        /// https://reference.wolfram.com/language/ref/MessageList.html
        ///</summary>
        corewolf::engine *MessageList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MessageList[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a WSTP packet containing a Wolfram Language message identifier of the form symbol::string.
        /// https://reference.wolfram.com/language/ref/MessagePacket.html
        ///</summary>
        corewolf::engine *MessagePacket(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MessagePacket[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives all the messages assigned to a particular symbol.
        /// https://reference.wolfram.com/language/ref/Messages.html
        ///</summary>
        corewolf::engine *Messages(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Messages[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the meteor shower entity.
        /// https://reference.wolfram.com/language/ref/MeteorShowerData.html
        ///</summary>
        corewolf::engine *MeteorShowerData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MeteorShowerData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified meteor shower entities.
        /// https://reference.wolfram.com/language/ref/MeteorShowerData.html
        ///</summary>
        corewolf::engine *MeteorShowerData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MeteorShowerData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/MeteorShowerData.html
        ///</summary>
        corewolf::engine *MeteorShowerData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MeteorShowerData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the Mexican hat wavelet of width 1.
        /// https://reference.wolfram.com/language/ref/MexicanHatWavelet.html
        ///</summary>
        corewolf::engine *MexicanHatWavelet(const std::string &name = "")
        {
            return this->execute("MexicanHatWavelet[]", name);
        }

        ///< summary>
        /// represents the Mexican hat wavelet of width σ.
        /// https://reference.wolfram.com/language/ref/MexicanHatWavelet.html
        ///</summary>
        corewolf::engine *MexicanHatWavelet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MexicanHatWavelet[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the Meyer wavelet of order 3.
        /// https://reference.wolfram.com/language/ref/MeyerWavelet.html
        ///</summary>
        corewolf::engine *MeyerWavelet(const std::string &name = "")
        {
            return this->execute("MeyerWavelet[]", name);
        }

        ///< summary>
        /// represents the Meyer wavelet of order n evaluated on the equally spaced interval {-10,10}.
        /// https://reference.wolfram.com/language/ref/MeyerWavelet.html
        ///</summary>
        corewolf::engine *MeyerWavelet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MeyerWavelet[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the Meyer wavelet of order n evaluated on the equally spaced interval {-lim,lim}.
        /// https://reference.wolfram.com/language/ref/MeyerWavelet.html
        ///</summary>
        corewolf::engine *MeyerWavelet(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MeyerWavelet[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the midpoint of the line segment connecting the points p1 and p2.
        /// https://reference.wolfram.com/language/ref/Midpoint.html
        ///</summary>
        corewolf::engine *Midpoint(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Midpoint[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the midpoint of a line.
        /// https://reference.wolfram.com/language/ref/Midpoint.html
        ///</summary>
        corewolf::engine *Midpoint(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Midpoint[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns lists of file formats corresponding to all registered MIME types.
        /// https://reference.wolfram.com/language/ref/MIMETypeToFormatList.html
        ///</summary>
        corewolf::engine *MIMETypeToFormatList(const std::string &name = "")
        {
            return this->execute("MIMETypeToFormatList[]", name);
        }

        ///< summary>
        /// returns a list of file formats that matches the MIME type mime.
        /// https://reference.wolfram.com/language/ref/MIMETypeToFormatList.html
        ///</summary>
        corewolf::engine *MIMETypeToFormatList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MIMETypeToFormatList[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields the numerically smallest of the xi.
        /// https://reference.wolfram.com/language/ref/Min.html
        ///</summary>
        corewolf::engine *Min(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Min[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields the smallest element of any of the lists.
        /// https://reference.wolfram.com/language/ref/Min.html
        ///</summary>
        corewolf::engine *Min(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Min[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the earliest date of the datei.
        /// https://reference.wolfram.com/language/ref/MinDate.html
        ///</summary>
        corewolf::engine *MinDate(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("MinDate[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the beginning of the date interval interval.
        /// https://reference.wolfram.com/language/ref/MinDate.html
        ///</summary>
        corewolf::engine *MinDate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MinDate[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the beginning of interval as specified by granularity gran.
        /// https://reference.wolfram.com/language/ref/MinDate.html
        ///</summary>
        corewolf::engine *MinDate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MinDate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a binary image in which white pixels correspond to constant extended minima in image.
        /// https://reference.wolfram.com/language/ref/MinDetect.html
        ///</summary>
        corewolf::engine *MinDetect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MinDetect[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds extended minima where the range of values is not greater than h.
        /// https://reference.wolfram.com/language/ref/MinDetect.html
        ///</summary>
        corewolf::engine *MinDetect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MinDetect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the mineral entity.
        /// https://reference.wolfram.com/language/ref/MineralData.html
        ///</summary>
        corewolf::engine *MineralData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MineralData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified mineral entities.
        /// https://reference.wolfram.com/language/ref/MineralData.html
        ///</summary>
        corewolf::engine *MineralData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MineralData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/MineralData.html
        ///</summary>
        corewolf::engine *MineralData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MineralData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// filters data by replacing every value by the minimum value in its range-r neighborhood.
        /// https://reference.wolfram.com/language/ref/MinFilter.html
        ///</summary>
        corewolf::engine *MinFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MinFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses ri for filtering the dimension in data.
        /// https://reference.wolfram.com/language/ref/MinFilter.html
        ///</summary>
        corewolf::engine *MinFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MinFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns a list of the ei for which the value of f[ei] is minimal.
        /// https://reference.wolfram.com/language/ref/MinimalBy.html
        ///</summary>
        corewolf::engine *MinimalBy(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MinimalBy[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a list of the ei corresponding to the n smallest f[ei].
        /// https://reference.wolfram.com/language/ref/MinimalBy.html
        ///</summary>
        corewolf::engine *MinimalBy(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MinimalBy[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of MinimalBy that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/MinimalBy.html
        ///</summary>
        corewolf::engine *MinimalBy(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MinimalBy[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the minimal polynomial in x for which the algebraic number s is a root.
        /// https://reference.wolfram.com/language/ref/MinimalPolynomial.html
        ///</summary>
        corewolf::engine *MinimalPolynomial(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MinimalPolynomial[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the minimal state-space model of the state-space model sys.
        /// https://reference.wolfram.com/language/ref/MinimalStateSpaceModel.html
        ///</summary>
        corewolf::engine *MinimalStateSpaceModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MinimalStateSpaceModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies the new coordinates zi.
        /// https://reference.wolfram.com/language/ref/MinimalStateSpaceModel.html
        ///</summary>
        corewolf::engine *MinimalStateSpaceModel(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MinimalStateSpaceModel[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// minimizes f exactly with respect to x.
        /// https://reference.wolfram.com/language/ref/Minimize.html
        ///</summary>
        corewolf::engine *Minimize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Minimize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// minimizes f exactly with respect to x, y, ….
        /// https://reference.wolfram.com/language/ref/Minimize.html
        ///</summary>
        corewolf::engine *Minimize(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Minimize[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// minimizes f exactly subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/Minimize.html
        ///</summary>
        corewolf::engine *Minimize(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Minimize[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// constrains variables to the domain dom, typically Reals or Integers.
        /// https://reference.wolfram.com/language/ref/Minimize.html
        ///</summary>
        corewolf::engine *Minimize(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Minimize[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the minimum time increment in the time series tseries.
        /// https://reference.wolfram.com/language/ref/MinimumTimeIncrement.html
        ///</summary>
        corewolf::engine *MinimumTimeIncrement(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MinimumTimeIncrement[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives Minkowski's question mark function .
        /// https://reference.wolfram.com/language/ref/MinkowskiQuestionMark.html
        ///</summary>
        corewolf::engine *MinkowskiQuestionMark(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MinkowskiQuestionMark[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the min limit xx*f(x).
        /// https://reference.wolfram.com/language/ref/MinLimit.html
        ///</summary>
        corewolf::engine *MinLimit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MinLimit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the nested min limit ⋯ f (x1,…,xn).
        /// https://reference.wolfram.com/language/ref/MinLimit.html
        ///</summary>
        corewolf::engine *MinLimit(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MinLimit[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the list {Min[list],Max[list]}.
        /// https://reference.wolfram.com/language/ref/MinMax.html
        ///</summary>
        corewolf::engine *MinMax(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MinMax[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives {Min[list]-δ, Max[list]+δ}.
        /// https://reference.wolfram.com/language/ref/MinMax.html
        ///</summary>
        corewolf::engine *MinMax(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MinMax[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives {Min[list]-δmin,Max[list]+δmax}.
        /// https://reference.wolfram.com/language/ref/MinMax.html
        ///</summary>
        corewolf::engine *MinMax(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MinMax[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the minor planet entity.
        /// https://reference.wolfram.com/language/ref/MinorPlanetData.html
        ///</summary>
        corewolf::engine *MinorPlanetData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MinorPlanetData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified minor planet entities.
        /// https://reference.wolfram.com/language/ref/MinorPlanetData.html
        ///</summary>
        corewolf::engine *MinorPlanetData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MinorPlanetData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/MinorPlanetData.html
        ///</summary>
        corewolf::engine *MinorPlanetData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MinorPlanetData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the minors of a matrix m.
        /// https://reference.wolfram.com/language/ref/Minors.html
        ///</summary>
        corewolf::engine *Minors(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Minors[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the k  minors.
        /// https://reference.wolfram.com/language/ref/Minors.html
        ///</summary>
        corewolf::engine *Minors(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Minors[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies the function f rather than Det to each of the submatrices picked out.
        /// https://reference.wolfram.com/language/ref/Minors.html
        ///</summary>
        corewolf::engine *Minors(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Minors[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a generalized minimum extreme value distribution with location parameter μ, scale parameter σ, and shape parameter ξ.
        /// https://reference.wolfram.com/language/ref/MinStableDistribution.html
        ///</summary>
        corewolf::engine *MinStableDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MinStableDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/MinusPlus.html
        ///</summary>
        corewolf::engine *MinusPlus(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MinusPlus[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/MinusPlus.html
        ///</summary>
        corewolf::engine *MinusPlus(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MinusPlus[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the minimum value of f with respect to x.
        /// https://reference.wolfram.com/language/ref/MinValue.html
        ///</summary>
        corewolf::engine *MinValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MinValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the exact minimum value of f with respect to x, y, ….
        /// https://reference.wolfram.com/language/ref/MinValue.html
        ///</summary>
        corewolf::engine *MinValue(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MinValue[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the minimum value of f subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/MinValue.html
        ///</summary>
        corewolf::engine *MinValue(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MinValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// constrains variables to the domain dom, typically Reals or Integers.
        /// https://reference.wolfram.com/language/ref/MinValue.html
        ///</summary>
        corewolf::engine *MinValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MinValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents data that is missing.
        /// https://reference.wolfram.com/language/ref/Missing.html
        ///</summary>
        corewolf::engine *Missing(const std::string &name = "")
        {
            return this->execute("Missing[]", name);
        }

        ///< summary>
        /// specifies a reason for the data's being missing.
        /// https://reference.wolfram.com/language/ref/Missing.html
        ///</summary>
        corewolf::engine *Missing(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Missing[" + arg0 + "]", name);
        }

        ///< summary>
        /// associates the expression expr with the missing data.
        /// https://reference.wolfram.com/language/ref/Missing.html
        ///</summary>
        corewolf::engine *Missing(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Missing[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if expr has head Missing.
        /// https://reference.wolfram.com/language/ref/MissingQ.html
        ///</summary>
        corewolf::engine *MissingQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MissingQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Mittag–Leffler function .
        /// https://reference.wolfram.com/language/ref/MittagLefflerE.html
        ///</summary>
        corewolf::engine *MittagLefflerE(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MittagLefflerE[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the generalized Mittag–Leffler function .
        /// https://reference.wolfram.com/language/ref/MittagLefflerE.html
        ///</summary>
        corewolf::engine *MittagLefflerE(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MittagLefflerE[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the list {IntegerPart[expr],FractionalPart[expr]}.
        /// https://reference.wolfram.com/language/ref/MixedFractionParts.html
        ///</summary>
        corewolf::engine *MixedFractionParts(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MixedFractionParts[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is a mixed graph and False otherwise.
        /// https://reference.wolfram.com/language/ref/MixedGraphQ.html
        ///</summary>
        corewolf::engine *MixedGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MixedGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a mixed-magnitude expression consisting of values val1 through valn.
        /// https://reference.wolfram.com/language/ref/MixedMagnitude.html
        ///</summary>
        corewolf::engine *MixedMagnitude(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("MixedMagnitude[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the list of bases of a numerical system in which different digits have different bases.
        /// https://reference.wolfram.com/language/ref/MixedRadix.html
        ///</summary>
        corewolf::engine *MixedRadix(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("MixedRadix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// yields a single Quantity expression representing the addition of compatible units with magnitude values.
        /// https://reference.wolfram.com/language/ref/MixedRadixQuantity.html
        ///</summary>
        corewolf::engine *MixedRadixQuantity(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MixedRadixQuantity[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a mixed-unit expression consisting of units unit1 through unitn.
        /// https://reference.wolfram.com/language/ref/MixedUnit.html
        ///</summary>
        corewolf::engine *MixedUnit(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("MixedUnit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a mixture distribution whose CDF is given as a sum of the CDFs of the component distributions disti, each with weight wi.
        /// https://reference.wolfram.com/language/ref/MixtureDistribution.html
        ///</summary>
        corewolf::engine *MixtureDistribution(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MixtureDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the remainder on division of m by n.
        /// https://reference.wolfram.com/language/ref/Mod.html
        ///</summary>
        corewolf::engine *Mod(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Mod[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses an offset d.
        /// https://reference.wolfram.com/language/ref/Mod.html
        ///</summary>
        corewolf::engine *Mod(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Mod[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes the model predictive controller for the system specification sspec that minimizes the cost function cost and satisfies the constraints cons.
        /// https://reference.wolfram.com/language/ref/ModelPredictiveController.html
        ///</summary>
        corewolf::engine *ModelPredictiveController(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ModelPredictiveController[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the value of the property "prop".
        /// https://reference.wolfram.com/language/ref/ModelPredictiveController.html
        ///</summary>
        corewolf::engine *ModelPredictiveController(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ModelPredictiveController[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the modular inverse of k modulo n.
        /// https://reference.wolfram.com/language/ref/ModularInverse.html
        ///</summary>
        corewolf::engine *ModularInverse(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ModularInverse[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the modular lambda elliptic function .
        /// https://reference.wolfram.com/language/ref/ModularLambda.html
        ///</summary>
        corewolf::engine *ModularLambda(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ModularLambda[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies that occurrences of the symbols x, y, … in expr should be treated as local.
        /// https://reference.wolfram.com/language/ref/Module.html
        ///</summary>
        corewolf::engine *Module(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Module[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Möbius function .
        /// https://reference.wolfram.com/language/ref/MoebiusMu.html
        ///</summary>
        corewolf::engine *MoebiusMu(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MoebiusMu[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a molecule with atoms atomi and bonds bondi.
        /// https://reference.wolfram.com/language/ref/Molecule.html
        ///</summary>
        corewolf::engine *Molecule(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Molecule[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the molecule corresponding to the input name.
        /// https://reference.wolfram.com/language/ref/Molecule.html
        ///</summary>
        corewolf::engine *Molecule(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Molecule[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a version of mol that is aligned with reference molecule ref.
        /// https://reference.wolfram.com/language/ref/MoleculeAlign.html
        ///</summary>
        corewolf::engine *MoleculeAlign(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MoleculeAlign[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// aligns atoms in mol with index mi to the atoms in ref with index ri.
        /// https://reference.wolfram.com/language/ref/MoleculeAlign.html
        ///</summary>
        corewolf::engine *MoleculeAlign(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("MoleculeAlign[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses the molecule pattern patt to find an atom mapping between ref and mol.
        /// https://reference.wolfram.com/language/ref/MoleculeAlign.html
        ///</summary>
        corewolf::engine *MoleculeAlign(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MoleculeAlign[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// aligns each of the moli with ref.
        /// https://reference.wolfram.com/language/ref/MoleculeAlign.html
        ///</summary>
        corewolf::engine *MoleculeAlign(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MoleculeAlign[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// aligns the molecules and returns the property prop of the alignment.
        /// https://reference.wolfram.com/language/ref/MoleculeAlign.html
        ///</summary>
        corewolf::engine *MoleculeAlign(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("MoleculeAlign[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// returns True if patt is a substructure of molecule, and False otherwise.
        /// https://reference.wolfram.com/language/ref/MoleculeContainsQ.html
        ///</summary>
        corewolf::engine *MoleculeContainsQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MoleculeContainsQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of MoleculeContainsQ that can be applied to a molecule.
        /// https://reference.wolfram.com/language/ref/MoleculeContainsQ.html
        ///</summary>
        corewolf::engine *MoleculeContainsQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MoleculeContainsQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays a window with interactive tools for drawing a Molecule, and returns the result.
        /// https://reference.wolfram.com/language/ref/MoleculeDraw.html
        ///</summary>
        corewolf::engine *MoleculeDraw(const std::string &name = "")
        {
            return this->execute("MoleculeDraw[]", name);
        }

        ///< summary>
        /// displays a window that initially contains the Molecule mol.
        /// https://reference.wolfram.com/language/ref/MoleculeDraw.html
        ///</summary>
        corewolf::engine *MoleculeDraw(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MoleculeDraw[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if patt is not a substructure of molecule, and False otherwise.
        /// https://reference.wolfram.com/language/ref/MoleculeFreeQ.html
        ///</summary>
        corewolf::engine *MoleculeFreeQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MoleculeFreeQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of MoleculeFreeQ that can be applied to a molecule.
        /// https://reference.wolfram.com/language/ref/MoleculeFreeQ.html
        ///</summary>
        corewolf::engine *MoleculeFreeQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MoleculeFreeQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a graph constructed from the molecule mol.
        /// https://reference.wolfram.com/language/ref/MoleculeGraph.html
        ///</summary>
        corewolf::engine *MoleculeGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MoleculeGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if the Molecule matches the given pattern.
        /// https://reference.wolfram.com/language/ref/MoleculeMatchQ.html
        ///</summary>
        corewolf::engine *MoleculeMatchQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MoleculeMatchQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of MoleculeMatchQ that can be applied to a molecule.
        /// https://reference.wolfram.com/language/ref/MoleculeMatchQ.html
        ///</summary>
        corewolf::engine *MoleculeMatchQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MoleculeMatchQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a molecule pattern representing the largest common substructure for the input molecules.
        /// https://reference.wolfram.com/language/ref/MoleculeMaximumCommonSubstructure.html
        ///</summary>
        corewolf::engine *MoleculeMaximumCommonSubstructure(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("MoleculeMaximumCommonSubstructure[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// uses params to determine equivalence between atoms and bonds.
        /// https://reference.wolfram.com/language/ref/MoleculeMaximumCommonSubstructure.html
        ///</summary>
        corewolf::engine *MoleculeMaximumCommonSubstructure(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MoleculeMaximumCommonSubstructure[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a molecule or list of molecules derived from the molecule mol by applying the modification "mod".
        /// https://reference.wolfram.com/language/ref/MoleculeModify.html
        ///</summary>
        corewolf::engine *MoleculeModify(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MoleculeModify[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a molecule or list of molecules derived from the molecule mol by applying the modification "mod" with additional specifications specs.
        /// https://reference.wolfram.com/language/ref/MoleculeModify.html
        ///</summary>
        corewolf::engine *MoleculeModify(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MoleculeModify[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an operator form of MoleculeModify that can be applied to a molecule.
        /// https://reference.wolfram.com/language/ref/MoleculeModify.html
        ///</summary>
        corewolf::engine *MoleculeModify(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MoleculeModify[" + arg0 + "]", name);
        }

        ///< summary>
        /// attempts to return the systematic chemical name for the given molecule.
        /// https://reference.wolfram.com/language/ref/MoleculeName.html
        ///</summary>
        corewolf::engine *MoleculeName(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MoleculeName[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the given source to find the molecule name.
        /// https://reference.wolfram.com/language/ref/MoleculeName.html
        ///</summary>
        corewolf::engine *MoleculeName(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MoleculeName[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a molecule pattern with atoms atomi and bonds bondi for use in substructure searching.
        /// https://reference.wolfram.com/language/ref/MoleculePattern.html
        ///</summary>
        corewolf::engine *MoleculePattern(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MoleculePattern[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a molecule pattern from the input SMARTS pattern.
        /// https://reference.wolfram.com/language/ref/MoleculePattern.html
        ///</summary>
        corewolf::engine *MoleculePattern(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MoleculePattern[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a two-dimensional structure diagram of the molecule mol.
        /// https://reference.wolfram.com/language/ref/MoleculePlot.html
        ///</summary>
        corewolf::engine *MoleculePlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MoleculePlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a diagram of mol where all atoms and bonds matching the pattern patt are highlighted.
        /// https://reference.wolfram.com/language/ref/MoleculePlot.html
        ///</summary>
        corewolf::engine *MoleculePlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MoleculePlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a three-dimensional model of the molecule mol.
        /// https://reference.wolfram.com/language/ref/MoleculePlot3D.html
        ///</summary>
        corewolf::engine *MoleculePlot3D(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MoleculePlot3D[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a model of mol where all atoms and bonds matching the pattern patt are highlighted.
        /// https://reference.wolfram.com/language/ref/MoleculePlot3D.html
        ///</summary>
        corewolf::engine *MoleculePlot3D(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MoleculePlot3D[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a property identified by pname for use in MoleculeValue.
        /// https://reference.wolfram.com/language/ref/MoleculeProperty.html
        ///</summary>
        corewolf::engine *MoleculeProperty(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MoleculeProperty[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a property that applies to item within a molecule.
        /// https://reference.wolfram.com/language/ref/MoleculeProperty.html
        ///</summary>
        corewolf::engine *MoleculeProperty(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("MoleculeProperty[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns True if mol is a valid Molecule expression, and False otherwise.
        /// https://reference.wolfram.com/language/ref/MoleculeQ.html
        ///</summary>
        corewolf::engine *MoleculeQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MoleculeQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// recognizes a molecule in image and returns it as a Molecule object.
        /// https://reference.wolfram.com/language/ref/MoleculeRecognize.html
        ///</summary>
        corewolf::engine *MoleculeRecognize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MoleculeRecognize[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a count of the number of times patt appears as a substructure in mol.
        /// https://reference.wolfram.com/language/ref/MoleculeSubstructureCount.html
        ///</summary>
        corewolf::engine *MoleculeSubstructureCount(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MoleculeSubstructureCount[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of MoleculeSubstructureCount that can be applied to a molecule.
        /// https://reference.wolfram.com/language/ref/MoleculeSubstructureCount.html
        ///</summary>
        corewolf::engine *MoleculeSubstructureCount(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MoleculeSubstructureCount[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the given molecule.
        /// https://reference.wolfram.com/language/ref/MoleculeValue.html
        ///</summary>
        corewolf::engine *MoleculeValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MoleculeValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of values for the specified property for each of the moleculei.
        /// https://reference.wolfram.com/language/ref/MoleculeValue.html
        ///</summary>
        corewolf::engine *MoleculeValue(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MoleculeValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of values of the propertyi for the specified molecule.
        /// https://reference.wolfram.com/language/ref/MoleculeValue.html
        ///</summary>
        corewolf::engine *MoleculeValue(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MoleculeValue[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the list of values of the propertyi for each of the moleculei.
        /// https://reference.wolfram.com/language/ref/MoleculeValue.html
        ///</summary>
        corewolf::engine *MoleculeValue(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MoleculeValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the r sample moment of the elements in list.
        /// https://reference.wolfram.com/language/ref/Moment.html
        ///</summary>
        corewolf::engine *Moment(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Moment[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the {r1,r2,…} multivariate moment.
        /// https://reference.wolfram.com/language/ref/Moment.html
        ///</summary>
        corewolf::engine *Moment(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Moment[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents the r formal moment.
        /// https://reference.wolfram.com/language/ref/Moment.html
        ///</summary>
        corewolf::engine *Moment(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Moment[" + arg0 + "]", name);
        }

        ///< summary>
        /// converts the moment expression mexpr to the specified form.
        /// https://reference.wolfram.com/language/ref/MomentConvert.html
        ///</summary>
        corewolf::engine *MomentConvert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MomentConvert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates formal moments in the moment expression mexpr on the distribution dist.
        /// https://reference.wolfram.com/language/ref/MomentEvaluate.html
        ///</summary>
        corewolf::engine *MomentEvaluate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MomentEvaluate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates formal moments on the distribution dist and formal sample moments on the data list.
        /// https://reference.wolfram.com/language/ref/MomentEvaluate.html
        ///</summary>
        corewolf::engine *MomentEvaluate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MomentEvaluate[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the moment-generating function for the distribution dist as a function of the variable t.
        /// https://reference.wolfram.com/language/ref/MomentGeneratingFunction.html
        ///</summary>
        corewolf::engine *MomentGeneratingFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MomentGeneratingFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the moment-generating function for the multivariate distribution dist as a function of the variables t1, t2, … .
        /// https://reference.wolfram.com/language/ref/MomentGeneratingFunction.html
        ///</summary>
        corewolf::engine *MomentGeneratingFunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MomentGeneratingFunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// computes the moment of inertia for the region reg rotating around an axis through the point pt in direction v.
        /// https://reference.wolfram.com/language/ref/MomentOfInertia.html
        ///</summary>
        corewolf::engine *MomentOfInertia(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MomentOfInertia[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes the moment of inertia matrix for the region reg relative to the center of mass.
        /// https://reference.wolfram.com/language/ref/MomentOfInertia.html
        ///</summary>
        corewolf::engine *MomentOfInertia(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MomentOfInertia[" + arg0 + "]", name);
        }

        ///< summary>
        /// computes the moment of inertia matrix relative to the point pt.
        /// https://reference.wolfram.com/language/ref/MomentOfInertia.html
        ///</summary>
        corewolf::engine *MomentOfInertia(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MomentOfInertia[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a temporary monitor cell in which the continually updated current value of mon is displayed during the course of evaluation of expr.
        /// https://reference.wolfram.com/language/ref/Monitor.html
        ///</summary>
        corewolf::engine *Monitor(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Monitor[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of all monomials in the polynomial poly.
        /// https://reference.wolfram.com/language/ref/MonomialList.html
        ///</summary>
        corewolf::engine *MonomialList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MonomialList[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the list of monomials with respect to the variables xi in poly.
        /// https://reference.wolfram.com/language/ref/MonomialList.html
        ///</summary>
        corewolf::engine *MonomialList(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MonomialList[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// puts the monomials in the specified order.
        /// https://reference.wolfram.com/language/ref/MonomialList.html
        ///</summary>
        corewolf::engine *MonomialList(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MonomialList[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the sporadic simple monster group .
        /// https://reference.wolfram.com/language/ref/MonsterGroupM.html
        ///</summary>
        corewolf::engine *MonsterGroupM(const std::string &name = "")
        {
            return this->execute("MonsterGroupM[]", name);
        }

        ///< summary>
        /// gives moon phase fraction of illumination for the current date.
        /// https://reference.wolfram.com/language/ref/MoonPhase.html
        ///</summary>
        corewolf::engine *MoonPhase(const std::string &name = "")
        {
            return this->execute("MoonPhase[]", name);
        }

        ///< summary>
        /// gives moon phase fraction of illumination for the specified date.
        /// https://reference.wolfram.com/language/ref/MoonPhase.html
        ///</summary>
        corewolf::engine *MoonPhase(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MoonPhase[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the property of the moon phase for the specified date.
        /// https://reference.wolfram.com/language/ref/MoonPhase.html
        ///</summary>
        corewolf::engine *MoonPhase(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MoonPhase[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the position of the Moon for the current date and location.
        /// https://reference.wolfram.com/language/ref/MoonPosition.html
        ///</summary>
        corewolf::engine *MoonPosition(const std::string &name = "")
        {
            return this->execute("MoonPosition[]", name);
        }

        ///< summary>
        /// gives the position of the Moon for the specified date.
        /// https://reference.wolfram.com/language/ref/MoonPosition.html
        ///</summary>
        corewolf::engine *MoonPosition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MoonPosition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the position of the Moon for the specified date and location.
        /// https://reference.wolfram.com/language/ref/MoonPosition.html
        ///</summary>
        corewolf::engine *MoonPosition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MoonPosition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the positions of the Moon for all specified locations on the specified dates.
        /// https://reference.wolfram.com/language/ref/MoonPosition.html
        ///</summary>
        corewolf::engine *MoonPosition(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MoonPosition[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses func to determine what to return for extended locations.
        /// https://reference.wolfram.com/language/ref/MoonPosition.html
        ///</summary>
        corewolf::engine *MoonPosition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MoonPosition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Morlet wavelet.
        /// https://reference.wolfram.com/language/ref/MorletWavelet.html
        ///</summary>
        corewolf::engine *MorletWavelet(const std::string &name = "")
        {
            return this->execute("MorletWavelet[]", name);
        }

        ///< summary>
        /// creates a binary image from image by replacing all values above the upper threshold t2 with 1, also including pixels with intensities above the lower threshold t1 that are connected to the foreground.
        /// https://reference.wolfram.com/language/ref/MorphologicalBinarize.html
        ///</summary>
        corewolf::engine *MorphologicalBinarize(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MorphologicalBinarize[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses t as the upper threshold, automatically choosing a suitable value for the lower threshold.
        /// https://reference.wolfram.com/language/ref/MorphologicalBinarize.html
        ///</summary>
        corewolf::engine *MorphologicalBinarize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MorphologicalBinarize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// chooses the lower and the upper threshold automatically.
        /// https://reference.wolfram.com/language/ref/MorphologicalBinarize.html
        ///</summary>
        corewolf::engine *MorphologicalBinarize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MorphologicalBinarize[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a version of a binary image image in which white pixels represent the morphological branch points.
        /// https://reference.wolfram.com/language/ref/MorphologicalBranchPoints.html
        ///</summary>
        corewolf::engine *MorphologicalBranchPoints(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MorphologicalBranchPoints[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an array in which each pixel of image is replaced by an integer index representing the connected foreground image component in which the pixel lies.
        /// https://reference.wolfram.com/language/ref/MorphologicalComponents.html
        ///</summary>
        corewolf::engine *MorphologicalComponents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MorphologicalComponents[" + arg0 + "]", name);
        }

        ///< summary>
        /// treats values above t as foreground.
        /// https://reference.wolfram.com/language/ref/MorphologicalComponents.html
        ///</summary>
        corewolf::engine *MorphologicalComponents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MorphologicalComponents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes the morphological Euler number of regions in a binary image.
        /// https://reference.wolfram.com/language/ref/MorphologicalEulerNumber.html
        ///</summary>
        corewolf::engine *MorphologicalEulerNumber(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MorphologicalEulerNumber[" + arg0 + "]", name);
        }

        ///< summary>
        /// treats values above t as foreground.
        /// https://reference.wolfram.com/language/ref/MorphologicalEulerNumber.html
        ///</summary>
        corewolf::engine *MorphologicalEulerNumber(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MorphologicalEulerNumber[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a graph const std::string &that represents the connectivity of the morphological branch points and endpoints of the objects in image after applying morphological thinning.
        /// https://reference.wolfram.com/language/ref/MorphologicalGraph.html
        ///</summary>
        corewolf::engine *MorphologicalGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MorphologicalGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// picks out the morphological perimeter of regions of foreground in image.
        /// https://reference.wolfram.com/language/ref/MorphologicalPerimeter.html
        ///</summary>
        corewolf::engine *MorphologicalPerimeter(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MorphologicalPerimeter[" + arg0 + "]", name);
        }

        ///< summary>
        /// treats values above t as foreground.
        /// https://reference.wolfram.com/language/ref/MorphologicalPerimeter.html
        ///</summary>
        corewolf::engine *MorphologicalPerimeter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MorphologicalPerimeter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies the function f to the 3×3 neighborhood of each pixel in a binary image image.
        /// https://reference.wolfram.com/language/ref/MorphologicalTransform.html
        ///</summary>
        corewolf::engine *MorphologicalTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MorphologicalTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies n iterations of transformation on image.
        /// https://reference.wolfram.com/language/ref/MorphologicalTransform.html
        ///</summary>
        corewolf::engine *MorphologicalTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MorphologicalTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the values of all properties for the specified demographic.
        /// https://reference.wolfram.com/language/ref/MortalityData.html
        ///</summary>
        corewolf::engine *MortalityData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MortalityData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the specified demographic.
        /// https://reference.wolfram.com/language/ref/MortalityData.html
        ///</summary>
        corewolf::engine *MortalityData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MortalityData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives expr with the last element removed.
        /// https://reference.wolfram.com/language/ref/Most.html
        ///</summary>
        corewolf::engine *Most(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Most[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the mountain entity.
        /// https://reference.wolfram.com/language/ref/MountainData.html
        ///</summary>
        corewolf::engine *MountainData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MountainData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified mountain entities.
        /// https://reference.wolfram.com/language/ref/MountainData.html
        ///</summary>
        corewolf::engine *MountainData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MountainData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/MountainData.html
        ///</summary>
        corewolf::engine *MountainData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MountainData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives any mouse annotation associated with the expression at the current mouse position.
        /// https://reference.wolfram.com/language/ref/MouseAnnotation.html
        ///</summary>
        corewolf::engine *MouseAnnotation(const std::string &name = "")
        {
            return this->execute("MouseAnnotation[]", name);
        }

        ///< summary>
        /// changes the mouse cursor to appear as graphic when the mouse pointer is in the area where expr is displayed.
        /// https://reference.wolfram.com/language/ref/MouseAppearance.html
        ///</summary>
        corewolf::engine *MouseAppearance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MouseAppearance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the coordinates {x,y} in the graphic as the hotspot for the mouse cursor.
        /// https://reference.wolfram.com/language/ref/MouseAppearance.html
        ///</summary>
        corewolf::engine *MouseAppearance(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("MouseAppearance[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses the scaled coordinates {x,y} as the hotspot for the mouse cursor.
        /// https://reference.wolfram.com/language/ref/MouseAppearance.html
        ///</summary>
        corewolf::engine *MouseAppearance(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MouseAppearance[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an const std::string &that displays as over when the mouse pointer is over it, and as expr otherwise.
        /// https://reference.wolfram.com/language/ref/Mouseover.html
        ///</summary>
        corewolf::engine *Mouseover(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Mouseover[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the current mouse position in the notebook front end.
        /// https://reference.wolfram.com/language/ref/MousePosition.html
        ///</summary>
        corewolf::engine *MousePosition(const std::string &name = "")
        {
            return this->execute("MousePosition[]", name);
        }

        ///< summary>
        /// gives the mouse position with respect to the specified coordinate system.
        /// https://reference.wolfram.com/language/ref/MousePosition.html
        ///</summary>
        corewolf::engine *MousePosition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MousePosition[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns def if the mouse is not over an const std::string &that defines the specified coordinate system.
        /// https://reference.wolfram.com/language/ref/MousePosition.html
        ///</summary>
        corewolf::engine *MousePosition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MousePosition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the movie entity.
        /// https://reference.wolfram.com/language/ref/MovieData.html
        ///</summary>
        corewolf::engine *MovieData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MovieData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified movie entities.
        /// https://reference.wolfram.com/language/ref/MovieData.html
        ///</summary>
        corewolf::engine *MovieData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MovieData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/MovieData.html
        ///</summary>
        corewolf::engine *MovieData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MovieData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the moving average of list, computed by averaging runs of r elements.
        /// https://reference.wolfram.com/language/ref/MovingAverage.html
        ///</summary>
        corewolf::engine *MovingAverage(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MovingAverage[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the moving average of list, computed with weights wi.
        /// https://reference.wolfram.com/language/ref/MovingAverage.html
        ///</summary>
        corewolf::engine *MovingAverage(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MovingAverage[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// applies f to size w windows in the specified data.
        /// https://reference.wolfram.com/language/ref/MovingMap.html
        ///</summary>
        corewolf::engine *MovingMap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MovingMap[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// pads data using padding.
        /// https://reference.wolfram.com/language/ref/MovingMap.html
        ///</summary>
        corewolf::engine *MovingMap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("MovingMap[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the moving median of list, computed using spans of r elements.
        /// https://reference.wolfram.com/language/ref/MovingMedian.html
        ///</summary>
        corewolf::engine *MovingMedian(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MovingMedian[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Moyal distribution with location parameter μ and scale parameter σ.
        /// https://reference.wolfram.com/language/ref/MoyalDistribution.html
        ///</summary>
        corewolf::engine *MoyalDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MoyalDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Moyal distribution with location parameter 0 and scale parameter 1.
        /// https://reference.wolfram.com/language/ref/MoyalDistribution.html
        ///</summary>
        corewolf::engine *MoyalDistribution(const std::string &name = "")
        {
            return this->execute("MoyalDistribution[]", name);
        }

        ///< summary>
        /// is an const std::string &that formats with the elements of list arranged in a grid with the indicated number of columns.
        /// https://reference.wolfram.com/language/ref/Multicolumn.html
        ///</summary>
        corewolf::engine *Multicolumn(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Multicolumn[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// formats as a grid with the indicated number of rows.
        /// https://reference.wolfram.com/language/ref/Multicolumn.html
        ///</summary>
        corewolf::engine *Multicolumn(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Multicolumn[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// formats with the elements of list in a roughly square arrangement.
        /// https://reference.wolfram.com/language/ref/Multicolumn.html
        ///</summary>
        corewolf::engine *Multicolumn(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Multicolumn[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is a multigraph and False otherwise.
        /// https://reference.wolfram.com/language/ref/MultigraphQ.html
        ///</summary>
        corewolf::engine *MultigraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MultigraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the multinomial coefficient .
        /// https://reference.wolfram.com/language/ref/Multinomial.html
        ///</summary>
        corewolf::engine *Multinomial(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Multinomial[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a multinomial distribution with n trials and probabilities pi.
        /// https://reference.wolfram.com/language/ref/MultinomialDistribution.html
        ///</summary>
        corewolf::engine *MultinomialDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MultinomialDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a multivariate normal (Gaussian) distribution with mean vector μ and covariance matrix Σ.
        /// https://reference.wolfram.com/language/ref/MultinormalDistribution.html
        ///</summary>
        corewolf::engine *MultinormalDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MultinormalDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a multivariate normal distribution with zero mean and covariance matrix Σ.
        /// https://reference.wolfram.com/language/ref/MultinormalDistribution.html
        ///</summary>
        corewolf::engine *MultinormalDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("MultinormalDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the multiplicative order of k modulo n, defined as the smallest integer  such that .
        /// https://reference.wolfram.com/language/ref/MultiplicativeOrder.html
        ///</summary>
        corewolf::engine *MultiplicativeOrder(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MultiplicativeOrder[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the generalized multiplicative order of k modulo n, defined as the smallest integer  such that  for some .
        /// https://reference.wolfram.com/language/ref/MultiplicativeOrder.html
        ///</summary>
        corewolf::engine *MultiplicativeOrder(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("MultiplicativeOrder[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// multiplies each side of the equation or inequality rel by x.
        /// https://reference.wolfram.com/language/ref/MultiplySides.html
        ///</summary>
        corewolf::engine *MultiplySides(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MultiplySides[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a multivariate hypergeometric distribution with n draws without replacement from a collection containing mi objects of type i.
        /// https://reference.wolfram.com/language/ref/MultivariateHypergeometricDistribution.html
        ///</summary>
        corewolf::engine *MultivariateHypergeometricDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MultivariateHypergeometricDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a multivariate Poisson distribution with mean vector {μ0+μ1,μ0+μ2,…}.
        /// https://reference.wolfram.com/language/ref/MultivariatePoissonDistribution.html
        ///</summary>
        corewolf::engine *MultivariatePoissonDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("MultivariatePoissonDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents the multivariate Student  distribution with scale matrix Σ and degrees of freedom parameter ν.
        /// https://reference.wolfram.com/language/ref/MultivariateTDistribution.html
        ///</summary>
        corewolf::engine *MultivariateTDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("MultivariateTDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the multivariate Student  distribution with location μ, scale matrix Σ, and ν degrees of freedom.
        /// https://reference.wolfram.com/language/ref/MultivariateTDistribution.html
        ///</summary>
        corewolf::engine *MultivariateTDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("MultivariateTDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the numerical value of expr.
        /// https://reference.wolfram.com/language/ref/N.html
        ///</summary>
        corewolf::engine *N(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("N[" + arg0 + "]", name);
        }

        ///< summary>
        /// attempts to give a result with n‐digit precision.
        /// https://reference.wolfram.com/language/ref/N.html
        ///</summary>
        corewolf::engine *N(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("N[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Nakagami distribution with shape parameter μ and spread parameter ω.
        /// https://reference.wolfram.com/language/ref/NakagamiDistribution.html
        ///</summary>
        corewolf::engine *NakagamiDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NakagamiDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if there are any symbols whose names match the string pattern given, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/NameQ.html
        ///</summary>
        corewolf::engine *NameQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NameQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of the names of symbols that match the string.
        /// https://reference.wolfram.com/language/ref/Names.html
        ///</summary>
        corewolf::engine *Names(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Names[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of names matching any of the patti.
        /// https://reference.wolfram.com/language/ref/Names.html
        ///</summary>
        corewolf::engine *Names(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Names[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// is the logical NAND function. It evaluates its arguments in order, giving True immediately if any of them are False, and False if they are all True.
        /// https://reference.wolfram.com/language/ref/Nand.html
        ///</summary>
        corewolf::engine *Nand(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Nand[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a position xmax at which f is numerically maximized.
        /// https://reference.wolfram.com/language/ref/NArgMax.html
        ///</summary>
        corewolf::engine *NArgMax(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NArgMax[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a position {xmax,ymax,…} at which f is numerically maximized.
        /// https://reference.wolfram.com/language/ref/NArgMax.html
        ///</summary>
        corewolf::engine *NArgMax(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NArgMax[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a position at which f is numerically maximized subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/NArgMax.html
        ///</summary>
        corewolf::engine *NArgMax(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NArgMax[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a position xmin at which f is numerically minimized.
        /// https://reference.wolfram.com/language/ref/NArgMin.html
        ///</summary>
        corewolf::engine *NArgMin(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NArgMin[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a position {xmin,ymin,…} at which f is numerically minimized.
        /// https://reference.wolfram.com/language/ref/NArgMin.html
        ///</summary>
        corewolf::engine *NArgMin(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NArgMin[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a position at which f is numerically minimized subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/NArgMin.html
        ///</summary>
        corewolf::engine *NArgMin(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NArgMin[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a simulation of the motion of a system of n bodies with initial states statei, governed by the specified potential or force law, over a length of time t.
        /// https://reference.wolfram.com/language/ref/NBodySimulation.html
        ///</summary>
        corewolf::engine *NBodySimulation(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NBodySimulation[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a simulation of the motion of a system of n bodies with names bodyi.
        /// https://reference.wolfram.com/language/ref/NBodySimulation.html
        ///</summary>
        corewolf::engine *NBodySimulation(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("NBodySimulation[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// represents the result of an n-body simulation.
        /// https://reference.wolfram.com/language/ref/NBodySimulationData.html
        ///</summary>
        corewolf::engine *NBodySimulationData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NBodySimulationData[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a numeric cache const std::string &for a quantity with exact value x and approximate numerical value xn.
        /// https://reference.wolfram.com/language/ref/NCache.html
        ///</summary>
        corewolf::engine *NCache(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NCache[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the n smallest magnitude eigenvalues and eigenfunctions for the linear differential operator ℒ over the region Ω.
        /// https://reference.wolfram.com/language/ref/NDEigensystem.html
        ///</summary>
        corewolf::engine *NDEigensystem(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NDEigensystem[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives eigenvalues and eigenfunctions for the coupled differential operators {op1,op2,…} over the region Ω.
        /// https://reference.wolfram.com/language/ref/NDEigensystem.html
        ///</summary>
        corewolf::engine *NDEigensystem(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NDEigensystem[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the eigenvalues and eigenfunctions in the spatial variables {x,y,…} for solutions u,… of the coupled time-dependent differential equations eqns.
        /// https://reference.wolfram.com/language/ref/NDEigensystem.html
        ///</summary>
        corewolf::engine *NDEigensystem(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("NDEigensystem[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// gives the n smallest magnitude eigenvalues for the linear differential operator ℒ over the region Ω.
        /// https://reference.wolfram.com/language/ref/NDEigenvalues.html
        ///</summary>
        corewolf::engine *NDEigenvalues(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NDEigenvalues[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives eigenvalues for the coupled differential operators {op1,op2,…} over the region Ω.
        /// https://reference.wolfram.com/language/ref/NDEigenvalues.html
        ///</summary>
        corewolf::engine *NDEigenvalues(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NDEigenvalues[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the eigenvalues in the spatial variables {x,y,…} for solutions u,… of the coupled time-dependent differential equations eqns.
        /// https://reference.wolfram.com/language/ref/NDEigenvalues.html
        ///</summary>
        corewolf::engine *NDEigenvalues(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("NDEigenvalues[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// finds a numerical solution to the ordinary differential equations eqns for the function u with the independent variable x in the range xmin to xmax.
        /// https://reference.wolfram.com/language/ref/NDSolve.html
        ///</summary>
        corewolf::engine *NDSolve(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("NDSolve[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// solves the partial differential equations eqns over a rectangular region.
        /// https://reference.wolfram.com/language/ref/NDSolve.html
        ///</summary>
        corewolf::engine *NDSolve(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("NDSolve[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// solves the partial differential equations eqns over the region Ω.
        /// https://reference.wolfram.com/language/ref/NDSolve.html
        ///</summary>
        corewolf::engine *NDSolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NDSolve[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// solves the time-dependent partial differential equations eqns over the region Ω.
        /// https://reference.wolfram.com/language/ref/NDSolve.html
        ///</summary>
        corewolf::engine *NDSolve(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NDSolve[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// solves for the functions ui.
        /// https://reference.wolfram.com/language/ref/NDSolve.html
        ///</summary>
        corewolf::engine *NDSolve(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NDSolve[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of expr with functions determined by a numerical solution to the ordinary differential equations eqns with the independent variable x in the range xmin to xmax.
        /// https://reference.wolfram.com/language/ref/NDSolveValue.html
        ///</summary>
        corewolf::engine *NDSolveValue(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("NDSolveValue[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// solves the partial differential equations eqns over a rectangular region.
        /// https://reference.wolfram.com/language/ref/NDSolveValue.html
        ///</summary>
        corewolf::engine *NDSolveValue(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("NDSolveValue[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// solves the partial differential equations eqns over the region Ω.
        /// https://reference.wolfram.com/language/ref/NDSolveValue.html
        ///</summary>
        corewolf::engine *NDSolveValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NDSolveValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// solves the time-dependent partial differential equations eqns over the region Ω.
        /// https://reference.wolfram.com/language/ref/NDSolveValue.html
        ///</summary>
        corewolf::engine *NDSolveValue(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NDSolveValue[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the list of elemi to which x is nearest.
        /// https://reference.wolfram.com/language/ref/Nearest.html
        ///</summary>
        corewolf::engine *Nearest(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Nearest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the property prop for the elemi to which x is nearest.
        /// https://reference.wolfram.com/language/ref/Nearest.html
        ///</summary>
        corewolf::engine *Nearest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Nearest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// effectively gives {Nearest[data,x1],Nearest[data,x2],…}.
        /// https://reference.wolfram.com/language/ref/Nearest.html
        ///</summary>
        corewolf::engine *Nearest(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Nearest[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the n nearest elemi to x.
        /// https://reference.wolfram.com/language/ref/Nearest.html
        ///</summary>
        corewolf::engine *Nearest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Nearest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the n or fewer nearest elemi to x that are within radius r of x.
        /// https://reference.wolfram.com/language/ref/Nearest.html
        ///</summary>
        corewolf::engine *Nearest(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Nearest[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates a NearestFunction[…] that can be applied repeatedly to different x.
        /// https://reference.wolfram.com/language/ref/Nearest.html
        ///</summary>
        corewolf::engine *Nearest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Nearest[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a function whose values give the elements closest to an element that is supplied.
        /// https://reference.wolfram.com/language/ref/NearestFunction.html
        ///</summary>
        corewolf::engine *NearestFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NearestFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the indices for the cells to which the point pt is nearest in the mesh region mr.
        /// https://reference.wolfram.com/language/ref/NearestMeshCells.html
        ///</summary>
        corewolf::engine *NearestMeshCells(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NearestMeshCells[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the n nearest cell indices to pt.
        /// https://reference.wolfram.com/language/ref/NearestMeshCells.html
        ///</summary>
        corewolf::engine *NearestMeshCells(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NearestMeshCells[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the n or fewer nearest cell indices to pt that are within radius r of pt.
        /// https://reference.wolfram.com/language/ref/NearestMeshCells.html
        ///</summary>
        corewolf::engine *NearestMeshCells(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("NearestMeshCells[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the indices for the cells of dimension d.
        /// https://reference.wolfram.com/language/ref/NearestMeshCells.html
        ///</summary>
        corewolf::engine *NearestMeshCells(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NearestMeshCells[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// estimates the nearest neighbor function  at radius r in the point data pdata.
        /// https://reference.wolfram.com/language/ref/NearestNeighborG.html
        ///</summary>
        corewolf::engine *NearestNeighborG(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NearestNeighborG[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates the function  that can be applied repeatedly to different radii r.
        /// https://reference.wolfram.com/language/ref/NearestNeighborG.html
        ///</summary>
        corewolf::engine *NearestNeighborG(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NearestNeighborG[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a graph with vertices elem1,elem2,… and edges connecting each elemi to its nearest neighbors.
        /// https://reference.wolfram.com/language/ref/NearestNeighborGraph.html
        ///</summary>
        corewolf::engine *NearestNeighborGraph(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("NearestNeighborGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a graph connecting each elemi to its k nearest neighbors.
        /// https://reference.wolfram.com/language/ref/NearestNeighborGraph.html
        ///</summary>
        corewolf::engine *NearestNeighborGraph(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NearestNeighborGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a graph connecting each elemi to at most k nearest vertices within radius r of elemi.
        /// https://reference.wolfram.com/language/ref/NearestNeighborGraph.html
        ///</summary>
        corewolf::engine *NearestNeighborGraph(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NearestNeighborGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is an operator form that yields Nearest[elems,x] when applied to a list elems.
        /// https://reference.wolfram.com/language/ref/NearestTo.html
        ///</summary>
        corewolf::engine *NearestTo(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NearestTo[" + arg0 + "]", name);
        }

        ///< summary>
        /// is an operator form that yields Nearest[elems,x,n] when applied to a list elems.
        /// https://reference.wolfram.com/language/ref/NearestTo.html
        ///</summary>
        corewolf::engine *NearestTo(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NearestTo[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is an operator form that yields Nearest[elems,x,{n,r}] when applied to a list elems.
        /// https://reference.wolfram.com/language/ref/NearestTo.html
        ///</summary>
        corewolf::engine *NearestTo(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NearestTo[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the nebula entity.
        /// https://reference.wolfram.com/language/ref/NebulaData.html
        ///</summary>
        corewolf::engine *NebulaData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NebulaData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified nebula entities.
        /// https://reference.wolfram.com/language/ref/NebulaData.html
        ///</summary>
        corewolf::engine *NebulaData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NebulaData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/NebulaData.html
        ///</summary>
        corewolf::engine *NebulaData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NebulaData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a number representing the Needleman–Wunsch similarity between strings, vectors or biomolecular sequences u and v.
        /// https://reference.wolfram.com/language/ref/NeedlemanWunschSimilarity.html
        ///</summary>
        corewolf::engine *NeedlemanWunschSimilarity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NeedlemanWunschSimilarity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// loads an appropriate file if the specified context is not already in $Packages.
        /// https://reference.wolfram.com/language/ref/Needs.html
        ///</summary>
        corewolf::engine *Needs(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Needs[" + arg0 + "]", name);
        }

        ///< summary>
        /// loads file if the specified context is not already in $Packages.
        /// https://reference.wolfram.com/language/ref/Needs.html
        ///</summary>
        corewolf::engine *Needs(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Needs[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if x is a negative number.
        /// https://reference.wolfram.com/language/ref/Negative.html
        ///</summary>
        corewolf::engine *Negative(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Negative[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a negative binomial distribution with parameters n and p.
        /// https://reference.wolfram.com/language/ref/NegativeBinomialDistribution.html
        ///</summary>
        corewolf::engine *NegativeBinomialDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NegativeBinomialDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if m is explicitly negative definite, and False otherwise.
        /// https://reference.wolfram.com/language/ref/NegativeDefiniteMatrixQ.html
        ///</summary>
        corewolf::engine *NegativeDefiniteMatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NegativeDefiniteMatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the sequence of points p1,p2,p3,…,pn is negatively oriented.
        /// https://reference.wolfram.com/language/ref/NegativelyOrientedPoints.html
        ///</summary>
        corewolf::engine *NegativelyOrientedPoints(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("NegativelyOrientedPoints[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a negative multinomial distribution with parameter n and failure probability vector p.
        /// https://reference.wolfram.com/language/ref/NegativeMultinomialDistribution.html
        ///</summary>
        corewolf::engine *NegativeMultinomialDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NegativeMultinomialDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if m is explicitly negative semidefinite, and False otherwise.
        /// https://reference.wolfram.com/language/ref/NegativeSemidefiniteMatrixQ.html
        ///</summary>
        corewolf::engine *NegativeSemidefiniteMatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NegativeSemidefiniteMatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the neighborhood entity.
        /// https://reference.wolfram.com/language/ref/NeighborhoodData.html
        ///</summary>
        corewolf::engine *NeighborhoodData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NeighborhoodData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified neighborhood entities.
        /// https://reference.wolfram.com/language/ref/NeighborhoodData.html
        ///</summary>
        corewolf::engine *NeighborhoodData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NeighborhoodData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/NeighborhoodData.html
        ///</summary>
        corewolf::engine *NeighborhoodData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NeighborhoodData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the graph neighborhood of a vertex v in the graph g.
        /// https://reference.wolfram.com/language/ref/NeighborhoodGraph.html
        ///</summary>
        corewolf::engine *NeighborhoodGraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NeighborhoodGraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the graph neighborhood of the ai that can be vertices, edges, or subgraphs of g.
        /// https://reference.wolfram.com/language/ref/NeighborhoodGraph.html
        ///</summary>
        corewolf::engine *NeighborhoodGraph(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NeighborhoodGraph[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the neighborhood up to distance d.
        /// https://reference.wolfram.com/language/ref/NeighborhoodGraph.html
        ///</summary>
        corewolf::engine *NeighborhoodGraph(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NeighborhoodGraph[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/NeighborhoodGraph.html
        ///</summary>
        corewolf::engine *NeighborhoodGraph(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NeighborhoodGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an expression with f applied n times to expr.
        /// https://reference.wolfram.com/language/ref/Nest.html
        ///</summary>
        corewolf::engine *Nest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Nest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⪢y⪢….
        /// https://reference.wolfram.com/language/ref/NestedGreaterGreater.html
        ///</summary>
        corewolf::engine *NestedGreaterGreater(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NestedGreaterGreater[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NestedLessLess.html
        ///</summary>
        corewolf::engine *NestedLessLess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NestedLessLess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the graph obtained by starting with expr and applying f successively n times.
        /// https://reference.wolfram.com/language/ref/NestGraph.html
        ///</summary>
        corewolf::engine *NestGraph(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NestGraph[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the graph obtained by applying f to expr1, expr2, ….
        /// https://reference.wolfram.com/language/ref/NestGraph.html
        ///</summary>
        corewolf::engine *NestGraph(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NestGraph[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of the results of applying f to expr 0 through n times.
        /// https://reference.wolfram.com/language/ref/NestList.html
        ///</summary>
        corewolf::engine *NestList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NestList[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// adds children to each leaf of tree, with f[expr] giving the list of data for the new children of a leaf with data expr.
        /// https://reference.wolfram.com/language/ref/NestTree.html
        ///</summary>
        corewolf::engine *NestTree(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NestTree[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// successively applies f to the data of each leaf up to level n, adding at most n levels to each leaf.
        /// https://reference.wolfram.com/language/ref/NestTree.html
        ///</summary>
        corewolf::engine *NestTree(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NestTree[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// additionally applies h to the data of the new subtrees.
        /// https://reference.wolfram.com/language/ref/NestTree.html
        ///</summary>
        corewolf::engine *NestTree(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NestTree[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// starts with expr, then repeatedly applies f until applying test to the result no longer yields True.
        /// https://reference.wolfram.com/language/ref/NestWhile.html
        ///</summary>
        corewolf::engine *NestWhile(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NestWhile[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// supplies the most recent m results as arguments for test at each step.
        /// https://reference.wolfram.com/language/ref/NestWhile.html
        ///</summary>
        corewolf::engine *NestWhile(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NestWhile[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// applies f at most max times.
        /// https://reference.wolfram.com/language/ref/NestWhile.html
        ///</summary>
        corewolf::engine *NestWhile(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("NestWhile[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// applies f an extra n times.
        /// https://reference.wolfram.com/language/ref/NestWhile.html
        ///</summary>
        corewolf::engine *NestWhile(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("NestWhile[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// generates a list of the results of applying f repeatedly, starting with expr, and continuing until applying test to the result no longer yields True.
        /// https://reference.wolfram.com/language/ref/NestWhileList.html
        ///</summary>
        corewolf::engine *NestWhileList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NestWhileList[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// supplies the most recent m results as arguments for test at each step.
        /// https://reference.wolfram.com/language/ref/NestWhileList.html
        ///</summary>
        corewolf::engine *NestWhileList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NestWhileList[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// applies f at most max times.
        /// https://reference.wolfram.com/language/ref/NestWhileList.html
        ///</summary>
        corewolf::engine *NestWhileList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("NestWhileList[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// appends a layer or a net onto a NetChain, a layer or a NetGraph with one output port.
        /// https://reference.wolfram.com/language/ref/NetAppend.html
        ///</summary>
        corewolf::engine *NetAppend(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetAppend[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// appends several layers or nets.
        /// https://reference.wolfram.com/language/ref/NetAppend.html
        ///</summary>
        corewolf::engine *NetAppend(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NetAppend[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an array in a net.
        /// https://reference.wolfram.com/language/ref/NetArray.html
        ///</summary>
        corewolf::engine *NetArray(const std::string &name = "")
        {
            return this->execute("NetArray[]", name);
        }

        ///< summary>
        /// uses "name" as an identifier to share the array in more than one layer.
        /// https://reference.wolfram.com/language/ref/NetArray.html
        ///</summary>
        corewolf::engine *NetArray(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetArray[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies several properties for the array.
        /// https://reference.wolfram.com/language/ref/NetArray.html
        ///</summary>
        corewolf::engine *NetArray(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NetArray[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a layer that has no input and produces as output a constant array.
        /// https://reference.wolfram.com/language/ref/NetArrayLayer.html
        ///</summary>
        corewolf::engine *NetArrayLayer(const std::string &name = "")
        {
            return this->execute("NetArrayLayer[]", name);
        }

        ///< summary>
        /// includes options for the initial value of the array or output size.
        /// https://reference.wolfram.com/language/ref/NetArrayLayer.html
        ///</summary>
        corewolf::engine *NetArrayLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetArrayLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a net that applies net to a sequence and to its reverse, concatenating both results into one output sequence.
        /// https://reference.wolfram.com/language/ref/NetBidirectionalOperator.html
        ///</summary>
        corewolf::engine *NetBidirectionalOperator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetBidirectionalOperator[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses fnet on the normal input and bnet on the reversed input.
        /// https://reference.wolfram.com/language/ref/NetBidirectionalOperator.html
        ///</summary>
        corewolf::engine *NetBidirectionalOperator(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("NetBidirectionalOperator[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// aggregates the two output sequences using the specified aggregation function.
        /// https://reference.wolfram.com/language/ref/NetBidirectionalOperator.html
        ///</summary>
        corewolf::engine *NetBidirectionalOperator(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetBidirectionalOperator[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies a neural net in which the output of layeri is connected to the input of layeri+1.
        /// https://reference.wolfram.com/language/ref/NetChain.html
        ///</summary>
        corewolf::engine *NetChain(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("NetChain[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// specifies a net consisting of a chain of explicitly named layers.
        /// https://reference.wolfram.com/language/ref/NetChain.html
        ///</summary>
        corewolf::engine *NetChain(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NetChain[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a decoder that takes a net representation and decodes it into an expression of a given form.
        /// https://reference.wolfram.com/language/ref/NetDecoder.html
        ///</summary>
        corewolf::engine *NetDecoder(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetDecoder[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a decoder with additional parameters specified.
        /// https://reference.wolfram.com/language/ref/NetDecoder.html
        ///</summary>
        corewolf::engine *NetDecoder(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("NetDecoder[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// deletes the n from a NetChain or NetGraph.
        /// https://reference.wolfram.com/language/ref/NetDelete.html
        ///</summary>
        corewolf::engine *NetDelete(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetDelete[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// deletes several layers simultaneously.
        /// https://reference.wolfram.com/language/ref/NetDelete.html
        ///</summary>
        corewolf::engine *NetDelete(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NetDelete[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// removes the first n layers from a NetChain.
        /// https://reference.wolfram.com/language/ref/NetDrop.html
        ///</summary>
        corewolf::engine *NetDrop(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetDrop[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// drops the layers between start and end in a NetChain.
        /// https://reference.wolfram.com/language/ref/NetDrop.html
        ///</summary>
        corewolf::engine *NetDrop(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NetDrop[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an encoder that takes a given form of input and encodes it as an array for use in a net.
        /// https://reference.wolfram.com/language/ref/NetEncoder.html
        ///</summary>
        corewolf::engine *NetEncoder(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetEncoder[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an encoder with additional parameters specified.
        /// https://reference.wolfram.com/language/ref/NetEncoder.html
        ///</summary>
        corewolf::engine *NetEncoder(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("NetEncoder[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// extracts the value of a parameter for the specified net layer.
        /// https://reference.wolfram.com/language/ref/NetExtract.html
        ///</summary>
        corewolf::engine *NetExtract(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetExtract[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// extracts the value of the parameter param from the layer identified by lspec in net.
        /// https://reference.wolfram.com/language/ref/NetExtract.html
        ///</summary>
        corewolf::engine *NetExtract(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NetExtract[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// collapses nested NetChain and NetGraph objects within net.
        /// https://reference.wolfram.com/language/ref/NetFlatten.html
        ///</summary>
        corewolf::engine *NetFlatten(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetFlatten[" + arg0 + "]", name);
        }

        ///< summary>
        /// collapses up to nesting level n.
        /// https://reference.wolfram.com/language/ref/NetFlatten.html
        ///</summary>
        corewolf::engine *NetFlatten(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetFlatten[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a net in which net is folded over a sequence of inputs, maintaining a recurrent state.
        /// https://reference.wolfram.com/language/ref/NetFoldOperator.html
        ///</summary>
        corewolf::engine *NetFoldOperator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetFoldOperator[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a net in which net is folded over its inputs, maintaining a recurrent state by feeding the outi of each step back to the ini of the next step.
        /// https://reference.wolfram.com/language/ref/NetFoldOperator.html
        ///</summary>
        corewolf::engine *NetFoldOperator(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NetFoldOperator[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// treats the inputs consti to net as being constant instead of mapped over.
        /// https://reference.wolfram.com/language/ref/NetFoldOperator.html
        ///</summary>
        corewolf::engine *NetFoldOperator(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("NetFoldOperator[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// returns the sequence of values for the specific outputs outi.
        /// https://reference.wolfram.com/language/ref/NetFoldOperator.html
        ///</summary>
        corewolf::engine *NetFoldOperator(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("NetFoldOperator[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// represents a network to perform generative adversarial network (GAN) training with a generative net generator and a classification net discriminator.
        /// https://reference.wolfram.com/language/ref/NetGANOperator.html
        ///</summary>
        corewolf::engine *NetGANOperator(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("NetGANOperator[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// specifies the loss type to be used.
        /// https://reference.wolfram.com/language/ref/NetGANOperator.html
        ///</summary>
        corewolf::engine *NetGANOperator(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetGANOperator[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies a neural net defined by a graph in which the output of layer mi is given as input to layer ni.
        /// https://reference.wolfram.com/language/ref/NetGraph.html
        ///</summary>
        corewolf::engine *NetGraph(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NetGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// specifies a net with explicitly named layers.
        /// https://reference.wolfram.com/language/ref/NetGraph.html
        ///</summary>
        corewolf::engine *NetGraph(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("NetGraph[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// converts a layer or a NetChain into an equivalent minimal NetGraph.
        /// https://reference.wolfram.com/language/ref/NetGraph.html
        ///</summary>
        corewolf::engine *NetGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a net in which all uninitialized learnable parameters in net have been given initial values.
        /// https://reference.wolfram.com/language/ref/NetInitialize.html
        ///</summary>
        corewolf::engine *NetInitialize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetInitialize[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a net in which all learnable parameters have been given initial values.
        /// https://reference.wolfram.com/language/ref/NetInitialize.html
        ///</summary>
        corewolf::engine *NetInitialize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetInitialize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// inserts a layer into a NetChain before the layer at position i.
        /// https://reference.wolfram.com/language/ref/NetInsert.html
        ///</summary>
        corewolf::engine *NetInsert(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NetInsert[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// converts all ordinary arrays in net into NetSharedArray objects.
        /// https://reference.wolfram.com/language/ref/NetInsertSharedArrays.html
        ///</summary>
        corewolf::engine *NetInsertSharedArrays(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetInsertSharedArrays[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses a prefix for the names of all newly shared arrays.
        /// https://reference.wolfram.com/language/ref/NetInsertSharedArrays.html
        ///</summary>
        corewolf::engine *NetInsertSharedArrays(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetInsertSharedArrays[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// connects a series of NetChain or NetGraph objects to form a single NetChain or NetGraph.
        /// https://reference.wolfram.com/language/ref/NetJoin.html
        ///</summary>
        corewolf::engine *NetJoin(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NetJoin[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a net in which net is mapped over a sequence of inputs to give a sequence of outputs.
        /// https://reference.wolfram.com/language/ref/NetMapOperator.html
        ///</summary>
        corewolf::engine *NetMapOperator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetMapOperator[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a net in which mapnet is mapped over one or more inputs to give one or more outputs.
        /// https://reference.wolfram.com/language/ref/NetMapThreadOperator.html
        ///</summary>
        corewolf::engine *NetMapThreadOperator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetMapThreadOperator[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a net in which mapnet is mapped over its inputs at depth n.
        /// https://reference.wolfram.com/language/ref/NetMapThreadOperator.html
        ///</summary>
        corewolf::engine *NetMapThreadOperator(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetMapThreadOperator[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a net in which mapnet is mapped over the input named inputi at depth ni, and all other inputs are replicated.
        /// https://reference.wolfram.com/language/ref/NetMapThreadOperator.html
        ///</summary>
        corewolf::engine *NetMapThreadOperator(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NetMapThreadOperator[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// computes the requested measurement for the net evaluated on data.
        /// https://reference.wolfram.com/language/ref/NetMeasurements.html
        ///</summary>
        corewolf::engine *NetMeasurements(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NetMeasurements[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes a list of measurements for the net evaluated on data.
        /// https://reference.wolfram.com/language/ref/NetMeasurements.html
        ///</summary>
        corewolf::engine *NetMeasurements(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("NetMeasurements[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// obtains a neural net model with the specified name from the Neural Net Repository.
        /// https://reference.wolfram.com/language/ref/NetModel.html
        ///</summary>
        corewolf::engine *NetModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// obtains a specified model from a parameterized family of models.
        /// https://reference.wolfram.com/language/ref/NetModel.html
        ///</summary>
        corewolf::engine *NetModel(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("NetModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives property prop of the model.
        /// https://reference.wolfram.com/language/ref/NetModel.html
        ///</summary>
        corewolf::engine *NetModel(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetModel[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a dataset of available pre-trained neural net models.
        /// https://reference.wolfram.com/language/ref/NetModel.html
        ///</summary>
        corewolf::engine *NetModel(const std::string &name = "")
        {
            return this->execute("NetModel[]", name);
        }

        ///< summary>
        /// represents a net in which net is applied n times to the input.
        /// https://reference.wolfram.com/language/ref/NetNestOperator.html
        ///</summary>
        corewolf::engine *NetNestOperator(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetNestOperator[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a net that takes a pair of arrays, embeds them into a vector space using net, and outputs the distance under the embedding.
        /// https://reference.wolfram.com/language/ref/NetPairEmbeddingOperator.html
        ///</summary>
        corewolf::engine *NetPairEmbeddingOperator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetPairEmbeddingOperator[" + arg0 + "]", name);
        }

        ///< summary>
        /// includes options for distance function to use and other parameters.
        /// https://reference.wolfram.com/language/ref/NetPairEmbeddingOperator.html
        ///</summary>
        corewolf::engine *NetPairEmbeddingOperator(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetPairEmbeddingOperator[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the specified input or output port for a complete net.
        /// https://reference.wolfram.com/language/ref/NetPort.html
        ///</summary>
        corewolf::engine *NetPort(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetPort[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the specified port for layer number n in a NetGraph or similar construct.
        /// https://reference.wolfram.com/language/ref/NetPort.html
        ///</summary>
        corewolf::engine *NetPort(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("NetPort[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// is treated as equivalent to NetPort[{spec,port}].
        /// https://reference.wolfram.com/language/ref/NetPort.html
        ///</summary>
        corewolf::engine *NetPort(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetPort[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the gradient of the output of a net with respect to the value of the specified input port.
        /// https://reference.wolfram.com/language/ref/NetPortGradient.html
        ///</summary>
        corewolf::engine *NetPortGradient(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetPortGradient[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the gradient with respect to a parameter at a specific position in a net.
        /// https://reference.wolfram.com/language/ref/NetPortGradient.html
        ///</summary>
        corewolf::engine *NetPortGradient(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("NetPortGradient[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// prepends a layer or a net onto a NetChain, a layer or a NetGraph with one input port.
        /// https://reference.wolfram.com/language/ref/NetPrepend.html
        ///</summary>
        corewolf::engine *NetPrepend(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetPrepend[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// prepends several layers or nets.
        /// https://reference.wolfram.com/language/ref/NetPrepend.html
        ///</summary>
        corewolf::engine *NetPrepend(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NetPrepend[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a net in which the name old for a layer is replaced with new.
        /// https://reference.wolfram.com/language/ref/NetRename.html
        ///</summary>
        corewolf::engine *NetRename(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetRename[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// performs all renamings specified by the rulei.
        /// https://reference.wolfram.com/language/ref/NetRename.html
        ///</summary>
        corewolf::engine *NetRename(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NetRename[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// renames layers and ports nested at level levelspec.
        /// https://reference.wolfram.com/language/ref/NetRename.html
        ///</summary>
        corewolf::engine *NetRename(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NetRename[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a net in which all layers matching patt are replaced with layer.
        /// https://reference.wolfram.com/language/ref/NetReplace.html
        ///</summary>
        corewolf::engine *NetReplace(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetReplace[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// performs all replacements specified by the rulei.
        /// https://reference.wolfram.com/language/ref/NetReplace.html
        ///</summary>
        corewolf::engine *NetReplace(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NetReplace[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// replaces an array within a layer, returning a new layer.
        /// https://reference.wolfram.com/language/ref/NetReplacePart.html
        ///</summary>
        corewolf::engine *NetReplacePart(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetReplacePart[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// makes multiple simultaneous replacements.
        /// https://reference.wolfram.com/language/ref/NetReplacePart.html
        ///</summary>
        corewolf::engine *NetReplacePart(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NetReplacePart[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// creates an const std::string &derived from net that represents a neural net with additional stored state information that is updated when the net is applied to data.
        /// https://reference.wolfram.com/language/ref/NetStateObject.html
        ///</summary>
        corewolf::engine *NetStateObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetStateObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates an const std::string &in which additional stored state information is initialized using seed.
        /// https://reference.wolfram.com/language/ref/NetStateObject.html
        ///</summary>
        corewolf::engine *NetStateObject(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetStateObject[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// takes only those layers up to end in a NetChain or NetGraph.
        /// https://reference.wolfram.com/language/ref/NetTake.html
        ///</summary>
        corewolf::engine *NetTake(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetTake[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// takes only those layers between start and end in a NetChain or NetGraph.
        /// https://reference.wolfram.com/language/ref/NetTake.html
        ///</summary>
        corewolf::engine *NetTake(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NetTake[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// trains the specified neural net by giving the inputi as input and minimizing the discrepancy between the outputi and the actual output of the net, using an automatically chosen loss function.
        /// https://reference.wolfram.com/language/ref/NetTrain.html
        ///</summary>
        corewolf::engine *NetTrain(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NetTrain[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// trains the specified net by supplying training data at the specified ports.
        /// https://reference.wolfram.com/language/ref/NetTrain.html
        ///</summary>
        corewolf::engine *NetTrain(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NetTrain[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// trains on a named dataset from the Wolfram Data Repository.
        /// https://reference.wolfram.com/language/ref/NetTrain.html
        ///</summary>
        corewolf::engine *NetTrain(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetTrain[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives data associated with a specific property prop of the training session.
        /// https://reference.wolfram.com/language/ref/NetTrain.html
        ///</summary>
        corewolf::engine *NetTrain(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NetTrain[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an const std::string &generated by NetTrain that contains the trained net and other information about the training process.
        /// https://reference.wolfram.com/language/ref/NetTrainResultsObject.html
        ///</summary>
        corewolf::engine *NetTrainResultsObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetTrainResultsObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// produces the elementary net of the folded net fnet, exposing the recurrent states.
        /// https://reference.wolfram.com/language/ref/NetUnfold.html
        ///</summary>
        corewolf::engine *NetUnfold(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetUnfold[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a temporary interactive interface for capturing information on network packets transmitted or received through all network interfaces on your computer.
        /// https://reference.wolfram.com/language/ref/NetworkPacketCapture.html
        ///</summary>
        corewolf::engine *NetworkPacketCapture(const std::string &name = "")
        {
            return this->execute("NetworkPacketCapture[]", name);
        }

        ///< summary>
        /// captures only packets associated with the specified network service.
        /// https://reference.wolfram.com/language/ref/NetworkPacketCapture.html
        ///</summary>
        corewolf::engine *NetworkPacketCapture(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetworkPacketCapture[" + arg0 + "]", name);
        }

        ///< summary>
        /// records information on network packets transmitted or received through all network interfaces on your computer for t seconds.
        /// https://reference.wolfram.com/language/ref/NetworkPacketRecording.html
        ///</summary>
        corewolf::engine *NetworkPacketRecording(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetworkPacketRecording[" + arg0 + "]", name);
        }

        ///< summary>
        /// records only packets associated with the specified network service.
        /// https://reference.wolfram.com/language/ref/NetworkPacketRecording.html
        ///</summary>
        corewolf::engine *NetworkPacketRecording(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetworkPacketRecording[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// records only packets associated with any of the ports porti.
        /// https://reference.wolfram.com/language/ref/NetworkPacketRecording.html
        ///</summary>
        corewolf::engine *NetworkPacketRecording(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NetworkPacketRecording[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates expr and returns information on network packets transmitted or received through all network interfaces on your computer during the time of the evaluation, together with the result of the evaluation.
        /// https://reference.wolfram.com/language/ref/NetworkPacketTrace.html
        ///</summary>
        corewolf::engine *NetworkPacketTrace(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NetworkPacketTrace[" + arg0 + "]", name);
        }

        ///< summary>
        /// records only packets associated with the specified network service.
        /// https://reference.wolfram.com/language/ref/NetworkPacketTrace.html
        ///</summary>
        corewolf::engine *NetworkPacketTrace(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NetworkPacketTrace[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// records only packets associated with any of the ports porti.
        /// https://reference.wolfram.com/language/ref/NetworkPacketTrace.html
        ///</summary>
        corewolf::engine *NetworkPacketTrace(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NetworkPacketTrace[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a Neumann boundary value val, specified on the part of the boundary of the region given to NDSolve and related functions where pred is True.
        /// https://reference.wolfram.com/language/ref/NeumannValue.html
        ///</summary>
        corewolf::engine *NeumannValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NeumannValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Neville theta function .
        /// https://reference.wolfram.com/language/ref/NevilleThetaC.html
        ///</summary>
        corewolf::engine *NevilleThetaC(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NevilleThetaC[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Neville theta function .
        /// https://reference.wolfram.com/language/ref/NevilleThetaD.html
        ///</summary>
        corewolf::engine *NevilleThetaD(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NevilleThetaD[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Neville theta function .
        /// https://reference.wolfram.com/language/ref/NevilleThetaN.html
        ///</summary>
        corewolf::engine *NevilleThetaN(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NevilleThetaN[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Neville theta function .
        /// https://reference.wolfram.com/language/ref/NevilleThetaS.html
        ///</summary>
        corewolf::engine *NevilleThetaS(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NevilleThetaS[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the numerical expectation of expr under the assumption that x follows the probability distribution dist.
        /// https://reference.wolfram.com/language/ref/NExpectation.html
        ///</summary>
        corewolf::engine *NExpectation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NExpectation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the numerical expectation of expr under the assumption that x1, x2, … are independent and follow the distributions dist1, dist2, ….
        /// https://reference.wolfram.com/language/ref/NExpectation.html
        ///</summary>
        corewolf::engine *NExpectation(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NExpectation[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns the CellObject corresponding to the cell directly below the currently evaluating cell.
        /// https://reference.wolfram.com/language/ref/NextCell.html
        ///</summary>
        corewolf::engine *NextCell(const std::string &name = "")
        {
            return this->execute("NextCell[]", name);
        }

        ///< summary>
        /// starts looking from the given cell.
        /// https://reference.wolfram.com/language/ref/NextCell.html
        ///</summary>
        corewolf::engine *NextCell(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NextCell[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the next occurring date of the specified granularity type gran.
        /// https://reference.wolfram.com/language/ref/NextDate.html
        ///</summary>
        corewolf::engine *NextDate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NextDate[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the next date of the given granularity relative to the specified date.
        /// https://reference.wolfram.com/language/ref/NextDate.html
        ///</summary>
        corewolf::engine *NextDate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NextDate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the smallest prime above .
        /// https://reference.wolfram.com/language/ref/NextPrime.html
        ///</summary>
        corewolf::engine *NextPrime(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NextPrime[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the -next prime above .
        /// https://reference.wolfram.com/language/ref/NextPrime.html
        ///</summary>
        corewolf::engine *NextPrime(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NextPrime[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Neyman–Scott point process with density function μ, cluster mean λ and radial cluster point distribution rdist in .
        /// https://reference.wolfram.com/language/ref/NeymanScottPointProcess.html
        ///</summary>
        corewolf::engine *NeymanScottPointProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NeymanScottPointProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// generates a Nichols plot of the transfer function for the system lsys.
        /// https://reference.wolfram.com/language/ref/NicholsPlot.html
        ///</summary>
        corewolf::engine *NicholsPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NicholsPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots for the frequency range ωmin to ωmax.
        /// https://reference.wolfram.com/language/ref/NicholsPlot.html
        ///</summary>
        corewolf::engine *NicholsPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NicholsPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is a two-dimensional GeoGraphics primitive that represents the half of the Earth currently in darkness.
        /// https://reference.wolfram.com/language/ref/NightHemisphere.html
        ///</summary>
        corewolf::engine *NightHemisphere(const std::string &name = "")
        {
            return this->execute("NightHemisphere[]", name);
        }

        ///< summary>
        /// represents the night half of the Earth for the specified date.
        /// https://reference.wolfram.com/language/ref/NightHemisphere.html
        ///</summary>
        corewolf::engine *NightHemisphere(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NightHemisphere[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a numerical approximation to the integral .
        /// https://reference.wolfram.com/language/ref/NIntegrate.html
        ///</summary>
        corewolf::engine *NIntegrate(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NIntegrate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a numerical approximation to the multiple integral .
        /// https://reference.wolfram.com/language/ref/NIntegrate.html
        ///</summary>
        corewolf::engine *NIntegrate(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NIntegrate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// integrates over the geometric region reg.
        /// https://reference.wolfram.com/language/ref/NIntegrate.html
        ///</summary>
        corewolf::engine *NIntegrate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NIntegrate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// maximizes f numerically with respect to x.
        /// https://reference.wolfram.com/language/ref/NMaximize.html
        ///</summary>
        corewolf::engine *NMaximize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NMaximize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// maximizes f numerically with respect to x, y, ….
        /// https://reference.wolfram.com/language/ref/NMaximize.html
        ///</summary>
        corewolf::engine *NMaximize(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NMaximize[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// maximizes f numerically subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/NMaximize.html
        ///</summary>
        corewolf::engine *NMaximize(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NMaximize[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the maximum value of f with respect to x.
        /// https://reference.wolfram.com/language/ref/NMaxValue.html
        ///</summary>
        corewolf::engine *NMaxValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NMaxValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the maximum value of f with respect to x, y, ….
        /// https://reference.wolfram.com/language/ref/NMaxValue.html
        ///</summary>
        corewolf::engine *NMaxValue(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NMaxValue[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the maximum value of f subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/NMaxValue.html
        ///</summary>
        corewolf::engine *NMaxValue(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NMaxValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// minimizes f numerically with respect to x.
        /// https://reference.wolfram.com/language/ref/NMinimize.html
        ///</summary>
        corewolf::engine *NMinimize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NMinimize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// minimizes f numerically with respect to x, y, ….
        /// https://reference.wolfram.com/language/ref/NMinimize.html
        ///</summary>
        corewolf::engine *NMinimize(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NMinimize[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// minimizes f numerically subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/NMinimize.html
        ///</summary>
        corewolf::engine *NMinimize(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NMinimize[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the minimum value of f with respect to x.
        /// https://reference.wolfram.com/language/ref/NMinValue.html
        ///</summary>
        corewolf::engine *NMinValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NMinValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the minimum value of f with respect to x, y, ….
        /// https://reference.wolfram.com/language/ref/NMinValue.html
        ///</summary>
        corewolf::engine *NMinValue(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NMinValue[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the minimum value of f subject to the constraints cons.
        /// https://reference.wolfram.com/language/ref/NMinValue.html
        ///</summary>
        corewolf::engine *NMinValue(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NMinValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a set of unordered categories cati.
        /// https://reference.wolfram.com/language/ref/NominalScale.html
        ///</summary>
        corewolf::engine *NominalScale(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("NominalScale[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// also associates the category cati with the labels labi.
        /// https://reference.wolfram.com/language/ref/NominalScale.html
        ///</summary>
        corewolf::engine *NominalScale(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NominalScale[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// automatically determines the categories.
        /// https://reference.wolfram.com/language/ref/NominalScale.html
        ///</summary>
        corewolf::engine *NominalScale(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NominalScale[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a noncentral beta distribution with shape parameters α, β and noncentrality parameter δ.
        /// https://reference.wolfram.com/language/ref/NoncentralBetaDistribution.html
        ///</summary>
        corewolf::engine *NoncentralBetaDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NoncentralBetaDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a noncentral  distribution with ν degrees of freedom and noncentrality parameter λ.
        /// https://reference.wolfram.com/language/ref/NoncentralChiSquareDistribution.html
        ///</summary>
        corewolf::engine *NoncentralChiSquareDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NoncentralChiSquareDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a noncentral F-ratio distribution with n numerator degrees of freedom, m denominator degrees of freedom, and numerator noncentrality parameter λ.
        /// https://reference.wolfram.com/language/ref/NoncentralFRatioDistribution.html
        ///</summary>
        corewolf::engine *NoncentralFRatioDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NoncentralFRatioDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a doubly noncentral F-ratio distribution with numerator noncentrality parameter λ and denominator noncentrality parameter η.
        /// https://reference.wolfram.com/language/ref/NoncentralFRatioDistribution.html
        ///</summary>
        corewolf::engine *NoncentralFRatioDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NoncentralFRatioDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a noncentral Student  distribution with ν degrees of freedom and noncentrality parameter δ.
        /// https://reference.wolfram.com/language/ref/NoncentralStudentTDistribution.html
        ///</summary>
        corewolf::engine *NoncentralStudentTDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NoncentralStudentTDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// nondimensionalizes eq, replacing original variables ovars with the variables fvars.
        /// https://reference.wolfram.com/language/ref/NondimensionalizationTransform.html
        ///</summary>
        corewolf::engine *NondimensionalizationTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NondimensionalizationTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns a property associated with the nondimensionalization of eq.
        /// https://reference.wolfram.com/language/ref/NondimensionalizationTransform.html
        ///</summary>
        corewolf::engine *NondimensionalizationTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NondimensionalizationTransform[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// yields True if test[ei] is False for all of the ei.
        /// https://reference.wolfram.com/language/ref/NoneTrue.html
        ///</summary>
        corewolf::engine *NoneTrue(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NoneTrue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests parts of expr at level level.
        /// https://reference.wolfram.com/language/ref/NoneTrue.html
        ///</summary>
        corewolf::engine *NoneTrue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NoneTrue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of NoneTrue that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/NoneTrue.html
        ///</summary>
        corewolf::engine *NoneTrue(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NoneTrue[" + arg0 + "]", name);
        }

        ///< summary>
        /// constructs a nonlinear model with structure form that fits the yi for successive x values 1, 2, … using the parameters β1, ….
        /// https://reference.wolfram.com/language/ref/NonlinearModelFit.html
        ///</summary>
        corewolf::engine *NonlinearModelFit(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NonlinearModelFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// constructs a nonlinear model where form depends on the variables xk.
        /// https://reference.wolfram.com/language/ref/NonlinearModelFit.html
        ///</summary>
        corewolf::engine *NonlinearModelFit(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::vector<std::string> &arg4, const std::string &name = "")
        {
            return this->execute("NonlinearModelFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + "]", name);
        }

        ///< summary>
        /// constructs a nonlinear model subject to the parameter constraints cons.
        /// https://reference.wolfram.com/language/ref/NonlinearModelFit.html
        ///</summary>
        corewolf::engine *NonlinearModelFit(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("NonlinearModelFit[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// represents the model , .
        /// https://reference.wolfram.com/language/ref/NonlinearStateSpaceModel.html
        ///</summary>
        corewolf::engine *NonlinearStateSpaceModel(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NonlinearStateSpaceModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a state-space representation corresponding to the systems model sys.
        /// https://reference.wolfram.com/language/ref/NonlinearStateSpaceModel.html
        ///</summary>
        corewolf::engine *NonlinearStateSpaceModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NonlinearStateSpaceModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the state-space model of the differential equations eqns with dependent variables xi, input variables ui, operating vaues xi0 and ui0, outputs gi, and independent variable t.
        /// https://reference.wolfram.com/language/ref/NonlinearStateSpaceModel.html
        ///</summary>
        corewolf::engine *NonlinearStateSpaceModel(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("NonlinearStateSpaceModel[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// applies a nonlocal means filter to image by comparing a range r neighborhood to its nearby neighborhoods.
        /// https://reference.wolfram.com/language/ref/NonlocalMeansFilter.html
        ///</summary>
        corewolf::engine *NonlocalMeansFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NonlocalMeansFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// assumes an additive noise power value ns for comparing neighborhoods.
        /// https://reference.wolfram.com/language/ref/NonlocalMeansFilter.html
        ///</summary>
        corewolf::engine *NonlocalMeansFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NonlocalMeansFilter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// compares neighborhoods in a range w window.
        /// https://reference.wolfram.com/language/ref/NonlocalMeansFilter.html
        ///</summary>
        corewolf::engine *NonlocalMeansFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NonlocalMeansFilter[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives True if x is a non‐negative number.
        /// https://reference.wolfram.com/language/ref/NonNegative.html
        ///</summary>
        corewolf::engine *NonNegative(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NonNegative[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if x is a non‐positive number.
        /// https://reference.wolfram.com/language/ref/NonPositive.html
        ///</summary>
        corewolf::engine *NonPositive(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NonPositive[" + arg0 + "]", name);
        }

        ///< summary>
        /// is the logical NOR function. It evaluates its arguments in order, giving False immediately if any of them are True, and True if they are all False.
        /// https://reference.wolfram.com/language/ref/Nor.html
        ///</summary>
        corewolf::engine *Nor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Nor[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives Nørlund polynomials  of degree n in a.
        /// https://reference.wolfram.com/language/ref/NorlundB.html
        ///</summary>
        corewolf::engine *NorlundB(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NorlundB[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives generalized Bernoulli polynomials .
        /// https://reference.wolfram.com/language/ref/NorlundB.html
        ///</summary>
        corewolf::engine *NorlundB(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NorlundB[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the norm of a number, vector, or matrix.
        /// https://reference.wolfram.com/language/ref/Norm.html
        ///</summary>
        corewolf::engine *Norm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Norm[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the ‐norm.
        /// https://reference.wolfram.com/language/ref/Norm.html
        ///</summary>
        corewolf::engine *Norm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Norm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts expr to a normal expression from a variety of special forms.
        /// https://reference.wolfram.com/language/ref/Normal.html
        ///</summary>
        corewolf::engine *Normal(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Normal[" + arg0 + "]", name);
        }

        ///< summary>
        /// converts objects with head h in expr to normal expressions.
        /// https://reference.wolfram.com/language/ref/Normal.html
        ///</summary>
        corewolf::engine *Normal(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Normal[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts objects with head hi to normal expressions.
        /// https://reference.wolfram.com/language/ref/Normal.html
        ///</summary>
        corewolf::engine *Normal(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Normal[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a normal (Gaussian) distribution with mean μ and standard deviation σ.
        /// https://reference.wolfram.com/language/ref/NormalDistribution.html
        ///</summary>
        corewolf::engine *NormalDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NormalDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a normal distribution with zero mean and unit standard deviation.
        /// https://reference.wolfram.com/language/ref/NormalDistribution.html
        ///</summary>
        corewolf::engine *NormalDistribution(const std::string &name = "")
        {
            return this->execute("NormalDistribution[]", name);
        }

        ///< summary>
        /// represents a trainable net layer that normalizes its input data across the second and subsequent dimensions and applies an independent scaling and bias to each component of the first dimension.
        /// https://reference.wolfram.com/language/ref/NormalizationLayer.html
        ///</summary>
        corewolf::engine *NormalizationLayer(const std::string &name = "")
        {
            return this->execute("NormalizationLayer[]", name);
        }

        ///< summary>
        /// normalizes its input data across the specified aggregation levels and applies a learned scaling and bias on the remaining levels.
        /// https://reference.wolfram.com/language/ref/NormalizationLayer.html
        ///</summary>
        corewolf::engine *NormalizationLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NormalizationLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies a learned scaling and bias at the specified scaling levels.
        /// https://reference.wolfram.com/language/ref/NormalizationLayer.html
        ///</summary>
        corewolf::engine *NormalizationLayer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NormalizationLayer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the normalized form of a vector v.
        /// https://reference.wolfram.com/language/ref/Normalize.html
        ///</summary>
        corewolf::engine *Normalize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Normalize[" + arg0 + "]", name);
        }

        ///< summary>
        /// normalizes with respect to the norm function f.
        /// https://reference.wolfram.com/language/ref/Normalize.html
        ///</summary>
        corewolf::engine *Normalize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Normalize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the normalized squared Euclidean distance between vectors u and v.
        /// https://reference.wolfram.com/language/ref/NormalizedSquaredEuclideanDistance.html
        ///</summary>
        corewolf::engine *NormalizedSquaredEuclideanDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NormalizedSquaredEuclideanDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if m is an explicitly normal matrix, and False otherwise.
        /// https://reference.wolfram.com/language/ref/NormalMatrixQ.html
        ///</summary>
        corewolf::engine *NormalMatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NormalMatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotCongruent.html
        ///</summary>
        corewolf::engine *NotCongruent(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotCongruent[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotCupCap.html
        ///</summary>
        corewolf::engine *NotCupCap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotCupCap[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotDoubleVerticalBar.html
        ///</summary>
        corewolf::engine *NotDoubleVerticalBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotDoubleVerticalBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is the low‐level construct that represents a notebook manipulated by the Wolfram System front end.
        /// https://reference.wolfram.com/language/ref/Notebook.html
        ///</summary>
        corewolf::engine *Notebook(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Notebook[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// writes data into a notebook at the current selection, replacing the first selection placeholder in data by the current selection, and then setting the current selection to be just after the data written.
        /// https://reference.wolfram.com/language/ref/NotebookApply.html
        ///</summary>
        corewolf::engine *NotebookApply(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NotebookApply[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// writes data into a notebook and then sets the current selection to be as specified by sel.
        /// https://reference.wolfram.com/language/ref/NotebookApply.html
        ///</summary>
        corewolf::engine *NotebookApply(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotebookApply[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// closes the notebook corresponding to the specified notebook object.
        /// https://reference.wolfram.com/language/ref/NotebookClose.html
        ///</summary>
        corewolf::engine *NotebookClose(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NotebookClose[" + arg0 + "]", name);
        }

        ///< summary>
        /// closes the current evaluation notebook.
        /// https://reference.wolfram.com/language/ref/NotebookClose.html
        ///</summary>
        corewolf::engine *NotebookClose(const std::string &name = "")
        {
            return this->execute("NotebookClose[]", name);
        }

        ///< summary>
        /// deletes the current selection in the notebook corresponding to the specified notebook object.
        /// https://reference.wolfram.com/language/ref/NotebookDelete.html
        ///</summary>
        corewolf::engine *NotebookDelete(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NotebookDelete[" + arg0 + "]", name);
        }

        ///< summary>
        /// deletes all specified objects.
        /// https://reference.wolfram.com/language/ref/NotebookDelete.html
        ///</summary>
        corewolf::engine *NotebookDelete(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("NotebookDelete[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// deletes the current selection in the current evaluation notebook.
        /// https://reference.wolfram.com/language/ref/NotebookDelete.html
        ///</summary>
        corewolf::engine *NotebookDelete(const std::string &name = "")
        {
            return this->execute("NotebookDelete[]", name);
        }

        ///< summary>
        /// gives the directory of the current evaluation notebook.
        /// https://reference.wolfram.com/language/ref/NotebookDirectory.html
        ///</summary>
        corewolf::engine *NotebookDirectory(const std::string &name = "")
        {
            return this->execute("NotebookDirectory[]", name);
        }

        ///< summary>
        /// gives the directory for the notebook specified by nb.
        /// https://reference.wolfram.com/language/ref/NotebookDirectory.html
        ///</summary>
        corewolf::engine *NotebookDirectory(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NotebookDirectory[" + arg0 + "]", name);
        }

        ///< summary>
        /// evaluates all the evaluatable cells in notebook.
        /// https://reference.wolfram.com/language/ref/NotebookEvaluate.html
        ///</summary>
        corewolf::engine *NotebookEvaluate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NotebookEvaluate[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the file name of the current evaluation notebook.
        /// https://reference.wolfram.com/language/ref/NotebookFileName.html
        ///</summary>
        corewolf::engine *NotebookFileName(const std::string &name = "")
        {
            return this->execute("NotebookFileName[]", name);
        }

        ///< summary>
        /// gives the file name for the notebook specified by nb.
        /// https://reference.wolfram.com/language/ref/NotebookFileName.html
        ///</summary>
        corewolf::engine *NotebookFileName(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NotebookFileName[" + arg0 + "]", name);
        }

        ///< summary>
        /// sets the current selection in the specified notebook const std::string &to be the next occurrence of data.
        /// https://reference.wolfram.com/language/ref/NotebookFind.html
        ///</summary>
        corewolf::engine *NotebookFind(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NotebookFind[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sets the current selection to be the previous occurrence.
        /// https://reference.wolfram.com/language/ref/NotebookFind.html
        ///</summary>
        corewolf::engine *NotebookFind(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotebookFind[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// sets the current selection to be the occurrence in the direction dir and searches the elements of cells specified by elems.
        /// https://reference.wolfram.com/language/ref/NotebookFind.html
        ///</summary>
        corewolf::engine *NotebookFind(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("NotebookFind[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gets the raw expression corresponding to the notebook represented by the notebook const std::string &obj.
        /// https://reference.wolfram.com/language/ref/NotebookGet.html
        ///</summary>
        corewolf::engine *NotebookGet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NotebookGet[" + arg0 + "]", name);
        }

        ///< summary>
        /// gets the raw expression corresponding to the currently selected notebook.
        /// https://reference.wolfram.com/language/ref/NotebookGet.html
        ///</summary>
        corewolf::engine *NotebookGet(const std::string &name = "")
        {
            return this->execute("NotebookGet[]", name);
        }

        ///< summary>
        /// imports cells with the given cell style from the specified notebook.
        /// https://reference.wolfram.com/language/ref/NotebookImport.html
        ///</summary>
        corewolf::engine *NotebookImport(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NotebookImport[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of properties of the current evaluation notebook.
        /// https://reference.wolfram.com/language/ref/NotebookInformation.html
        ///</summary>
        corewolf::engine *NotebookInformation(const std::string &name = "")
        {
            return this->execute("NotebookInformation[]", name);
        }

        ///< summary>
        /// gives a list of properties for the specified notebook.
        /// https://reference.wolfram.com/language/ref/NotebookInformation.html
        ///</summary>
        corewolf::engine *NotebookInformation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NotebookInformation[" + arg0 + "]", name);
        }

        ///< summary>
        /// locates all cells with the specified tag in your current input notebook, selecting the cells and scrolling to the position of the first one.
        /// https://reference.wolfram.com/language/ref/NotebookLocate.html
        ///</summary>
        corewolf::engine *NotebookLocate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NotebookLocate[" + arg0 + "]", name);
        }

        ///< summary>
        /// if necessary opens the notebook stored in file, then locates cells with the specified tag.
        /// https://reference.wolfram.com/language/ref/NotebookLocate.html
        ///</summary>
        corewolf::engine *NotebookLocate(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("NotebookLocate[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// is an const std::string &that represents an open notebook in the front end.
        /// https://reference.wolfram.com/language/ref/NotebookObject.html
        ///</summary>
        corewolf::engine *NotebookObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NotebookObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// opens an existing notebook with the specified name, returning the corresponding notebook object.
        /// https://reference.wolfram.com/language/ref/NotebookOpen.html
        ///</summary>
        corewolf::engine *NotebookOpen(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NotebookOpen[" + arg0 + "]", name);
        }

        ///< summary>
        /// opens a notebook using the options given.
        /// https://reference.wolfram.com/language/ref/NotebookOpen.html
        ///</summary>
        corewolf::engine *NotebookOpen(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NotebookOpen[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sends a notebook containing expr to your default printer.
        /// https://reference.wolfram.com/language/ref/NotebookPrint.html
        ///</summary>
        corewolf::engine *NotebookPrint(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NotebookPrint[" + arg0 + "]", name);
        }

        ///< summary>
        /// saves a print‐ready form of the notebook to a file in the format indicated by the file extension ext.
        /// https://reference.wolfram.com/language/ref/NotebookPrint.html
        ///</summary>
        corewolf::engine *NotebookPrint(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NotebookPrint[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sends the current evaluation notebook to your default printer.
        /// https://reference.wolfram.com/language/ref/NotebookPrint.html
        ///</summary>
        corewolf::engine *NotebookPrint(const std::string &name = "")
        {
            return this->execute("NotebookPrint[]", name);
        }

        ///< summary>
        /// creates a notebook corresponding to expr and makes it the currently selected notebook in the front end.
        /// https://reference.wolfram.com/language/ref/NotebookPut.html
        ///</summary>
        corewolf::engine *NotebookPut(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NotebookPut[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a new empty notebook.
        /// https://reference.wolfram.com/language/ref/NotebookPut.html
        ///</summary>
        corewolf::engine *NotebookPut(const std::string &name = "")
        {
            return this->execute("NotebookPut[]", name);
        }

        ///< summary>
        /// replaces the notebook represented by the notebook const std::string &obj with one corresponding to expr.
        /// https://reference.wolfram.com/language/ref/NotebookPut.html
        ///</summary>
        corewolf::engine *NotebookPut(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NotebookPut[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the expression corresponding to the current selection in the specified notebook object.
        /// https://reference.wolfram.com/language/ref/NotebookRead.html
        ///</summary>
        corewolf::engine *NotebookRead(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NotebookRead[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of expressions corresponding to the obji.
        /// https://reference.wolfram.com/language/ref/NotebookRead.html
        ///</summary>
        corewolf::engine *NotebookRead(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("NotebookRead[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of notebooks currently open in the front end.
        /// https://reference.wolfram.com/language/ref/Notebooks.html
        ///</summary>
        corewolf::engine *Notebooks(const std::string &name = "")
        {
            return this->execute("Notebooks[]", name);
        }

        ///< summary>
        /// saves the current version of the specified notebook.
        /// https://reference.wolfram.com/language/ref/NotebookSave.html
        ///</summary>
        corewolf::engine *NotebookSave(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NotebookSave[" + arg0 + "]", name);
        }

        ///< summary>
        /// saves the notebook in the specified file.
        /// https://reference.wolfram.com/language/ref/NotebookSave.html
        ///</summary>
        corewolf::engine *NotebookSave(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NotebookSave[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// saves the current version of the current evaluation notebook in a file.
        /// https://reference.wolfram.com/language/ref/NotebookSave.html
        ///</summary>
        corewolf::engine *NotebookSave(const std::string &name = "")
        {
            return this->execute("NotebookSave[]", name);
        }

        ///< summary>
        /// represents the current selection in the current evaluation notebook in the front end.
        /// https://reference.wolfram.com/language/ref/NotebookSelection.html
        ///</summary>
        corewolf::engine *NotebookSelection(const std::string &name = "")
        {
            return this->execute("NotebookSelection[]", name);
        }

        ///< summary>
        /// represents the current selection associated with the open notebook nb.
        /// https://reference.wolfram.com/language/ref/NotebookSelection.html
        ///</summary>
        corewolf::engine *NotebookSelection(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NotebookSelection[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields a TemplateObject that represents a notebook template to be applied using functions like GenerateDocument and FileTemplateApply.
        /// https://reference.wolfram.com/language/ref/NotebookTemplate.html
        ///</summary>
        corewolf::engine *NotebookTemplate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NotebookTemplate[" + arg0 + "]", name);
        }

        ///< summary>
        /// writes data into a notebook at the current selection, setting the current selection to be just after the data written.
        /// https://reference.wolfram.com/language/ref/NotebookWrite.html
        ///</summary>
        corewolf::engine *NotebookWrite(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NotebookWrite[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// writes data into a notebook, setting the current selection to be as specified by sel.
        /// https://reference.wolfram.com/language/ref/NotebookWrite.html
        ///</summary>
        corewolf::engine *NotebookWrite(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotebookWrite[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// or x∉dom asserts that  is not an element of the domain dom.
        /// https://reference.wolfram.com/language/ref/NotElement.html
        ///</summary>
        corewolf::engine *NotElement(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NotElement[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotEqualTilde.html
        ///</summary>
        corewolf::engine *NotEqualTilde(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotEqualTilde[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotExists.html
        ///</summary>
        corewolf::engine *NotExists(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NotExists[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotGreater.html
        ///</summary>
        corewolf::engine *NotGreater(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotGreater[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotGreaterEqual.html
        ///</summary>
        corewolf::engine *NotGreaterEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotGreaterEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotGreaterFullEqual.html
        ///</summary>
        corewolf::engine *NotGreaterFullEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotGreaterFullEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotGreaterGreater.html
        ///</summary>
        corewolf::engine *NotGreaterGreater(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotGreaterGreater[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotGreaterLess.html
        ///</summary>
        corewolf::engine *NotGreaterLess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotGreaterLess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotGreaterSlantEqual.html
        ///</summary>
        corewolf::engine *NotGreaterSlantEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotGreaterSlantEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotGreaterTilde.html
        ///</summary>
        corewolf::engine *NotGreaterTilde(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotGreaterTilde[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotHumpDownHump.html
        ///</summary>
        corewolf::engine *NotHumpDownHump(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotHumpDownHump[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotHumpEqual.html
        ///</summary>
        corewolf::engine *NotHumpEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotHumpEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotLeftTriangle.html
        ///</summary>
        corewolf::engine *NotLeftTriangle(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotLeftTriangle[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotLeftTriangleBar.html
        ///</summary>
        corewolf::engine *NotLeftTriangleBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotLeftTriangleBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotLeftTriangleEqual.html
        ///</summary>
        corewolf::engine *NotLeftTriangleEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotLeftTriangleEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotLess.html
        ///</summary>
        corewolf::engine *NotLess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotLess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotLessEqual.html
        ///</summary>
        corewolf::engine *NotLessEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotLessEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotLessFullEqual.html
        ///</summary>
        corewolf::engine *NotLessFullEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotLessFullEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotLessGreater.html
        ///</summary>
        corewolf::engine *NotLessGreater(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotLessGreater[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotLessLess.html
        ///</summary>
        corewolf::engine *NotLessLess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotLessLess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotLessSlantEqual.html
        ///</summary>
        corewolf::engine *NotLessSlantEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotLessSlantEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotLessTilde.html
        ///</summary>
        corewolf::engine *NotLessTilde(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotLessTilde[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotNestedGreaterGreater.html
        ///</summary>
        corewolf::engine *NotNestedGreaterGreater(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotNestedGreaterGreater[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotNestedLessLess.html
        ///</summary>
        corewolf::engine *NotNestedLessLess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotNestedLessLess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotPrecedes.html
        ///</summary>
        corewolf::engine *NotPrecedes(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotPrecedes[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotPrecedesEqual.html
        ///</summary>
        corewolf::engine *NotPrecedesEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotPrecedesEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotPrecedesSlantEqual.html
        ///</summary>
        corewolf::engine *NotPrecedesSlantEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotPrecedesSlantEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotPrecedesTilde.html
        ///</summary>
        corewolf::engine *NotPrecedesTilde(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotPrecedesTilde[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotReverseElement.html
        ///</summary>
        corewolf::engine *NotReverseElement(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotReverseElement[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotRightTriangle.html
        ///</summary>
        corewolf::engine *NotRightTriangle(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotRightTriangle[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotRightTriangleBar.html
        ///</summary>
        corewolf::engine *NotRightTriangleBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotRightTriangleBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotRightTriangleEqual.html
        ///</summary>
        corewolf::engine *NotRightTriangleEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotRightTriangleEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotSquareSubset.html
        ///</summary>
        corewolf::engine *NotSquareSubset(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotSquareSubset[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotSquareSubsetEqual.html
        ///</summary>
        corewolf::engine *NotSquareSubsetEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotSquareSubsetEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotSquareSuperset.html
        ///</summary>
        corewolf::engine *NotSquareSuperset(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotSquareSuperset[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotSquareSupersetEqual.html
        ///</summary>
        corewolf::engine *NotSquareSupersetEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotSquareSupersetEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotSubset.html
        ///</summary>
        corewolf::engine *NotSubset(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotSubset[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotSubsetEqual.html
        ///</summary>
        corewolf::engine *NotSubsetEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotSubsetEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotSucceeds.html
        ///</summary>
        corewolf::engine *NotSucceeds(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotSucceeds[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotSucceedsEqual.html
        ///</summary>
        corewolf::engine *NotSucceedsEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotSucceedsEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotSucceedsSlantEqual.html
        ///</summary>
        corewolf::engine *NotSucceedsSlantEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotSucceedsSlantEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotSucceedsTilde.html
        ///</summary>
        corewolf::engine *NotSucceedsTilde(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotSucceedsTilde[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotSuperset.html
        ///</summary>
        corewolf::engine *NotSuperset(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotSuperset[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotSupersetEqual.html
        ///</summary>
        corewolf::engine *NotSupersetEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotSupersetEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotTilde.html
        ///</summary>
        corewolf::engine *NotTilde(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotTilde[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotTildeEqual.html
        ///</summary>
        corewolf::engine *NotTildeEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotTildeEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotTildeFullEqual.html
        ///</summary>
        corewolf::engine *NotTildeFullEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotTildeFullEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotTildeTilde.html
        ///</summary>
        corewolf::engine *NotTildeTilde(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotTildeTilde[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/NotVerticalBar.html
        ///</summary>
        corewolf::engine *NotVerticalBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NotVerticalBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the numerical probability for an event that satisfies the predicate pred under the assumption that x follows the probability distribution dist.
        /// https://reference.wolfram.com/language/ref/NProbability.html
        ///</summary>
        corewolf::engine *NProbability(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NProbability[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the numerical probability that an event satisfies pred under the assumption that x1, x2, … are independent and follow the distributions dist1, dist2, ….
        /// https://reference.wolfram.com/language/ref/NProbability.html
        ///</summary>
        corewolf::engine *NProbability(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NProbability[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a numerical approximation to the product .
        /// https://reference.wolfram.com/language/ref/NProduct.html
        ///</summary>
        corewolf::engine *NProduct(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NProduct[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields a disjunction of equations which represent numerical approximations to the roots of a polynomial equation.
        /// https://reference.wolfram.com/language/ref/NRoots.html
        ///</summary>
        corewolf::engine *NRoots(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NRoots[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// attempts to find numerical approximations to the solutions of the system expr of equations or inequalities for the variables vars.
        /// https://reference.wolfram.com/language/ref/NSolve.html
        ///</summary>
        corewolf::engine *NSolve(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NSolve[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds solutions over the domain of real numbers.
        /// https://reference.wolfram.com/language/ref/NSolve.html
        ///</summary>
        corewolf::engine *NSolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NSolve[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// attempts to find numerical approximations to the values of vars determined by the solutions of the system expr.
        /// https://reference.wolfram.com/language/ref/NSolveValues.html
        ///</summary>
        corewolf::engine *NSolveValues(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NSolveValues[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds solutions over the domain of real numbers.
        /// https://reference.wolfram.com/language/ref/NSolveValues.html
        ///</summary>
        corewolf::engine *NSolveValues(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NSolveValues[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a numerical approximation to the sum .
        /// https://reference.wolfram.com/language/ref/NSum.html
        ///</summary>
        corewolf::engine *NSum(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NSum[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the nuclear explosion entity.
        /// https://reference.wolfram.com/language/ref/NuclearExplosionData.html
        ///</summary>
        corewolf::engine *NuclearExplosionData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NuclearExplosionData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified nuclear explosion entities.
        /// https://reference.wolfram.com/language/ref/NuclearExplosionData.html
        ///</summary>
        corewolf::engine *NuclearExplosionData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NuclearExplosionData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/NuclearExplosionData.html
        ///</summary>
        corewolf::engine *NuclearExplosionData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NuclearExplosionData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the nuclear reactor entity.
        /// https://reference.wolfram.com/language/ref/NuclearReactorData.html
        ///</summary>
        corewolf::engine *NuclearReactorData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NuclearReactorData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified nuclear reactor entities.
        /// https://reference.wolfram.com/language/ref/NuclearReactorData.html
        ///</summary>
        corewolf::engine *NuclearReactorData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NuclearReactorData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/NuclearReactorData.html
        ///</summary>
        corewolf::engine *NuclearReactorData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NuclearReactorData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of vectors that forms a basis for the null space of the matrix m.
        /// https://reference.wolfram.com/language/ref/NullSpace.html
        ///</summary>
        corewolf::engine *NullSpace(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NullSpace[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the quantity c1 u1+…+cn un.
        /// https://reference.wolfram.com/language/ref/NumberCompose.html
        ///</summary>
        corewolf::engine *NumberCompose(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NumberCompose[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns a list of coefficients {c1,…,cn} of a decomposition of the number x in the basis {u1,…,un}.
        /// https://reference.wolfram.com/language/ref/NumberDecompose.html
        ///</summary>
        corewolf::engine *NumberDecompose(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NumberDecompose[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns the digit corresponding to 10n in the real-valued number x.
        /// https://reference.wolfram.com/language/ref/NumberDigit.html
        ///</summary>
        corewolf::engine *NumberDigit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NumberDigit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the digit corresponding to b.
        /// https://reference.wolfram.com/language/ref/NumberDigit.html
        ///</summary>
        corewolf::engine *NumberDigit(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NumberDigit[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of the decimal digits of x multiplied by their corresponding powers of 10.
        /// https://reference.wolfram.com/language/ref/NumberExpand.html
        ///</summary>
        corewolf::engine *NumberExpand(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NumberExpand[" + arg0 + "]", name);
        }

        ///< summary>
        /// expands x in base b.
        /// https://reference.wolfram.com/language/ref/NumberExpand.html
        ///</summary>
        corewolf::engine *NumberExpand(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NumberExpand[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of length len.
        /// https://reference.wolfram.com/language/ref/NumberExpand.html
        ///</summary>
        corewolf::engine *NumberExpand(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NumberExpand[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the class number for the algebraic number field  generated by .
        /// https://reference.wolfram.com/language/ref/NumberFieldClassNumber.html
        ///</summary>
        corewolf::engine *NumberFieldClassNumber(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NumberFieldClassNumber[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the discriminant of the field  generated by the algebraic number .
        /// https://reference.wolfram.com/language/ref/NumberFieldDiscriminant.html
        ///</summary>
        corewolf::engine *NumberFieldDiscriminant(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NumberFieldDiscriminant[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of fundamental units for the field  generated by the algebraic number .
        /// https://reference.wolfram.com/language/ref/NumberFieldFundamentalUnits.html
        ///</summary>
        corewolf::engine *NumberFieldFundamentalUnits(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NumberFieldFundamentalUnits[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an integral basis for the field  generated by the algebraic number .
        /// https://reference.wolfram.com/language/ref/NumberFieldIntegralBasis.html
        ///</summary>
        corewolf::engine *NumberFieldIntegralBasis(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NumberFieldIntegralBasis[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of representatives of classes of algebraic integers of norm  in the field  generated by the algebraic number .
        /// https://reference.wolfram.com/language/ref/NumberFieldNormRepresentatives.html
        ///</summary>
        corewolf::engine *NumberFieldNormRepresentatives(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NumberFieldNormRepresentatives[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the regulator of the field  generated by the algebraic number .
        /// https://reference.wolfram.com/language/ref/NumberFieldRegulator.html
        ///</summary>
        corewolf::engine *NumberFieldRegulator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NumberFieldRegulator[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the roots of unity for the field  generated by the algebraic number .
        /// https://reference.wolfram.com/language/ref/NumberFieldRootsOfUnity.html
        ///</summary>
        corewolf::engine *NumberFieldRootsOfUnity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NumberFieldRootsOfUnity[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the signature of the field  generated by the algebraic number .
        /// https://reference.wolfram.com/language/ref/NumberFieldSignature.html
        ///</summary>
        corewolf::engine *NumberFieldSignature(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NumberFieldSignature[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints with approximate real numbers in expr given to n‐digit precision.
        /// https://reference.wolfram.com/language/ref/NumberForm.html
        ///</summary>
        corewolf::engine *NumberForm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NumberForm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// prints with approximate real numbers having n digits, with f digits to the right of the decimal point.
        /// https://reference.wolfram.com/language/ref/NumberForm.html
        ///</summary>
        corewolf::engine *NumberForm(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NumberForm[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// prints using the default options of NumberForm.
        /// https://reference.wolfram.com/language/ref/NumberForm.html
        ///</summary>
        corewolf::engine *NumberForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NumberForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots the values vi on a number line.
        /// https://reference.wolfram.com/language/ref/NumberLinePlot.html
        ///</summary>
        corewolf::engine *NumberLinePlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("NumberLinePlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots a number line illustrating the region pred.
        /// https://reference.wolfram.com/language/ref/NumberLinePlot.html
        ///</summary>
        corewolf::engine *NumberLinePlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NumberLinePlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// plots the number to extend over the interval from xmin to xmax.
        /// https://reference.wolfram.com/language/ref/NumberLinePlot.html
        ///</summary>
        corewolf::engine *NumberLinePlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NumberLinePlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots several number lines.
        /// https://reference.wolfram.com/language/ref/NumberLinePlot.html
        ///</summary>
        corewolf::engine *NumberLinePlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NumberLinePlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if expr is a number, and False otherwise.
        /// https://reference.wolfram.com/language/ref/NumberQ.html
        ///</summary>
        corewolf::engine *NumberQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NumberQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the numerator of expr.
        /// https://reference.wolfram.com/language/ref/Numerator.html
        ///</summary>
        corewolf::engine *Numerator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Numerator[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the list {Numerator[expr],Denominator[expr]} of expr.
        /// https://reference.wolfram.com/language/ref/NumeratorDenominator.html
        ///</summary>
        corewolf::engine *NumeratorDenominator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NumeratorDenominator[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives 1 if e1<e2, -1 if e1>e2, 0 if e1 and e2 are identical or numerically the same and Order[e1,e2] if e1 and e2 are not numerically comparable.
        /// https://reference.wolfram.com/language/ref/NumericalOrder.html
        ///</summary>
        corewolf::engine *NumericalOrder(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NumericalOrder[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sorts the elements of list into numerical order.
        /// https://reference.wolfram.com/language/ref/NumericalSort.html
        ///</summary>
        corewolf::engine *NumericalSort(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NumericalSort[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a numeric array of the specified type.
        /// https://reference.wolfram.com/language/ref/NumericArray.html
        ///</summary>
        corewolf::engine *NumericArray(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NumericArray[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses method to convert numbers into type.
        /// https://reference.wolfram.com/language/ref/NumericArray.html
        ///</summary>
        corewolf::engine *NumericArray(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NumericArray[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives True if expr is a valid NumericArray object, and False otherwise.
        /// https://reference.wolfram.com/language/ref/NumericArrayQ.html
        ///</summary>
        corewolf::engine *NumericArrayQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NumericArrayQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// requires additionally that NumericArrayType[expr] match the pattern tpatt.
        /// https://reference.wolfram.com/language/ref/NumericArrayQ.html
        ///</summary>
        corewolf::engine *NumericArrayQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("NumericArrayQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// requires additionally that ArrayDepth[expr] match the pattern dpatt.
        /// https://reference.wolfram.com/language/ref/NumericArrayQ.html
        ///</summary>
        corewolf::engine *NumericArrayQ(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("NumericArrayQ[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the underlying type of values used for each element in the NumericArray object.
        /// https://reference.wolfram.com/language/ref/NumericArrayType.html
        ///</summary>
        corewolf::engine *NumericArrayType(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NumericArrayType[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if expr is a numeric quantity, and False otherwise.
        /// https://reference.wolfram.com/language/ref/NumericQ.html
        ///</summary>
        corewolf::engine *NumericQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NumericQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Nuttall window function of x.
        /// https://reference.wolfram.com/language/ref/NuttallWindow.html
        ///</summary>
        corewolf::engine *NuttallWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NuttallWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a Nyquist plot of the transfer function for the system lsys.
        /// https://reference.wolfram.com/language/ref/NyquistPlot.html
        ///</summary>
        corewolf::engine *NyquistPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("NyquistPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots for the frequency range ωmin to ωmax.
        /// https://reference.wolfram.com/language/ref/NyquistPlot.html
        ///</summary>
        corewolf::engine *NyquistPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("NyquistPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the observability Gramian of the state-space model ssm.
        /// https://reference.wolfram.com/language/ref/ObservabilityGramian.html
        ///</summary>
        corewolf::engine *ObservabilityGramian(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ObservabilityGramian[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the observability matrix of the state-space model ssm.
        /// https://reference.wolfram.com/language/ref/ObservabilityMatrix.html
        ///</summary>
        corewolf::engine *ObservabilityMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ObservabilityMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields the observable subsystem of the system sys.
        /// https://reference.wolfram.com/language/ref/ObservableDecomposition.html
        ///</summary>
        corewolf::engine *ObservableDecomposition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ObservableDecomposition[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies the new coordinates zi.
        /// https://reference.wolfram.com/language/ref/ObservableDecomposition.html
        ///</summary>
        corewolf::engine *ObservableDecomposition(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ObservableDecomposition[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives True if the system sys is observable, and False otherwise.
        /// https://reference.wolfram.com/language/ref/ObservableModelQ.html
        ///</summary>
        corewolf::engine *ObservableModelQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ObservableModelQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if the subsystem sub is observable.
        /// https://reference.wolfram.com/language/ref/ObservableModelQ.html
        ///</summary>
        corewolf::engine *ObservableModelQ(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ObservableModelQ[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the ocean entity.
        /// https://reference.wolfram.com/language/ref/OceanData.html
        ///</summary>
        corewolf::engine *OceanData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("OceanData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified ocean entities.
        /// https://reference.wolfram.com/language/ref/OceanData.html
        ///</summary>
        corewolf::engine *OceanData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("OceanData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/OceanData.html
        ///</summary>
        corewolf::engine *OceanData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("OceanData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a regular octahedron centered at the origin with unit edge length.
        /// https://reference.wolfram.com/language/ref/Octahedron.html
        ///</summary>
        corewolf::engine *Octahedron(const std::string &name = "")
        {
            return this->execute("Octahedron[]", name);
        }

        ///< summary>
        /// represents an octahedron with edge length l.
        /// https://reference.wolfram.com/language/ref/Octahedron.html
        ///</summary>
        corewolf::engine *Octahedron(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Octahedron[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an octahedron rotated by an angle θ with respect to the z axis and angle ϕ with respect to the y axis.
        /// https://reference.wolfram.com/language/ref/Octahedron.html
        ///</summary>
        corewolf::engine *Octahedron(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Octahedron[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if expr is an odd integer, and False otherwise.
        /// https://reference.wolfram.com/language/ref/OddQ.html
        ///</summary>
        corewolf::engine *OddQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OddQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// switches off a message, so that it is no longer printed.
        /// https://reference.wolfram.com/language/ref/Off.html
        ///</summary>
        corewolf::engine *Off(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Off[" + arg0 + "]", name);
        }

        ///< summary>
        /// switches off several messages or message groups.
        /// https://reference.wolfram.com/language/ref/Off.html
        ///</summary>
        corewolf::engine *Off(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Off[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the position of a graphical const std::string &obtained by starting at the specified position and then moving by absolute offset {dx,dy}.
        /// https://reference.wolfram.com/language/ref/Offset.html
        ///</summary>
        corewolf::engine *Offset(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Offset[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// switches on a message, so that it can be printed.
        /// https://reference.wolfram.com/language/ref/On.html
        ///</summary>
        corewolf::engine *On(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("On[" + arg0 + "]", name);
        }

        ///< summary>
        /// switches on several messages or message groups.
        /// https://reference.wolfram.com/language/ref/On.html
        ///</summary>
        corewolf::engine *On(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("On[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the sporadic simple O'Nan group .
        /// https://reference.wolfram.com/language/ref/ONanGroupON.html
        ///</summary>
        corewolf::engine *ONanGroupON(const std::string &name = "")
        {
            return this->execute("ONanGroupON[]", name);
        }

        ///< summary>
        /// evaluates expr once in each Wolfram Language session, always returning the result from the first evaluation.
        /// https://reference.wolfram.com/language/ref/Once.html
        ///</summary>
        corewolf::engine *Once(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Once[" + arg0 + "]", name);
        }

        ///< summary>
        /// evaluates expr once and caches the result in persistence location loc.
        /// https://reference.wolfram.com/language/ref/Once.html
        ///</summary>
        corewolf::engine *Once(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Once[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a graphics directive that specifies that graphical objects that follow are to be displayed, if possible, with opacity a.
        /// https://reference.wolfram.com/language/ref/Opacity.html
        ///</summary>
        corewolf::engine *Opacity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Opacity[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the specified color with opacity a.
        /// https://reference.wolfram.com/language/ref/Opacity.html
        ///</summary>
        corewolf::engine *Opacity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Opacity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// opens a file to append output to it, and returns an OutputStream object.
        /// https://reference.wolfram.com/language/ref/OpenAppend.html
        ///</summary>
        corewolf::engine *OpenAppend(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OpenAppend[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an opener with setting x, displayed as  when x is True and  when x is False.
        /// https://reference.wolfram.com/language/ref/Opener.html
        ///</summary>
        corewolf::engine *Opener(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Opener[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an const std::string &which displays as an opener, together with expr1 if the opener is closed, and both expr1 and expr2 if it is open.
        /// https://reference.wolfram.com/language/ref/OpenerView.html
        ///</summary>
        corewolf::engine *OpenerView(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("OpenerView[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// specifies the state of the opener, with False being closed, and True being open.
        /// https://reference.wolfram.com/language/ref/OpenerView.html
        ///</summary>
        corewolf::engine *OpenerView(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("OpenerView[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the morphological opening of image with respect to the structuring element ker.
        /// https://reference.wolfram.com/language/ref/Opening.html
        ///</summary>
        corewolf::engine *Opening(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Opening[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// opens a file to read data from, and returns an InputStream object.
        /// https://reference.wolfram.com/language/ref/OpenRead.html
        ///</summary>
        corewolf::engine *OpenRead(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OpenRead[" + arg0 + "]", name);
        }

        ///< summary>
        /// opens a file to write output to it, and returns an OutputStream object.
        /// https://reference.wolfram.com/language/ref/OpenWrite.html
        ///</summary>
        corewolf::engine *OpenWrite(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OpenWrite[" + arg0 + "]", name);
        }

        ///< summary>
        /// opens a new file in the default area for temporary files on your computer system.
        /// https://reference.wolfram.com/language/ref/OpenWrite.html
        ///</summary>
        corewolf::engine *OpenWrite(const std::string &name = "")
        {
            return this->execute("OpenWrite[]", name);
        }

        ///< summary>
        /// gives p[f][x,y].
        /// https://reference.wolfram.com/language/ref/Operate.html
        ///</summary>
        corewolf::engine *Operate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Operate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies p at level n in the head of expr.
        /// https://reference.wolfram.com/language/ref/Operate.html
        ///</summary>
        corewolf::engine *Operate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Operate[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of the function f of n arguments so that OperatorApplied[f,n][x1]…[xn] is equivalent to f[x1,…,xn].
        /// https://reference.wolfram.com/language/ref/OperatorApplied.html
        ///</summary>
        corewolf::engine *OperatorApplied(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("OperatorApplied[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of the function f of two arguments so that OperatorApplied[f][y][x] is equivalent to f[x,y].
        /// https://reference.wolfram.com/language/ref/OperatorApplied.html
        ///</summary>
        corewolf::engine *OperatorApplied(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OperatorApplied[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an operator form of the function f of n arguments so that OperatorApplied[f,{i1,…,in}][x1]…[xn] is equivalent to f[xi1,…,xin].
        /// https://reference.wolfram.com/language/ref/OperatorApplied.html
        ///</summary>
        corewolf::engine *OperatorApplied(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("OperatorApplied[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is a pattern const std::string &that represents an expression of the form patt, which, if omitted, should be replaced by the default value def.
        /// https://reference.wolfram.com/language/ref/Optional.html
        ///</summary>
        corewolf::engine *Optional(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Optional[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a grammar rules pattern const std::string &that represents 0 or 1 instances of patt.
        /// https://reference.wolfram.com/language/ref/OptionalElement.html
        ///</summary>
        corewolf::engine *OptionalElement(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OptionalElement[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses default if the element is not present.
        /// https://reference.wolfram.com/language/ref/OptionalElement.html
        ///</summary>
        corewolf::engine *OptionalElement(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("OptionalElement[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of default options assigned to a symbol.
        /// https://reference.wolfram.com/language/ref/Options.html
        ///</summary>
        corewolf::engine *Options(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Options[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the setting for the option name.
        /// https://reference.wolfram.com/language/ref/Options.html
        ///</summary>
        corewolf::engine *Options(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Options[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the settings for the options namei.
        /// https://reference.wolfram.com/language/ref/Options.html
        ///</summary>
        corewolf::engine *Options(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Options[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is a pattern const std::string &that represents a collection of options given as rules, where the values of the options can be accessed using OptionValue.
        /// https://reference.wolfram.com/language/ref/OptionsPattern.html
        ///</summary>
        corewolf::engine *OptionsPattern(const std::string &name = "")
        {
            return this->execute("OptionsPattern[]", name);
        }

        ///< summary>
        /// takes default option values from Options[f].
        /// https://reference.wolfram.com/language/ref/OptionsPattern.html
        ///</summary>
        corewolf::engine *OptionsPattern(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OptionsPattern[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses an explicit list of default option values.
        /// https://reference.wolfram.com/language/ref/OptionsPattern.html
        ///</summary>
        corewolf::engine *OptionsPattern(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("OptionsPattern[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of name in options matched by OptionsPattern.
        /// https://reference.wolfram.com/language/ref/OptionValue.html
        ///</summary>
        corewolf::engine *OptionValue(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OptionValue[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of name for options associated with the head f.
        /// https://reference.wolfram.com/language/ref/OptionValue.html
        ///</summary>
        corewolf::engine *OptionValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("OptionValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// extracts option values from the explicit list of rules opts.
        /// https://reference.wolfram.com/language/ref/OptionValue.html
        ///</summary>
        corewolf::engine *OptionValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("OptionValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// extracts several option values.
        /// https://reference.wolfram.com/language/ref/OptionValue.html
        ///</summary>
        corewolf::engine *OptionValue(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("OptionValue[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives 1 if expr1 is before expr2 in canonical order, and -1 if expr1 is after expr2 in canonical order. It gives 0 if expr1 is identical to expr2.
        /// https://reference.wolfram.com/language/ref/Order.html
        ///</summary>
        corewolf::engine *Order(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Order[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the k-order statistics distribution for n observations from the distribution dist.
        /// https://reference.wolfram.com/language/ref/OrderDistribution.html
        ///</summary>
        corewolf::engine *OrderDistribution(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("OrderDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the joint -order statistics distribution from n observations from the distribution dist.
        /// https://reference.wolfram.com/language/ref/OrderDistribution.html
        ///</summary>
        corewolf::engine *OrderDistribution(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("OrderDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents the order statistics distribution for multivariate distribution mdist.
        /// https://reference.wolfram.com/language/ref/OrderDistribution.html
        ///</summary>
        corewolf::engine *OrderDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("OrderDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if the ei are in canonical order, and False otherwise.
        /// https://reference.wolfram.com/language/ref/OrderedQ.html
        ///</summary>
        corewolf::engine *OrderedQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OrderedQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the ordering function p to determine whether each pair of elements ei, ei+1 is in order.
        /// https://reference.wolfram.com/language/ref/OrderedQ.html
        ///</summary>
        corewolf::engine *OrderedQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("OrderedQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the positions in list at which each successive element of Sort[list] appears.
        /// https://reference.wolfram.com/language/ref/Ordering.html
        ///</summary>
        corewolf::engine *Ordering(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Ordering[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the positions in list at which the first n elements of Sort[list] appear.
        /// https://reference.wolfram.com/language/ref/Ordering.html
        ///</summary>
        corewolf::engine *Ordering(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Ordering[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives positions in list of elements of Sort[list,p].
        /// https://reference.wolfram.com/language/ref/Ordering.html
        ///</summary>
        corewolf::engine *Ordering(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Ordering[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the positions in list at which each successive element of SortBy[list,f] appears.
        /// https://reference.wolfram.com/language/ref/OrderingBy.html
        ///</summary>
        corewolf::engine *OrderingBy(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("OrderingBy[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the positions in list at which the first n elements of SortBy[list,f] appear.
        /// https://reference.wolfram.com/language/ref/OrderingBy.html
        ///</summary>
        corewolf::engine *OrderingBy(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("OrderingBy[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives positions in list of elements of SortBy[list,f,p].
        /// https://reference.wolfram.com/language/ref/OrderingBy.html
        ///</summary>
        corewolf::engine *OrderingBy(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("OrderingBy[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a net layer that effectively applies Ordering to its input.
        /// https://reference.wolfram.com/language/ref/OrderingLayer.html
        ///</summary>
        corewolf::engine *OrderingLayer(const std::string &name = "")
        {
            return this->execute("OrderingLayer[]", name);
        }

        ///< summary>
        /// gives the first n elements in the ordering of its input.
        /// https://reference.wolfram.com/language/ref/OrderingLayer.html
        ///</summary>
        corewolf::engine *OrderingLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OrderingLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a pattern const std::string &that represents a sequence of arguments matching p1,p2,… in any order.
        /// https://reference.wolfram.com/language/ref/OrderlessPatternSequence.html
        ///</summary>
        corewolf::engine *OrderlessPatternSequence(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("OrderlessPatternSequence[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a set of ordered categories cati with order cat1<cat2<…<catn.
        /// https://reference.wolfram.com/language/ref/OrdinalScale.html
        ///</summary>
        corewolf::engine *OrdinalScale(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("OrdinalScale[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// associates the category cati with the numeric value vali.
        /// https://reference.wolfram.com/language/ref/OrdinalScale.html
        ///</summary>
        corewolf::engine *OrdinalScale(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("OrdinalScale[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// also associates the category cati with the numeric value vali.
        /// https://reference.wolfram.com/language/ref/OrdinalScale.html
        ///</summary>
        corewolf::engine *OrdinalScale(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("OrdinalScale[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays the category cati as the corresponding labi when used as a label in plots etc.
        /// https://reference.wolfram.com/language/ref/OrdinalScale.html
        ///</summary>
        corewolf::engine *OrdinalScale(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("OrdinalScale[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a stationary Ornstein–Uhlenbeck process with long-term mean μ, volatility , and mean reversion speed θ.
        /// https://reference.wolfram.com/language/ref/OrnsteinUhlenbeckProcess.html
        ///</summary>
        corewolf::engine *OrnsteinUhlenbeckProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("OrnsteinUhlenbeckProcess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an Ornstein–Uhlenbeck process with initial condition x0.
        /// https://reference.wolfram.com/language/ref/OrnsteinUhlenbeckProcess.html
        ///</summary>
        corewolf::engine *OrnsteinUhlenbeckProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("OrnsteinUhlenbeckProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives an orthonormal basis found by orthogonalizing the vectors vi.
        /// https://reference.wolfram.com/language/ref/Orthogonalize.html
        ///</summary>
        corewolf::engine *Orthogonalize(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Orthogonalize[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives an orthonormal basis found by orthogonalizing the elements ei with respect to the inner product function f.
        /// https://reference.wolfram.com/language/ref/Orthogonalize.html
        ///</summary>
        corewolf::engine *Orthogonalize(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Orthogonalize[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if m is an explicitly orthogonal matrix, and False otherwise.
        /// https://reference.wolfram.com/language/ref/OrthogonalMatrixQ.html
        ///</summary>
        corewolf::engine *OrthogonalMatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OrthogonalMatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a global const std::string &that is assigned to be the value produced on the n output line.
        /// https://reference.wolfram.com/language/ref/Out.html
        ///</summary>
        corewolf::engine *Out(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Out[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the last result generated.
        /// https://reference.wolfram.com/language/ref/Out.html
        ///</summary>
        corewolf::engine *Out(const std::string &name = "")
        {
            return this->execute("Out[]", name);
        }

        ///< summary>
        /// gives the generalized outer product of the listi, forming all possible combinations of the lowest‐level elements in each of them, and feeding them as arguments to f.
        /// https://reference.wolfram.com/language/ref/Outer.html
        ///</summary>
        corewolf::engine *Outer(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Outer[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// treats as separate elements only sublists at level n in the listi.
        /// https://reference.wolfram.com/language/ref/Outer.html
        ///</summary>
        corewolf::engine *Outer(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("Outer[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// treats as separate elements only sublists at level ni in the corresponding listi.
        /// https://reference.wolfram.com/language/ref/Outer.html
        ///</summary>
        corewolf::engine *Outer(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &arg6, const std::string &name = "")
        {
            return this->execute("Outer[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + ", " + arg6 + "]", name);
        }

        ///< summary>
        /// gives the outer polygon of the polygon poly.
        /// https://reference.wolfram.com/language/ref/OuterPolygon.html
        ///</summary>
        corewolf::engine *OuterPolygon(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OuterPolygon[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the outer polyhedron of the polyhedron poly.
        /// https://reference.wolfram.com/language/ref/OuterPolyhedron.html
        ///</summary>
        corewolf::engine *OuterPolyhedron(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OuterPolyhedron[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the output controllability matrix of the state-space model ssm.
        /// https://reference.wolfram.com/language/ref/OutputControllabilityMatrix.html
        ///</summary>
        corewolf::engine *OutputControllabilityMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OutputControllabilityMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if the state-space model ssm is output controllable, and False otherwise.
        /// https://reference.wolfram.com/language/ref/OutputControllableModelQ.html
        ///</summary>
        corewolf::engine *OutputControllableModelQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OutputControllableModelQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints as a two-dimensional representation of expr using only keyboard characters.
        /// https://reference.wolfram.com/language/ref/OutputForm.html
        ///</summary>
        corewolf::engine *OutputForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OutputForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a WSTP packet that contains in string the name assigned to the next output.
        /// https://reference.wolfram.com/language/ref/OutputNamePacket.html
        ///</summary>
        corewolf::engine *OutputNamePacket(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OutputNamePacket[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the numeric output response of systems model sys to the input u[t] for tmin≤t≤tmax.
        /// https://reference.wolfram.com/language/ref/OutputResponse.html
        ///</summary>
        corewolf::engine *OutputResponse(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("OutputResponse[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the output response of the discrete-time system sys to the input sequence u[i].
        /// https://reference.wolfram.com/language/ref/OutputResponse.html
        ///</summary>
        corewolf::engine *OutputResponse(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("OutputResponse[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the symbolic output response of system sys to the input u[t] as a function of time t.
        /// https://reference.wolfram.com/language/ref/OutputResponse.html
        ///</summary>
        corewolf::engine *OutputResponse(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("OutputResponse[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the output response for multiple inputs ui[t].
        /// https://reference.wolfram.com/language/ref/OutputResponse.html
        ///</summary>
        corewolf::engine *OutputResponse(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("OutputResponse[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is an const std::string &that represents an output stream for functions such as Write.
        /// https://reference.wolfram.com/language/ref/OutputStream.html
        ///</summary>
        corewolf::engine *OutputStream(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("OutputStream[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays with a bar over expr.
        /// https://reference.wolfram.com/language/ref/OverBar.html
        ///</summary>
        corewolf::engine *OverBar(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OverBar[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays with a dot over expr.
        /// https://reference.wolfram.com/language/ref/OverDot.html
        ///</summary>
        corewolf::engine *OverDot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OverDot[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a number too large to represent explicitly on your computer system.
        /// https://reference.wolfram.com/language/ref/Overflow.html
        ///</summary>
        corewolf::engine *Overflow(const std::string &name = "")
        {
            return this->execute("Overflow[]", name);
        }

        ///< summary>
        /// displays with a hat over expr.
        /// https://reference.wolfram.com/language/ref/OverHat.html
        ///</summary>
        corewolf::engine *OverHat(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OverHat[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as an overlay of all the expri.
        /// https://reference.wolfram.com/language/ref/Overlay.html
        ///</summary>
        corewolf::engine *Overlay(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Overlay[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// displays as an overlay of expri, exprj, ….
        /// https://reference.wolfram.com/language/ref/Overlay.html
        ///</summary>
        corewolf::engine *Overlay(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Overlay[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// allows selections to be made and controls to be clicked in exprs.
        /// https://reference.wolfram.com/language/ref/Overlay.html
        ///</summary>
        corewolf::engine *Overlay(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Overlay[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the result of overlaying o onto a background video or image background.
        /// https://reference.wolfram.com/language/ref/OverlayVideo.html
        ///</summary>
        corewolf::engine *OverlayVideo(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("OverlayVideo[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the result of overlaying o1, o2, ….
        /// https://reference.wolfram.com/language/ref/OverlayVideo.html
        ///</summary>
        corewolf::engine *OverlayVideo(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("OverlayVideo[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is an const std::string &that formats as .
        /// https://reference.wolfram.com/language/ref/Overscript.html
        ///</summary>
        corewolf::engine *Overscript(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Overscript[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is the low‐level box representation for  in notebook expressions.
        /// https://reference.wolfram.com/language/ref/OverscriptBox.html
        ///</summary>
        corewolf::engine *OverscriptBox(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("OverscriptBox[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays with a tilde over expr.
        /// https://reference.wolfram.com/language/ref/OverTilde.html
        ///</summary>
        corewolf::engine *OverTilde(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OverTilde[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays with a right vector over expr.
        /// https://reference.wolfram.com/language/ref/OverVector.html
        ///</summary>
        corewolf::engine *OverVector(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OverVector[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives Owen's T function .
        /// https://reference.wolfram.com/language/ref/OwenT.html
        ///</summary>
        corewolf::engine *OwenT(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("OwenT[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of transformation rules corresponding to all ownvalues defined for the symbol x.
        /// https://reference.wolfram.com/language/ref/OwnValues.html
        ///</summary>
        corewolf::engine *OwnValues(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("OwnValues[" + arg0 + "]", name);
        }

        ///< summary>
        /// rescans all the installed paclets to rebuild the internal cache of paclet data.
        /// https://reference.wolfram.com/language/ref/PacletDataRebuild.html
        ///</summary>
        corewolf::engine *PacletDataRebuild(const std::string &name = "")
        {
            return this->execute("PacletDataRebuild[]", name);
        }

        ///< summary>
        /// makes paclets in dir visible in the current session.
        /// https://reference.wolfram.com/language/ref/PacletDirectoryLoad.html
        ///</summary>
        corewolf::engine *PacletDirectoryLoad(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PacletDirectoryLoad[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes paclets in all the diri visible in the current session.
        /// https://reference.wolfram.com/language/ref/PacletDirectoryLoad.html
        ///</summary>
        corewolf::engine *PacletDirectoryLoad(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PacletDirectoryLoad[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes paclets in dir no longer visible in the current session.
        /// https://reference.wolfram.com/language/ref/PacletDirectoryUnload.html
        ///</summary>
        corewolf::engine *PacletDirectoryUnload(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PacletDirectoryUnload[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes paclets in all the diri no longer visible in the current session.
        /// https://reference.wolfram.com/language/ref/PacletDirectoryUnload.html
        ///</summary>
        corewolf::engine *PacletDirectoryUnload(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PacletDirectoryUnload[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// disables an installed paclet.
        /// https://reference.wolfram.com/language/ref/PacletDisable.html
        ///</summary>
        corewolf::engine *PacletDisable(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PacletDisable[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of installed paclets that match "name".
        /// https://reference.wolfram.com/language/ref/PacletFind.html
        ///</summary>
        corewolf::engine *PacletFind(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PacletFind[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of installed paclets that match "name" and criteria given by the propivali.
        /// https://reference.wolfram.com/language/ref/PacletFind.html
        ///</summary>
        corewolf::engine *PacletFind(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("PacletFind[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives a list of paclets that match "name" available on known paclet sites.
        /// https://reference.wolfram.com/language/ref/PacletFindRemote.html
        ///</summary>
        corewolf::engine *PacletFindRemote(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PacletFindRemote[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of paclets that match "name" and criteria given by the propivali available on known paclet sites.
        /// https://reference.wolfram.com/language/ref/PacletFindRemote.html
        ///</summary>
        corewolf::engine *PacletFindRemote(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("PacletFindRemote[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// installs or updates paclet.
        /// https://reference.wolfram.com/language/ref/PacletInstall.html
        ///</summary>
        corewolf::engine *PacletInstall(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PacletInstall[" + arg0 + "]", name);
        }

        ///< summary>
        /// asynchronously installs or updates paclet.
        /// https://reference.wolfram.com/language/ref/PacletInstallSubmit.html
        ///</summary>
        corewolf::engine *PacletInstallSubmit(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PacletInstallSubmit[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if paclet1 has a higher version number than paclet2, and False otherwise.
        /// https://reference.wolfram.com/language/ref/PacletNewerQ.html
        ///</summary>
        corewolf::engine *PacletNewerQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PacletNewerQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a paclet on the local machine or on a remote paclet site.
        /// https://reference.wolfram.com/language/ref/PacletObject.html
        ///</summary>
        corewolf::engine *PacletObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PacletObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a site from which paclets can be automatically downloaded.
        /// https://reference.wolfram.com/language/ref/PacletSiteObject.html
        ///</summary>
        corewolf::engine *PacletSiteObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PacletSiteObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// registers url as a known paclet site.
        /// https://reference.wolfram.com/language/ref/PacletSiteRegister.html
        ///</summary>
        corewolf::engine *PacletSiteRegister(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PacletSiteRegister[" + arg0 + "]", name);
        }

        ///< summary>
        /// registers url as a known paclet site with name.
        /// https://reference.wolfram.com/language/ref/PacletSiteRegister.html
        ///</summary>
        corewolf::engine *PacletSiteRegister(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PacletSiteRegister[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of all paclet sites known to your system.
        /// https://reference.wolfram.com/language/ref/PacletSites.html
        ///</summary>
        corewolf::engine *PacletSites(const std::string &name = "")
        {
            return this->execute("PacletSites[]", name);
        }

        ///< summary>
        /// removes url from the list of registered paclet sites.
        /// https://reference.wolfram.com/language/ref/PacletSiteUnregister.html
        ///</summary>
        corewolf::engine *PacletSiteUnregister(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PacletSiteUnregister[" + arg0 + "]", name);
        }

        ///< summary>
        /// acquires and caches current information about the available paclets on the given paclet site.
        /// https://reference.wolfram.com/language/ref/PacletSiteUpdate.html
        ///</summary>
        corewolf::engine *PacletSiteUpdate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PacletSiteUpdate[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the symbol named "sym" in the primary context of paclet.
        /// https://reference.wolfram.com/language/ref/PacletSymbol.html
        ///</summary>
        corewolf::engine *PacletSymbol(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PacletSymbol[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// wraps the head h around the symbol before returning it.
        /// https://reference.wolfram.com/language/ref/PacletSymbol.html
        ///</summary>
        corewolf::engine *PacletSymbol(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PacletSymbol[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uninstalls a paclet.
        /// https://reference.wolfram.com/language/ref/PacletUninstall.html
        ///</summary>
        corewolf::engine *PacletUninstall(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PacletUninstall[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints with all numbers in expr padded to leave room for a total of n digits.
        /// https://reference.wolfram.com/language/ref/PaddedForm.html
        ///</summary>
        corewolf::engine *PaddedForm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PaddedForm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// prints with approximate real numbers having exactly f digits to the right of the decimal point.
        /// https://reference.wolfram.com/language/ref/PaddedForm.html
        ///</summary>
        corewolf::engine *PaddedForm(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PaddedForm[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a net layer that pads an input array with mi elements at the beginning and ni elements at the end at level i of the array.
        /// https://reference.wolfram.com/language/ref/PaddingLayer.html
        ///</summary>
        corewolf::engine *PaddingLayer(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PaddingLayer[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Padé approximant to expr about the point x=x0, with numerator order m and denominator order n.
        /// https://reference.wolfram.com/language/ref/PadeApproximant.html
        ///</summary>
        corewolf::engine *PadeApproximant(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("PadeApproximant[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// gives the diagonal Padé approximant to expr about the point x=x0 of order n.
        /// https://reference.wolfram.com/language/ref/PadeApproximant.html
        ///</summary>
        corewolf::engine *PadeApproximant(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PadeApproximant[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a list of length n by padding list with zeros on the left.
        /// https://reference.wolfram.com/language/ref/PadLeft.html
        ///</summary>
        corewolf::engine *PadLeft(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PadLeft[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// pads by repeating the element x.
        /// https://reference.wolfram.com/language/ref/PadLeft.html
        ///</summary>
        corewolf::engine *PadLeft(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PadLeft[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// pads by cyclically repeating the elements xi.
        /// https://reference.wolfram.com/language/ref/PadLeft.html
        ///</summary>
        corewolf::engine *PadLeft(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("PadLeft[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// leaves a margin of m elements of padding on the right.
        /// https://reference.wolfram.com/language/ref/PadLeft.html
        ///</summary>
        corewolf::engine *PadLeft(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("PadLeft[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// makes a nested list with length ni at level i.
        /// https://reference.wolfram.com/language/ref/PadLeft.html
        ///</summary>
        corewolf::engine *PadLeft(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PadLeft[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// pads a ragged array list with zeros to make it full.
        /// https://reference.wolfram.com/language/ref/PadLeft.html
        ///</summary>
        corewolf::engine *PadLeft(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PadLeft[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes a list of length n by padding list with zeros on the right.
        /// https://reference.wolfram.com/language/ref/PadRight.html
        ///</summary>
        corewolf::engine *PadRight(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PadRight[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// pads by repeating the element x.
        /// https://reference.wolfram.com/language/ref/PadRight.html
        ///</summary>
        corewolf::engine *PadRight(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PadRight[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// pads by cyclically repeating the elements xi.
        /// https://reference.wolfram.com/language/ref/PadRight.html
        ///</summary>
        corewolf::engine *PadRight(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("PadRight[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// leaves a margin of m elements of padding on the left.
        /// https://reference.wolfram.com/language/ref/PadRight.html
        ///</summary>
        corewolf::engine *PadRight(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("PadRight[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// makes a nested list with length ni at level i.
        /// https://reference.wolfram.com/language/ref/PadRight.html
        ///</summary>
        corewolf::engine *PadRight(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PadRight[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// pads a ragged array list with zeros to make it full.
        /// https://reference.wolfram.com/language/ref/PadRight.html
        ///</summary>
        corewolf::engine *PadRight(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PadRight[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of page-rank centralities for the vertices in the graph g and weight α.
        /// https://reference.wolfram.com/language/ref/PageRankCentrality.html
        ///</summary>
        corewolf::engine *PageRankCentrality(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PageRankCentrality[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of page-rank centralities, using weight α and initial centralities β.
        /// https://reference.wolfram.com/language/ref/PageRankCentrality.html
        ///</summary>
        corewolf::engine *PageRankCentrality(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PageRankCentrality[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/PageRankCentrality.html
        ///</summary>
        corewolf::engine *PageRankCentrality(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PageRankCentrality[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// estimates the pair correlation function  for point data pdata at radius r.
        /// https://reference.wolfram.com/language/ref/PairCorrelationG.html
        ///</summary>
        corewolf::engine *PairCorrelationG(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PairCorrelationG[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates the function  that can be applied repeatedly to different radii r.
        /// https://reference.wolfram.com/language/ref/PairCorrelationG.html
        ///</summary>
        corewolf::engine *PairCorrelationG(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PairCorrelationG[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes a paired bar chart with bar lengths y1,  y2, … and z1, z2, …, respectively.
        /// https://reference.wolfram.com/language/ref/PairedBarChart.html
        ///</summary>
        corewolf::engine *PairedBarChart(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PairedBarChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots a paired histogram of the values xi and yi.
        /// https://reference.wolfram.com/language/ref/PairedHistogram.html
        ///</summary>
        corewolf::engine *PairedHistogram(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PairedHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots a paired histogram with bin width specification bspec.
        /// https://reference.wolfram.com/language/ref/PairedHistogram.html
        ///</summary>
        corewolf::engine *PairedHistogram(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PairedHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// plots a paired histogram with bin heights computed according to the specification hspec.
        /// https://reference.wolfram.com/language/ref/PairedHistogram.html
        ///</summary>
        corewolf::engine *PairedHistogram(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("PairedHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// plots a paired smooth histogram of the values xi and yi.
        /// https://reference.wolfram.com/language/ref/PairedSmoothHistogram.html
        ///</summary>
        corewolf::engine *PairedSmoothHistogram(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PairedSmoothHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots a paired smooth histogram with estimator specification espec.
        /// https://reference.wolfram.com/language/ref/PairedSmoothHistogram.html
        ///</summary>
        corewolf::engine *PairedSmoothHistogram(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PairedSmoothHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// plots a paired smooth histogram with distribution function dfun.
        /// https://reference.wolfram.com/language/ref/PairedSmoothHistogram.html
        ///</summary>
        corewolf::engine *PairedSmoothHistogram(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("PairedSmoothHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// tests whether the mean of data is zero.
        /// https://reference.wolfram.com/language/ref/PairedTTest.html
        ///</summary>
        corewolf::engine *PairedTTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PairedTTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the mean of data1– data2 is zero.
        /// https://reference.wolfram.com/language/ref/PairedTTest.html
        ///</summary>
        corewolf::engine *PairedTTest(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PairedTTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// tests a location measure against μ0.
        /// https://reference.wolfram.com/language/ref/PairedTTest.html
        ///</summary>
        corewolf::engine *PairedTTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PairedTTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/PairedTTest.html
        ///</summary>
        corewolf::engine *PairedTTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PairedTTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether the mean of the data is zero.
        /// https://reference.wolfram.com/language/ref/PairedZTest.html
        ///</summary>
        corewolf::engine *PairedZTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PairedZTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the means of data1 and data2 are equal.
        /// https://reference.wolfram.com/language/ref/PairedZTest.html
        ///</summary>
        corewolf::engine *PairedZTest(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PairedZTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// tests for zero or equal means assuming a population variance σ.
        /// https://reference.wolfram.com/language/ref/PairedZTest.html
        ///</summary>
        corewolf::engine *PairedZTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PairedZTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests the mean against μ0.
        /// https://reference.wolfram.com/language/ref/PairedZTest.html
        ///</summary>
        corewolf::engine *PairedZTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PairedZTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/PairedZTest.html
        ///</summary>
        corewolf::engine *PairedZTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("PairedZTest[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a palette notebook that can be manipulated by the Wolfram System front end.
        /// https://reference.wolfram.com/language/ref/PaletteNotebook.html
        ///</summary>
        corewolf::engine *PaletteNotebook(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PaletteNotebook[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns True if the given list is identical to Reverse[list], and False otherwise.
        /// https://reference.wolfram.com/language/ref/PalindromeQ.html
        ///</summary>
        corewolf::engine *PalindromeQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PalindromeQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as a pane containing expr.
        /// https://reference.wolfram.com/language/ref/Pane.html
        ///</summary>
        corewolf::engine *Pane(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Pane[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes the pane be w printer's points wide, linewrapping the contents if necessary.
        /// https://reference.wolfram.com/language/ref/Pane.html
        ///</summary>
        corewolf::engine *Pane(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Pane[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// makes the pane be w points wide and h points high, shrinking the contents if necessary.
        /// https://reference.wolfram.com/language/ref/Pane.html
        ///</summary>
        corewolf::engine *Pane(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Pane[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// displays as a panel containing expr.
        /// https://reference.wolfram.com/language/ref/Panel.html
        ///</summary>
        corewolf::engine *Panel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Panel[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the panel the specified title.
        /// https://reference.wolfram.com/language/ref/Panel.html
        ///</summary>
        corewolf::engine *Panel(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Panel[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// places title at a position specified by pos.
        /// https://reference.wolfram.com/language/ref/Panel.html
        ///</summary>
        corewolf::engine *Panel(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Panel[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// places titlei at position posi.
        /// https://reference.wolfram.com/language/ref/Panel.html
        ///</summary>
        corewolf::engine *Panel(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Panel[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// displays an empty panel.
        /// https://reference.wolfram.com/language/ref/Panel.html
        ///</summary>
        corewolf::engine *Panel(const std::string &name = "")
        {
            return this->execute("Panel[]", name);
        }

        ///< summary>
        /// represents an const std::string &that displays as a pane containing the expri for which vali is equal to x.
        /// https://reference.wolfram.com/language/ref/PaneSelector.html
        ///</summary>
        corewolf::engine *PaneSelector(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PaneSelector[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays default if x is none of the vali.
        /// https://reference.wolfram.com/language/ref/PaneSelector.html
        ///</summary>
        corewolf::engine *PaneSelector(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PaneSelector[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the parabolic cylinder function .
        /// https://reference.wolfram.com/language/ref/ParabolicCylinderD.html
        ///</summary>
        corewolf::engine *ParabolicCylinderD(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParabolicCylinderD[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates in parallel a list of length n, with elements f[i], evaluated.
        /// https://reference.wolfram.com/language/ref/ParallelArray.html
        ///</summary>
        corewolf::engine *ParallelArray(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParallelArray[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates in parallel an  array of nested lists, with elements f[i1,i2,…].
        /// https://reference.wolfram.com/language/ref/ParallelArray.html
        ///</summary>
        corewolf::engine *ParallelArray(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ParallelArray[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates in parallel a list using the index origins ri (default 1).
        /// https://reference.wolfram.com/language/ref/ParallelArray.html
        ///</summary>
        corewolf::engine *ParallelArray(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ParallelArray[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses head h, rather than List, for each level of the array.
        /// https://reference.wolfram.com/language/ref/ParallelArray.html
        ///</summary>
        corewolf::engine *ParallelArray(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ParallelArray[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// generates a parallel axis plot for the points {yi1,…,yin} using equally spaced axes.
        /// https://reference.wolfram.com/language/ref/ParallelAxisPlot.html
        ///</summary>
        corewolf::engine *ParallelAxisPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ParallelAxisPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// plots several sets of points.
        /// https://reference.wolfram.com/language/ref/ParallelAxisPlot.html
        ///</summary>
        corewolf::engine *ParallelAxisPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ParallelAxisPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates f[h[e1,e2,…]] in parallel by distributing parts of the computation to all parallel kernels and combining the partial results with comb.
        /// https://reference.wolfram.com/language/ref/ParallelCombine.html
        ///</summary>
        corewolf::engine *ParallelCombine(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ParallelCombine[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is equivalent to ParallelCombine[f,h[e1,e2,…],h] if h has attribute Flat, and ParallelCombine[f,h[e1,e2,…],Join] otherwise.
        /// https://reference.wolfram.com/language/ref/ParallelCombine.html
        ///</summary>
        corewolf::engine *ParallelCombine(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParallelCombine[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates expr in parallel imax times.
        /// https://reference.wolfram.com/language/ref/ParallelDo.html
        ///</summary>
        corewolf::engine *ParallelDo(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ParallelDo[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses the successive values i1, i2, ….
        /// https://reference.wolfram.com/language/ref/ParallelDo.html
        ///</summary>
        corewolf::engine *ParallelDo(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ParallelDo[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates expr looping in parallel over different values of j, etc. for each i.
        /// https://reference.wolfram.com/language/ref/ParallelDo.html
        ///</summary>
        corewolf::engine *ParallelDo(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ParallelDo[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a parallelepiped with origin p and directions vi.
        /// https://reference.wolfram.com/language/ref/Parallelepiped.html
        ///</summary>
        corewolf::engine *Parallelepiped(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Parallelepiped[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates the expression expr on all available parallel kernels and returns the list of results obtained.
        /// https://reference.wolfram.com/language/ref/ParallelEvaluate.html
        ///</summary>
        corewolf::engine *ParallelEvaluate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ParallelEvaluate[" + arg0 + "]", name);
        }

        ///< summary>
        /// evaluates expr on the parallel kernel specified.
        /// https://reference.wolfram.com/language/ref/ParallelEvaluate.html
        ///</summary>
        corewolf::engine *ParallelEvaluate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParallelEvaluate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates expr on the parallel kernels keri.
        /// https://reference.wolfram.com/language/ref/ParallelEvaluate.html
        ///</summary>
        corewolf::engine *ParallelEvaluate(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ParallelEvaluate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// wraps the head h around the results before returning them.
        /// https://reference.wolfram.com/language/ref/ParallelEvaluate.html
        ///</summary>
        corewolf::engine *ParallelEvaluate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ParallelEvaluate[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// evaluates expr using automatic parallelization.
        /// https://reference.wolfram.com/language/ref/Parallelize.html
        ///</summary>
        corewolf::engine *Parallelize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Parallelize[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies f in parallel to each element on the first level in expr.
        /// https://reference.wolfram.com/language/ref/ParallelMap.html
        ///</summary>
        corewolf::engine *ParallelMap(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParallelMap[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f in parallel to parts of expr specified by levelspec.
        /// https://reference.wolfram.com/language/ref/ParallelMap.html
        ///</summary>
        corewolf::engine *ParallelMap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ParallelMap[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// evaluates Needs["context`"] on all available parallel kernels.
        /// https://reference.wolfram.com/language/ref/ParallelNeeds.html
        ///</summary>
        corewolf::engine *ParallelNeeds(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ParallelNeeds[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a parallelogram with origin p and directions v1 and v2.
        /// https://reference.wolfram.com/language/ref/Parallelogram.html
        ///</summary>
        corewolf::engine *Parallelogram(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Parallelogram[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates the product  in parallel.
        /// https://reference.wolfram.com/language/ref/ParallelProduct.html
        ///</summary>
        corewolf::engine *ParallelProduct(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ParallelProduct[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses successive values , , ….
        /// https://reference.wolfram.com/language/ref/ParallelProduct.html
        ///</summary>
        corewolf::engine *ParallelProduct(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ParallelProduct[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates the multiple product  in parallel.
        /// https://reference.wolfram.com/language/ref/ParallelProduct.html
        ///</summary>
        corewolf::engine *ParallelProduct(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ParallelProduct[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// submits expr for evaluation on the next available parallel kernel and returns an EvaluationObject expression representing the submitted evaluation.
        /// https://reference.wolfram.com/language/ref/ParallelSubmit.html
        ///</summary>
        corewolf::engine *ParallelSubmit(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ParallelSubmit[" + arg0 + "]", name);
        }

        ///< summary>
        /// builds a closure for the variables given before submitting expr.
        /// https://reference.wolfram.com/language/ref/ParallelSubmit.html
        ///</summary>
        corewolf::engine *ParallelSubmit(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParallelSubmit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates in parallel the sum .
        /// https://reference.wolfram.com/language/ref/ParallelSum.html
        ///</summary>
        corewolf::engine *ParallelSum(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ParallelSum[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses successive values , , ….
        /// https://reference.wolfram.com/language/ref/ParallelSum.html
        ///</summary>
        corewolf::engine *ParallelSum(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ParallelSum[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates in parallel the multiple sum .
        /// https://reference.wolfram.com/language/ref/ParallelSum.html
        ///</summary>
        corewolf::engine *ParallelSum(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ParallelSum[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// generates in parallel a list of imax copies of expr.
        /// https://reference.wolfram.com/language/ref/ParallelTable.html
        ///</summary>
        corewolf::engine *ParallelTable(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ParallelTable[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses the successive values i1, i2, ….
        /// https://reference.wolfram.com/language/ref/ParallelTable.html
        ///</summary>
        corewolf::engine *ParallelTable(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ParallelTable[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives a nested list. The list associated with i is outermost.
        /// https://reference.wolfram.com/language/ref/ParallelTable.html
        ///</summary>
        corewolf::engine *ParallelTable(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ParallelTable[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// evaluates f[argi] in parallel, returning the first result received.
        /// https://reference.wolfram.com/language/ref/ParallelTry.html
        ///</summary>
        corewolf::engine *ParallelTry(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ParallelTry[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns a list of the first k results.
        /// https://reference.wolfram.com/language/ref/ParallelTry.html
        ///</summary>
        corewolf::engine *ParallelTry(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ParallelTry[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a parameter mixture distribution where the parameter θ is distributed according to the weight distribution wdist.
        /// https://reference.wolfram.com/language/ref/ParameterMixtureDistribution.html
        ///</summary>
        corewolf::engine *ParameterMixtureDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParameterMixtureDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a parameter mixture distribution where the parameter θ1 has weight distribution wdist1, θ2 has weight distribution wdist2, etc.
        /// https://reference.wolfram.com/language/ref/ParameterMixtureDistribution.html
        ///</summary>
        corewolf::engine *ParameterMixtureDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ParameterMixtureDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a ParametricFunction const std::string &that finds values of variables vars that minimize the convex objective function f subject to convex constraints cons with parameters pars.
        /// https://reference.wolfram.com/language/ref/ParametricConvexOptimization.html
        ///</summary>
        corewolf::engine *ParametricConvexOptimization(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ParametricConvexOptimization[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// specifies what solution property "prop" should be returned by the ParametricFunction object.
        /// https://reference.wolfram.com/language/ref/ParametricConvexOptimization.html
        ///</summary>
        corewolf::engine *ParametricConvexOptimization(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParametricConvexOptimization[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a function that computes a solution when evaluated with numerical values for the parameters pars.
        /// https://reference.wolfram.com/language/ref/ParametricFunction.html
        ///</summary>
        corewolf::engine *ParametricFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParametricFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds a numerical solution to the ordinary differential equations eqns for the function u with the independent variable x in the range xmin to xmax with parameters pars.
        /// https://reference.wolfram.com/language/ref/ParametricNDSolve.html
        ///</summary>
        corewolf::engine *ParametricNDSolve(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ParametricNDSolve[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// solves the partial differential equations eqns over a rectangular region.
        /// https://reference.wolfram.com/language/ref/ParametricNDSolve.html
        ///</summary>
        corewolf::engine *ParametricNDSolve(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("ParametricNDSolve[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// solves the partial differential equations eqns over the region Ω.
        /// https://reference.wolfram.com/language/ref/ParametricNDSolve.html
        ///</summary>
        corewolf::engine *ParametricNDSolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ParametricNDSolve[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// solves the time-dependent partial differential equations eqns over the region Ω.
        /// https://reference.wolfram.com/language/ref/ParametricNDSolve.html
        ///</summary>
        corewolf::engine *ParametricNDSolve(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("ParametricNDSolve[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// solves for the functions ui.
        /// https://reference.wolfram.com/language/ref/ParametricNDSolve.html
        ///</summary>
        corewolf::engine *ParametricNDSolve(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ParametricNDSolve[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of expr with functions determined by a numerical solution to the ordinary differential equations eqns with the independent variable x in the range xmin to xmax with parameters pars.
        /// https://reference.wolfram.com/language/ref/ParametricNDSolveValue.html
        ///</summary>
        corewolf::engine *ParametricNDSolveValue(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ParametricNDSolveValue[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// solves the partial differential equations eqns over a rectangular region.
        /// https://reference.wolfram.com/language/ref/ParametricNDSolveValue.html
        ///</summary>
        corewolf::engine *ParametricNDSolveValue(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("ParametricNDSolveValue[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// solves the partial differential equations eqns over the region Ω.
        /// https://reference.wolfram.com/language/ref/ParametricNDSolveValue.html
        ///</summary>
        corewolf::engine *ParametricNDSolveValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ParametricNDSolveValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// solves the time-dependent partial differential equations eqns over the region Ω.
        /// https://reference.wolfram.com/language/ref/ParametricNDSolveValue.html
        ///</summary>
        corewolf::engine *ParametricNDSolveValue(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("ParametricNDSolveValue[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// generates a parametric plot of a curve with x and y coordinates fx and fy as a function of u.
        /// https://reference.wolfram.com/language/ref/ParametricPlot.html
        ///</summary>
        corewolf::engine *ParametricPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ParametricPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots several parametric curves.
        /// https://reference.wolfram.com/language/ref/ParametricPlot.html
        ///</summary>
        corewolf::engine *ParametricPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ParametricPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// plots several parametric regions.
        /// https://reference.wolfram.com/language/ref/ParametricPlot.html
        ///</summary>
        corewolf::engine *ParametricPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("ParametricPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// plots the curve {fx,fy} with features defined by the symbolic wrapper w.
        /// https://reference.wolfram.com/language/ref/ParametricPlot.html
        ///</summary>
        corewolf::engine *ParametricPlot(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ParametricPlot[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// takes parameters {u,v} to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/ParametricPlot.html
        ///</summary>
        corewolf::engine *ParametricPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParametricPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// produces a three-dimensional space curve parametrized by a variable u which runs from umin to umax.
        /// https://reference.wolfram.com/language/ref/ParametricPlot3D.html
        ///</summary>
        corewolf::engine *ParametricPlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ParametricPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// produces a three-dimensional surface parametrized by u and v.
        /// https://reference.wolfram.com/language/ref/ParametricPlot3D.html
        ///</summary>
        corewolf::engine *ParametricPlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ParametricPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// plots several objects together.
        /// https://reference.wolfram.com/language/ref/ParametricPlot3D.html
        ///</summary>
        corewolf::engine *ParametricPlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ParametricPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// takes parameters {u,v} to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/ParametricPlot3D.html
        ///</summary>
        corewolf::engine *ParametricPlot3D(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParametricPlot3D[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a net layer that computes a leaky ReLU activation with a slope that can be learned.
        /// https://reference.wolfram.com/language/ref/ParametricRampLayer.html
        ///</summary>
        corewolf::engine *ParametricRampLayer(const std::string &name = "")
        {
            return this->execute("ParametricRampLayer[]", name);
        }

        ///< summary>
        /// specifies the levels on which each dimension has a specific slope.
        /// https://reference.wolfram.com/language/ref/ParametricRampLayer.html
        ///</summary>
        corewolf::engine *ParametricRampLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ParametricRampLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a region in  given by the points {f1,…,fn} for parameters ui∈.
        /// https://reference.wolfram.com/language/ref/ParametricRegion.html
        ///</summary>
        corewolf::engine *ParametricRegion(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ParametricRegion[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// constrains parameters to satisfy the condition cond.
        /// https://reference.wolfram.com/language/ref/ParametricRegion.html
        ///</summary>
        corewolf::engine *ParametricRegion(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParametricRegion[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the BoxObject that contains obj.
        /// https://reference.wolfram.com/language/ref/ParentBox.html
        ///</summary>
        corewolf::engine *ParentBox(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ParentBox[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the CellObject that contains obj.
        /// https://reference.wolfram.com/language/ref/ParentCell.html
        ///</summary>
        corewolf::engine *ParentCell(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ParentCell[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the parent of the current working directory.
        /// https://reference.wolfram.com/language/ref/ParentDirectory.html
        ///</summary>
        corewolf::engine *ParentDirectory(const std::string &name = "")
        {
            return this->execute("ParentDirectory[]", name);
        }

        ///< summary>
        /// gives the parent of the directory dir.
        /// https://reference.wolfram.com/language/ref/ParentDirectory.html
        ///</summary>
        corewolf::engine *ParentDirectory(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ParentDirectory[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the directory n levels up from dir.
        /// https://reference.wolfram.com/language/ref/ParentDirectory.html
        ///</summary>
        corewolf::engine *ParentDirectory(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParentDirectory[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the NotebookObject that contains obj.
        /// https://reference.wolfram.com/language/ref/ParentNotebook.html
        ///</summary>
        corewolf::engine *ParentNotebook(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ParentNotebook[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Pareto distribution with minimum value parameter k and shape parameter α.
        /// https://reference.wolfram.com/language/ref/ParetoDistribution.html
        ///</summary>
        corewolf::engine *ParetoDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParetoDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Pareto type II distribution with location parameter μ.
        /// https://reference.wolfram.com/language/ref/ParetoDistribution.html
        ///</summary>
        corewolf::engine *ParetoDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ParetoDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Pareto type IV distribution with shape parameter γ.
        /// https://reference.wolfram.com/language/ref/ParetoDistribution.html
        ///</summary>
        corewolf::engine *ParetoDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ParetoDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives a Pareto–Pickands distribution with location parameter μ, scale parameter σ and shape parameter ξ.
        /// https://reference.wolfram.com/language/ref/ParetoPickandsDistribution.html
        ///</summary>
        corewolf::engine *ParetoPickandsDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ParetoPickandsDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the standard Pareto–Pickands distribution with zero location and unit scale parameters.
        /// https://reference.wolfram.com/language/ref/ParetoPickandsDistribution.html
        ///</summary>
        corewolf::engine *ParetoPickandsDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ParetoPickandsDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the park entity.
        /// https://reference.wolfram.com/language/ref/ParkData.html
        ///</summary>
        corewolf::engine *ParkData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParkData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified park entities.
        /// https://reference.wolfram.com/language/ref/ParkData.html
        ///</summary>
        corewolf::engine *ParkData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParkData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/ParkData.html
        ///</summary>
        corewolf::engine *ParkData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ParkData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the i part of expr.
        /// https://reference.wolfram.com/language/ref/Part.html
        ///</summary>
        corewolf::engine *Part(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Part[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// counts from the end.
        /// https://reference.wolfram.com/language/ref/Part.html
        ///</summary>
        corewolf::engine *Part(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Part[" + arg0 + "]", name);
        }

        ///< summary>
        /// is equivalent to expr[[i]][[j]]….
        /// https://reference.wolfram.com/language/ref/Part.html
        ///</summary>
        corewolf::engine *Part(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Part[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// estimates the partial correlation function at lags hspec from data.
        /// https://reference.wolfram.com/language/ref/PartialCorrelationFunction.html
        ///</summary>
        corewolf::engine *PartialCorrelationFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PartialCorrelationFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the particle accelerator entity.
        /// https://reference.wolfram.com/language/ref/ParticleAcceleratorData.html
        ///</summary>
        corewolf::engine *ParticleAcceleratorData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParticleAcceleratorData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified particle accelerator entities.
        /// https://reference.wolfram.com/language/ref/ParticleAcceleratorData.html
        ///</summary>
        corewolf::engine *ParticleAcceleratorData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParticleAcceleratorData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/ParticleAcceleratorData.html
        ///</summary>
        corewolf::engine *ParticleAcceleratorData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ParticleAcceleratorData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the specified property for a subatomic particle or family of particles with the specified name.
        /// https://reference.wolfram.com/language/ref/ParticleData.html
        ///</summary>
        corewolf::engine *ParticleData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParticleData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified property for a version of the particle with charge q.
        /// https://reference.wolfram.com/language/ref/ParticleData.html
        ///</summary>
        corewolf::engine *ParticleData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ParticleData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// partitions list into nonoverlapping sublists of length n.
        /// https://reference.wolfram.com/language/ref/Partition.html
        ///</summary>
        corewolf::engine *Partition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Partition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates sublists with offset d.
        /// https://reference.wolfram.com/language/ref/Partition.html
        ///</summary>
        corewolf::engine *Partition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Partition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// partitions a nested list into blocks of size ××….
        /// https://reference.wolfram.com/language/ref/Partition.html
        ///</summary>
        corewolf::engine *Partition(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Partition[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses offset di at level i in list.
        /// https://reference.wolfram.com/language/ref/Partition.html
        ///</summary>
        corewolf::engine *Partition(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Partition[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// specifies that the first element of list should appear at position kL in the first sublist, and the last element of list should appear at or after position kR in the last sublist. If additional elements are needed, Partition fills them in by treating list as cyclic.
        /// https://reference.wolfram.com/language/ref/Partition.html
        ///</summary>
        corewolf::engine *Partition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("Partition[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// pads if necessary by repeating the element x.
        /// https://reference.wolfram.com/language/ref/Partition.html
        ///</summary>
        corewolf::engine *Partition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("Partition[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// pads if necessary by cyclically repeating the elements xi.
        /// https://reference.wolfram.com/language/ref/Partition.html
        ///</summary>
        corewolf::engine *Partition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::vector<std::string> &arg4, const std::string &name = "")
        {
            return this->execute("Partition[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + "]", name);
        }

        ///< summary>
        /// gives the number p(n) of unrestricted partitions of the integer n.
        /// https://reference.wolfram.com/language/ref/PartitionsP.html
        ///</summary>
        corewolf::engine *PartitionsP(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PartitionsP[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number q(n) of partitions of the integer n into distinct parts.
        /// https://reference.wolfram.com/language/ref/PartitionsQ.html
        ///</summary>
        corewolf::engine *PartitionsQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PartitionsQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a net layer that gives the i part of the input.
        /// https://reference.wolfram.com/language/ref/PartLayer.html
        ///</summary>
        corewolf::engine *PartLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PartLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// takes part speci at level i in the input.
        /// https://reference.wolfram.com/language/ref/PartLayer.html
        ///</summary>
        corewolf::engine *PartLayer(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PartLayer[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns the possible parts of speech for the specified word.
        /// https://reference.wolfram.com/language/ref/PartOfSpeech.html
        ///</summary>
        corewolf::engine *PartOfSpeech(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PartOfSpeech[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Parzen window function of x.
        /// https://reference.wolfram.com/language/ref/ParzenWindow.html
        ///</summary>
        corewolf::engine *ParzenWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ParzenWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Pascal distribution with parameters n and p.
        /// https://reference.wolfram.com/language/ref/PascalDistribution.html
        ///</summary>
        corewolf::engine *PascalDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PascalDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// pastes expr at the current insertion point in the input notebook.
        /// https://reference.wolfram.com/language/ref/Paste.html
        ///</summary>
        corewolf::engine *Paste(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Paste[" + arg0 + "]", name);
        }

        ///< summary>
        /// pastes expr to the specified notebook.
        /// https://reference.wolfram.com/language/ref/Paste.html
        ///</summary>
        corewolf::engine *Paste(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Paste[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// pastes the contents of the system clipboard in the input notebook.
        /// https://reference.wolfram.com/language/ref/Paste.html
        ///</summary>
        corewolf::engine *Paste(const std::string &name = "")
        {
            return this->execute("Paste[]", name);
        }

        ///< summary>
        /// represents a button that pastes expr whenever it is pressed.
        /// https://reference.wolfram.com/language/ref/PasteButton.html
        ///</summary>
        corewolf::engine *PasteButton(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PasteButton[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays with label on the button.
        /// https://reference.wolfram.com/language/ref/PasteButton.html
        ///</summary>
        corewolf::engine *PasteButton(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PasteButton[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields a path with vertices vi and edges between vi and vi+1 .
        /// https://reference.wolfram.com/language/ref/PathGraph.html
        ///</summary>
        corewolf::engine *PathGraph(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PathGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// yields a path with vertices vi and edges ej.
        /// https://reference.wolfram.com/language/ref/PathGraph.html
        ///</summary>
        corewolf::engine *PathGraph(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PathGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is a path and False otherwise.
        /// https://reference.wolfram.com/language/ref/PathGraphQ.html
        ///</summary>
        corewolf::engine *PathGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PathGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the pattern const std::string &obj, assigned the name sym.
        /// https://reference.wolfram.com/language/ref/Pattern.html
        ///</summary>
        corewolf::engine *Pattern(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Pattern[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a two-dimensional graphics directive specifying that obj should be used to fill faces of polygons and other filled graphics objects.
        /// https://reference.wolfram.com/language/ref/PatternFilling.html
        ///</summary>
        corewolf::engine *PatternFilling(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PatternFilling[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies the size of the const std::string &obj.
        /// https://reference.wolfram.com/language/ref/PatternFilling.html
        ///</summary>
        corewolf::engine *PatternFilling(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PatternFilling[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// moves the const std::string &obj by the offset {dx,dy}.
        /// https://reference.wolfram.com/language/ref/PatternFilling.html
        ///</summary>
        corewolf::engine *PatternFilling(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("PatternFilling[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a templated reaction between molecule patterns in reactants and products.
        /// https://reference.wolfram.com/language/ref/PatternReaction.html
        ///</summary>
        corewolf::engine *PatternReaction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PatternReaction[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a reaction with a specified mapping between atoms in reactants and products.
        /// https://reference.wolfram.com/language/ref/PatternReaction.html
        ///</summary>
        corewolf::engine *PatternReaction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PatternReaction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a pattern const std::string &that represents a sequence of arguments matching p1, p2, ….
        /// https://reference.wolfram.com/language/ref/PatternSequence.html
        ///</summary>
        corewolf::engine *PatternSequence(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PatternSequence[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the k Pauli spin matrix .
        /// https://reference.wolfram.com/language/ref/PauliMatrix.html
        ///</summary>
        corewolf::engine *PauliMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PauliMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Paul wavelet of order 4.
        /// https://reference.wolfram.com/language/ref/PaulWavelet.html
        ///</summary>
        corewolf::engine *PaulWavelet(const std::string &name = "")
        {
            return this->execute("PaulWavelet[]", name);
        }

        ///< summary>
        /// represents a Paul wavelet of order n.
        /// https://reference.wolfram.com/language/ref/PaulWavelet.html
        ///</summary>
        corewolf::engine *PaulWavelet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PaulWavelet[" + arg0 + "]", name);
        }

        ///< summary>
        /// pauses for at least n seconds.
        /// https://reference.wolfram.com/language/ref/Pause.html
        ///</summary>
        corewolf::engine *Pause(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Pause[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the probability density function for the distribution dist evaluated at x.
        /// https://reference.wolfram.com/language/ref/PDF.html
        ///</summary>
        corewolf::engine *PDF(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PDF[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the multivariate probability density function for a distribution dist evaluated at {x1,x2,…}.
        /// https://reference.wolfram.com/language/ref/PDF.html
        ///</summary>
        corewolf::engine *PDF(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PDF[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the PDF as a pure function.
        /// https://reference.wolfram.com/language/ref/PDF.html
        ///</summary>
        corewolf::engine *PDF(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PDF[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a binary list in which 1s correspond to peak positions in list.
        /// https://reference.wolfram.com/language/ref/PeakDetect.html
        ///</summary>
        corewolf::engine *PeakDetect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PeakDetect[" + arg0 + "]", name);
        }

        ///< summary>
        /// detects peaks that survive Gaussian blurring up to scale σ.
        /// https://reference.wolfram.com/language/ref/PeakDetect.html
        ///</summary>
        corewolf::engine *PeakDetect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PeakDetect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// detects peaks with minimum sharpness s.
        /// https://reference.wolfram.com/language/ref/PeakDetect.html
        ///</summary>
        corewolf::engine *PeakDetect(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PeakDetect[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// detects only peaks with values greater than t.
        /// https://reference.wolfram.com/language/ref/PeakDetect.html
        ///</summary>
        corewolf::engine *PeakDetect(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("PeakDetect[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// uses different scales for thresholding sharpness and value.
        /// https://reference.wolfram.com/language/ref/PeakDetect.html
        ///</summary>
        corewolf::engine *PeakDetect(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("PeakDetect[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// gives the line segments representing the n-step Peano curve.
        /// https://reference.wolfram.com/language/ref/PeanoCurve.html
        ///</summary>
        corewolf::engine *PeanoCurve(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PeanoCurve[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether data is normally distributed using the Pearson  test.
        /// https://reference.wolfram.com/language/ref/PearsonChiSquareTest.html
        ///</summary>
        corewolf::engine *PearsonChiSquareTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PearsonChiSquareTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether data is distributed according to dist using the Pearson  test.
        /// https://reference.wolfram.com/language/ref/PearsonChiSquareTest.html
        ///</summary>
        corewolf::engine *PearsonChiSquareTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PearsonChiSquareTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/PearsonChiSquareTest.html
        ///</summary>
        corewolf::engine *PearsonChiSquareTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PearsonChiSquareTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether the vectors v1 and v2 are linearly independent.
        /// https://reference.wolfram.com/language/ref/PearsonCorrelationTest.html
        ///</summary>
        corewolf::engine *PearsonCorrelationTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PearsonCorrelationTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a distribution of the Pearson family with parameters a1, a0, b2, b1, and b0.
        /// https://reference.wolfram.com/language/ref/PearsonDistribution.html
        ///</summary>
        corewolf::engine *PearsonDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("PearsonDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// represents a Pearson distribution of given type.
        /// https://reference.wolfram.com/language/ref/PearsonDistribution.html
        ///</summary>
        corewolf::engine *PearsonDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("PearsonDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// represents a Penttinen point process with constant intensity μ, interaction parameter γ and interaction radius rp in .
        /// https://reference.wolfram.com/language/ref/PenttinenPointProcess.html
        ///</summary>
        corewolf::engine *PenttinenPointProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("PenttinenPointProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// prints with numbers in expr given as percentages.
        /// https://reference.wolfram.com/language/ref/PercentForm.html
        ///</summary>
        corewolf::engine *PercentForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PercentForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints with approximate real numbers in expr given as percentages to n-digit precision.
        /// https://reference.wolfram.com/language/ref/PercentForm.html
        ///</summary>
        corewolf::engine *PercentForm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PercentForm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the n perfect number.
        /// https://reference.wolfram.com/language/ref/PerfectNumber.html
        ///</summary>
        corewolf::engine *PerfectNumber(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PerfectNumber[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if n is a perfect number, and False otherwise.
        /// https://reference.wolfram.com/language/ref/PerfectNumberQ.html
        ///</summary>
        corewolf::engine *PerfectNumberQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PerfectNumberQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the perimeter of the two-dimensional region reg.
        /// https://reference.wolfram.com/language/ref/Perimeter.html
        ///</summary>
        corewolf::engine *Perimeter(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Perimeter[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the perimeter of the parametrized region whose Cartesian coordinates xi are functions of s and t.
        /// https://reference.wolfram.com/language/ref/Perimeter.html
        ///</summary>
        corewolf::engine *Perimeter(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Perimeter[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// interprets the xi as coordinates in the specified coordinate chart.
        /// https://reference.wolfram.com/language/ref/Perimeter.html
        ///</summary>
        corewolf::engine *Perimeter(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Perimeter[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a periodic boundary condition  for all xtarget on the boundary of the region given to NDSolve where pred is True.
        /// https://reference.wolfram.com/language/ref/PeriodicBoundaryCondition.html
        ///</summary>
        corewolf::engine *PeriodicBoundaryCondition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PeriodicBoundaryCondition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// plots the squared magnitude of the discrete Fourier transform (power spectrum) of list.
        /// https://reference.wolfram.com/language/ref/Periodogram.html
        ///</summary>
        corewolf::engine *Periodogram(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Periodogram[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots the mean of power spectra of non-overlapping partitions of length n.
        /// https://reference.wolfram.com/language/ref/Periodogram.html
        ///</summary>
        corewolf::engine *Periodogram(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Periodogram[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses partitions with offset d.
        /// https://reference.wolfram.com/language/ref/Periodogram.html
        ///</summary>
        corewolf::engine *Periodogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Periodogram[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies a smoothing window wfun to each partition.
        /// https://reference.wolfram.com/language/ref/Periodogram.html
        ///</summary>
        corewolf::engine *Periodogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Periodogram[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// pads partitions with zeros to length m prior to the computation of the transform.
        /// https://reference.wolfram.com/language/ref/Periodogram.html
        ///</summary>
        corewolf::engine *Periodogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("Periodogram[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// plots power spectra of several lists.
        /// https://reference.wolfram.com/language/ref/Periodogram.html
        ///</summary>
        corewolf::engine *Periodogram(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("Periodogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// plots the power spectra of all audioi.
        /// https://reference.wolfram.com/language/ref/Periodogram.html
        ///</summary>
        corewolf::engine *Periodogram(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Periodogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the squared magnitude of the discrete Fourier transform (power spectrum) of list.
        /// https://reference.wolfram.com/language/ref/PeriodogramArray.html
        ///</summary>
        corewolf::engine *PeriodogramArray(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PeriodogramArray[" + arg0 + "]", name);
        }

        ///< summary>
        /// averages the power spectra of non-overlapping partitions of length n.
        /// https://reference.wolfram.com/language/ref/PeriodogramArray.html
        ///</summary>
        corewolf::engine *PeriodogramArray(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PeriodogramArray[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses partitions with offset d.
        /// https://reference.wolfram.com/language/ref/PeriodogramArray.html
        ///</summary>
        corewolf::engine *PeriodogramArray(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PeriodogramArray[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies a smoothing window wfun to each partition.
        /// https://reference.wolfram.com/language/ref/PeriodogramArray.html
        ///</summary>
        corewolf::engine *PeriodogramArray(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("PeriodogramArray[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// pads partitions with zeros to length m prior to the computation of the transform.
        /// https://reference.wolfram.com/language/ref/PeriodogramArray.html
        ///</summary>
        corewolf::engine *PeriodogramArray(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("PeriodogramArray[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// represents a permissions group with the specified name, owned by the current user.
        /// https://reference.wolfram.com/language/ref/PermissionsGroup.html
        ///</summary>
        corewolf::engine *PermissionsGroup(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PermissionsGroup[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a permissions group owned by the specified user.
        /// https://reference.wolfram.com/language/ref/PermissionsGroup.html
        ///</summary>
        corewolf::engine *PermissionsGroup(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PermissionsGroup[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns True if user is a member of the permissions group group, and False otherwise.
        /// https://reference.wolfram.com/language/ref/PermissionsGroupMemberQ.html
        ///</summary>
        corewolf::engine *PermissionsGroupMemberQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PermissionsGroupMemberQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of permissions groups belonging to the current user.
        /// https://reference.wolfram.com/language/ref/PermissionsGroups.html
        ///</summary>
        corewolf::engine *PermissionsGroups(const std::string &name = "")
        {
            return this->execute("PermissionsGroups[]", name);
        }

        ///< summary>
        /// represents a permissions key that can be used to authorize access to cloud resources.
        /// https://reference.wolfram.com/language/ref/PermissionsKey.html
        ///</summary>
        corewolf::engine *PermissionsKey(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PermissionsKey[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of all valid permissions keys created by the currently authenticated user.
        /// https://reference.wolfram.com/language/ref/PermissionsKeys.html
        ///</summary>
        corewolf::engine *PermissionsKeys(const std::string &name = "")
        {
            return this->execute("PermissionsKeys[]", name);
        }

        ///< summary>
        /// gives a disjoint cycle representation of permutation perm.
        /// https://reference.wolfram.com/language/ref/PermutationCycles.html
        ///</summary>
        corewolf::engine *PermutationCycles(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PermutationCycles[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if expr is a permutation in disjoint cyclic form, and False otherwise.
        /// https://reference.wolfram.com/language/ref/PermutationCyclesQ.html
        ///</summary>
        corewolf::engine *PermutationCyclesQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PermutationCyclesQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the group generated by multiplication of the permutations perm1,…,permn.
        /// https://reference.wolfram.com/language/ref/PermutationGroup.html
        ///</summary>
        corewolf::engine *PermutationGroup(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PermutationGroup[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns the number of integers moved by the permutation perm.
        /// https://reference.wolfram.com/language/ref/PermutationLength.html
        ///</summary>
        corewolf::engine *PermutationLength(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PermutationLength[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a permutation list representation of permutation perm.
        /// https://reference.wolfram.com/language/ref/PermutationList.html
        ///</summary>
        corewolf::engine *PermutationList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PermutationList[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a permutation list of length len.
        /// https://reference.wolfram.com/language/ref/PermutationList.html
        ///</summary>
        corewolf::engine *PermutationList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PermutationList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns True if expr is a valid permutation list and False otherwise.
        /// https://reference.wolfram.com/language/ref/PermutationListQ.html
        ///</summary>
        corewolf::engine *PermutationListQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PermutationListQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the permutation matrix given by permutation vector permv as a structured array.
        /// https://reference.wolfram.com/language/ref/PermutationMatrix.html
        ///</summary>
        corewolf::engine *PermutationMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PermutationMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the largest integer moved by the permutation perm.
        /// https://reference.wolfram.com/language/ref/PermutationMax.html
        ///</summary>
        corewolf::engine *PermutationMax(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PermutationMax[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the smallest integer moved by the permutation perm.
        /// https://reference.wolfram.com/language/ref/PermutationMin.html
        ///</summary>
        corewolf::engine *PermutationMin(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PermutationMin[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the order of permutation perm.
        /// https://reference.wolfram.com/language/ref/PermutationOrder.html
        ///</summary>
        corewolf::engine *PermutationOrder(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PermutationOrder[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the n permutation power of the permutation perm.
        /// https://reference.wolfram.com/language/ref/PermutationPower.html
        ///</summary>
        corewolf::engine *PermutationPower(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PermutationPower[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the product of permutations a, b, c.
        /// https://reference.wolfram.com/language/ref/PermutationProduct.html
        ///</summary>
        corewolf::engine *PermutationProduct(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PermutationProduct[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// replaces each part in expr by its image under the permutation perm.
        /// https://reference.wolfram.com/language/ref/PermutationReplace.html
        ///</summary>
        corewolf::engine *PermutationReplace(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PermutationReplace[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a list of all possible permutations of the elements in list.
        /// https://reference.wolfram.com/language/ref/Permutations.html
        ///</summary>
        corewolf::engine *Permutations(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Permutations[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives all permutations containing at most n elements.
        /// https://reference.wolfram.com/language/ref/Permutations.html
        ///</summary>
        corewolf::engine *Permutations(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Permutations[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives all permutations containing exactly n elements.
        /// https://reference.wolfram.com/language/ref/Permutations.html
        ///</summary>
        corewolf::engine *Permutations(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Permutations[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns the support of the permutation perm.
        /// https://reference.wolfram.com/language/ref/PermutationSupport.html
        ///</summary>
        corewolf::engine *PermutationSupport(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PermutationSupport[" + arg0 + "]", name);
        }

        ///< summary>
        /// permutes the positions of the elements of expr according to the permutation perm.
        /// https://reference.wolfram.com/language/ref/Permute.html
        ///</summary>
        corewolf::engine *Permute(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Permute[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies a Perona–Malik diffusion filter to image.
        /// https://reference.wolfram.com/language/ref/PeronaMalikFilter.html
        ///</summary>
        corewolf::engine *PeronaMalikFilter(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PeronaMalikFilter[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies the amount of diffusion time t to be applied.
        /// https://reference.wolfram.com/language/ref/PeronaMalikFilter.html
        ///</summary>
        corewolf::engine *PeronaMalikFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PeronaMalikFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses a conductance parameter k.
        /// https://reference.wolfram.com/language/ref/PeronaMalikFilter.html
        ///</summary>
        corewolf::engine *PeronaMalikFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PeronaMalikFilter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies a Gaussian regularization of width σ to the image gradient in the conductance function.
        /// https://reference.wolfram.com/language/ref/PeronaMalikFilter.html
        ///</summary>
        corewolf::engine *PeronaMalikFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("PeronaMalikFilter[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the perpendicular bisector of the line segment connecting p1 and p2.
        /// https://reference.wolfram.com/language/ref/PerpendicularBisector.html
        ///</summary>
        corewolf::engine *PerpendicularBisector(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PerpendicularBisector[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the perpendicular bisector of a line segment.
        /// https://reference.wolfram.com/language/ref/PerpendicularBisector.html
        ///</summary>
        corewolf::engine *PerpendicularBisector(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PerpendicularBisector[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a persistence location of the given type.
        /// https://reference.wolfram.com/language/ref/PersistenceLocation.html
        ///</summary>
        corewolf::engine *PersistenceLocation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PersistenceLocation[" + arg0 + "]", name);
        }

        ///< summary>
        /// includes the base address for a location type that allows multiple locations.
        /// https://reference.wolfram.com/language/ref/PersistenceLocation.html
        ///</summary>
        corewolf::engine *PersistenceLocation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PersistenceLocation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a persistent const std::string &stored at persistence location loc.
        /// https://reference.wolfram.com/language/ref/PersistentObject.html
        ///</summary>
        corewolf::engine *PersistentObject(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PersistentObject[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives all persistent objects in all locations in $PersistencePath.
        /// https://reference.wolfram.com/language/ref/PersistentObjects.html
        ///</summary>
        corewolf::engine *PersistentObjects(const std::string &name = "")
        {
            return this->execute("PersistentObjects[]", name);
        }

        ///< summary>
        /// gives all persistent objects whose names match the string pattern patt.
        /// https://reference.wolfram.com/language/ref/PersistentObjects.html
        ///</summary>
        corewolf::engine *PersistentObjects(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PersistentObjects[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives all matching persistent objects in persistence location loc.
        /// https://reference.wolfram.com/language/ref/PersistentObjects.html
        ///</summary>
        corewolf::engine *PersistentObjects(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PersistentObjects[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives all matching persistent objects in all the loci.
        /// https://reference.wolfram.com/language/ref/PersistentObjects.html
        ///</summary>
        corewolf::engine *PersistentObjects(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PersistentObjects[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents the persistent symbol associated with the key "name".
        /// https://reference.wolfram.com/language/ref/PersistentSymbol.html
        ///</summary>
        corewolf::engine *PersistentSymbol(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PersistentSymbol[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the persistent symbol associated with name stored in persistence location loc.
        /// https://reference.wolfram.com/language/ref/PersistentSymbol.html
        ///</summary>
        corewolf::engine *PersistentSymbol(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PersistentSymbol[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the persistent symbol associated with name at the first of the locations loci at which it occurs.
        /// https://reference.wolfram.com/language/ref/PersistentSymbol.html
        ///</summary>
        corewolf::engine *PersistentSymbol(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PersistentSymbol[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the person entity.
        /// https://reference.wolfram.com/language/ref/PersonData.html
        ///</summary>
        corewolf::engine *PersonData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PersonData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified person entities.
        /// https://reference.wolfram.com/language/ref/PersonData.html
        ///</summary>
        corewolf::engine *PersonData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PersonData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/PersonData.html
        ///</summary>
        corewolf::engine *PersonData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PersonData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a PERT distribution with range min to max and mode at c.
        /// https://reference.wolfram.com/language/ref/PERTDistribution.html
        ///</summary>
        corewolf::engine *PERTDistribution(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PERTDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a modified PERT distribution with shape parameter λ.
        /// https://reference.wolfram.com/language/ref/PERTDistribution.html
        ///</summary>
        corewolf::engine *PERTDistribution(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PERTDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the generalized Petersen graph .
        /// https://reference.wolfram.com/language/ref/PetersenGraph.html
        ///</summary>
        corewolf::engine *PetersenGraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PetersenGraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the phase margins of the linear time-invariant system lsys.
        /// https://reference.wolfram.com/language/ref/PhaseMargins.html
        ///</summary>
        corewolf::engine *PhaseMargins(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PhaseMargins[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a three‐dimensional graphics directive that specifies that faces of polygons and other filled graphics objects are to be drawn to reflect as a smooth surface using a normal‐vector interpolation shading.
        /// https://reference.wolfram.com/language/ref/PhongShading.html
        ///</summary>
        corewolf::engine *PhongShading(const std::string &name = "")
        {
            return this->execute("PhongShading[]", name);
        }

        ///< summary>
        /// uses the attenuation factor d for the diffuse light.
        /// https://reference.wolfram.com/language/ref/PhongShading.html
        ///</summary>
        corewolf::engine *PhongShading(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PhongShading[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the attenuation factor s for the specular light.
        /// https://reference.wolfram.com/language/ref/PhongShading.html
        ///</summary>
        corewolf::engine *PhongShading(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PhongShading[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the attenuation factor a for the ambient light.
        /// https://reference.wolfram.com/language/ref/PhongShading.html
        ///</summary>
        corewolf::engine *PhongShading(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PhongShading[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the physical system entity.
        /// https://reference.wolfram.com/language/ref/PhysicalSystemData.html
        ///</summary>
        corewolf::engine *PhysicalSystemData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PhysicalSystemData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified physical system entities.
        /// https://reference.wolfram.com/language/ref/PhysicalSystemData.html
        ///</summary>
        corewolf::engine *PhysicalSystemData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PhysicalSystemData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/PhysicalSystemData.html
        ///</summary>
        corewolf::engine *PhysicalSystemData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PhysicalSystemData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// picks out those elements of list for which the corresponding element of sel is True.
        /// https://reference.wolfram.com/language/ref/Pick.html
        ///</summary>
        corewolf::engine *Pick(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Pick[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// picks out those elements of list for which the corresponding element of sel matches patt.
        /// https://reference.wolfram.com/language/ref/Pick.html
        ///</summary>
        corewolf::engine *Pick(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Pick[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a feedback PID controller for the system sys.
        /// https://reference.wolfram.com/language/ref/PIDTune.html
        ///</summary>
        corewolf::engine *PIDTune(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PIDTune[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a controller of architecture "carch" ("P", "PI", "PID", etc).
        /// https://reference.wolfram.com/language/ref/PIDTune.html
        ///</summary>
        corewolf::engine *PIDTune(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PIDTune[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a controller using the tuning rule "trule".
        /// https://reference.wolfram.com/language/ref/PIDTune.html
        ///</summary>
        corewolf::engine *PIDTune(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PIDTune[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns the value for the property "prop".
        /// https://reference.wolfram.com/language/ref/PIDTune.html
        ///</summary>
        corewolf::engine *PIDTune(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PIDTune[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a piecewise function with values vali in the regions defined by the conditions condi.
        /// https://reference.wolfram.com/language/ref/Piecewise.html
        ///</summary>
        corewolf::engine *Piecewise(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Piecewise[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses default value val if none of the condi apply. The default for val is 0.
        /// https://reference.wolfram.com/language/ref/Piecewise.html
        ///</summary>
        corewolf::engine *Piecewise(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Piecewise[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// expands nested piecewise functions in expr to give a single piecewise function.
        /// https://reference.wolfram.com/language/ref/PiecewiseExpand.html
        ///</summary>
        corewolf::engine *PiecewiseExpand(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PiecewiseExpand[" + arg0 + "]", name);
        }

        ///< summary>
        /// expands piecewise functions using assumptions.
        /// https://reference.wolfram.com/language/ref/PiecewiseExpand.html
        ///</summary>
        corewolf::engine *PiecewiseExpand(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PiecewiseExpand[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// does the expansion over the domain dom.
        /// https://reference.wolfram.com/language/ref/PiecewiseExpand.html
        ///</summary>
        corewolf::engine *PiecewiseExpand(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PiecewiseExpand[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// makes a pie chart with sector angle proportional to y1, y2, ….
        /// https://reference.wolfram.com/language/ref/PieChart.html
        ///</summary>
        corewolf::engine *PieChart(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PieChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a 3D pie chart with sector angle proportional to y1, y2, … .
        /// https://reference.wolfram.com/language/ref/PieChart3D.html
        ///</summary>
        corewolf::engine *PieChart3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PieChart3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives Pillai's trace for the matrices m1 and m2.
        /// https://reference.wolfram.com/language/ref/PillaiTrace.html
        ///</summary>
        corewolf::engine *PillaiTrace(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PillaiTrace[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether the matrices m1 and m2 are independent.
        /// https://reference.wolfram.com/language/ref/PillaiTraceTest.html
        ///</summary>
        corewolf::engine *PillaiTraceTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PillaiTraceTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the round-trip ping time for the specified network host.
        /// https://reference.wolfram.com/language/ref/PingTime.html
        ///</summary>
        corewolf::engine *PingTime(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PingTime[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of times for n successive pings.
        /// https://reference.wolfram.com/language/ref/PingTime.html
        ///</summary>
        corewolf::engine *PingTime(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PingTime[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// recognizes the main pitch in audio, returning it as a TimeSeries object.
        /// https://reference.wolfram.com/language/ref/PitchRecognize.html
        ///</summary>
        corewolf::engine *PitchRecognize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PitchRecognize[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the main pitch processed according to the specified spec.
        /// https://reference.wolfram.com/language/ref/PitchRecognize.html
        ///</summary>
        corewolf::engine *PitchRecognize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PitchRecognize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the pixel value of image at position pos.
        /// https://reference.wolfram.com/language/ref/PixelValue.html
        ///</summary>
        corewolf::engine *PixelValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PixelValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the pixel value converted to the specified type.
        /// https://reference.wolfram.com/language/ref/PixelValue.html
        ///</summary>
        corewolf::engine *PixelValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PixelValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns a list of pixel positions in image that exactly match the value val.
        /// https://reference.wolfram.com/language/ref/PixelValuePositions.html
        ///</summary>
        corewolf::engine *PixelValuePositions(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PixelValuePositions[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns all pixel positions that have values within a distance d from val.
        /// https://reference.wolfram.com/language/ref/PixelValuePositions.html
        ///</summary>
        corewolf::engine *PixelValuePositions(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PixelValuePositions[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an expression expr placed at relative position pos in a chart or other display.
        /// https://reference.wolfram.com/language/ref/Placed.html
        ///</summary>
        corewolf::engine *Placed(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Placed[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// places each of the ei at a relative position specified by pos.
        /// https://reference.wolfram.com/language/ref/Placed.html
        ///</summary>
        corewolf::engine *Placed(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Placed[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies the function f to each of the ei before displaying it.
        /// https://reference.wolfram.com/language/ref/Placed.html
        ///</summary>
        corewolf::engine *Placed(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Placed[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a placeholder labeled with name that indicates a place to type.
        /// https://reference.wolfram.com/language/ref/Placeholder.html
        ///</summary>
        corewolf::engine *Placeholder(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Placeholder[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the empty placeholder .
        /// https://reference.wolfram.com/language/ref/Placeholder.html
        ///</summary>
        corewolf::engine *Placeholder(const std::string &name = "")
        {
            return this->execute("Placeholder[]", name);
        }

        ///< summary>
        /// represents a net layer whose operation is undefined.
        /// https://reference.wolfram.com/language/ref/PlaceholderLayer.html
        ///</summary>
        corewolf::engine *PlaceholderLayer(const std::string &name = "")
        {
            return this->execute("PlaceholderLayer[]", name);
        }

        ///< summary>
        /// indicates a tag and information given by the association assoc.
        /// https://reference.wolfram.com/language/ref/PlaceholderLayer.html
        ///</summary>
        corewolf::engine *PlaceholderLayer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PlaceholderLayer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the angle between the half‐lines from p through q1 and q2.
        /// https://reference.wolfram.com/language/ref/PlanarAngle.html
        ///</summary>
        corewolf::engine *PlanarAngle(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PlanarAngle[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the angle at p formed by the triangle with vertex points p, q1 and q2.
        /// https://reference.wolfram.com/language/ref/PlanarAngle.html
        ///</summary>
        corewolf::engine *PlanarAngle(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PlanarAngle[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the angle specified by "spec".
        /// https://reference.wolfram.com/language/ref/PlanarAngle.html
        ///</summary>
        corewolf::engine *PlanarAngle(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PlanarAngle[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of faces of the planar graph g.
        /// https://reference.wolfram.com/language/ref/PlanarFaceList.html
        ///</summary>
        corewolf::engine *PlanarFaceList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PlanarFaceList[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields a planar graph with edges ej.
        /// https://reference.wolfram.com/language/ref/PlanarGraph.html
        ///</summary>
        corewolf::engine *PlanarGraph(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PlanarGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// yields a planar graph with vertices vi and edges ej.
        /// https://reference.wolfram.com/language/ref/PlanarGraph.html
        ///</summary>
        corewolf::engine *PlanarGraph(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PlanarGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if g is a planar graph and False otherwise.
        /// https://reference.wolfram.com/language/ref/PlanarGraphQ.html
        ///</summary>
        corewolf::engine *PlanarGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PlanarGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the spectral radiance for the specified temperature and wavelength λ.
        /// https://reference.wolfram.com/language/ref/PlanckRadiationLaw.html
        ///</summary>
        corewolf::engine *PlanckRadiationLaw(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PlanckRadiationLaw[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the integrated result of the spectral radiance over the wavelength range λ1 to λ2.
        /// https://reference.wolfram.com/language/ref/PlanckRadiationLaw.html
        ///</summary>
        corewolf::engine *PlanckRadiationLaw(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PlanckRadiationLaw[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the plane curve entity.
        /// https://reference.wolfram.com/language/ref/PlaneCurveData.html
        ///</summary>
        corewolf::engine *PlaneCurveData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PlaneCurveData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified plane curve entities.
        /// https://reference.wolfram.com/language/ref/PlaneCurveData.html
        ///</summary>
        corewolf::engine *PlaneCurveData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PlaneCurveData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/PlaneCurveData.html
        ///</summary>
        corewolf::engine *PlaneCurveData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PlaneCurveData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the moon entity of a planet or minor planet.
        /// https://reference.wolfram.com/language/ref/PlanetaryMoonData.html
        ///</summary>
        corewolf::engine *PlanetaryMoonData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PlanetaryMoonData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified moon entities.
        /// https://reference.wolfram.com/language/ref/PlanetaryMoonData.html
        ///</summary>
        corewolf::engine *PlanetaryMoonData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PlanetaryMoonData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the property.
        /// https://reference.wolfram.com/language/ref/PlanetaryMoonData.html
        ///</summary>
        corewolf::engine *PlanetaryMoonData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PlanetaryMoonData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the planet entity.
        /// https://reference.wolfram.com/language/ref/PlanetData.html
        ///</summary>
        corewolf::engine *PlanetData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PlanetData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified planet entities.
        /// https://reference.wolfram.com/language/ref/PlanetData.html
        ///</summary>
        corewolf::engine *PlanetData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PlanetData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the property.
        /// https://reference.wolfram.com/language/ref/PlanetData.html
        ///</summary>
        corewolf::engine *PlanetData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PlanetData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the plant entity.
        /// https://reference.wolfram.com/language/ref/PlantData.html
        ///</summary>
        corewolf::engine *PlantData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PlantData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified plant entities.
        /// https://reference.wolfram.com/language/ref/PlantData.html
        ///</summary>
        corewolf::engine *PlantData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PlantData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the property.
        /// https://reference.wolfram.com/language/ref/PlantData.html
        ///</summary>
        corewolf::engine *PlantData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PlantData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// creates an const std::string &that plays as a sound whose amplitude is given by f as a function of time t in seconds between tmin and tmax.
        /// https://reference.wolfram.com/language/ref/Play.html
        ///</summary>
        corewolf::engine *Play(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Play[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a plot of f as a function of x from xmin to xmax.
        /// https://reference.wolfram.com/language/ref/Plot.html
        ///</summary>
        corewolf::engine *Plot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Plot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots several functions fi.
        /// https://reference.wolfram.com/language/ref/Plot.html
        ///</summary>
        corewolf::engine *Plot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Plot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots fi with features defined by the symbolic wrapper w.
        /// https://reference.wolfram.com/language/ref/Plot.html
        ///</summary>
        corewolf::engine *Plot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Plot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// takes the variable x to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/Plot.html
        ///</summary>
        corewolf::engine *Plot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Plot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a three-dimensional plot of f as a function of x and y.
        /// https://reference.wolfram.com/language/ref/Plot3D.html
        ///</summary>
        corewolf::engine *Plot3D(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Plot3D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// plots several functions.
        /// https://reference.wolfram.com/language/ref/Plot3D.html
        ///</summary>
        corewolf::engine *Plot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Plot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// plots fi with features defined by the symbolic wrapper w.
        /// https://reference.wolfram.com/language/ref/Plot3D.html
        ///</summary>
        corewolf::engine *Plot3D(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Plot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// takes variables {x,y} to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/Plot3D.html
        ///</summary>
        corewolf::engine *Plot3D(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Plot3D[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the plural form of the English word "noun".
        /// https://reference.wolfram.com/language/ref/Pluralize.html
        ///</summary>
        corewolf::engine *Pluralize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Pluralize[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the inflected form of "noun" for n instances.
        /// https://reference.wolfram.com/language/ref/Pluralize.html
        ///</summary>
        corewolf::engine *Pluralize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Pluralize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// inflects using the specified forms.
        /// https://reference.wolfram.com/language/ref/Pluralize.html
        ///</summary>
        corewolf::engine *Pluralize(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Pluralize[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as ±x.
        /// https://reference.wolfram.com/language/ref/PlusMinus.html
        ///</summary>
        corewolf::engine *PlusMinus(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PlusMinus[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as x±y±….
        /// https://reference.wolfram.com/language/ref/PlusMinus.html
        ///</summary>
        corewolf::engine *PlusMinus(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PlusMinus[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Pochhammer symbol .
        /// https://reference.wolfram.com/language/ref/Pochhammer.html
        ///</summary>
        corewolf::engine *Pochhammer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Pochhammer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a graphics and geometry primitive that represents a point at p.
        /// https://reference.wolfram.com/language/ref/Point.html
        ///</summary>
        corewolf::engine *Point(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Point[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a collection of points.
        /// https://reference.wolfram.com/language/ref/Point.html
        ///</summary>
        corewolf::engine *Point(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Point[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the distribution of point counts for the point process pproc in the region reg.
        /// https://reference.wolfram.com/language/ref/PointCountDistribution.html
        ///</summary>
        corewolf::engine *PointCountDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PointCountDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the joint distribution of point counts in regions regi.
        /// https://reference.wolfram.com/language/ref/PointCountDistribution.html
        ///</summary>
        corewolf::engine *PointCountDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PointCountDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// estimates the point density function  from point data pdata.
        /// https://reference.wolfram.com/language/ref/PointDensity.html
        ///</summary>
        corewolf::engine *PointDensity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PointDensity[" + arg0 + "]", name);
        }

        ///< summary>
        /// estimates the point density function  with the partition method pmethod.
        /// https://reference.wolfram.com/language/ref/PointDensity.html
        ///</summary>
        corewolf::engine *PointDensity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PointDensity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a function whose values give the density at a given location.
        /// https://reference.wolfram.com/language/ref/PointDensityFunction.html
        ///</summary>
        corewolf::engine *PointDensityFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PointDensityFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes a point and figure chart with prices pi at date datei.
        /// https://reference.wolfram.com/language/ref/PointFigureChart.html
        ///</summary>
        corewolf::engine *PointFigureChart(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PointFigureChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a point and figure chart of closing prices for the financial entity "name" over the date range daterange.
        /// https://reference.wolfram.com/language/ref/PointFigureChart.html
        ///</summary>
        corewolf::engine *PointFigureChart(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PointFigureChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a point and figure chart with point and figure height s and n reversals.
        /// https://reference.wolfram.com/language/ref/PointFigureChart.html
        ///</summary>
        corewolf::engine *PointFigureChart(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PointFigureChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a legend that associates points of colors coli with labels lbli.
        /// https://reference.wolfram.com/language/ref/PointLegend.html
        ///</summary>
        corewolf::engine *PointLegend(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PointLegend[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a legend with placeholder labels for the colors coli.
        /// https://reference.wolfram.com/language/ref/PointLegend.html
        ///</summary>
        corewolf::engine *PointLegend(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PointLegend[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a legend with inherited colors within visualization functions.
        /// https://reference.wolfram.com/language/ref/PointLegend.html
        ///</summary>
        corewolf::engine *PointLegend(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PointLegend[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// is a three-dimensional graphics directive that specifies the point light of color col at position pt to use in coloring 3D surfaces.
        /// https://reference.wolfram.com/language/ref/PointLight.html
        ///</summary>
        corewolf::engine *PointLight(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PointLight[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses the point light with geometric attenuation att.
        /// https://reference.wolfram.com/language/ref/PointLight.html
        ///</summary>
        corewolf::engine *PointLight(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PointLight[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is an option to EstimatedPointProcess and FindPointProcessParameters that specifies what point process parameter estimator to use.
        /// https://reference.wolfram.com/language/ref/PointProcessEstimator.html
        ///</summary>
        corewolf::engine *PointProcessEstimator(const std::string &name = "")
        {
            return this->execute("PointProcessEstimator[]", name);
        }

        ///< summary>
        /// tests whether the point collection pdata could be modeled by a Poisson point process.
        /// https://reference.wolfram.com/language/ref/PointProcessFitTest.html
        ///</summary>
        corewolf::engine *PointProcessFitTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PointProcessFitTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the point collection could be modeled by the point process pproc.
        /// https://reference.wolfram.com/language/ref/PointProcessFitTest.html
        ///</summary>
        corewolf::engine *PointProcessFitTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PointProcessFitTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/PointProcessFitTest.html
        ///</summary>
        corewolf::engine *PointProcessFitTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PointProcessFitTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a logical expression for assumptions on parameters in the point process proc.
        /// https://reference.wolfram.com/language/ref/PointProcessParameterAssumptions.html
        ///</summary>
        corewolf::engine *PointProcessParameterAssumptions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PointProcessParameterAssumptions[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if proc is a valid random point process, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/PointProcessParameterQ.html
        ///</summary>
        corewolf::engine *PointProcessParameterQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PointProcessParameterQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a graphics directive which specifies that points which follow are to be shown if possible as circular regions with diameter d. The diameter d is given as a fraction of the total width of the plot.
        /// https://reference.wolfram.com/language/ref/PointSize.html
        ///</summary>
        corewolf::engine *PointSize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PointSize[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a function whose values give the statistic of a points collection pdata at a supplied radius.
        /// https://reference.wolfram.com/language/ref/PointStatisticFunction.html
        ///</summary>
        corewolf::engine *PointStatisticFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PointStatisticFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots the points pti styled according to the values vali.
        /// https://reference.wolfram.com/language/ref/PointValuePlot.html
        ///</summary>
        corewolf::engine *PointValuePlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PointValuePlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// uses a collection of points pti from pts with corresponding values vali from val.
        /// https://reference.wolfram.com/language/ref/PointValuePlot.html
        ///</summary>
        corewolf::engine *PointValuePlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PointValuePlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the visual encoding enc to represent the values vali in the plot.
        /// https://reference.wolfram.com/language/ref/PointValuePlot.html
        ///</summary>
        corewolf::engine *PointValuePlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PointValuePlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Poisson–Consul distribution with parameters μ and λ.
        /// https://reference.wolfram.com/language/ref/PoissonConsulDistribution.html
        ///</summary>
        corewolf::engine *PoissonConsulDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PoissonConsulDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Poisson distribution with mean μ.
        /// https://reference.wolfram.com/language/ref/PoissonDistribution.html
        ///</summary>
        corewolf::engine *PoissonDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PoissonDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields a Poisson PDE term  with model variables vars and model parameters pars.
        /// https://reference.wolfram.com/language/ref/PoissonPDEComponent.html
        ///</summary>
        corewolf::engine *PoissonPDEComponent(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PoissonPDEComponent[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a homogeneous Poisson point process with constant intensity μ in .
        /// https://reference.wolfram.com/language/ref/PoissonPointProcess.html
        ///</summary>
        corewolf::engine *PoissonPointProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PoissonPointProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Poisson process with rate μ.
        /// https://reference.wolfram.com/language/ref/PoissonProcess.html
        ///</summary>
        corewolf::engine *PoissonProcess(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PoissonProcess[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Poisson window function of x.
        /// https://reference.wolfram.com/language/ref/PoissonWindow.html
        ///</summary>
        corewolf::engine *PoissonWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PoissonWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the parameter α.
        /// https://reference.wolfram.com/language/ref/PoissonWindow.html
        ///</summary>
        corewolf::engine *PoissonWindow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PoissonWindow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a polar plot of a curve with radius r as a function of angle θ.
        /// https://reference.wolfram.com/language/ref/PolarPlot.html
        ///</summary>
        corewolf::engine *PolarPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PolarPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a polar plot of curves with radius functions r1, r2, ….
        /// https://reference.wolfram.com/language/ref/PolarPlot.html
        ///</summary>
        corewolf::engine *PolarPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PolarPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a Pólya–Aeppli distribution with shape parameters θ and p.
        /// https://reference.wolfram.com/language/ref/PolyaAeppliDistribution.html
        ///</summary>
        corewolf::engine *PolyaAeppliDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PolyaAeppliDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the digamma function .
        /// https://reference.wolfram.com/language/ref/PolyGamma.html
        ///</summary>
        corewolf::engine *PolyGamma(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PolyGamma[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the n derivative of the digamma function .
        /// https://reference.wolfram.com/language/ref/PolyGamma.html
        ///</summary>
        corewolf::engine *PolyGamma(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PolyGamma[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a filled polygon with points pi.
        /// https://reference.wolfram.com/language/ref/Polygon.html
        ///</summary>
        corewolf::engine *Polygon(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Polygon[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a polygon in which coordinates given as integers i in data are taken to be pi.
        /// https://reference.wolfram.com/language/ref/Polygon.html
        ///</summary>
        corewolf::engine *Polygon(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Polygon[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the n triangular number .
        /// https://reference.wolfram.com/language/ref/PolygonalNumber.html
        ///</summary>
        corewolf::engine *PolygonalNumber(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PolygonalNumber[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the n r-gonal number .
        /// https://reference.wolfram.com/language/ref/PolygonalNumber.html
        ///</summary>
        corewolf::engine *PolygonalNumber(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PolygonalNumber[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of angles at the vertex points of poly.
        /// https://reference.wolfram.com/language/ref/PolygonAngle.html
        ///</summary>
        corewolf::engine *PolygonAngle(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PolygonAngle[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the angle at the vertex point p of a polygon poly.
        /// https://reference.wolfram.com/language/ref/PolygonAngle.html
        ///</summary>
        corewolf::engine *PolygonAngle(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PolygonAngle[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of coordinates in the polygon poly.
        /// https://reference.wolfram.com/language/ref/PolygonCoordinates.html
        ///</summary>
        corewolf::engine *PolygonCoordinates(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PolygonCoordinates[" + arg0 + "]", name);
        }

        ///< summary>
        /// decomposes the polygon poly into a disjoint union of simpler polygons.
        /// https://reference.wolfram.com/language/ref/PolygonDecomposition.html
        ///</summary>
        corewolf::engine *PolygonDecomposition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PolygonDecomposition[" + arg0 + "]", name);
        }

        ///< summary>
        /// decomposes into polygons of the specified "type".
        /// https://reference.wolfram.com/language/ref/PolygonDecomposition.html
        ///</summary>
        corewolf::engine *PolygonDecomposition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PolygonDecomposition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a filled polyhedron inside the closed surfaces with polygon faces fi.
        /// https://reference.wolfram.com/language/ref/Polyhedron.html
        ///</summary>
        corewolf::engine *Polyhedron(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Polyhedron[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a polyhedron in which coordinates given as integers i in data are taken to be pi.
        /// https://reference.wolfram.com/language/ref/Polyhedron.html
        ///</summary>
        corewolf::engine *Polyhedron(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Polyhedron[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the solid angle at the point p and spanned by edges with common point p.
        /// https://reference.wolfram.com/language/ref/PolyhedronAngle.html
        ///</summary>
        corewolf::engine *PolyhedronAngle(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PolyhedronAngle[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of coordinates in the polyhedron poly.
        /// https://reference.wolfram.com/language/ref/PolyhedronCoordinates.html
        ///</summary>
        corewolf::engine *PolyhedronCoordinates(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PolyhedronCoordinates[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the polyhedron named poly.
        /// https://reference.wolfram.com/language/ref/PolyhedronData.html
        ///</summary>
        corewolf::engine *PolyhedronData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PolyhedronData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an image of the polyhedron named poly.
        /// https://reference.wolfram.com/language/ref/PolyhedronData.html
        ///</summary>
        corewolf::engine *PolyhedronData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PolyhedronData[" + arg0 + "]", name);
        }

        ///< summary>
        /// decomposes the polyhedron poly into a union of simpler polyhedra.
        /// https://reference.wolfram.com/language/ref/PolyhedronDecomposition.html
        ///</summary>
        corewolf::engine *PolyhedronDecomposition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PolyhedronDecomposition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the polylogarithm function .
        /// https://reference.wolfram.com/language/ref/PolyLog.html
        ///</summary>
        corewolf::engine *PolyLog(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PolyLog[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Nielsen generalized polylogarithm function .
        /// https://reference.wolfram.com/language/ref/PolyLog.html
        ///</summary>
        corewolf::engine *PolyLog(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PolyLog[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives True if expr is structurally a polynomial expression in x, and False otherwise.
        /// https://reference.wolfram.com/language/ref/PolynomialExpressionQ.html
        ///</summary>
        corewolf::engine *PolynomialExpressionQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PolynomialExpressionQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if expr is structurally a polynomial expression in x,y,…, and False otherwise.
        /// https://reference.wolfram.com/language/ref/PolynomialExpressionQ.html
        ///</summary>
        corewolf::engine *PolynomialExpressionQ(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PolynomialExpressionQ[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives True if expr is structurally a polynomial expression in x,y,… with coefficients satisfying test, and False otherwise.
        /// https://reference.wolfram.com/language/ref/PolynomialExpressionQ.html
        ///</summary>
        corewolf::engine *PolynomialExpressionQ(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PolynomialExpressionQ[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the extended GCD of poly1 and poly2 treated as univariate polynomials in x.
        /// https://reference.wolfram.com/language/ref/PolynomialExtendedGCD.html
        ///</summary>
        corewolf::engine *PolynomialExtendedGCD(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PolynomialExtendedGCD[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the extended GCD over the integers mod prime p.
        /// https://reference.wolfram.com/language/ref/PolynomialExtendedGCD.html
        ///</summary>
        corewolf::engine *PolynomialExtendedGCD(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("PolynomialExtendedGCD[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the greatest common divisor of the polynomials polyi.
        /// https://reference.wolfram.com/language/ref/PolynomialGCD.html
        ///</summary>
        corewolf::engine *PolynomialGCD(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PolynomialGCD[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// evaluates the GCD modulo the prime p.
        /// https://reference.wolfram.com/language/ref/PolynomialGCD.html
        ///</summary>
        corewolf::engine *PolynomialGCD(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("PolynomialGCD[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the least common multiple of the polynomials polyi.
        /// https://reference.wolfram.com/language/ref/PolynomialLCM.html
        ///</summary>
        corewolf::engine *PolynomialLCM(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PolynomialLCM[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// evaluates the LCM modulo the prime p.
        /// https://reference.wolfram.com/language/ref/PolynomialLCM.html
        ///</summary>
        corewolf::engine *PolynomialLCM(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("PolynomialLCM[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the polynomial poly reduced modulo m.
        /// https://reference.wolfram.com/language/ref/PolynomialMod.html
        ///</summary>
        corewolf::engine *PolynomialMod(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PolynomialMod[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reduces modulo all of the mi.
        /// https://reference.wolfram.com/language/ref/PolynomialMod.html
        ///</summary>
        corewolf::engine *PolynomialMod(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PolynomialMod[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if expr is a polynomial in var, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/PolynomialQ.html
        ///</summary>
        corewolf::engine *PolynomialQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PolynomialQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether expr is a polynomial in the vari.
        /// https://reference.wolfram.com/language/ref/PolynomialQ.html
        ///</summary>
        corewolf::engine *PolynomialQ(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PolynomialQ[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the quotient of p and q, treated as polynomials in x, with any remainder dropped.
        /// https://reference.wolfram.com/language/ref/PolynomialQuotient.html
        ///</summary>
        corewolf::engine *PolynomialQuotient(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PolynomialQuotient[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of the quotient and remainder of p and q, treated as polynomials in x.
        /// https://reference.wolfram.com/language/ref/PolynomialQuotientRemainder.html
        ///</summary>
        corewolf::engine *PolynomialQuotientRemainder(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PolynomialQuotientRemainder[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields a list representing a reduction of poly in terms of the polyi. The list has the form {{a1,a2,…},b}, where b is minimal and a1 poly1+a2 poly2+…+b is exactly poly.
        /// https://reference.wolfram.com/language/ref/PolynomialReduce.html
        ///</summary>
        corewolf::engine *PolynomialReduce(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("PolynomialReduce[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the remainder from dividing p by q, treated as polynomials in x.
        /// https://reference.wolfram.com/language/ref/PolynomialRemainder.html
        ///</summary>
        corewolf::engine *PolynomialRemainder(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PolynomialRemainder[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// attempts to find polynomials with real coefficients {f1,…,fn} such that f==f12+…+fn2.
        /// https://reference.wolfram.com/language/ref/PolynomialSumOfSquaresList.html
        ///</summary>
        corewolf::engine *PolynomialSumOfSquaresList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PolynomialSumOfSquaresList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a pooling net layer using kernels of size sz.
        /// https://reference.wolfram.com/language/ref/PoolingLayer.html
        ///</summary>
        corewolf::engine *PoolingLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PoolingLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a layer performing one-dimensional pooling with kernels of size w.
        /// https://reference.wolfram.com/language/ref/PoolingLayer.html
        ///</summary>
        corewolf::engine *PoolingLayer(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PoolingLayer[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a layer that uses stride as the step size between kernel applications.
        /// https://reference.wolfram.com/language/ref/PoolingLayer.html
        ///</summary>
        corewolf::engine *PoolingLayer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PoolingLayer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a popup menu with setting x and possible values vali.
        /// https://reference.wolfram.com/language/ref/PopupMenu.html
        ///</summary>
        corewolf::engine *PopupMenu(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PopupMenu[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// displays the menu item as dlbl if x is none of the vali.
        /// https://reference.wolfram.com/language/ref/PopupMenu.html
        ///</summary>
        corewolf::engine *PopupMenu(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PopupMenu[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as base when it is not being clicked.
        /// https://reference.wolfram.com/language/ref/PopupMenu.html
        ///</summary>
        corewolf::engine *PopupMenu(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("PopupMenu[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an const std::string &which displays as a popup menu whose items are the expri.
        /// https://reference.wolfram.com/language/ref/PopupView.html
        ///</summary>
        corewolf::engine *PopupView(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PopupView[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes the i entry be the one currently chosen.
        /// https://reference.wolfram.com/language/ref/PopupView.html
        ///</summary>
        corewolf::engine *PopupView(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PopupView[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as base if it is not being clicked.
        /// https://reference.wolfram.com/language/ref/PopupView.html
        ///</summary>
        corewolf::engine *PopupView(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PopupView[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as expr, but pops up a window containing contents when clicked.
        /// https://reference.wolfram.com/language/ref/PopupWindow.html
        ///</summary>
        corewolf::engine *PopupWindow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PopupWindow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the positions at which objects matching pattern appear in expr.
        /// https://reference.wolfram.com/language/ref/Position.html
        ///</summary>
        corewolf::engine *Position(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Position[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds only objects that appear on levels specified by levelspec.
        /// https://reference.wolfram.com/language/ref/Position.html
        ///</summary>
        corewolf::engine *Position(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Position[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the positions of the first n objects found.
        /// https://reference.wolfram.com/language/ref/Position.html
        ///</summary>
        corewolf::engine *Position(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Position[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an operator form of Position that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/Position.html
        ///</summary>
        corewolf::engine *Position(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Position[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an association between unique elements in list and the positions at which they occur.
        /// https://reference.wolfram.com/language/ref/PositionIndex.html
        ///</summary>
        corewolf::engine *PositionIndex(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PositionIndex[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if x is a positive number.
        /// https://reference.wolfram.com/language/ref/Positive.html
        ///</summary>
        corewolf::engine *Positive(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Positive[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if m is explicitly positive definite, and False otherwise.
        /// https://reference.wolfram.com/language/ref/PositiveDefiniteMatrixQ.html
        ///</summary>
        corewolf::engine *PositiveDefiniteMatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PositiveDefiniteMatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the sequence of points p1,p2,p3,…,pd+1 is positively oriented.
        /// https://reference.wolfram.com/language/ref/PositivelyOrientedPoints.html
        ///</summary>
        corewolf::engine *PositivelyOrientedPoints(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PositivelyOrientedPoints[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives True if m is explicitly positive semidefinite, and False otherwise.
        /// https://reference.wolfram.com/language/ref/PositiveSemidefiniteMatrixQ.html
        ///</summary>
        corewolf::engine *PositiveSemidefiniteMatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PositiveSemidefiniteMatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if basic symbolic and numerical methods suggest that expr has value zero, and gives False otherwise.
        /// https://reference.wolfram.com/language/ref/PossibleZeroQ.html
        ///</summary>
        corewolf::engine *PossibleZeroQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PossibleZeroQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints with f[expr] given in default postfix form: expr//f.
        /// https://reference.wolfram.com/language/ref/Postfix.html
        ///</summary>
        corewolf::engine *Postfix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Postfix[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints as exprh.
        /// https://reference.wolfram.com/language/ref/Postfix.html
        ///</summary>
        corewolf::engine *Postfix(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Postfix[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a power distribution with domain parameter k and shape parameter a.
        /// https://reference.wolfram.com/language/ref/PowerDistribution.html
        ///</summary>
        corewolf::engine *PowerDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PowerDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// expands all powers of products and powers.
        /// https://reference.wolfram.com/language/ref/PowerExpand.html
        ///</summary>
        corewolf::engine *PowerExpand(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PowerExpand[" + arg0 + "]", name);
        }

        ///< summary>
        /// expands only with respect to the variables xi.
        /// https://reference.wolfram.com/language/ref/PowerExpand.html
        ///</summary>
        corewolf::engine *PowerExpand(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PowerExpand[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives ab mod m.
        /// https://reference.wolfram.com/language/ref/PowerMod.html
        ///</summary>
        corewolf::engine *PowerMod(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PowerMod[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of all  modulo m for which  mod m.
        /// https://reference.wolfram.com/language/ref/PowerModList.html
        ///</summary>
        corewolf::engine *PowerModList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PowerModList[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates the list {1,10,100,…,max}, where max is the largest power of 10 that does not exceed b.
        /// https://reference.wolfram.com/language/ref/PowerRange.html
        ///</summary>
        corewolf::engine *PowerRange(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PowerRange[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates the list {a,10a,100a,…,max}, with successive elements increasing by factors of 10.
        /// https://reference.wolfram.com/language/ref/PowerRange.html
        ///</summary>
        corewolf::engine *PowerRange(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PowerRange[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses factors of r instead of 10.
        /// https://reference.wolfram.com/language/ref/PowerRange.html
        ///</summary>
        corewolf::engine *PowerRange(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PowerRange[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// estimates the power spectral density for data.
        /// https://reference.wolfram.com/language/ref/PowerSpectralDensity.html
        ///</summary>
        corewolf::engine *PowerSpectralDensity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PowerSpectralDensity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// estimates the power spectral density for data with smoothing specification sspec.
        /// https://reference.wolfram.com/language/ref/PowerSpectralDensity.html
        ///</summary>
        corewolf::engine *PowerSpectralDensity(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PowerSpectralDensity[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the distinct representations of the integer n as a sum of k non-negative p integer powers.
        /// https://reference.wolfram.com/language/ref/PowersRepresentations.html
        ///</summary>
        corewolf::engine *PowersRepresentations(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PowersRepresentations[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a formal power symmetric polynomial with exponent r.
        /// https://reference.wolfram.com/language/ref/PowerSymmetricPolynomial.html
        ///</summary>
        corewolf::engine *PowerSymmetricPolynomial(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PowerSymmetricPolynomial[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a multivariate formal power symmetric polynomial with exponents r1, r2, ….
        /// https://reference.wolfram.com/language/ref/PowerSymmetricPolynomial.html
        ///</summary>
        corewolf::engine *PowerSymmetricPolynomial(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("PowerSymmetricPolynomial[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the power symmetric polynomial in data.
        /// https://reference.wolfram.com/language/ref/PowerSymmetricPolynomial.html
        ///</summary>
        corewolf::engine *PowerSymmetricPolynomial(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PowerSymmetricPolynomial[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// prints with expr parenthesized as it would be if it contained an operator with precedence prec.
        /// https://reference.wolfram.com/language/ref/PrecedenceForm.html
        ///</summary>
        corewolf::engine *PrecedenceForm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PrecedenceForm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Precedes.html
        ///</summary>
        corewolf::engine *Precedes(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Precedes[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/PrecedesEqual.html
        ///</summary>
        corewolf::engine *PrecedesEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PrecedesEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/PrecedesSlantEqual.html
        ///</summary>
        corewolf::engine *PrecedesSlantEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PrecedesSlantEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/PrecedesTilde.html
        ///</summary>
        corewolf::engine *PrecedesTilde(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PrecedesTilde[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the effective number of digits of precision in the number x.
        /// https://reference.wolfram.com/language/ref/Precision.html
        ///</summary>
        corewolf::engine *Precision(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Precision[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a PredictorFunction[…] based on the example input-output pairs given.
        /// https://reference.wolfram.com/language/ref/Predict.html
        ///</summary>
        corewolf::engine *Predict(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Predict[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// attempts to predict the output associated with input from the training examples given.
        /// https://reference.wolfram.com/language/ref/Predict.html
        ///</summary>
        corewolf::engine *Predict(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Predict[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a function generated by Predict that predicts numerical values from data.
        /// https://reference.wolfram.com/language/ref/PredictorFunction.html
        ///</summary>
        corewolf::engine *PredictorFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PredictorFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives measurements associated with the property prop when predictor is evaluated on testset.
        /// https://reference.wolfram.com/language/ref/PredictorMeasurements.html
        ///</summary>
        corewolf::engine *PredictorMeasurements(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PredictorMeasurements[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields a measurement report that can be applied to any property.
        /// https://reference.wolfram.com/language/ref/PredictorMeasurements.html
        ///</summary>
        corewolf::engine *PredictorMeasurements(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PredictorMeasurements[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives properties prop1, prop2, etc.
        /// https://reference.wolfram.com/language/ref/PredictorMeasurements.html
        ///</summary>
        corewolf::engine *PredictorMeasurements(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("PredictorMeasurements[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an const std::string &generated by PredictorMeasurements that can be applied to properties.
        /// https://reference.wolfram.com/language/ref/PredictorMeasurementsObject.html
        ///</summary>
        corewolf::engine *PredictorMeasurementsObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PredictorMeasurementsObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// evaluates expr, without any interruption from preemptive evaluations.
        /// https://reference.wolfram.com/language/ref/PreemptProtect.html
        ///</summary>
        corewolf::engine *PreemptProtect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PreemptProtect[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints with f[expr] given in default prefix form: f@expr.
        /// https://reference.wolfram.com/language/ref/Prefix.html
        ///</summary>
        corewolf::engine *Prefix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Prefix[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints as hexpr.
        /// https://reference.wolfram.com/language/ref/Prefix.html
        ///</summary>
        corewolf::engine *Prefix(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Prefix[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives expr with elem prepended.
        /// https://reference.wolfram.com/language/ref/Prepend.html
        ///</summary>
        corewolf::engine *Prepend(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Prepend[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of Prepend that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/Prepend.html
        ///</summary>
        corewolf::engine *Prepend(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Prepend[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a net layer that takes an input array and prepends another array to it.
        /// https://reference.wolfram.com/language/ref/PrependLayer.html
        ///</summary>
        corewolf::engine *PrependLayer(const std::string &name = "")
        {
            return this->execute("PrependLayer[]", name);
        }

        ///< summary>
        /// prepends elem to the value of x, and resets x to the result.
        /// https://reference.wolfram.com/language/ref/PrependTo.html
        ///</summary>
        corewolf::engine *PrependTo(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PrependTo[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the CellObject corresponding to the cell directly above the currently evaluating cell.
        /// https://reference.wolfram.com/language/ref/PreviousCell.html
        ///</summary>
        corewolf::engine *PreviousCell(const std::string &name = "")
        {
            return this->execute("PreviousCell[]", name);
        }

        ///< summary>
        /// starts looking from the given cell.
        /// https://reference.wolfram.com/language/ref/PreviousCell.html
        ///</summary>
        corewolf::engine *PreviousCell(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PreviousCell[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the previously occurring date of the specified granularity type gran.
        /// https://reference.wolfram.com/language/ref/PreviousDate.html
        ///</summary>
        corewolf::engine *PreviousDate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PreviousDate[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the previous date of the given granularity relative to the specified date.
        /// https://reference.wolfram.com/language/ref/PreviousDate.html
        ///</summary>
        corewolf::engine *PreviousDate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PreviousDate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a de Solla Price graph distribution for n-vertex graphs where a new vertex with k edges is added at each step, using attractiveness parameter a.
        /// https://reference.wolfram.com/language/ref/PriceGraphDistribution.html
        ///</summary>
        corewolf::engine *PriceGraphDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PriceGraphDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the nprime number .
        /// https://reference.wolfram.com/language/ref/Prime.html
        ///</summary>
        corewolf::engine *Prime(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Prime[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number of distinct primes  in n.
        /// https://reference.wolfram.com/language/ref/PrimeNu.html
        ///</summary>
        corewolf::engine *PrimeNu(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PrimeNu[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number of prime factors counting multiplicities  in n.
        /// https://reference.wolfram.com/language/ref/PrimeOmega.html
        ///</summary>
        corewolf::engine *PrimeOmega(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PrimeOmega[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number of primes  less than or equal to x.
        /// https://reference.wolfram.com/language/ref/PrimePi.html
        ///</summary>
        corewolf::engine *PrimePi(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PrimePi[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if expr is a power of a prime number, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/PrimePowerQ.html
        ///</summary>
        corewolf::engine *PrimePowerQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PrimePowerQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if n is a prime number, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/PrimeQ.html
        ///</summary>
        corewolf::engine *PrimeQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PrimeQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives prime zeta function .
        /// https://reference.wolfram.com/language/ref/PrimeZetaP.html
        ///</summary>
        corewolf::engine *PrimeZetaP(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PrimeZetaP[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether poly is a primitive polynomial modulo a prime p.
        /// https://reference.wolfram.com/language/ref/PrimitivePolynomialQ.html
        ///</summary>
        corewolf::engine *PrimitivePolynomialQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PrimitivePolynomialQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a primitive root of n.
        /// https://reference.wolfram.com/language/ref/PrimitiveRoot.html
        ///</summary>
        corewolf::engine *PrimitiveRoot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PrimitiveRoot[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the smallest primitive root of n greater than or equal to k.
        /// https://reference.wolfram.com/language/ref/PrimitiveRoot.html
        ///</summary>
        corewolf::engine *PrimitiveRoot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PrimitiveRoot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of primitive roots of n.
        /// https://reference.wolfram.com/language/ref/PrimitiveRootList.html
        ///</summary>
        corewolf::engine *PrimitiveRootList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PrimitiveRootList[" + arg0 + "]", name);
        }

        ///< summary>
        /// transforms elements of matrix into unscaled principal components.
        /// https://reference.wolfram.com/language/ref/PrincipalComponents.html
        ///</summary>
        corewolf::engine *PrincipalComponents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PrincipalComponents[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints expr as output.
        /// https://reference.wolfram.com/language/ref/Print.html
        ///</summary>
        corewolf::engine *Print(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Print[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if the string contains only printable ASCII characters, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/PrintableASCIIQ.html
        ///</summary>
        corewolf::engine *PrintableASCIIQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PrintableASCIIQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints out the 3D model using a 3D print previewer.
        /// https://reference.wolfram.com/language/ref/Printout3D.html
        ///</summary>
        corewolf::engine *Printout3D(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Printout3D[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints out the 3D model using the specified 3D printing service.
        /// https://reference.wolfram.com/language/ref/Printout3D.html
        ///</summary>
        corewolf::engine *Printout3D(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Printout3D[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// prints expr as a temporary cell in a notebook, removing it when the evaluation of the current input line is complete.
        /// https://reference.wolfram.com/language/ref/PrintTemporary.html
        ///</summary>
        corewolf::engine *PrintTemporary(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PrintTemporary[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a filled prism connecting the triangles {p1,p2,p3} and {p4,p5,p6}.
        /// https://reference.wolfram.com/language/ref/Prism.html
        ///</summary>
        corewolf::engine *Prism(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Prism[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the private part of a key pair for a public-key cryptographic system.
        /// https://reference.wolfram.com/language/ref/PrivateKey.html
        ///</summary>
        corewolf::engine *PrivateKey(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PrivateKey[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the probability for an event that satisfies the predicate pred under the assumption that x follows the probability distribution dist.
        /// https://reference.wolfram.com/language/ref/Probability.html
        ///</summary>
        corewolf::engine *Probability(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Probability[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the probability that an event satisfies pred under the assumption that x1, x2, … are independent and follow the distributions dist1, dist2, ….
        /// https://reference.wolfram.com/language/ref/Probability.html
        ///</summary>
        corewolf::engine *Probability(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Probability[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents the continuous distribution with PDF pdf in the variable x where the pdf is taken to be zero for  and .
        /// https://reference.wolfram.com/language/ref/ProbabilityDistribution.html
        ///</summary>
        corewolf::engine *ProbabilityDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ProbabilityDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a multivariate distribution with PDF pdf in the variables x, y, …, etc.
        /// https://reference.wolfram.com/language/ref/ProbabilityDistribution.html
        ///</summary>
        corewolf::engine *ProbabilityDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ProbabilityDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a probability distribution with CDF given by cdf.
        /// https://reference.wolfram.com/language/ref/ProbabilityDistribution.html
        ///</summary>
        corewolf::engine *ProbabilityDistribution(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ProbabilityDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a plot of the CDF of list against the CDF of a normal distribution.
        /// https://reference.wolfram.com/language/ref/ProbabilityPlot.html
        ///</summary>
        corewolf::engine *ProbabilityPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ProbabilityPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a plot of the CDF of data against the CDF of rdata.
        /// https://reference.wolfram.com/language/ref/ProbabilityPlot.html
        ///</summary>
        corewolf::engine *ProbabilityPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ProbabilityPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a plot of the CDF of datai against the CDF of a reference distribution ref.
        /// https://reference.wolfram.com/language/ref/ProbabilityPlot.html
        ///</summary>
        corewolf::engine *ProbabilityPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ProbabilityPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a normal probability plot of the samples xi.
        /// https://reference.wolfram.com/language/ref/ProbabilityScalePlot.html
        ///</summary>
        corewolf::engine *ProbabilityScalePlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ProbabilityScalePlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a probability plot scaled for the distribution "dist".
        /// https://reference.wolfram.com/language/ref/ProbabilityScalePlot.html
        ///</summary>
        corewolf::engine *ProbabilityScalePlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ProbabilityScalePlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// constructs a binomial probit regression model of the form  that fits the yi for successive x values 1, 2, ….
        /// https://reference.wolfram.com/language/ref/ProbitModelFit.html
        ///</summary>
        corewolf::engine *ProbitModelFit(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ProbitModelFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// constructs a binomial probit regression model of the form  where the fi depend on the variables xk.
        /// https://reference.wolfram.com/language/ref/ProbitModelFit.html
        ///</summary>
        corewolf::engine *ProbitModelFit(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("ProbitModelFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// constructs a binomial probit regression model from the design matrix m and response vector v.
        /// https://reference.wolfram.com/language/ref/ProbitModelFit.html
        ///</summary>
        corewolf::engine *ProbitModelFit(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ProbitModelFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns the stream const std::string &for a given stream.
        /// https://reference.wolfram.com/language/ref/ProcessConnection.html
        ///</summary>
        corewolf::engine *ProcessConnection(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ProcessConnection[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a list of currently running external processes started in this Wolfram Language session.
        /// https://reference.wolfram.com/language/ref/Processes.html
        ///</summary>
        corewolf::engine *Processes(const std::string &name = "")
        {
            return this->execute("Processes[]", name);
        }

        ///< summary>
        /// gives information about an external process proc.
        /// https://reference.wolfram.com/language/ref/ProcessInformation.html
        ///</summary>
        corewolf::engine *ProcessInformation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ProcessInformation[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives information about the property "prop".
        /// https://reference.wolfram.com/language/ref/ProcessInformation.html
        ///</summary>
        corewolf::engine *ProcessInformation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ProcessInformation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is an const std::string &that represents a runnable external process.
        /// https://reference.wolfram.com/language/ref/ProcessObject.html
        ///</summary>
        corewolf::engine *ProcessObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ProcessObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a logical expression for assumptions on parameters in the random process proc.
        /// https://reference.wolfram.com/language/ref/ProcessParameterAssumptions.html
        ///</summary>
        corewolf::engine *ProcessParameterAssumptions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ProcessParameterAssumptions[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if proc is a valid random process, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/ProcessParameterQ.html
        ///</summary>
        corewolf::engine *ProcessParameterQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ProcessParameterQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the current status of the external process represented by the ProcessObject proc.
        /// https://reference.wolfram.com/language/ref/ProcessStatus.html
        ///</summary>
        corewolf::engine *ProcessStatus(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ProcessStatus[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if the process has the status given and returns False otherwise.
        /// https://reference.wolfram.com/language/ref/ProcessStatus.html
        ///</summary>
        corewolf::engine *ProcessStatus(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ProcessStatus[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates the product .
        /// https://reference.wolfram.com/language/ref/Product.html
        ///</summary>
        corewolf::engine *Product(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Product[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses successive values i1, i2, ….
        /// https://reference.wolfram.com/language/ref/Product.html
        ///</summary>
        corewolf::engine *Product(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Product[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates the multiple product .
        /// https://reference.wolfram.com/language/ref/Product.html
        ///</summary>
        corewolf::engine *Product(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Product[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the indefinite product .
        /// https://reference.wolfram.com/language/ref/Product.html
        ///</summary>
        corewolf::engine *Product(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Product[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the joint distribution with independent component distributions dist1, dist2, ….
        /// https://reference.wolfram.com/language/ref/ProductDistribution.html
        ///</summary>
        corewolf::engine *ProductDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ProductDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the principal solution for w in .
        /// https://reference.wolfram.com/language/ref/ProductLog.html
        ///</summary>
        corewolf::engine *ProductLog(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ProductLog[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the k solution.
        /// https://reference.wolfram.com/language/ref/ProductLog.html
        ///</summary>
        corewolf::engine *ProductLog(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ProductLog[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a progress indicator with setting x in the range 0 to 1.
        /// https://reference.wolfram.com/language/ref/ProgressIndicator.html
        ///</summary>
        corewolf::engine *ProgressIndicator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ProgressIndicator[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a progress indicator with range xmin to xmax.
        /// https://reference.wolfram.com/language/ref/ProgressIndicator.html
        ///</summary>
        corewolf::engine *ProgressIndicator(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ProgressIndicator[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a progress indicator with indeterminate range.
        /// https://reference.wolfram.com/language/ref/ProgressIndicator.html
        ///</summary>
        corewolf::engine *ProgressIndicator(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ProgressIndicator[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the projection of the vector u onto the vector v.
        /// https://reference.wolfram.com/language/ref/Projection.html
        ///</summary>
        corewolf::engine *Projection(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Projection[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds projections with respect to the inner product function f.
        /// https://reference.wolfram.com/language/ref/Projection.html
        ///</summary>
        corewolf::engine *Projection(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Projection[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a proof const std::string &generated by FindEquationalProof.
        /// https://reference.wolfram.com/language/ref/ProofObject.html
        ///</summary>
        corewolf::engine *ProofObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ProofObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Proportion.html
        ///</summary>
        corewolf::engine *Proportion(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Proportion[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Proportional.html
        ///</summary>
        corewolf::engine *Proportional(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Proportional[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// sets the attribute Protected for the symbols si.
        /// https://reference.wolfram.com/language/ref/Protect.html
        ///</summary>
        corewolf::engine *Protect(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Protect[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// protects any symbols that are equal to or match any of the speci.
        /// https://reference.wolfram.com/language/ref/Protect.html
        ///</summary>
        corewolf::engine *Protect(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Protect[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the reference amino acid sequence for the protein entity.
        /// https://reference.wolfram.com/language/ref/ProteinData.html
        ///</summary>
        corewolf::engine *ProteinData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ProteinData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the protein entity.
        /// https://reference.wolfram.com/language/ref/ProteinData.html
        ///</summary>
        corewolf::engine *ProteinData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ProteinData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/ProteinData.html
        ///</summary>
        corewolf::engine *ProteinData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ProteinData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// removes the outermost branches of thin objects in image by setting their values to black.
        /// https://reference.wolfram.com/language/ref/Pruning.html
        ///</summary>
        corewolf::engine *Pruning(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Pruning[" + arg0 + "]", name);
        }

        ///< summary>
        /// removes branches that are at most n pixels long.
        /// https://reference.wolfram.com/language/ref/Pruning.html
        ///</summary>
        corewolf::engine *Pruning(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Pruning[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// removes n pixels from each branch.
        /// https://reference.wolfram.com/language/ref/Pruning.html
        ///</summary>
        corewolf::engine *Pruning(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Pruning[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// treats values above t as foreground.
        /// https://reference.wolfram.com/language/ref/Pruning.html
        ///</summary>
        corewolf::engine *Pruning(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Pruning[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds the pseudoinverse of a rectangular matrix.
        /// https://reference.wolfram.com/language/ref/PseudoInverse.html
        ///</summary>
        corewolf::engine *PseudoInverse(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PseudoInverse[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the psychrometric properties of moist air for the specified parameters.
        /// https://reference.wolfram.com/language/ref/PsychrometricPropertyData.html
        ///</summary>
        corewolf::engine *PsychrometricPropertyData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PsychrometricPropertyData[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the specified property for the given parameters.
        /// https://reference.wolfram.com/language/ref/PsychrometricPropertyData.html
        ///</summary>
        corewolf::engine *PsychrometricPropertyData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PsychrometricPropertyData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the public part of a key pair for a public-key cryptographic system.
        /// https://reference.wolfram.com/language/ref/PublicKey.html
        ///</summary>
        corewolf::engine *PublicKey(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("PublicKey[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the pulsar entity.
        /// https://reference.wolfram.com/language/ref/PulsarData.html
        ///</summary>
        corewolf::engine *PulsarData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PulsarData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified pulsar entities.
        /// https://reference.wolfram.com/language/ref/PulsarData.html
        ///</summary>
        corewolf::engine *PulsarData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("PulsarData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/PulsarData.html
        ///</summary>
        corewolf::engine *PulsarData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("PulsarData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a filled pyramid with base {p1,…,p4} and top p5.
        /// https://reference.wolfram.com/language/ref/Pyramid.html
        ///</summary>
        corewolf::engine *Pyramid(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Pyramid[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the -binomial coefficient .
        /// https://reference.wolfram.com/language/ref/QBinomial.html
        ///</summary>
        corewolf::engine *QBinomial(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("QBinomial[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the -factorial .
        /// https://reference.wolfram.com/language/ref/QFactorial.html
        ///</summary>
        corewolf::engine *QFactorial(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QFactorial[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the -gamma function .
        /// https://reference.wolfram.com/language/ref/QGamma.html
        ///</summary>
        corewolf::engine *QGamma(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QGamma[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the basic hypergeometric series .
        /// https://reference.wolfram.com/language/ref/QHypergeometricPFQ.html
        ///</summary>
        corewolf::engine *QHypergeometricPFQ(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("QHypergeometricPFQ[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the  statistic of the elements in list.
        /// https://reference.wolfram.com/language/ref/QnDispersion.html
        ///</summary>
        corewolf::engine *QnDispersion(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QnDispersion[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the  statistic with a scaling factor c.
        /// https://reference.wolfram.com/language/ref/QnDispersion.html
        ///</summary>
        corewolf::engine *QnDispersion(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QnDispersion[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the -Pochhammer symbol .
        /// https://reference.wolfram.com/language/ref/QPochhammer.html
        ///</summary>
        corewolf::engine *QPochhammer(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("QPochhammer[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the -Pochhammer symbol .
        /// https://reference.wolfram.com/language/ref/QPochhammer.html
        ///</summary>
        corewolf::engine *QPochhammer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QPochhammer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the -Pochhammer symbol .
        /// https://reference.wolfram.com/language/ref/QPochhammer.html
        ///</summary>
        corewolf::engine *QPochhammer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QPochhammer[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the -digamma function .
        /// https://reference.wolfram.com/language/ref/QPolyGamma.html
        ///</summary>
        corewolf::engine *QPolyGamma(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QPolyGamma[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the  derivative of the -digamma function .
        /// https://reference.wolfram.com/language/ref/QPolyGamma.html
        ///</summary>
        corewolf::engine *QPolyGamma(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("QPolyGamma[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields the QR decomposition for a numerical matrix m. The result is a list {q,r}, where q is a unitary matrix and r is an upper‐triangular matrix.
        /// https://reference.wolfram.com/language/ref/QRDecomposition.html
        ///</summary>
        corewolf::engine *QRDecomposition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QRDecomposition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if x is a quadratic irrational and False otherwise.
        /// https://reference.wolfram.com/language/ref/QuadraticIrrationalQ.html
        ///</summary>
        corewolf::engine *QuadraticIrrationalQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QuadraticIrrationalQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds values of variables vars that minimize the quadratic objective f subject to linear constraints cons.
        /// https://reference.wolfram.com/language/ref/QuadraticOptimization.html
        ///</summary>
        corewolf::engine *QuadraticOptimization(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("QuadraticOptimization[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds a vector  that minimizes the quadratic objective  subject to the linear inequality constraints .
        /// https://reference.wolfram.com/language/ref/QuadraticOptimization.html
        ///</summary>
        corewolf::engine *QuadraticOptimization(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("QuadraticOptimization[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// includes the linear equality constraints .
        /// https://reference.wolfram.com/language/ref/QuadraticOptimization.html
        ///</summary>
        corewolf::engine *QuadraticOptimization(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("QuadraticOptimization[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// takes  to be in the domain domi, where domi is Integers or Reals.
        /// https://reference.wolfram.com/language/ref/QuadraticOptimization.html
        ///</summary>
        corewolf::engine *QuadraticOptimization(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("QuadraticOptimization[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// specifies what solution property "prop" should be returned.
        /// https://reference.wolfram.com/language/ref/QuadraticOptimization.html
        ///</summary>
        corewolf::engine *QuadraticOptimization(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QuadraticOptimization[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the q  quantile of list.
        /// https://reference.wolfram.com/language/ref/Quantile.html
        ///</summary>
        corewolf::engine *Quantile(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Quantile[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of quantiles q1, q2, ….
        /// https://reference.wolfram.com/language/ref/Quantile.html
        ///</summary>
        corewolf::engine *Quantile(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Quantile[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses the quantile definition specified by parameters a, b, c, d.
        /// https://reference.wolfram.com/language/ref/Quantile.html
        ///</summary>
        corewolf::engine *Quantile(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("Quantile[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// generates a plot of quantiles of list against the quantiles of a normal distribution.
        /// https://reference.wolfram.com/language/ref/QuantilePlot.html
        ///</summary>
        corewolf::engine *QuantilePlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QuantilePlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a plot of the quantiles of data against the quantiles of rdata.
        /// https://reference.wolfram.com/language/ref/QuantilePlot.html
        ///</summary>
        corewolf::engine *QuantilePlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QuantilePlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a plot of quantiles of datai against the quantiles of a reference distribution ref.
        /// https://reference.wolfram.com/language/ref/QuantilePlot.html
        ///</summary>
        corewolf::engine *QuantilePlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QuantilePlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a quantity with size magnitude and unit specified by unit.
        /// https://reference.wolfram.com/language/ref/Quantity.html
        ///</summary>
        corewolf::engine *Quantity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Quantity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// assumes the magnitude of the specified unit to be 1.
        /// https://reference.wolfram.com/language/ref/Quantity.html
        ///</summary>
        corewolf::engine *Quantity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Quantity[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an array of quantities with magnitudes mags and common unit.
        /// https://reference.wolfram.com/language/ref/QuantityArray.html
        ///</summary>
        corewolf::engine *QuantityArray(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QuantityArray[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an array of lists of quantities with units {unit1,unit2,…}.
        /// https://reference.wolfram.com/language/ref/QuantityArray.html
        ///</summary>
        corewolf::engine *QuantityArray(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("QuantityArray[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// converts an array of Quantity objects into a single QuantityArray object.
        /// https://reference.wolfram.com/language/ref/QuantityArray.html
        ///</summary>
        corewolf::engine *QuantityArray(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QuantityArray[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a distribution dist of quantities with unit specified by unit.
        /// https://reference.wolfram.com/language/ref/QuantityDistribution.html
        ///</summary>
        corewolf::engine *QuantityDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QuantityDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a multivariate distribution with units {unit1,unit2,…}.
        /// https://reference.wolfram.com/language/ref/QuantityDistribution.html
        ///</summary>
        corewolf::engine *QuantityDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("QuantityDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// prints expr with all Quantity expressions using the specified unit display form form.
        /// https://reference.wolfram.com/language/ref/QuantityForm.html
        ///</summary>
        corewolf::engine *QuantityForm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QuantityForm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// prints expr using the appropriate combination of the specified unit display forms forms.
        /// https://reference.wolfram.com/language/ref/QuantityForm.html
        ///</summary>
        corewolf::engine *QuantityForm(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("QuantityForm[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the amount of the specified quantity.
        /// https://reference.wolfram.com/language/ref/QuantityMagnitude.html
        ///</summary>
        corewolf::engine *QuantityMagnitude(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QuantityMagnitude[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value corresponding to quantity when converted to unit.
        /// https://reference.wolfram.com/language/ref/QuantityMagnitude.html
        ///</summary>
        corewolf::engine *QuantityMagnitude(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QuantityMagnitude[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if expr is a Quantity with valid arguments, and False otherwise.
        /// https://reference.wolfram.com/language/ref/QuantityQ.html
        ///</summary>
        corewolf::engine *QuantityQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QuantityQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the unit associated with the specified quantity.
        /// https://reference.wolfram.com/language/ref/QuantityUnit.html
        ///</summary>
        corewolf::engine *QuantityUnit(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QuantityUnit[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a variable with the label var and the corresponding physical quantity "pq".
        /// https://reference.wolfram.com/language/ref/QuantityVariable.html
        ///</summary>
        corewolf::engine *QuantityVariable(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QuantityVariable[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the unlabeled physical quantity "pq".
        /// https://reference.wolfram.com/language/ref/QuantityVariable.html
        ///</summary>
        corewolf::engine *QuantityVariable(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QuantityVariable[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the canonical unit associated with the specified quantityvariable.
        /// https://reference.wolfram.com/language/ref/QuantityVariableCanonicalUnit.html
        ///</summary>
        corewolf::engine *QuantityVariableCanonicalUnit(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QuantityVariableCanonicalUnit[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a list of base dimensions associated with the specified quantityvariable.
        /// https://reference.wolfram.com/language/ref/QuantityVariableDimensions.html
        ///</summary>
        corewolf::engine *QuantityVariableDimensions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QuantityVariableDimensions[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the identifier associated with the specified quantityvariable.
        /// https://reference.wolfram.com/language/ref/QuantityVariableIdentifier.html
        ///</summary>
        corewolf::engine *QuantityVariableIdentifier(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QuantityVariableIdentifier[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the physical quantity associated with the quantity variable var.
        /// https://reference.wolfram.com/language/ref/QuantityVariablePhysicalQuantity.html
        ///</summary>
        corewolf::engine *QuantityVariablePhysicalQuantity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QuantityVariablePhysicalQuantity[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the physical quantity using the format type.
        /// https://reference.wolfram.com/language/ref/QuantityVariablePhysicalQuantity.html
        ///</summary>
        corewolf::engine *QuantityVariablePhysicalQuantity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QuantityVariablePhysicalQuantity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the quartile deviation or semi-interquartile range of the elements in list.
        /// https://reference.wolfram.com/language/ref/QuartileDeviation.html
        ///</summary>
        corewolf::engine *QuartileDeviation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QuartileDeviation[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of the 1/4, 1/2 and 3/4 quantiles of the elements in list.
        /// https://reference.wolfram.com/language/ref/Quartiles.html
        ///</summary>
        corewolf::engine *Quartiles(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Quartiles[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the coefficient of quartile skewness for the elements in list.
        /// https://reference.wolfram.com/language/ref/QuartileSkewness.html
        ///</summary>
        corewolf::engine *QuartileSkewness(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QuartileSkewness[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a query that can be applied to a Dataset object, in which the successive operatori are applied at successively deeper levels.
        /// https://reference.wolfram.com/language/ref/Query.html
        ///</summary>
        corewolf::engine *Query(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Query[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a QuestionObject generated by applying genfunc to "name1":>val1,"name1":>val2,….
        /// https://reference.wolfram.com/language/ref/QuestionGenerator.html
        ///</summary>
        corewolf::engine *QuestionGenerator(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("QuestionGenerator[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a cloud-deployed question generator.
        /// https://reference.wolfram.com/language/ref/QuestionGenerator.html
        ///</summary>
        corewolf::engine *QuestionGenerator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QuestionGenerator[" + arg0 + "]", name);
        }

        ///< summary>
        /// defines an interface for a QuestionObject using the given type and properties pi with settings si.
        /// https://reference.wolfram.com/language/ref/QuestionInterface.html
        ///</summary>
        corewolf::engine *QuestionInterface(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("QuestionInterface[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents the question q and the corresponding assessment assess.
        /// https://reference.wolfram.com/language/ref/QuestionObject.html
        ///</summary>
        corewolf::engine *QuestionObject(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QuestionObject[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// derives a question from the assessment.
        /// https://reference.wolfram.com/language/ref/QuestionObject.html
        ///</summary>
        corewolf::engine *QuestionObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QuestionObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a list of questions from which one of the question objects qoi can be randomly selected.
        /// https://reference.wolfram.com/language/ref/QuestionSelector.html
        ///</summary>
        corewolf::engine *QuestionSelector(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("QuestionSelector[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a cloud-deployed question selector.
        /// https://reference.wolfram.com/language/ref/QuestionSelector.html
        ///</summary>
        corewolf::engine *QuestionSelector(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QuestionSelector[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an open (Jackson) queueing network process with arrival vector γ, routing probability matrix r, service vector μ, and service channel vector c.
        /// https://reference.wolfram.com/language/ref/QueueingNetworkProcess.html
        ///</summary>
        corewolf::engine *QueueingNetworkProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("QueueingNetworkProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a closed (Gordon–Newell) queueing network process with k jobs in the system.
        /// https://reference.wolfram.com/language/ref/QueueingNetworkProcess.html
        ///</summary>
        corewolf::engine *QueueingNetworkProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("QueueingNetworkProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// represents an M/M/1 queue with arrival rate λ and service rate μ.
        /// https://reference.wolfram.com/language/ref/QueueingProcess.html
        ///</summary>
        corewolf::engine *QueueingProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QueueingProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a queueing process with c service channels.
        /// https://reference.wolfram.com/language/ref/QueueingProcess.html
        ///</summary>
        corewolf::engine *QueueingProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("QueueingProcess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a queueing process with system capacity k.
        /// https://reference.wolfram.com/language/ref/QueueingProcess.html
        ///</summary>
        corewolf::engine *QueueingProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("QueueingProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a queueing process with initial state x0.
        /// https://reference.wolfram.com/language/ref/QueueingProcess.html
        ///</summary>
        corewolf::engine *QueueingProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("QueueingProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// gives a summary of properties for the queueing process qproc.
        /// https://reference.wolfram.com/language/ref/QueueProperties.html
        ///</summary>
        corewolf::engine *QueueProperties(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QueueProperties[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a summary of properties for the i node in the queueing network process qproc.
        /// https://reference.wolfram.com/language/ref/QueueProperties.html
        ///</summary>
        corewolf::engine *QueueProperties(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("QueueProperties[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the specified "property".
        /// https://reference.wolfram.com/language/ref/QueueProperties.html
        ///</summary>
        corewolf::engine *QueueProperties(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QueueProperties[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates expr "quietly", without actually outputting any messages generated.
        /// https://reference.wolfram.com/language/ref/Quiet.html
        ///</summary>
        corewolf::engine *Quiet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Quiet[" + arg0 + "]", name);
        }

        ///< summary>
        /// quietens only the specified messages during the evaluation of expr.
        /// https://reference.wolfram.com/language/ref/Quiet.html
        ///</summary>
        corewolf::engine *Quiet(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Quiet[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// quietens only the named group of messages.
        /// https://reference.wolfram.com/language/ref/Quiet.html
        ///</summary>
        corewolf::engine *Quiet(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Quiet[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates expr without letting Echo and related functions inside expr print any result.
        /// https://reference.wolfram.com/language/ref/QuietEcho.html
        ///</summary>
        corewolf::engine *QuietEcho(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("QuietEcho[" + arg0 + "]", name);
        }

        ///< summary>
        /// terminates a Wolfram Language kernel session.
        /// https://reference.wolfram.com/language/ref/Quit.html
        ///</summary>
        corewolf::engine *Quit(const std::string &name = "")
        {
            return this->execute("Quit[]", name);
        }

        ///< summary>
        /// gives the integer quotient of m and n.
        /// https://reference.wolfram.com/language/ref/Quotient.html
        ///</summary>
        corewolf::engine *Quotient(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Quotient[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses an offset d.
        /// https://reference.wolfram.com/language/ref/Quotient.html
        ///</summary>
        corewolf::engine *Quotient(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Quotient[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of the quotient and remainder from division of m by n.
        /// https://reference.wolfram.com/language/ref/QuotientRemainder.html
        ///</summary>
        corewolf::engine *QuotientRemainder(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("QuotientRemainder[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a radial axis plot where the yi are displayed on radial axes equally spaced around the origin.
        /// https://reference.wolfram.com/language/ref/RadialAxisPlot.html
        ///</summary>
        corewolf::engine *RadialAxisPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RadialAxisPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// is a two-dimensional graphics directive specifying that faces of polygons and other filled graphics objects are to be drawn using concentric circles of colors coli.
        /// https://reference.wolfram.com/language/ref/RadialGradientFilling.html
        ///</summary>
        corewolf::engine *RadialGradientFilling(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RadialGradientFilling[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// radiates from the center point {x,y}.
        /// https://reference.wolfram.com/language/ref/RadialGradientFilling.html
        ///</summary>
        corewolf::engine *RadialGradientFilling(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RadialGradientFilling[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// radiates from the center point {x,y} in concentric axis-aligned ellipsoids with semiaxes length proportional to ri.
        /// https://reference.wolfram.com/language/ref/RadialGradientFilling.html
        ///</summary>
        corewolf::engine *RadialGradientFilling(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RadialGradientFilling[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses the specified padding when drawing beyond the boundary radii r1 and rn.
        /// https://reference.wolfram.com/language/ref/RadialGradientFilling.html
        ///</summary>
        corewolf::engine *RadialGradientFilling(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("RadialGradientFilling[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// returns an image with values radially changing from center to corners based on gradient color gcol.
        /// https://reference.wolfram.com/language/ref/RadialGradientImage.html
        ///</summary>
        corewolf::engine *RadialGradientImage(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RadialGradientImage[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a radial gradient image of the specified size.
        /// https://reference.wolfram.com/language/ref/RadialGradientImage.html
        ///</summary>
        corewolf::engine *RadialGradientImage(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RadialGradientImage[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an image converted to the specified type.
        /// https://reference.wolfram.com/language/ref/RadialGradientImage.html
        ///</summary>
        corewolf::engine *RadialGradientImage(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RadialGradientImage[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of radiality centralities for the vertices in the graph g.
        /// https://reference.wolfram.com/language/ref/RadialityCentrality.html
        ///</summary>
        corewolf::engine *RadialityCentrality(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RadialityCentrality[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of in-centralities for a directed graph g.
        /// https://reference.wolfram.com/language/ref/RadialityCentrality.html
        ///</summary>
        corewolf::engine *RadialityCentrality(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RadialityCentrality[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/RadialityCentrality.html
        ///</summary>
        corewolf::engine *RadialityCentrality(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RadialityCentrality[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a low-level box construct that represents the displayed const std::string & in notebook expressions.
        /// https://reference.wolfram.com/language/ref/RadicalBox.html
        ///</summary>
        corewolf::engine *RadicalBox(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RadicalBox[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a radio button whose setting x is set to val when the button is clicked.
        /// https://reference.wolfram.com/language/ref/RadioButton.html
        ///</summary>
        corewolf::engine *RadioButton(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RadioButton[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a radio button bar with setting x and with labeled radio buttons for values vali.
        /// https://reference.wolfram.com/language/ref/RadioButtonBar.html
        ///</summary>
        corewolf::engine *RadioButtonBar(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RadioButtonBar[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives an image representing the discrete Radon transform of image.
        /// https://reference.wolfram.com/language/ref/Radon.html
        ///</summary>
        corewolf::engine *Radon(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Radon[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies the width w and the height h of the resulting image.
        /// https://reference.wolfram.com/language/ref/Radon.html
        ///</summary>
        corewolf::engine *Radon(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Radon[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// computes the Radon transform only for angles from θ1 to θ2.
        /// https://reference.wolfram.com/language/ref/Radon.html
        ///</summary>
        corewolf::engine *Radon(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Radon[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Radon transform of expr.
        /// https://reference.wolfram.com/language/ref/RadonTransform.html
        ///</summary>
        corewolf::engine *RadonTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RadonTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Ramanujan  function .
        /// https://reference.wolfram.com/language/ref/RamanujanTau.html
        ///</summary>
        corewolf::engine *RamanujanTau(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RamanujanTau[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Ramanujan tau Dirichlet L-function .
        /// https://reference.wolfram.com/language/ref/RamanujanTauL.html
        ///</summary>
        corewolf::engine *RamanujanTauL(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RamanujanTauL[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Ramanujan tau theta function .
        /// https://reference.wolfram.com/language/ref/RamanujanTauTheta.html
        ///</summary>
        corewolf::engine *RamanujanTauTheta(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RamanujanTauTheta[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Ramanujan tau Z-function .
        /// https://reference.wolfram.com/language/ref/RamanujanTauZ.html
        ///</summary>
        corewolf::engine *RamanujanTauZ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RamanujanTauZ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives x if x≥0 and 0 otherwise.
        /// https://reference.wolfram.com/language/ref/Ramp.html
        ///</summary>
        corewolf::engine *Ramp(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Ramp[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a net layer that has no input and produces a random array from the univariate distribution dist.
        /// https://reference.wolfram.com/language/ref/RandomArrayLayer.html
        ///</summary>
        corewolf::engine *RandomArrayLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomArrayLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom choice of one of the ei.
        /// https://reference.wolfram.com/language/ref/RandomChoice.html
        ///</summary>
        corewolf::engine *RandomChoice(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RandomChoice[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of n pseudorandom choices.
        /// https://reference.wolfram.com/language/ref/RandomChoice.html
        ///</summary>
        corewolf::engine *RandomChoice(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomChoice[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an n1×n2×… array of pseudorandom choices.
        /// https://reference.wolfram.com/language/ref/RandomChoice.html
        ///</summary>
        corewolf::engine *RandomChoice(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RandomChoice[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom color directive in the RGBColor space.
        /// https://reference.wolfram.com/language/ref/RandomColor.html
        ///</summary>
        corewolf::engine *RandomColor(const std::string &name = "")
        {
            return this->execute("RandomColor[]", name);
        }

        ///< summary>
        /// gives n pseudorandom colors.
        /// https://reference.wolfram.com/language/ref/RandomColor.html
        ///</summary>
        corewolf::engine *RandomColor(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomColor[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives n colors.
        /// https://reference.wolfram.com/language/ref/RandomColor.html
        ///</summary>
        corewolf::engine *RandomColor(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomColor[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an array of colors.
        /// https://reference.wolfram.com/language/ref/RandomColor.html
        ///</summary>
        corewolf::engine *RandomColor(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RandomColor[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom complex number with real and imaginary parts in the range 0 to 1.
        /// https://reference.wolfram.com/language/ref/RandomComplex.html
        ///</summary>
        corewolf::engine *RandomComplex(const std::string &name = "")
        {
            return this->execute("RandomComplex[]", name);
        }

        ///< summary>
        /// gives a pseudorandom complex number in the rectangle with corners given by the complex numbers zmin and zmax.
        /// https://reference.wolfram.com/language/ref/RandomComplex.html
        ///</summary>
        corewolf::engine *RandomComplex(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RandomComplex[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom complex number in the rectangle whose corners are the origin and zmax.
        /// https://reference.wolfram.com/language/ref/RandomComplex.html
        ///</summary>
        corewolf::engine *RandomComplex(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomComplex[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of n pseudorandom complex numbers.
        /// https://reference.wolfram.com/language/ref/RandomComplex.html
        ///</summary>
        corewolf::engine *RandomComplex(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomComplex[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an n1×n2×… array of pseudorandom complex numbers.
        /// https://reference.wolfram.com/language/ref/RandomComplex.html
        ///</summary>
        corewolf::engine *RandomComplex(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RandomComplex[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom entity with a type determined by the specification spec.
        /// https://reference.wolfram.com/language/ref/RandomEntity.html
        ///</summary>
        corewolf::engine *RandomEntity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomEntity[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of n pseudorandom entities.
        /// https://reference.wolfram.com/language/ref/RandomEntity.html
        ///</summary>
        corewolf::engine *RandomEntity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomEntity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a pseudorandom function from the process proc from tmin to tmax.
        /// https://reference.wolfram.com/language/ref/RandomFunction.html
        ///</summary>
        corewolf::engine *RandomFunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RandomFunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates an ensemble of n pseudorandom functions.
        /// https://reference.wolfram.com/language/ref/RandomFunction.html
        ///</summary>
        corewolf::engine *RandomFunction(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RandomFunction[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a representation of the internal state of a pseudorandom generator.
        /// https://reference.wolfram.com/language/ref/RandomGeneratorState.html
        ///</summary>
        corewolf::engine *RandomGeneratorState(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomGeneratorState[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom geo position uniformly distributed on the surface of the Earth.
        /// https://reference.wolfram.com/language/ref/RandomGeoPosition.html
        ///</summary>
        corewolf::engine *RandomGeoPosition(const std::string &name = "")
        {
            return this->execute("RandomGeoPosition[]", name);
        }

        ///< summary>
        /// gives a pseudorandom geo position uniformly distributed in the given geo bounding box.
        /// https://reference.wolfram.com/language/ref/RandomGeoPosition.html
        ///</summary>
        corewolf::engine *RandomGeoPosition(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RandomGeoPosition[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom geo position uniformly distributed in the geo region g.
        /// https://reference.wolfram.com/language/ref/RandomGeoPosition.html
        ///</summary>
        corewolf::engine *RandomGeoPosition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomGeoPosition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of n pseudorandom geo positions uniformly distributed in the geo region g.
        /// https://reference.wolfram.com/language/ref/RandomGeoPosition.html
        ///</summary>
        corewolf::engine *RandomGeoPosition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomGeoPosition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an n1× n2×… pseudorandom geo position array.
        /// https://reference.wolfram.com/language/ref/RandomGeoPosition.html
        ///</summary>
        corewolf::engine *RandomGeoPosition(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RandomGeoPosition[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom graph with n vertices and m edges.
        /// https://reference.wolfram.com/language/ref/RandomGraph.html
        ///</summary>
        corewolf::engine *RandomGraph(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RandomGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of k pseudorandom graphs.
        /// https://reference.wolfram.com/language/ref/RandomGraph.html
        ///</summary>
        corewolf::engine *RandomGraph(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// samples from the random graph distribution gdist.
        /// https://reference.wolfram.com/language/ref/RandomGraph.html
        ///</summary>
        corewolf::engine *RandomGraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomGraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an image with pseudorandom pixel values in the range 0 to max.
        /// https://reference.wolfram.com/language/ref/RandomImage.html
        ///</summary>
        corewolf::engine *RandomImage(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomImage[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates pseudorandom pixel values in the range min to max.
        /// https://reference.wolfram.com/language/ref/RandomImage.html
        ///</summary>
        corewolf::engine *RandomImage(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RandomImage[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates a random image of the specified size.
        /// https://reference.wolfram.com/language/ref/RandomImage.html
        ///</summary>
        corewolf::engine *RandomImage(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomImage[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an image converted to the specified type.
        /// https://reference.wolfram.com/language/ref/RandomImage.html
        ///</summary>
        corewolf::engine *RandomImage(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RandomImage[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds a random instance of an expression such as a geometric scene or biomolecular sequence.
        /// https://reference.wolfram.com/language/ref/RandomInstance.html
        ///</summary>
        corewolf::engine *RandomInstance(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomInstance[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds n instances.
        /// https://reference.wolfram.com/language/ref/RandomInstance.html
        ///</summary>
        corewolf::engine *RandomInstance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomInstance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom integer in the range {imin,imax}.
        /// https://reference.wolfram.com/language/ref/RandomInteger.html
        ///</summary>
        corewolf::engine *RandomInteger(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RandomInteger[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom integer in the range {0,,imax}.
        /// https://reference.wolfram.com/language/ref/RandomInteger.html
        ///</summary>
        corewolf::engine *RandomInteger(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomInteger[" + arg0 + "]", name);
        }

        ///< summary>
        /// pseudorandomly gives 0 or 1.
        /// https://reference.wolfram.com/language/ref/RandomInteger.html
        ///</summary>
        corewolf::engine *RandomInteger(const std::string &name = "")
        {
            return this->execute("RandomInteger[]", name);
        }

        ///< summary>
        /// gives a list of n pseudorandom integers.
        /// https://reference.wolfram.com/language/ref/RandomInteger.html
        ///</summary>
        corewolf::engine *RandomInteger(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomInteger[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an n1×n2×… array of pseudorandom integers.
        /// https://reference.wolfram.com/language/ref/RandomInteger.html
        ///</summary>
        corewolf::engine *RandomInteger(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RandomInteger[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom permutation in the permutation group gr.
        /// https://reference.wolfram.com/language/ref/RandomPermutation.html
        ///</summary>
        corewolf::engine *RandomPermutation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomPermutation[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of n pseudorandom permutations in the permutation group gr.
        /// https://reference.wolfram.com/language/ref/RandomPermutation.html
        ///</summary>
        corewolf::engine *RandomPermutation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomPermutation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom point uniformly distributed in the region reg.
        /// https://reference.wolfram.com/language/ref/RandomPoint.html
        ///</summary>
        corewolf::engine *RandomPoint(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomPoint[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of n pseudorandom points uniformly distributed in the region reg.
        /// https://reference.wolfram.com/language/ref/RandomPoint.html
        ///</summary>
        corewolf::engine *RandomPoint(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomPoint[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an n1× n2×… array of pseudorandom points.
        /// https://reference.wolfram.com/language/ref/RandomPoint.html
        ///</summary>
        corewolf::engine *RandomPoint(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RandomPoint[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// restricts to the bounds .
        /// https://reference.wolfram.com/language/ref/RandomPoint.html
        ///</summary>
        corewolf::engine *RandomPoint(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RandomPoint[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates a pseudorandom spatial point configuration from the spatial point process pproc in the observation region reg.
        /// https://reference.wolfram.com/language/ref/RandomPointConfiguration.html
        ///</summary>
        corewolf::engine *RandomPointConfiguration(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomPointConfiguration[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates an ensemble of n spatial point configurations.
        /// https://reference.wolfram.com/language/ref/RandomPointConfiguration.html
        ///</summary>
        corewolf::engine *RandomPointConfiguration(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RandomPointConfiguration[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom simple polygon with n vertex points.
        /// https://reference.wolfram.com/language/ref/RandomPolygon.html
        ///</summary>
        corewolf::engine *RandomPolygon(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomPolygon[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of k pseudorandom polygons.
        /// https://reference.wolfram.com/language/ref/RandomPolygon.html
        ///</summary>
        corewolf::engine *RandomPolygon(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomPolygon[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom polyhedron with the specified specification spec.
        /// https://reference.wolfram.com/language/ref/RandomPolyhedron.html
        ///</summary>
        corewolf::engine *RandomPolyhedron(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomPolyhedron[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of k pseudorandom polyhedra.
        /// https://reference.wolfram.com/language/ref/RandomPolyhedron.html
        ///</summary>
        corewolf::engine *RandomPolyhedron(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomPolyhedron[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom prime number in the range imin to imax.
        /// https://reference.wolfram.com/language/ref/RandomPrime.html
        ///</summary>
        corewolf::engine *RandomPrime(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RandomPrime[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom prime number in the range 2 to imax.
        /// https://reference.wolfram.com/language/ref/RandomPrime.html
        ///</summary>
        corewolf::engine *RandomPrime(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomPrime[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of n pseudorandom primes.
        /// https://reference.wolfram.com/language/ref/RandomPrime.html
        ///</summary>
        corewolf::engine *RandomPrime(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomPrime[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom real number in the range 0 to 1.
        /// https://reference.wolfram.com/language/ref/RandomReal.html
        ///</summary>
        corewolf::engine *RandomReal(const std::string &name = "")
        {
            return this->execute("RandomReal[]", name);
        }

        ///< summary>
        /// gives a pseudorandom real number in the range xmin to xmax.
        /// https://reference.wolfram.com/language/ref/RandomReal.html
        ///</summary>
        corewolf::engine *RandomReal(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RandomReal[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom real number in the range 0 to xmax.
        /// https://reference.wolfram.com/language/ref/RandomReal.html
        ///</summary>
        corewolf::engine *RandomReal(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomReal[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of n pseudorandom reals.
        /// https://reference.wolfram.com/language/ref/RandomReal.html
        ///</summary>
        corewolf::engine *RandomReal(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomReal[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an n1×n2×… array of pseudorandom reals.
        /// https://reference.wolfram.com/language/ref/RandomReal.html
        ///</summary>
        corewolf::engine *RandomReal(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RandomReal[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom sample of n of the ei.
        /// https://reference.wolfram.com/language/ref/RandomSample.html
        ///</summary>
        corewolf::engine *RandomSample(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomSample[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom permutation of the ei.
        /// https://reference.wolfram.com/language/ref/RandomSample.html
        ///</summary>
        corewolf::engine *RandomSample(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RandomSample[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom tree with n nodes.
        /// https://reference.wolfram.com/language/ref/RandomTree.html
        ///</summary>
        corewolf::engine *RandomTree(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomTree[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of k pseudorandom trees.
        /// https://reference.wolfram.com/language/ref/RandomTree.html
        ///</summary>
        corewolf::engine *RandomTree(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomTree[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a k1× k2×… array of trees.
        /// https://reference.wolfram.com/language/ref/RandomTree.html
        ///</summary>
        corewolf::engine *RandomTree(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RandomTree[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom variate from the symbolic distribution dist.
        /// https://reference.wolfram.com/language/ref/RandomVariate.html
        ///</summary>
        corewolf::engine *RandomVariate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomVariate[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of n pseudorandom variates from the symbolic distribution dist.
        /// https://reference.wolfram.com/language/ref/RandomVariate.html
        ///</summary>
        corewolf::engine *RandomVariate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomVariate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an n1× n2×… array of pseudorandom variates from the symbolic distribution dist.
        /// https://reference.wolfram.com/language/ref/RandomVariate.html
        ///</summary>
        corewolf::engine *RandomVariate(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RandomVariate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a random walk on a line with the probability of a positive unit step p and the probability of a negative unit step 1-p.
        /// https://reference.wolfram.com/language/ref/RandomWalkProcess.html
        ///</summary>
        corewolf::engine *RandomWalkProcess(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomWalkProcess[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a random walk with the probability of a positive unit step p, the probability of a negative unit step q, and the probability of a zero step 1-p-q.
        /// https://reference.wolfram.com/language/ref/RandomWalkProcess.html
        ///</summary>
        corewolf::engine *RandomWalkProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomWalkProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a pseudorandom commonly used word.
        /// https://reference.wolfram.com/language/ref/RandomWord.html
        ///</summary>
        corewolf::engine *RandomWord(const std::string &name = "")
        {
            return this->execute("RandomWord[]", name);
        }

        ///< summary>
        /// gives a list of n pseudorandom words.
        /// https://reference.wolfram.com/language/ref/RandomWord.html
        ///</summary>
        corewolf::engine *RandomWord(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RandomWord[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of n pseudorandom words of the specified type.
        /// https://reference.wolfram.com/language/ref/RandomWord.html
        ///</summary>
        corewolf::engine *RandomWord(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RandomWord[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates the list {1,2,…,imax}.
        /// https://reference.wolfram.com/language/ref/Range.html
        ///</summary>
        corewolf::engine *Range(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Range[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates the list {imin,…,imax}.
        /// https://reference.wolfram.com/language/ref/Range.html
        ///</summary>
        corewolf::engine *Range(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Range[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses step di.
        /// https://reference.wolfram.com/language/ref/Range.html
        ///</summary>
        corewolf::engine *Range(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Range[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// filters data by replacing every value by the difference of the maximum and minimum in its range-r neighborhood.
        /// https://reference.wolfram.com/language/ref/RangeFilter.html
        ///</summary>
        corewolf::engine *RangeFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RangeFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses ri for filtering the dimension in data.
        /// https://reference.wolfram.com/language/ref/RangeFilter.html
        ///</summary>
        corewolf::engine *RangeFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RangeFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the n largest element in list.
        /// https://reference.wolfram.com/language/ref/RankedMax.html
        ///</summary>
        corewolf::engine *RankedMax(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RankedMax[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the n smallest element in list.
        /// https://reference.wolfram.com/language/ref/RankedMin.html
        ///</summary>
        corewolf::engine *RankedMin(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RankedMin[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes the probability for distribution dist to generate a sample that has a lower or equal PDF than example.
        /// https://reference.wolfram.com/language/ref/RarerProbability.html
        ///</summary>
        corewolf::engine *RarerProbability(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RarerProbability[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes the rarer probability for each exi.
        /// https://reference.wolfram.com/language/ref/RarerProbability.html
        ///</summary>
        corewolf::engine *RarerProbability(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RarerProbability[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is a two-dimensional graphics primitive which represents a rectangular array of gray cells.
        /// https://reference.wolfram.com/language/ref/Raster.html
        ///</summary>
        corewolf::engine *Raster(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Raster[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// is a three-dimensional graphics primitive that represents a cubical array of gray cells.
        /// https://reference.wolfram.com/language/ref/Raster3D.html
        ///</summary>
        corewolf::engine *Raster3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Raster3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a three-dimensional graphics primitive by giving the coordinates of opposite corners.
        /// https://reference.wolfram.com/language/ref/Raster3D.html
        ///</summary>
        corewolf::engine *Raster3D(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Raster3D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a three-dimensional graphics primitive whose voxel values should be scaled so that amin corresponds to 0 and amax corresponds to 1.
        /// https://reference.wolfram.com/language/ref/Raster3D.html
        ///</summary>
        corewolf::engine *Raster3D(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Raster3D[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// returns a rasterized version of the displayed form of expr.
        /// https://reference.wolfram.com/language/ref/Rasterize.html
        ///</summary>
        corewolf::engine *Rasterize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Rasterize[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the element elem associated with the rasterized form of expr.
        /// https://reference.wolfram.com/language/ref/Rasterize.html
        ///</summary>
        corewolf::engine *Rasterize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Rasterize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the specified elemi.
        /// https://reference.wolfram.com/language/ref/Rasterize.html
        ///</summary>
        corewolf::engine *Rasterize(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Rasterize[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives True if expr is structurally a rational expression in x, and False otherwise.
        /// https://reference.wolfram.com/language/ref/RationalExpressionQ.html
        ///</summary>
        corewolf::engine *RationalExpressionQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RationalExpressionQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if expr is structurally a rational expression in x,y,…, and False otherwise.
        /// https://reference.wolfram.com/language/ref/RationalExpressionQ.html
        ///</summary>
        corewolf::engine *RationalExpressionQ(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RationalExpressionQ[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives True if expr is structurally a rational expression in x,y,… with coefficients satisfying test, and False otherwise.
        /// https://reference.wolfram.com/language/ref/RationalExpressionQ.html
        ///</summary>
        corewolf::engine *RationalExpressionQ(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RationalExpressionQ[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// converts an approximate number x to a nearby rational with small denominator.
        /// https://reference.wolfram.com/language/ref/Rationalize.html
        ///</summary>
        corewolf::engine *Rationalize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Rationalize[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields the rational number with smallest denominator that lies within dx of x.
        /// https://reference.wolfram.com/language/ref/Rationalize.html
        ///</summary>
        corewolf::engine *Rationalize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Rationalize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the successive ratios of elements in list.
        /// https://reference.wolfram.com/language/ref/Ratios.html
        ///</summary>
        corewolf::engine *Ratios(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Ratios[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the n iterated ratios of list.
        /// https://reference.wolfram.com/language/ref/Ratios.html
        ///</summary>
        corewolf::engine *Ratios(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Ratios[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the successive nk ratios at level k in a nested list.
        /// https://reference.wolfram.com/language/ref/Ratios.html
        ///</summary>
        corewolf::engine *Ratios(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Ratios[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is a low-level construct which is formatted as boxes without further interpretation.
        /// https://reference.wolfram.com/language/ref/RawBoxes.html
        ///</summary>
        corewolf::engine *RawBoxes(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RawBoxes[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a low-level representation of the contents of a cell in which Show Cell Expression has been toggled.
        /// https://reference.wolfram.com/language/ref/RawData.html
        ///</summary>
        corewolf::engine *RawData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RawData[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the Rayleigh distribution with scale parameter σ.
        /// https://reference.wolfram.com/language/ref/RayleighDistribution.html
        ///</summary>
        corewolf::engine *RayleighDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RayleighDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the real part of the complex number z.
        /// https://reference.wolfram.com/language/ref/Re.html
        ///</summary>
        corewolf::engine *Re(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Re[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a version of the reaction rxn in which the stoichiometric coefficients for elements in the reactants and products are balanced.
        /// https://reference.wolfram.com/language/ref/ReactionBalance.html
        ///</summary>
        corewolf::engine *ReactionBalance(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReactionBalance[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if the given chemical reaction is balanced, and False otherwise.
        /// https://reference.wolfram.com/language/ref/ReactionBalancedQ.html
        ///</summary>
        corewolf::engine *ReactionBalancedQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReactionBalancedQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a reaction term  with reaction coefficient  and with model variables vars.
        /// https://reference.wolfram.com/language/ref/ReactionPDETerm.html
        ///</summary>
        corewolf::engine *ReactionPDETerm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReactionPDETerm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses model parameters pars.
        /// https://reference.wolfram.com/language/ref/ReactionPDETerm.html
        ///</summary>
        corewolf::engine *ReactionPDETerm(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ReactionPDETerm[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// reads one expression from an input stream and returns the expression.
        /// https://reference.wolfram.com/language/ref/Read.html
        ///</summary>
        corewolf::engine *Read(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Read[" + arg0 + "]", name);
        }

        ///< summary>
        /// reads one const std::string &of the specified type.
        /// https://reference.wolfram.com/language/ref/Read.html
        ///</summary>
        corewolf::engine *Read(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Read[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reads a sequence of objects of the specified types.
        /// https://reference.wolfram.com/language/ref/Read.html
        ///</summary>
        corewolf::engine *Read(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Read[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the contents of src as a ByteArray object.
        /// https://reference.wolfram.com/language/ref/ReadByteArray.html
        ///</summary>
        corewolf::engine *ReadByteArray(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReadByteArray[" + arg0 + "]", name);
        }

        ///< summary>
        /// reads the first n bytes from src.
        /// https://reference.wolfram.com/language/ref/ReadByteArray.html
        ///</summary>
        corewolf::engine *ReadByteArray(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReadByteArray[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reads a line of text from a file and returns it as a string.
        /// https://reference.wolfram.com/language/ref/ReadLine.html
        ///</summary>
        corewolf::engine *ReadLine(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReadLine[" + arg0 + "]", name);
        }

        ///< summary>
        /// reads all the remaining expressions in a file and returns a list of them.
        /// https://reference.wolfram.com/language/ref/ReadList.html
        ///</summary>
        corewolf::engine *ReadList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReadList[" + arg0 + "]", name);
        }

        ///< summary>
        /// reads objects of the specified type from a file, until the end of the file is reached. The list of objects read is returned.
        /// https://reference.wolfram.com/language/ref/ReadList.html
        ///</summary>
        corewolf::engine *ReadList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReadList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reads objects with a sequence of types, until the end of the file is reached.
        /// https://reference.wolfram.com/language/ref/ReadList.html
        ///</summary>
        corewolf::engine *ReadList(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ReadList[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// reads only the first n objects of the specified types.
        /// https://reference.wolfram.com/language/ref/ReadList.html
        ///</summary>
        corewolf::engine *ReadList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ReadList[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// reads the complete contents of a file and returns it as a string.
        /// https://reference.wolfram.com/language/ref/ReadString.html
        ///</summary>
        corewolf::engine *ReadString(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReadString[" + arg0 + "]", name);
        }

        ///< summary>
        /// reads until the terminator term is encountered.
        /// https://reference.wolfram.com/language/ref/ReadString.html
        ///</summary>
        corewolf::engine *ReadString(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReadString[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the absolute value of the real number x.
        /// https://reference.wolfram.com/language/ref/RealAbs.html
        ///</summary>
        corewolf::engine *RealAbs(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RealAbs[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of the digits in the approximate real number x, together with the number of digits that are to the left of the decimal point.
        /// https://reference.wolfram.com/language/ref/RealDigits.html
        ///</summary>
        corewolf::engine *RealDigits(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RealDigits[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of base‐b digits in x.
        /// https://reference.wolfram.com/language/ref/RealDigits.html
        ///</summary>
        corewolf::engine *RealDigits(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RealDigits[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of len digits.
        /// https://reference.wolfram.com/language/ref/RealDigits.html
        ///</summary>
        corewolf::engine *RealDigits(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RealDigits[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives len digits starting with the coefficient of bn.
        /// https://reference.wolfram.com/language/ref/RealDigits.html
        ///</summary>
        corewolf::engine *RealDigits(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("RealDigits[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives .
        /// https://reference.wolfram.com/language/ref/RealExponent.html
        ///</summary>
        corewolf::engine *RealExponent(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RealExponent[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives .
        /// https://reference.wolfram.com/language/ref/RealExponent.html
        ///</summary>
        corewolf::engine *RealExponent(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RealExponent[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives -1, 0 or 1 depending on whether x is negative, zero or positive.
        /// https://reference.wolfram.com/language/ref/RealSign.html
        ///</summary>
        corewolf::engine *RealSign(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RealSign[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of expr together with all expressions to which Sow has been applied during its evaluation. Expressions sown using Sow[e] or Sow[e,tagi] with different tags are given in different lists.
        /// https://reference.wolfram.com/language/ref/Reap.html
        ///</summary>
        corewolf::engine *Reap(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Reap[" + arg0 + "]", name);
        }

        ///< summary>
        /// reaps only expressions sown with tags that match patt.
        /// https://reference.wolfram.com/language/ref/Reap.html
        ///</summary>
        corewolf::engine *Reap(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Reap[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// puts expressions associated with each of the patti in a separate list.
        /// https://reference.wolfram.com/language/ref/Reap.html
        ///</summary>
        corewolf::engine *Reap(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Reap[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns {expr,{f[tag1,{e11,e12,…}],…}}.
        /// https://reference.wolfram.com/language/ref/Reap.html
        ///</summary>
        corewolf::engine *Reap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Reap[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// reconstructs a mesh from a set of points pt1,pt2,….
        /// https://reference.wolfram.com/language/ref/ReconstructionMesh.html
        ///</summary>
        corewolf::engine *ReconstructionMesh(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ReconstructionMesh[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents an axis-aligned filled rectangle from {xmin,ymin} to {xmax,ymax}.
        /// https://reference.wolfram.com/language/ref/Rectangle.html
        ///</summary>
        corewolf::engine *Rectangle(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Rectangle[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// corresponds to a unit square with its bottom-left corner at {xmin,ymin}.
        /// https://reference.wolfram.com/language/ref/Rectangle.html
        ///</summary>
        corewolf::engine *Rectangle(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Rectangle[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a rectangle chart with bars of width xi and height yi.
        /// https://reference.wolfram.com/language/ref/RectangleChart.html
        ///</summary>
        corewolf::engine *RectangleChart(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RectangleChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a rectangle chart with bar features defined by the symbolic wrappers wk.
        /// https://reference.wolfram.com/language/ref/RectangleChart.html
        ///</summary>
        corewolf::engine *RectangleChart(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("RectangleChart[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// makes a rectangle chart from multiple datasets datai.
        /// https://reference.wolfram.com/language/ref/RectangleChart.html
        ///</summary>
        corewolf::engine *RectangleChart(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RectangleChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a 3D rectangle chart with bars of width xi, depth yi, and height zi.
        /// https://reference.wolfram.com/language/ref/RectangleChart3D.html
        ///</summary>
        corewolf::engine *RectangleChart3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RectangleChart3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a 3D rectangle chart with bar features defined by the symbolic wrappers wk.
        /// https://reference.wolfram.com/language/ref/RectangleChart3D.html
        ///</summary>
        corewolf::engine *RectangleChart3D(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("RectangleChart3D[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// makes a 3D rectangle chart from multiple datasets datai.
        /// https://reference.wolfram.com/language/ref/RectangleChart3D.html
        ///</summary>
        corewolf::engine *RectangleChart3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RectangleChart3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a rectangular array of elements of type spec in an interpreter, API or form specification.
        /// https://reference.wolfram.com/language/ref/RectangularRepeatingElement.html
        ///</summary>
        corewolf::engine *RectangularRepeatingElement(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RectangularRepeatingElement[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a rectangular array of elements of maximum size maxrows×maxcolums.
        /// https://reference.wolfram.com/language/ref/RectangularRepeatingElement.html
        ///</summary>
        corewolf::engine *RectangularRepeatingElement(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RectangularRepeatingElement[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a rectangular array of elements of dimensions between minrows×mincolumns and maxrows×maxcolums.
        /// https://reference.wolfram.com/language/ref/RectangularRepeatingElement.html
        ///</summary>
        corewolf::engine *RectangularRepeatingElement(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RectangularRepeatingElement[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// filters x using a linear recurrence equation with coefficients α and β.
        /// https://reference.wolfram.com/language/ref/RecurrenceFilter.html
        ///</summary>
        corewolf::engine *RecurrenceFilter(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RecurrenceFilter[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses a discrete-time filter defined by the TransferFunctionModel tf.
        /// https://reference.wolfram.com/language/ref/RecurrenceFilter.html
        ///</summary>
        corewolf::engine *RecurrenceFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RecurrenceFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses a specified list {y0,y-1,…} as the initial condition.
        /// https://reference.wolfram.com/language/ref/RecurrenceFilter.html
        ///</summary>
        corewolf::engine *RecurrenceFilter(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RecurrenceFilter[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates a list of values of expr for successive n based on solving the recurrence equations eqns.
        /// https://reference.wolfram.com/language/ref/RecurrenceTable.html
        ///</summary>
        corewolf::engine *RecurrenceTable(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RecurrenceTable[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates a list of values of expr over the range of n values specified by nspec.
        /// https://reference.wolfram.com/language/ref/RecurrenceTable.html
        ///</summary>
        corewolf::engine *RecurrenceTable(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RecurrenceTable[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates an array of values of expr for successive n1, n2, … .
        /// https://reference.wolfram.com/language/ref/RecurrenceTable.html
        ///</summary>
        corewolf::engine *RecurrenceTable(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("RecurrenceTable[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// reduces the statement expr by solving equations or inequalities for vars and eliminating quantifiers.
        /// https://reference.wolfram.com/language/ref/Reduce.html
        ///</summary>
        corewolf::engine *Reduce(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Reduce[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// does the reduction over the domain dom. Common choices of dom are Reals, Integers, and Complexes.
        /// https://reference.wolfram.com/language/ref/Reduce.html
        ///</summary>
        corewolf::engine *Reduce(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Reduce[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the form of expr that would be obtained if symbols in it were replaced by explicit numerical expressions satisfying the assumptions assum.
        /// https://reference.wolfram.com/language/ref/Refine.html
        ///</summary>
        corewolf::engine *Refine(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Refine[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses default assumptions specified by any enclosing Assuming constructs.
        /// https://reference.wolfram.com/language/ref/Refine.html
        ///</summary>
        corewolf::engine *Refine(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Refine[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the matrix that represents reflection of points in a mirror normal to the vector v.
        /// https://reference.wolfram.com/language/ref/ReflectionMatrix.html
        ///</summary>
        corewolf::engine *ReflectionMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReflectionMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a TransformationFunction that represents a reflection in a mirror through the origin, normal to the vector v.
        /// https://reference.wolfram.com/language/ref/ReflectionTransform.html
        ///</summary>
        corewolf::engine *ReflectionTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReflectionTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a reflection in a mirror through the point p, normal to the vector v.
        /// https://reference.wolfram.com/language/ref/ReflectionTransform.html
        ///</summary>
        corewolf::engine *ReflectionTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReflectionTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an const std::string &whose value in a Dynamic should be refreshed at times specified by the options opts.
        /// https://reference.wolfram.com/language/ref/Refresh.html
        ///</summary>
        corewolf::engine *Refresh(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Refresh[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a geometric region.
        /// https://reference.wolfram.com/language/ref/Region.html
        ///</summary>
        corewolf::engine *Region(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Region[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a region that uses the specified options.
        /// https://reference.wolfram.com/language/ref/Region.html
        ///</summary>
        corewolf::engine *Region(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Region[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a binary version of image that includes the foreground pixels of marker and also connected regions whose pixel values are within a distance d.
        /// https://reference.wolfram.com/language/ref/RegionBinarize.html
        ///</summary>
        corewolf::engine *RegionBinarize(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RegionBinarize[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// grows regions in marker by adding pixels whose average intensity is also constrained within an interval {t1,t2}.
        /// https://reference.wolfram.com/language/ref/RegionBinarize.html
        ///</summary>
        corewolf::engine *RegionBinarize(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("RegionBinarize[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// represents the boundary of the region reg.
        /// https://reference.wolfram.com/language/ref/RegionBoundary.html
        ///</summary>
        corewolf::engine *RegionBoundary(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RegionBoundary[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the bounds for the region reg.
        /// https://reference.wolfram.com/language/ref/RegionBounds.html
        ///</summary>
        corewolf::engine *RegionBounds(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RegionBounds[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives region bounds of the specified "type".
        /// https://reference.wolfram.com/language/ref/RegionBounds.html
        ///</summary>
        corewolf::engine *RegionBounds(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionBounds[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the centroid of the region reg.
        /// https://reference.wolfram.com/language/ref/RegionCentroid.html
        ///</summary>
        corewolf::engine *RegionCentroid(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RegionCentroid[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the regions reg1 and reg2 are congruent.
        /// https://reference.wolfram.com/language/ref/RegionCongruent.html
        ///</summary>
        corewolf::engine *RegionCongruent(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionCongruent[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts the region representation reg to the specified form.
        /// https://reference.wolfram.com/language/ref/RegionConvert.html
        ///</summary>
        corewolf::engine *RegionConvert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionConvert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the difference of the regions reg1 and reg2.
        /// https://reference.wolfram.com/language/ref/RegionDifference.html
        ///</summary>
        corewolf::engine *RegionDifference(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionDifference[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the dilation of the region reg by a disk of radius r centered at the origin.
        /// https://reference.wolfram.com/language/ref/RegionDilation.html
        ///</summary>
        corewolf::engine *RegionDilation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionDilation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the dilation of reg1 scaled by a factor u and reg2 scaled by a factor v.
        /// https://reference.wolfram.com/language/ref/RegionDilation.html
        ///</summary>
        corewolf::engine *RegionDilation(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RegionDilation[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the geometric dimension of the region reg.
        /// https://reference.wolfram.com/language/ref/RegionDimension.html
        ///</summary>
        corewolf::engine *RegionDimension(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RegionDimension[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if the regions reg1 and reg2 are disjoint.
        /// https://reference.wolfram.com/language/ref/RegionDisjoint.html
        ///</summary>
        corewolf::engine *RegionDisjoint(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionDisjoint[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns True if the regions reg1, reg2, reg3, … are pairwise disjoint.
        /// https://reference.wolfram.com/language/ref/RegionDisjoint.html
        ///</summary>
        corewolf::engine *RegionDisjoint(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("RegionDisjoint[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the minimum distance from the point p to the region reg.
        /// https://reference.wolfram.com/language/ref/RegionDistance.html
        ///</summary>
        corewolf::engine *RegionDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a RegionDistanceFunction[…] that can be applied repeatedly to different points.
        /// https://reference.wolfram.com/language/ref/RegionDistance.html
        ///</summary>
        corewolf::engine *RegionDistance(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RegionDistance[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a function whose values give the distance from a point to the region reg.
        /// https://reference.wolfram.com/language/ref/RegionDistanceFunction.html
        ///</summary>
        corewolf::engine *RegionDistanceFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionDistanceFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the dimension of the space in which the region reg is embedded.
        /// https://reference.wolfram.com/language/ref/RegionEmbeddingDimension.html
        ///</summary>
        corewolf::engine *RegionEmbeddingDimension(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RegionEmbeddingDimension[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if the regions reg1 and reg2 are equal.
        /// https://reference.wolfram.com/language/ref/RegionEqual.html
        ///</summary>
        corewolf::engine *RegionEqual(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionEqual[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns True if the regions reg1, reg2, reg3, … are all equal.
        /// https://reference.wolfram.com/language/ref/RegionEqual.html
        ///</summary>
        corewolf::engine *RegionEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("RegionEqual[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the erosion of the region reg by a disk of radius r centered at the origin.
        /// https://reference.wolfram.com/language/ref/RegionErosion.html
        ///</summary>
        corewolf::engine *RegionErosion(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionErosion[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the erosion of reg1 scaled by a factor u and reg2 scaled by a factor v.
        /// https://reference.wolfram.com/language/ref/RegionErosion.html
        ///</summary>
        corewolf::engine *RegionErosion(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RegionErosion[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// finds a geometric region "model" that best fits the points p1,p2,….
        /// https://reference.wolfram.com/language/ref/RegionFit.html
        ///</summary>
        corewolf::engine *RegionFit(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies what fit property "prop" should be returned.
        /// https://reference.wolfram.com/language/ref/RegionFit.html
        ///</summary>
        corewolf::engine *RegionFit(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RegionFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns a rasterized grayscale 2D or 3D image of reg.
        /// https://reference.wolfram.com/language/ref/RegionImage.html
        ///</summary>
        corewolf::engine *RegionImage(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RegionImage[" + arg0 + "]", name);
        }

        ///< summary>
        /// restricts to the bounds .
        /// https://reference.wolfram.com/language/ref/RegionImage.html
        ///</summary>
        corewolf::engine *RegionImage(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RegionImage[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the intersection of the regions reg1, reg2, ….
        /// https://reference.wolfram.com/language/ref/RegionIntersection.html
        ///</summary>
        corewolf::engine *RegionIntersection(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RegionIntersection[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the measure of the region reg.
        /// https://reference.wolfram.com/language/ref/RegionMeasure.html
        ///</summary>
        corewolf::engine *RegionMeasure(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RegionMeasure[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the d-dimensional measure of the region reg.
        /// https://reference.wolfram.com/language/ref/RegionMeasure.html
        ///</summary>
        corewolf::engine *RegionMeasure(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionMeasure[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the k-measure of the parametric formula whose Cartesian coordinates xi are functions of tj.
        /// https://reference.wolfram.com/language/ref/RegionMeasure.html
        ///</summary>
        corewolf::engine *RegionMeasure(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("RegionMeasure[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// interprets the xi as coordinates in the specified coordinate chart.
        /// https://reference.wolfram.com/language/ref/RegionMeasure.html
        ///</summary>
        corewolf::engine *RegionMeasure(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("RegionMeasure[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// gives True if the numeric point {x,y,…} is a member of the constant region reg and False otherwise.
        /// https://reference.wolfram.com/language/ref/RegionMember.html
        ///</summary>
        corewolf::engine *RegionMember(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RegionMember[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns a RegionMemberFunction[…] that can be applied repeatedly to different points.
        /// https://reference.wolfram.com/language/ref/RegionMember.html
        ///</summary>
        corewolf::engine *RegionMember(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RegionMember[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a function whose values give whether a point is in a region reg or not.
        /// https://reference.wolfram.com/language/ref/RegionMemberFunction.html
        ///</summary>
        corewolf::engine *RegionMemberFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionMemberFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes the polynomial moment  for the region reg.
        /// https://reference.wolfram.com/language/ref/RegionMoment.html
        ///</summary>
        corewolf::engine *RegionMoment(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RegionMoment[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a point in the region reg that is nearest the point p.
        /// https://reference.wolfram.com/language/ref/RegionNearest.html
        ///</summary>
        corewolf::engine *RegionNearest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionNearest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a RegionNearestFunction[…] that can be repeatedly applied to points.
        /// https://reference.wolfram.com/language/ref/RegionNearest.html
        ///</summary>
        corewolf::engine *RegionNearest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RegionNearest[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a function whose values give the nearest point in the region reg.
        /// https://reference.wolfram.com/language/ref/RegionNearestFunction.html
        ///</summary>
        corewolf::engine *RegionNearestFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionNearestFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// makes a plot showing the region in which pred is True.
        /// https://reference.wolfram.com/language/ref/RegionPlot.html
        ///</summary>
        corewolf::engine *RegionPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RegionPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// plots several regions corresponding to the predi.
        /// https://reference.wolfram.com/language/ref/RegionPlot.html
        ///</summary>
        corewolf::engine *RegionPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// makes a plot showing the three-dimensional region in which pred is True.
        /// https://reference.wolfram.com/language/ref/RegionPlot3D.html
        ///</summary>
        corewolf::engine *RegionPlot3D(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("RegionPlot3D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// plots several regions corresponding to the predi.
        /// https://reference.wolfram.com/language/ref/RegionPlot3D.html
        ///</summary>
        corewolf::engine *RegionPlot3D(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the Cartesian product of the regions reg1 and reg2.
        /// https://reference.wolfram.com/language/ref/RegionProduct.html
        ///</summary>
        corewolf::engine *RegionProduct(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionProduct[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the Cartesian product of the regions reg1, reg2, ….
        /// https://reference.wolfram.com/language/ref/RegionProduct.html
        ///</summary>
        corewolf::engine *RegionProduct(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RegionProduct[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives True if reg is a valid region and False otherwise.
        /// https://reference.wolfram.com/language/ref/RegionQ.html
        ///</summary>
        corewolf::engine *RegionQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RegionQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// resize the region reg to have the first side length l preserving side length ratios.
        /// https://reference.wolfram.com/language/ref/RegionResize.html
        ///</summary>
        corewolf::engine *RegionResize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionResize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// resize into a box with maximum side length lmax preserving side length ratios.
        /// https://reference.wolfram.com/language/ref/RegionResize.html
        ///</summary>
        corewolf::engine *RegionResize(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RegionResize[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// resize into a box with corners {x1,min,x2,min,…} and {x1,max,x2,max,…}.
        /// https://reference.wolfram.com/language/ref/RegionResize.html
        ///</summary>
        corewolf::engine *RegionResize(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RegionResize[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// tests whether the regions reg1 and reg2 are similar.
        /// https://reference.wolfram.com/language/ref/RegionSimilar.html
        ///</summary>
        corewolf::engine *RegionSimilar(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionSimilar[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the symmetric difference of the regions reg1, reg2, ….
        /// https://reference.wolfram.com/language/ref/RegionSymmetricDifference.html
        ///</summary>
        corewolf::engine *RegionSymmetricDifference(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RegionSymmetricDifference[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the union of the regions reg1, reg2, ….
        /// https://reference.wolfram.com/language/ref/RegionUnion.html
        ///</summary>
        corewolf::engine *RegionUnion(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RegionUnion[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns True if reg2 is contained within reg1.
        /// https://reference.wolfram.com/language/ref/RegionWithin.html
        ///</summary>
        corewolf::engine *RegionWithin(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegionWithin[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// registers the target for use as an external evaluator with the language or system sys.
        /// https://reference.wolfram.com/language/ref/RegisterExternalEvaluator.html
        ///</summary>
        corewolf::engine *RegisterExternalEvaluator(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegisterExternalEvaluator[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the generalized regular expression specified by the string "regex".
        /// https://reference.wolfram.com/language/ref/RegularExpression.html
        ///</summary>
        corewolf::engine *RegularExpression(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RegularExpression[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if tseries is a regular time series, and False otherwise.
        /// https://reference.wolfram.com/language/ref/RegularlySampledQ.html
        ///</summary>
        corewolf::engine *RegularlySampledQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RegularlySampledQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the regular polygon with n vertices equally spaced around the unit circle.
        /// https://reference.wolfram.com/language/ref/RegularPolygon.html
        ///</summary>
        corewolf::engine *RegularPolygon(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RegularPolygon[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the regular polygon of radius r.
        /// https://reference.wolfram.com/language/ref/RegularPolygon.html
        ///</summary>
        corewolf::engine *RegularPolygon(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegularPolygon[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// starts at angle θ with respect to the  axis.
        /// https://reference.wolfram.com/language/ref/RegularPolygon.html
        ///</summary>
        corewolf::engine *RegularPolygon(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RegularPolygon[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// centers the polygon at {x,y}.
        /// https://reference.wolfram.com/language/ref/RegularPolygon.html
        ///</summary>
        corewolf::engine *RegularPolygon(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RegularPolygon[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the list {Re[z],Im[z]} of the number z.
        /// https://reference.wolfram.com/language/ref/ReIm.html
        ///</summary>
        corewolf::engine *ReIm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReIm[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a plot of Re[f] and Im[f] as functions of x∈ from xmin to xmax.
        /// https://reference.wolfram.com/language/ref/ReImPlot.html
        ///</summary>
        corewolf::engine *ReImPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ReImPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots several functions.
        /// https://reference.wolfram.com/language/ref/ReImPlot.html
        ///</summary>
        corewolf::engine *ReImPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ReImPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots fi with features defined by the symbolic wrapper w.
        /// https://reference.wolfram.com/language/ref/ReImPlot.html
        ///</summary>
        corewolf::engine *ReImPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReImPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// takes the variable x to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/ReImPlot.html
        ///</summary>
        corewolf::engine *ReImPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReImPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents schema information about a relational database.
        /// https://reference.wolfram.com/language/ref/RelationalDatabase.html
        ///</summary>
        corewolf::engine *RelationalDatabase(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RelationalDatabase[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives schema information related to the tables tablei.
        /// https://reference.wolfram.com/language/ref/RelationalDatabase.html
        ///</summary>
        corewolf::engine *RelationalDatabase(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RelationalDatabase[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the graph with vertices vi and edges from vi to vj whenever f[vi,vj] is True.
        /// https://reference.wolfram.com/language/ref/RelationGraph.html
        ///</summary>
        corewolf::engine *RelationGraph(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RelationGraph[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the graph with vertices vi,wj and edges from vi to wj whenever f[vi,wj] is True.
        /// https://reference.wolfram.com/language/ref/RelationGraph.html
        ///</summary>
        corewolf::engine *RelationGraph(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RelationGraph[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// removes Hold, HoldForm, HoldPattern, and HoldComplete in expr.
        /// https://reference.wolfram.com/language/ref/ReleaseHold.html
        ///</summary>
        corewolf::engine *ReleaseHold(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReleaseHold[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the reliability distribution for a system with components xi having reliability distribution disti, where the whole system is working when the Boolean expression bexpr is True, and component xi is working when xi is True.
        /// https://reference.wolfram.com/language/ref/ReliabilityDistribution.html
        ///</summary>
        corewolf::engine *ReliabilityDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ReliabilityDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates a relief image of an array of height values.
        /// https://reference.wolfram.com/language/ref/ReliefImage.html
        ///</summary>
        corewolf::engine *ReliefImage(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReliefImage[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a relief plot of an array of height values.
        /// https://reference.wolfram.com/language/ref/ReliefPlot.html
        ///</summary>
        corewolf::engine *ReliefPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReliefPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// aborts a remote batch job.
        /// https://reference.wolfram.com/language/ref/RemoteBatchJobAbort.html
        ///</summary>
        corewolf::engine *RemoteBatchJobAbort(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoteBatchJobAbort[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a remote batch job submitted by RemoteBatchSubmit or RemoteBatchMapSubmit.
        /// https://reference.wolfram.com/language/ref/RemoteBatchJobObject.html
        ///</summary>
        corewolf::engine *RemoteBatchJobObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoteBatchJobObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of RemoteBatchJobObject expressions representing batch jobs submitted using env.
        /// https://reference.wolfram.com/language/ref/RemoteBatchJobs.html
        ///</summary>
        corewolf::engine *RemoteBatchJobs(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoteBatchJobs[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns only jobs of given type.
        /// https://reference.wolfram.com/language/ref/RemoteBatchJobs.html
        ///</summary>
        corewolf::engine *RemoteBatchJobs(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RemoteBatchJobs[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of jobs submitted using $DefaultRemoteBatchSubmissionEnvironment.
        /// https://reference.wolfram.com/language/ref/RemoteBatchJobs.html
        ///</summary>
        corewolf::engine *RemoteBatchJobs(const std::string &name = "")
        {
            return this->execute("RemoteBatchJobs[]", name);
        }

        ///< summary>
        /// submits an array batch job in which f is applied to each element on the first level of list, using the remote batch submission environment env.
        /// https://reference.wolfram.com/language/ref/RemoteBatchMapSubmit.html
        ///</summary>
        corewolf::engine *RemoteBatchMapSubmit(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RemoteBatchMapSubmit[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// submits an array job using $DefaultRemoteBatchSubmissionEnvironment.
        /// https://reference.wolfram.com/language/ref/RemoteBatchMapSubmit.html
        ///</summary>
        corewolf::engine *RemoteBatchMapSubmit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RemoteBatchMapSubmit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a remote batch job submission environment for provider with properties assoc.
        /// https://reference.wolfram.com/language/ref/RemoteBatchSubmissionEnvironment.html
        ///</summary>
        corewolf::engine *RemoteBatchSubmissionEnvironment(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RemoteBatchSubmissionEnvironment[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a submission environment for provider with default optional properties.
        /// https://reference.wolfram.com/language/ref/RemoteBatchSubmissionEnvironment.html
        ///</summary>
        corewolf::engine *RemoteBatchSubmissionEnvironment(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoteBatchSubmissionEnvironment[" + arg0 + "]", name);
        }

        ///< summary>
        /// submits expr for evaluation using the remote batch submission environment env.
        /// https://reference.wolfram.com/language/ref/RemoteBatchSubmit.html
        ///</summary>
        corewolf::engine *RemoteBatchSubmit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RemoteBatchSubmit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// submits expr for evaluation using $DefaultRemoteBatchSubmissionEnvironment.
        /// https://reference.wolfram.com/language/ref/RemoteBatchSubmit.html
        ///</summary>
        corewolf::engine *RemoteBatchSubmit(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoteBatchSubmit[" + arg0 + "]", name);
        }

        ///< summary>
        /// connects to the specified remote host.
        /// https://reference.wolfram.com/language/ref/RemoteConnect.html
        ///</summary>
        corewolf::engine *RemoteConnect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoteConnect[" + arg0 + "]", name);
        }

        ///< summary>
        /// connects using the specified username for the remote host.
        /// https://reference.wolfram.com/language/ref/RemoteConnect.html
        ///</summary>
        corewolf::engine *RemoteConnect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RemoteConnect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// connects using the specified username and password.
        /// https://reference.wolfram.com/language/ref/RemoteConnect.html
        ///</summary>
        corewolf::engine *RemoteConnect(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RemoteConnect[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is an const std::string &that represents a remote connection.
        /// https://reference.wolfram.com/language/ref/RemoteConnectionObject.html
        ///</summary>
        corewolf::engine *RemoteConnectionObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoteConnectionObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the result of evaluating expr using your current default remote Wolfram Language kernel.
        /// https://reference.wolfram.com/language/ref/RemoteEvaluate.html
        ///</summary>
        corewolf::engine *RemoteEvaluate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoteEvaluate[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the result of evaluating expr using the kernel specified by ker.
        /// https://reference.wolfram.com/language/ref/RemoteEvaluate.html
        ///</summary>
        corewolf::engine *RemoteEvaluate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RemoteEvaluate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the results of evaluating expr using each of the kernels keri.
        /// https://reference.wolfram.com/language/ref/RemoteEvaluate.html
        ///</summary>
        corewolf::engine *RemoteEvaluate(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RemoteEvaluate[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// wraps the head h around the result produced before returning it.
        /// https://reference.wolfram.com/language/ref/RemoteEvaluate.html
        ///</summary>
        corewolf::engine *RemoteEvaluate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RemoteEvaluate[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a symbolic representation of a file on a remote machine.
        /// https://reference.wolfram.com/language/ref/RemoteFile.html
        ///</summary>
        corewolf::engine *RemoteFile(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoteFile[" + arg0 + "]", name);
        }

        ///< summary>
        /// runs the specified operating system command on the remote host, returning the exit code obtained.
        /// https://reference.wolfram.com/language/ref/RemoteRun.html
        ///</summary>
        corewolf::engine *RemoteRun(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RemoteRun[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// runs the specified system command on the remote host, returning information on the outcome.
        /// https://reference.wolfram.com/language/ref/RemoteRunProcess.html
        ///</summary>
        corewolf::engine *RemoteRunProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RemoteRunProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// runs the specified command, with command-line arguments argi.
        /// https://reference.wolfram.com/language/ref/RemoteRunProcess.html
        ///</summary>
        corewolf::engine *RemoteRunProcess(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RemoteRunProcess[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns only the specified property.
        /// https://reference.wolfram.com/language/ref/RemoteRunProcess.html
        ///</summary>
        corewolf::engine *RemoteRunProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RemoteRunProcess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// feeds the specified initial input to the command.
        /// https://reference.wolfram.com/language/ref/RemoteRunProcess.html
        ///</summary>
        corewolf::engine *RemoteRunProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("RemoteRunProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// removes symbols completely, so that their names are no longer recognized by the Wolfram Language.
        /// https://reference.wolfram.com/language/ref/Remove.html
        ///</summary>
        corewolf::engine *Remove(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Remove[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// removes all symbols whose names match any of the string patterns formi.
        /// https://reference.wolfram.com/language/ref/Remove.html
        ///</summary>
        corewolf::engine *Remove(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Remove[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// removes opacity from color.
        /// https://reference.wolfram.com/language/ref/RemoveAlphaChannel.html
        ///</summary>
        corewolf::engine *RemoveAlphaChannel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoveAlphaChannel[" + arg0 + "]", name);
        }

        ///< summary>
        /// removes opacity by blending color with the background color bg.
        /// https://reference.wolfram.com/language/ref/RemoveAlphaChannel.html
        ///</summary>
        corewolf::engine *RemoveAlphaChannel(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RemoveAlphaChannel[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// deletes all AudioStream objects.
        /// https://reference.wolfram.com/language/ref/RemoveAudioStream.html
        ///</summary>
        corewolf::engine *RemoveAudioStream(const std::string &name = "")
        {
            return this->execute("RemoveAudioStream[]", name);
        }

        ///< summary>
        /// deletes the AudioStream const std::string &stream.
        /// https://reference.wolfram.com/language/ref/RemoveAudioStream.html
        ///</summary>
        corewolf::engine *RemoveAudioStream(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoveAudioStream[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns an image with an alpha channel where the background is transparent.
        /// https://reference.wolfram.com/language/ref/RemoveBackground.html
        ///</summary>
        corewolf::engine *RemoveBackground(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoveBackground[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses foreground or background model specification.
        /// https://reference.wolfram.com/language/ref/RemoveBackground.html
        ///</summary>
        corewolf::engine *RemoveBackground(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RemoveBackground[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// removes obj from the list of currently active channel listeners.
        /// https://reference.wolfram.com/language/ref/RemoveChannelListener.html
        ///</summary>
        corewolf::engine *RemoveChannelListener(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoveChannelListener[" + arg0 + "]", name);
        }

        ///< summary>
        /// removes all the obji.
        /// https://reference.wolfram.com/language/ref/RemoveChannelListener.html
        ///</summary>
        corewolf::engine *RemoveChannelListener(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RemoveChannelListener[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// removes all currently active channel listeners.
        /// https://reference.wolfram.com/language/ref/RemoveChannelListener.html
        ///</summary>
        corewolf::engine *RemoveChannelListener(const std::string &name = "")
        {
            return this->execute("RemoveChannelListener[]", name);
        }

        ///< summary>
        /// removes all subscribers from the specified channel.
        /// https://reference.wolfram.com/language/ref/RemoveChannelSubscribers.html
        ///</summary>
        corewolf::engine *RemoveChannelSubscribers(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoveChannelSubscribers[" + arg0 + "]", name);
        }

        ///< summary>
        /// removes the specified user from the subscriber list.
        /// https://reference.wolfram.com/language/ref/RemoveChannelSubscribers.html
        ///</summary>
        corewolf::engine *RemoveChannelSubscribers(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RemoveChannelSubscribers[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// removes the specified subscribers useri.
        /// https://reference.wolfram.com/language/ref/RemoveChannelSubscribers.html
        ///</summary>
        corewolf::engine *RemoveChannelSubscribers(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RemoveChannelSubscribers[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// replaces characters in string that have diacritics by their base ASCII characters, when possible.
        /// https://reference.wolfram.com/language/ref/RemoveDiacritics.html
        ///</summary>
        corewolf::engine *RemoveDiacritics(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoveDiacritics[" + arg0 + "]", name);
        }

        ///< summary>
        /// removes a custom input stream method.
        /// https://reference.wolfram.com/language/ref/RemoveInputStreamMethod.html
        ///</summary>
        corewolf::engine *RemoveInputStreamMethod(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoveInputStreamMethod[" + arg0 + "]", name);
        }

        ///< summary>
        /// removes a custom output stream method.
        /// https://reference.wolfram.com/language/ref/RemoveOutputStreamMethod.html
        ///</summary>
        corewolf::engine *RemoveOutputStreamMethod(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoveOutputStreamMethod[" + arg0 + "]", name);
        }

        ///< summary>
        /// removes the users useri from the permissions group group.
        /// https://reference.wolfram.com/language/ref/RemoveUsers.html
        ///</summary>
        corewolf::engine *RemoveUsers(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RemoveUsers[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// deletes all VideoStream objects.
        /// https://reference.wolfram.com/language/ref/RemoveVideoStream.html
        ///</summary>
        corewolf::engine *RemoveVideoStream(const std::string &name = "")
        {
            return this->execute("RemoveVideoStream[]", name);
        }

        ///< summary>
        /// deletes the VideoStream const std::string &stream.
        /// https://reference.wolfram.com/language/ref/RemoveVideoStream.html
        ///</summary>
        corewolf::engine *RemoveVideoStream(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RemoveVideoStream[" + arg0 + "]", name);
        }

        ///< summary>
        /// renames the directory dir1 to dir2.
        /// https://reference.wolfram.com/language/ref/RenameDirectory.html
        ///</summary>
        corewolf::engine *RenameDirectory(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RenameDirectory[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// renames file1 to file2.
        /// https://reference.wolfram.com/language/ref/RenameFile.html
        ///</summary>
        corewolf::engine *RenameFile(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RenameFile[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a renewal process with interarrival times distributed according to rdist.
        /// https://reference.wolfram.com/language/ref/RenewalProcess.html
        ///</summary>
        corewolf::engine *RenewalProcess(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RenewalProcess[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes a Renko chart with prices pi at date datei.
        /// https://reference.wolfram.com/language/ref/RenkoChart.html
        ///</summary>
        corewolf::engine *RenkoChart(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RenkoChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a Renko chart of closing prices for the financial entity "name" over the date range daterange.
        /// https://reference.wolfram.com/language/ref/RenkoChart.html
        ///</summary>
        corewolf::engine *RenkoChart(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RenkoChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a Renko chart with brick height of fraction s of the average price.
        /// https://reference.wolfram.com/language/ref/RenkoChart.html
        ///</summary>
        corewolf::engine *RenkoChart(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RenkoChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// repairs defects in the mesh region mreg.
        /// https://reference.wolfram.com/language/ref/RepairMesh.html
        ///</summary>
        corewolf::engine *RepairMesh(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RepairMesh[" + arg0 + "]", name);
        }

        ///< summary>
        /// repairs only the specified defects def1,….
        /// https://reference.wolfram.com/language/ref/RepairMesh.html
        ///</summary>
        corewolf::engine *RepairMesh(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RepairMesh[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is a pattern const std::string &that represents a sequence of one or more expressions, each matching p.
        /// https://reference.wolfram.com/language/ref/Repeated.html
        ///</summary>
        corewolf::engine *Repeated(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Repeated[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents from 1 to max expressions matching p.
        /// https://reference.wolfram.com/language/ref/Repeated.html
        ///</summary>
        corewolf::engine *Repeated(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Repeated[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents between min and max expressions matching p.
        /// https://reference.wolfram.com/language/ref/Repeated.html
        ///</summary>
        corewolf::engine *Repeated(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Repeated[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is a pattern const std::string &that represents a sequence of zero or more expressions, each matching p.
        /// https://reference.wolfram.com/language/ref/RepeatedNull.html
        ///</summary>
        corewolf::engine *RepeatedNull(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RepeatedNull[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents from 0 to max expressions matching p.
        /// https://reference.wolfram.com/language/ref/RepeatedNull.html
        ///</summary>
        corewolf::engine *RepeatedNull(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RepeatedNull[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents between min and max expressions matching p.
        /// https://reference.wolfram.com/language/ref/RepeatedNull.html
        ///</summary>
        corewolf::engine *RepeatedNull(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RepeatedNull[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates expr repeatedly and returns a list of the average time in seconds used, together with the result obtained.
        /// https://reference.wolfram.com/language/ref/RepeatedTiming.html
        ///</summary>
        corewolf::engine *RepeatedTiming(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RepeatedTiming[" + arg0 + "]", name);
        }

        ///< summary>
        /// does repeated evaluation for at least t seconds.
        /// https://reference.wolfram.com/language/ref/RepeatedTiming.html
        ///</summary>
        corewolf::engine *RepeatedTiming(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RepeatedTiming[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an arbitrarily repeated type of element in an interpreter, API or form specification.
        /// https://reference.wolfram.com/language/ref/RepeatingElement.html
        ///</summary>
        corewolf::engine *RepeatingElement(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RepeatingElement[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an element that can appear at most max times.
        /// https://reference.wolfram.com/language/ref/RepeatingElement.html
        ///</summary>
        corewolf::engine *RepeatingElement(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RepeatingElement[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an element that can appear between min and max times.
        /// https://reference.wolfram.com/language/ref/RepeatingElement.html
        ///</summary>
        corewolf::engine *RepeatingElement(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RepeatingElement[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an element that initially appears n times in a form.
        /// https://reference.wolfram.com/language/ref/RepeatingElement.html
        ///</summary>
        corewolf::engine *RepeatingElement(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RepeatingElement[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents an element where i takes successive values.
        /// https://reference.wolfram.com/language/ref/RepeatingElement.html
        ///</summary>
        corewolf::engine *RepeatingElement(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RepeatingElement[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// applies a rule or list of rules in an attempt to transform the entire expression expr.
        /// https://reference.wolfram.com/language/ref/Replace.html
        ///</summary>
        corewolf::engine *Replace(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Replace[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies rules to parts of expr specified by levelspec.
        /// https://reference.wolfram.com/language/ref/Replace.html
        ///</summary>
        corewolf::engine *Replace(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Replace[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of Replace that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/Replace.html
        ///</summary>
        corewolf::engine *Replace(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Replace[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies a rule or list of rules in an attempt to transform each subpart of an expression expr.
        /// https://reference.wolfram.com/language/ref/ReplaceAll.html
        ///</summary>
        corewolf::engine *ReplaceAll(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReplaceAll[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of ReplaceAll that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/ReplaceAll.html
        ///</summary>
        corewolf::engine *ReplaceAll(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReplaceAll[" + arg0 + "]", name);
        }

        ///< summary>
        /// transforms expr by replacing the  element using rules.
        /// https://reference.wolfram.com/language/ref/ReplaceAt.html
        ///</summary>
        corewolf::engine *ReplaceAt(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ReplaceAt[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// replaces the part of expr at position {i,j,…}.
        /// https://reference.wolfram.com/language/ref/ReplaceAt.html
        ///</summary>
        corewolf::engine *ReplaceAt(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ReplaceAt[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// replaces parts at several positions.
        /// https://reference.wolfram.com/language/ref/ReplaceAt.html
        ///</summary>
        corewolf::engine *ReplaceAt(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("ReplaceAt[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// represents an operator form of ReplaceAt that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/ReplaceAt.html
        ///</summary>
        corewolf::engine *ReplaceAt(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReplaceAt[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// changes the pixel values at position pos in image to val.
        /// https://reference.wolfram.com/language/ref/ReplaceImageValue.html
        ///</summary>
        corewolf::engine *ReplaceImageValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReplaceImageValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// assumes val to be of the specified type.
        /// https://reference.wolfram.com/language/ref/ReplaceImageValue.html
        ///</summary>
        corewolf::engine *ReplaceImageValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ReplaceImageValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// attempts to transform the entire expression expr by applying a rule or list of rules in all possible ways, and returns a list of the results obtained.
        /// https://reference.wolfram.com/language/ref/ReplaceList.html
        ///</summary>
        corewolf::engine *ReplaceList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReplaceList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of at most n results.
        /// https://reference.wolfram.com/language/ref/ReplaceList.html
        ///</summary>
        corewolf::engine *ReplaceList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ReplaceList[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is an operator form of ReplaceList that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/ReplaceList.html
        ///</summary>
        corewolf::engine *ReplaceList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReplaceList[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields an expression in which the i  part of expr is replaced by new.
        /// https://reference.wolfram.com/language/ref/ReplacePart.html
        ///</summary>
        corewolf::engine *ReplacePart(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReplacePart[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces parts at positions in by newn.
        /// https://reference.wolfram.com/language/ref/ReplacePart.html
        ///</summary>
        corewolf::engine *ReplacePart(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ReplacePart[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an operator form of ReplacePart that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/ReplacePart.html
        ///</summary>
        corewolf::engine *ReplacePart(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReplacePart[" + arg0 + "]", name);
        }

        ///< summary>
        /// changes the pixel values at pixel position ppos in image to val.
        /// https://reference.wolfram.com/language/ref/ReplacePixelValue.html
        ///</summary>
        corewolf::engine *ReplacePixelValue(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReplacePixelValue[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// assumes val to be of the specified type.
        /// https://reference.wolfram.com/language/ref/ReplacePixelValue.html
        ///</summary>
        corewolf::engine *ReplacePixelValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ReplacePixelValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a net layer that takes an input of dimensions {d1,d2,…} and replicates it n times to produce an output of dimensions {n,d1,d2,…}.
        /// https://reference.wolfram.com/language/ref/ReplicateLayer.html
        ///</summary>
        corewolf::engine *ReplicateLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReplicateLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a net layer that takes an input of dimensions {d1,d2,…} and replicates it to produce an output of dimensions {n1,n2,…,nm,d1,d2,…}.
        /// https://reference.wolfram.com/language/ref/ReplicateLayer.html
        ///</summary>
        corewolf::engine *ReplicateLayer(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ReplicateLayer[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// replicates so that dims appears at position m in the list of output dimensions.
        /// https://reference.wolfram.com/language/ref/ReplicateLayer.html
        ///</summary>
        corewolf::engine *ReplicateLayer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReplicateLayer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified property "prop" for the resampling rs.
        /// https://reference.wolfram.com/language/ref/ResamplingAlgorithmData.html
        ///</summary>
        corewolf::engine *ResamplingAlgorithmData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ResamplingAlgorithmData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives x rescaled to run from 0 to 1 over the range min to max.
        /// https://reference.wolfram.com/language/ref/Rescale.html
        ///</summary>
        corewolf::engine *Rescale(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Rescale[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives x rescaled to run from ymin to ymax over the range min to max.
        /// https://reference.wolfram.com/language/ref/Rescale.html
        ///</summary>
        corewolf::engine *Rescale(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Rescale[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// rescales each element of list to run from 0 to 1 over the range Min[list] to Max[list].
        /// https://reference.wolfram.com/language/ref/Rescale.html
        ///</summary>
        corewolf::engine *Rescale(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Rescale[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a TransformationFunction that rescales the region with coordinate ranges xmin to xmax, etc. to the region with coordinate ranges xpmin to xpmax, etc.
        /// https://reference.wolfram.com/language/ref/RescalingTransform.html
        ///</summary>
        corewolf::engine *RescalingTransform(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RescalingTransform[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives a TransformationFunction that rescales to the unit square, cube, etc.
        /// https://reference.wolfram.com/language/ref/RescalingTransform.html
        ///</summary>
        corewolf::engine *RescalingTransform(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RescalingTransform[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// resets the current working directory to its previous value.
        /// https://reference.wolfram.com/language/ref/ResetDirectory.html
        ///</summary>
        corewolf::engine *ResetDirectory(const std::string &name = "")
        {
            return this->execute("ResetDirectory[]", name);
        }

        ///< summary>
        /// represents a net layer that reinterprets the input to be an array of dimensions dims.
        /// https://reference.wolfram.com/language/ref/ReshapeLayer.html
        ///</summary>
        corewolf::engine *ReshapeLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReshapeLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds the residue of expr at the point z=z0.
        /// https://reference.wolfram.com/language/ref/Residue.html
        ///</summary>
        corewolf::engine *Residue(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Residue[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds the sum of residues of the meromorphic function f with the variable z.
        /// https://reference.wolfram.com/language/ref/ResidueSum.html
        ///</summary>
        corewolf::engine *ResidueSum(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ResidueSum[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the sum of residues of f within the solution set of the constraints cons.
        /// https://reference.wolfram.com/language/ref/ResidueSum.html
        ///</summary>
        corewolf::engine *ResidueSum(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ResidueSum[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a layer performing one-dimensional resizing of a two-dimensional array.
        /// https://reference.wolfram.com/language/ref/ResizeLayer.html
        ///</summary>
        corewolf::engine *ResizeLayer(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ResizeLayer[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// attempts to resolve expr into a form that eliminates ForAll and Exists quantifiers.
        /// https://reference.wolfram.com/language/ref/Resolve.html
        ///</summary>
        corewolf::engine *Resolve(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Resolve[" + arg0 + "]", name);
        }

        ///< summary>
        /// works over the domain dom. Common choices of dom are Complexes, Reals, and Booleans.
        /// https://reference.wolfram.com/language/ref/Resolve.html
        ///</summary>
        corewolf::engine *Resolve(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Resolve[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the primary content of the specified resource.
        /// https://reference.wolfram.com/language/ref/ResourceData.html
        ///</summary>
        corewolf::engine *ResourceData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ResourceData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives element elem of the content of the resource.
        /// https://reference.wolfram.com/language/ref/ResourceData.html
        ///</summary>
        corewolf::engine *ResourceData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ResourceData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the function associated with the specified resource.
        /// https://reference.wolfram.com/language/ref/ResourceFunction.html
        ///</summary>
        corewolf::engine *ResourceFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ResourceFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the specified property of the resource.
        /// https://reference.wolfram.com/language/ref/ResourceFunction.html
        ///</summary>
        corewolf::engine *ResourceFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ResourceFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a resource with the specified name.
        /// https://reference.wolfram.com/language/ref/ResourceObject.html
        ///</summary>
        corewolf::engine *ResourceObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ResourceObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a persistent cache of a resource const std::string &that can be referenced by name.
        /// https://reference.wolfram.com/language/ref/ResourceRegister.html
        ///</summary>
        corewolf::engine *ResourceRegister(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ResourceRegister[" + arg0 + "]", name);
        }

        ///< summary>
        /// stores the resource in persistence location loc.
        /// https://reference.wolfram.com/language/ref/ResourceRegister.html
        ///</summary>
        corewolf::engine *ResourceRegister(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ResourceRegister[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// removes the specified resource from the system on which it is run.
        /// https://reference.wolfram.com/language/ref/ResourceRemove.html
        ///</summary>
        corewolf::engine *ResourceRemove(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ResourceRemove[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a dataset of resources that contain text matching form.
        /// https://reference.wolfram.com/language/ref/ResourceSearch.html
        ///</summary>
        corewolf::engine *ResourceSearch(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ResourceSearch[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the property prop of the search results.
        /// https://reference.wolfram.com/language/ref/ResourceSearch.html
        ///</summary>
        corewolf::engine *ResourceSearch(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ResourceSearch[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// submits the specified resource const std::string &to be reviewed for publication.
        /// https://reference.wolfram.com/language/ref/ResourceSubmit.html
        ///</summary>
        corewolf::engine *ResourceSubmit(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ResourceSubmit[" + arg0 + "]", name);
        }

        ///< summary>
        /// submits the resource new as the updated version of the resource old.
        /// https://reference.wolfram.com/language/ref/ResourceSubmit.html
        ///</summary>
        corewolf::engine *ResourceSubmit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ResourceSubmit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// updates to the latest version of the specified resource object.
        /// https://reference.wolfram.com/language/ref/ResourceUpdate.html
        ///</summary>
        corewolf::engine *ResourceUpdate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ResourceUpdate[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a response record to be given in a specified format when requested during the execution of a function specified by APIFunction, FormFunction, etc.
        /// https://reference.wolfram.com/language/ref/ResponseForm.html
        ///</summary>
        corewolf::engine *ResponseForm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ResponseForm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// includes only the response record elements elemi.
        /// https://reference.wolfram.com/language/ref/ResponseForm.html
        ///</summary>
        corewolf::engine *ResponseForm(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ResponseForm[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives expr with the first element removed.
        /// https://reference.wolfram.com/language/ref/Rest.html
        ///</summary>
        corewolf::engine *Rest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Rest[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a form for Interpreter and related functions restricted according to the conditions cond.
        /// https://reference.wolfram.com/language/ref/Restricted.html
        ///</summary>
        corewolf::engine *Restricted(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Restricted[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes the resultant of the polynomials poly1 and poly2 with respect to the variable var.
        /// https://reference.wolfram.com/language/ref/Resultant.html
        ///</summary>
        corewolf::engine *Resultant(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Resultant[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes the resultant modulo the prime p.
        /// https://reference.wolfram.com/language/ref/Resultant.html
        ///</summary>
        corewolf::engine *Resultant(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Resultant[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// returns the value expr from a function.
        /// https://reference.wolfram.com/language/ref/Return.html
        ///</summary>
        corewolf::engine *Return(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Return[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the value Null.
        /// https://reference.wolfram.com/language/ref/Return.html
        ///</summary>
        corewolf::engine *Return(const std::string &name = "")
        {
            return this->execute("Return[]", name);
        }

        ///< summary>
        /// is a WSTP packet that contains the expression expr, the result of an EnterExpressionPacket evaluation.
        /// https://reference.wolfram.com/language/ref/ReturnExpressionPacket.html
        ///</summary>
        corewolf::engine *ReturnExpressionPacket(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReturnExpressionPacket[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a WSTP packet that contains the expression expr, the result of an EvaluatePacket evaluation.
        /// https://reference.wolfram.com/language/ref/ReturnPacket.html
        ///</summary>
        corewolf::engine *ReturnPacket(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReturnPacket[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a WSTP packet containing string, the result of an EnterTextPacket evaluation.
        /// https://reference.wolfram.com/language/ref/ReturnTextPacket.html
        ///</summary>
        corewolf::engine *ReturnTextPacket(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReturnTextPacket[" + arg0 + "]", name);
        }

        ///< summary>
        /// reverses the order of the elements in expr.
        /// https://reference.wolfram.com/language/ref/Reverse.html
        ///</summary>
        corewolf::engine *Reverse(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Reverse[" + arg0 + "]", name);
        }

        ///< summary>
        /// reverses elements at level n in expr.
        /// https://reference.wolfram.com/language/ref/Reverse.html
        ///</summary>
        corewolf::engine *Reverse(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Reverse[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// reverses elements at levels n1, n2, … in expr.
        /// https://reference.wolfram.com/language/ref/Reverse.html
        ///</summary>
        corewolf::engine *Reverse(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Reverse[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a form of f that takes arguments in reverse order so that ReverseApplied[f][x1,…,xn] is equivalent to f[xn,…,x1].
        /// https://reference.wolfram.com/language/ref/ReverseApplied.html
        ///</summary>
        corewolf::engine *ReverseApplied(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReverseApplied[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a form of f that reverses the first n arguments before evaluation.
        /// https://reference.wolfram.com/language/ref/ReverseApplied.html
        ///</summary>
        corewolf::engine *ReverseApplied(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReverseApplied[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a reverse biorthogonal spline wavelet of order 4 and dual order 2.
        /// https://reference.wolfram.com/language/ref/ReverseBiorthogonalSplineWavelet.html
        ///</summary>
        corewolf::engine *ReverseBiorthogonalSplineWavelet(const std::string &name = "")
        {
            return this->execute("ReverseBiorthogonalSplineWavelet[]", name);
        }

        ///< summary>
        /// represents a reverse biorthogonal spline wavelet of order n and dual order m.
        /// https://reference.wolfram.com/language/ref/ReverseBiorthogonalSplineWavelet.html
        ///</summary>
        corewolf::engine *ReverseBiorthogonalSplineWavelet(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReverseBiorthogonalSplineWavelet[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/ReverseElement.html
        ///</summary>
        corewolf::engine *ReverseElement(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ReverseElement[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/ReverseEquilibrium.html
        ///</summary>
        corewolf::engine *ReverseEquilibrium(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ReverseEquilibrium[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the reverse graph of the directed graph g.
        /// https://reference.wolfram.com/language/ref/ReverseGraph.html
        ///</summary>
        corewolf::engine *ReverseGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReverseGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/ReverseGraph.html
        ///</summary>
        corewolf::engine *ReverseGraph(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ReverseGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// sorts the elements of list into reverse canonical order.
        /// https://reference.wolfram.com/language/ref/ReverseSort.html
        ///</summary>
        corewolf::engine *ReverseSort(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReverseSort[" + arg0 + "]", name);
        }

        ///< summary>
        /// sorts using the ordering function p.
        /// https://reference.wolfram.com/language/ref/ReverseSort.html
        ///</summary>
        corewolf::engine *ReverseSort(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReverseSort[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sorts the elements of list using the reverse canonical order defined by applying f to each of them.
        /// https://reference.wolfram.com/language/ref/ReverseSortBy.html
        ///</summary>
        corewolf::engine *ReverseSortBy(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ReverseSortBy[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sorts the elements of list using the function p to compare pairs of results of applying f to each element.
        /// https://reference.wolfram.com/language/ref/ReverseSortBy.html
        ///</summary>
        corewolf::engine *ReverseSortBy(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ReverseSortBy[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of ReverseSortBy that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/ReverseSortBy.html
        ///</summary>
        corewolf::engine *ReverseSortBy(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ReverseSortBy[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/ReverseUpEquilibrium.html
        ///</summary>
        corewolf::engine *ReverseUpEquilibrium(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ReverseUpEquilibrium[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a plot of the surface of revolution with height fz at radius t.
        /// https://reference.wolfram.com/language/ref/RevolutionPlot3D.html
        ///</summary>
        corewolf::engine *RevolutionPlot3D(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RevolutionPlot3D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// takes the azimuthal angle θ to vary between θmin and θmax.
        /// https://reference.wolfram.com/language/ref/RevolutionPlot3D.html
        ///</summary>
        corewolf::engine *RevolutionPlot3D(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RevolutionPlot3D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates a plot of the surface obtained by rotating the parametric curve with x, z coordinates {fx,fz} around the z axis.
        /// https://reference.wolfram.com/language/ref/RevolutionPlot3D.html
        ///</summary>
        corewolf::engine *RevolutionPlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RevolutionPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// takes the azimuthal angle θ to vary from θmin to θmax.
        /// https://reference.wolfram.com/language/ref/RevolutionPlot3D.html
        ///</summary>
        corewolf::engine *RevolutionPlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RevolutionPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// plots the surface obtained by rotating the parametric curve with x, y, z coordinates {fx,fy,fz}.
        /// https://reference.wolfram.com/language/ref/RevolutionPlot3D.html
        ///</summary>
        corewolf::engine *RevolutionPlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RevolutionPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a color in the RGB color space with red, blue and green components.
        /// https://reference.wolfram.com/language/ref/RGBColor.html
        ///</summary>
        corewolf::engine *RGBColor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RGBColor[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// specifies opacity a.
        /// https://reference.wolfram.com/language/ref/RGBColor.html
        ///</summary>
        corewolf::engine *RGBColor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("RGBColor[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// returns a color from an HTML color name, etc.
        /// https://reference.wolfram.com/language/ref/RGBColor.html
        ///</summary>
        corewolf::engine *RGBColor(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RGBColor[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the matrix  that is the stabilizing solution of the continuous algebraic Riccati equation .
        /// https://reference.wolfram.com/language/ref/RiccatiSolve.html
        ///</summary>
        corewolf::engine *RiccatiSolve(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RiccatiSolve[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a Rice distribution with shape parameters α and β.
        /// https://reference.wolfram.com/language/ref/RiceDistribution.html
        ///</summary>
        corewolf::engine *RiceDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RiceDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Norton–Rice distribution with parameters m, α, and β.
        /// https://reference.wolfram.com/language/ref/RiceDistribution.html
        ///</summary>
        corewolf::engine *RiceDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RiceDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes a measure for the presence of a ridge at every position of data.
        /// https://reference.wolfram.com/language/ref/RidgeFilter.html
        ///</summary>
        corewolf::engine *RidgeFilter(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RidgeFilter[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the specified ridge scale σ.
        /// https://reference.wolfram.com/language/ref/RidgeFilter.html
        ///</summary>
        corewolf::engine *RidgeFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RidgeFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Riemann prime counting function .
        /// https://reference.wolfram.com/language/ref/RiemannR.html
        ///</summary>
        corewolf::engine *RiemannR(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RiemannR[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Riemann–Siegel function .
        /// https://reference.wolfram.com/language/ref/RiemannSiegelTheta.html
        ///</summary>
        corewolf::engine *RiemannSiegelTheta(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RiemannSiegelTheta[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Riemann–Siegel function .
        /// https://reference.wolfram.com/language/ref/RiemannSiegelZ.html
        ///</summary>
        corewolf::engine *RiemannSiegelZ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RiemannSiegelZ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Riemann xi function .
        /// https://reference.wolfram.com/language/ref/RiemannXi.html
        ///</summary>
        corewolf::engine *RiemannXi(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RiemannXi[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives {e1,x,e2,x,…}.
        /// https://reference.wolfram.com/language/ref/Riffle.html
        ///</summary>
        corewolf::engine *Riffle(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Riffle[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives {e1,x1,e2,x2,…}.
        /// https://reference.wolfram.com/language/ref/Riffle.html
        ///</summary>
        corewolf::engine *Riffle(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Riffle[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields a list in which every n element is x.
        /// https://reference.wolfram.com/language/ref/Riffle.html
        ///</summary>
        corewolf::engine *Riffle(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Riffle[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields a list in which x appears if possible at positions imin, imin+n, imin+2n, … , imax.
        /// https://reference.wolfram.com/language/ref/Riffle.html
        ///</summary>
        corewolf::engine *Riffle(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Riffle[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightArrow.html
        ///</summary>
        corewolf::engine *RightArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RightArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightArrowBar.html
        ///</summary>
        corewolf::engine *RightArrowBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RightArrowBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightArrowLeftArrow.html
        ///</summary>
        corewolf::engine *RightArrowLeftArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RightArrowLeftArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a composition on the right of the functions f1, f2, f3, ….
        /// https://reference.wolfram.com/language/ref/RightComposition.html
        ///</summary>
        corewolf::engine *RightComposition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("RightComposition[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// returns the smallest element in the right coset of products of the elements of group by g.
        /// https://reference.wolfram.com/language/ref/RightCosetRepresentative.html
        ///</summary>
        corewolf::engine *RightCosetRepresentative(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RightCosetRepresentative[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightDownTeeVector.html
        ///</summary>
        corewolf::engine *RightDownTeeVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RightDownTeeVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightDownVector.html
        ///</summary>
        corewolf::engine *RightDownVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RightDownVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightDownVectorBar.html
        ///</summary>
        corewolf::engine *RightDownVectorBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RightDownVectorBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightTee.html
        ///</summary>
        corewolf::engine *RightTee(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RightTee[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightTeeArrow.html
        ///</summary>
        corewolf::engine *RightTeeArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RightTeeArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightTeeVector.html
        ///</summary>
        corewolf::engine *RightTeeVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RightTeeVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightTriangle.html
        ///</summary>
        corewolf::engine *RightTriangle(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RightTriangle[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightTriangleBar.html
        ///</summary>
        corewolf::engine *RightTriangleBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RightTriangleBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightTriangleEqual.html
        ///</summary>
        corewolf::engine *RightTriangleEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RightTriangleEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightUpDownVector.html
        ///</summary>
        corewolf::engine *RightUpDownVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RightUpDownVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightUpTeeVector.html
        ///</summary>
        corewolf::engine *RightUpTeeVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RightUpTeeVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightUpVector.html
        ///</summary>
        corewolf::engine *RightUpVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RightUpVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightUpVectorBar.html
        ///</summary>
        corewolf::engine *RightUpVectorBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RightUpVectorBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightVector.html
        ///</summary>
        corewolf::engine *RightVector(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RightVector[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/RightVectorBar.html
        ///</summary>
        corewolf::engine *RightVectorBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RightVectorBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// estimates Ripley's  function  at radius r for point data pdata.
        /// https://reference.wolfram.com/language/ref/RipleyK.html
        ///</summary>
        corewolf::engine *RipleyK(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RipleyK[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates the function  that can be applied repeatedly at different radii r.
        /// https://reference.wolfram.com/language/ref/RipleyK.html
        ///</summary>
        corewolf::engine *RipleyK(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RipleyK[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an estimated observation based on the point data pdata.
        /// https://reference.wolfram.com/language/ref/RipleyRassonRegion.html
        ///</summary>
        corewolf::engine *RipleyRassonRegion(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RipleyRassonRegion[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the risk achievement importances for all components in the ReliabilityDistribution rdist at time t.
        /// https://reference.wolfram.com/language/ref/RiskAchievementImportance.html
        ///</summary>
        corewolf::engine *RiskAchievementImportance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RiskAchievementImportance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the risk reduction importances for all components in the ReliabilityDistribution rdist at time t.
        /// https://reference.wolfram.com/language/ref/RiskReductionImportance.html
        ///</summary>
        corewolf::engine *RiskReductionImportance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RiskReductionImportance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds values of vars that give the minimum value of f for vars that satisfy the constraints vcons for all possible values of the parameters pars that satisfy the parametric constraints pcons.
        /// https://reference.wolfram.com/language/ref/RobustConvexOptimization.html
        ///</summary>
        corewolf::engine *RobustConvexOptimization(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RobustConvexOptimization[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// specifies what solution property "prop" should be returned.
        /// https://reference.wolfram.com/language/ref/RobustConvexOptimization.html
        ///</summary>
        corewolf::engine *RobustConvexOptimization(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RobustConvexOptimization[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Rogers–Tanimoto dissimilarity between Boolean vectors u and v.
        /// https://reference.wolfram.com/language/ref/RogersTanimotoDissimilarity.html
        ///</summary>
        corewolf::engine *RogersTanimotoDissimilarity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RogersTanimotoDissimilarity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the roll-pitch-yaw angles {α,β,γ} corresponding to the rotation matrix r.
        /// https://reference.wolfram.com/language/ref/RollPitchYawAngles.html
        ///</summary>
        corewolf::engine *RollPitchYawAngles(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RollPitchYawAngles[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the roll-pitch-yaw angles {α,β,γ} corresponding to rotation order {a,b,c}.
        /// https://reference.wolfram.com/language/ref/RollPitchYawAngles.html
        ///</summary>
        corewolf::engine *RollPitchYawAngles(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RollPitchYawAngles[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the 3D rotation matrix formed by rotating by α around the initial  axis, then by β around the initial  axis, and then by γ around the initial  axis.
        /// https://reference.wolfram.com/language/ref/RollPitchYawMatrix.html
        ///</summary>
        corewolf::engine *RollPitchYawMatrix(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RollPitchYawMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the 3D rotation matrix formed by rotating by α around the fixed a axis, then by β around the fixed b axis, and then by γ around the fixed c axis.
        /// https://reference.wolfram.com/language/ref/RollPitchYawMatrix.html
        ///</summary>
        corewolf::engine *RollPitchYawMatrix(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RollPitchYawMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a string corresponding to the Roman numeral form of the integer n.
        /// https://reference.wolfram.com/language/ref/RomanNumeral.html
        ///</summary>
        corewolf::engine *RomanNumeral(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RomanNumeral[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the exact root of the general equation f[x]0 near x=c.
        /// https://reference.wolfram.com/language/ref/Root.html
        ///</summary>
        corewolf::engine *Root(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Root[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the j coordinate of the exact root of the system of equations {f1[x1,…,xn]0,…,fn[x1,…,xn]0} near {x1,…,xn}={c1,…,cn}.
        /// https://reference.wolfram.com/language/ref/Root.html
        ///</summary>
        corewolf::engine *Root(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Root[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the exact k root of the polynomial equation f[x]0.
        /// https://reference.wolfram.com/language/ref/Root.html
        ///</summary>
        corewolf::engine *Root(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Root[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the last coordinate of the exact vector {a1,a2,…} such that ai is the ki root of the polynomial equation fi[a1,…,ai-1,x]0.
        /// https://reference.wolfram.com/language/ref/Root.html
        ///</summary>
        corewolf::engine *Root(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Root[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// converts the number x to one of the "simplest" algebraic numbers that approximates it well.
        /// https://reference.wolfram.com/language/ref/RootApproximant.html
        ///</summary>
        corewolf::engine *RootApproximant(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RootApproximant[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds an algebraic number of degree at most n that approximates x.
        /// https://reference.wolfram.com/language/ref/RootApproximant.html
        ///</summary>
        corewolf::engine *RootApproximant(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RootApproximant[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of isolating intervals for the real roots of any of the polyi, together with a list of which polynomials actually have each successive root.
        /// https://reference.wolfram.com/language/ref/RootIntervals.html
        ///</summary>
        corewolf::engine *RootIntervals(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RootIntervals[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives isolating intervals for real roots of a single polynomial.
        /// https://reference.wolfram.com/language/ref/RootIntervals.html
        ///</summary>
        corewolf::engine *RootIntervals(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RootIntervals[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives bounding rectangles for complex roots.
        /// https://reference.wolfram.com/language/ref/RootIntervals.html
        ///</summary>
        corewolf::engine *RootIntervals(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RootIntervals[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a root locus plot of a linear time-invariant system lsys as the parameter k ranges from kmin to kmax.
        /// https://reference.wolfram.com/language/ref/RootLocusPlot.html
        ///</summary>
        corewolf::engine *RootLocusPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RootLocusPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the root mean square of values in list.
        /// https://reference.wolfram.com/language/ref/RootMeanSquare.html
        ///</summary>
        corewolf::engine *RootMeanSquare(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RootMeanSquare[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if a is a root of unity, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/RootOfUnityQ.html
        ///</summary>
        corewolf::engine *RootOfUnityQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RootOfUnityQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// attempts to reduce expr to a single Root object.
        /// https://reference.wolfram.com/language/ref/RootReduce.html
        ///</summary>
        corewolf::engine *RootReduce(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RootReduce[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields a disjunction of equations which represent the roots of a polynomial equation.
        /// https://reference.wolfram.com/language/ref/Roots.html
        ///</summary>
        corewolf::engine *Roots(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Roots[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the sum of form[x] for all x that satisfy the polynomial equation f[x]==0.
        /// https://reference.wolfram.com/language/ref/RootSum.html
        ///</summary>
        corewolf::engine *RootSum(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RootSum[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the root node of tree as a Tree object.
        /// https://reference.wolfram.com/language/ref/RootTree.html
        ///</summary>
        corewolf::engine *RootTree(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RootTree[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a Tree const std::string &containing the nodes of tree down to level n.
        /// https://reference.wolfram.com/language/ref/RootTree.html
        ///</summary>
        corewolf::engine *RootTree(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RootTree[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents 2D graphics primitives or any other objects g rotated counterclockwise by θ radians about the center of their bounding box.
        /// https://reference.wolfram.com/language/ref/Rotate.html
        ///</summary>
        corewolf::engine *Rotate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Rotate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// rotates about the point {x,y}.
        /// https://reference.wolfram.com/language/ref/Rotate.html
        ///</summary>
        corewolf::engine *Rotate(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Rotate[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// rotates around the origin, transforming the 2D or 3D vector u to v.
        /// https://reference.wolfram.com/language/ref/Rotate.html
        ///</summary>
        corewolf::engine *Rotate(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Rotate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// rotates 3D graphics primitives by θ radians around the 3D vector w anchored at the origin.
        /// https://reference.wolfram.com/language/ref/Rotate.html
        ///</summary>
        corewolf::engine *Rotate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Rotate[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// rotates around the 3D vector w anchored at p.
        /// https://reference.wolfram.com/language/ref/Rotate.html
        ///</summary>
        corewolf::engine *Rotate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Rotate[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// cycles the elements in expr n positions to the left.
        /// https://reference.wolfram.com/language/ref/RotateLeft.html
        ///</summary>
        corewolf::engine *RotateLeft(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RotateLeft[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// cycles one position to the left.
        /// https://reference.wolfram.com/language/ref/RotateLeft.html
        ///</summary>
        corewolf::engine *RotateLeft(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RotateLeft[" + arg0 + "]", name);
        }

        ///< summary>
        /// cycles elements at successive levels ni positions to the left.
        /// https://reference.wolfram.com/language/ref/RotateLeft.html
        ///</summary>
        corewolf::engine *RotateLeft(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RotateLeft[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// cycles the elements in expr n positions to the right.
        /// https://reference.wolfram.com/language/ref/RotateRight.html
        ///</summary>
        corewolf::engine *RotateRight(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RotateRight[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// cycles one position to the right.
        /// https://reference.wolfram.com/language/ref/RotateRight.html
        ///</summary>
        corewolf::engine *RotateRight(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RotateRight[" + arg0 + "]", name);
        }

        ///< summary>
        /// cycles elements at successive levels ni positions to the right.
        /// https://reference.wolfram.com/language/ref/RotateRight.html
        ///</summary>
        corewolf::engine *RotateRight(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RotateRight[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the 2D rotation matrix that rotates 2D vectors counterclockwise by θ radians.
        /// https://reference.wolfram.com/language/ref/RotationMatrix.html
        ///</summary>
        corewolf::engine *RotationMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RotationMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the 3D rotation matrix for a counterclockwise rotation around the 3D vector w.
        /// https://reference.wolfram.com/language/ref/RotationMatrix.html
        ///</summary>
        corewolf::engine *RotationMatrix(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RotationMatrix[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the matrix that rotates the vector u to the direction of the vector v in any dimension.
        /// https://reference.wolfram.com/language/ref/RotationMatrix.html
        ///</summary>
        corewolf::engine *RotationMatrix(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RotationMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the matrix that rotates by θ radians in the plane spanned by u and v.
        /// https://reference.wolfram.com/language/ref/RotationMatrix.html
        ///</summary>
        corewolf::engine *RotationMatrix(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("RotationMatrix[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a TransformationFunction that represents a rotation in 2D by θ radians about the origin.
        /// https://reference.wolfram.com/language/ref/RotationTransform.html
        ///</summary>
        corewolf::engine *RotationTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RotationTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a 2D rotation about the 2D point p.
        /// https://reference.wolfram.com/language/ref/RotationTransform.html
        ///</summary>
        corewolf::engine *RotationTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RotationTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a 3D rotation around the axis w anchored at the point p.
        /// https://reference.wolfram.com/language/ref/RotationTransform.html
        ///</summary>
        corewolf::engine *RotationTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RotationTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a rotation about the origin that transforms the vector u to the direction of the vector v.
        /// https://reference.wolfram.com/language/ref/RotationTransform.html
        ///</summary>
        corewolf::engine *RotationTransform(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RotationTransform[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a rotation about the point p that transforms u to the direction of v.
        /// https://reference.wolfram.com/language/ref/RotationTransform.html
        ///</summary>
        corewolf::engine *RotationTransform(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RotationTransform[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a rotation by θ radians in the plane spanned by u and v.
        /// https://reference.wolfram.com/language/ref/RotationTransform.html
        ///</summary>
        corewolf::engine *RotationTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RotationTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the integer closest to x.
        /// https://reference.wolfram.com/language/ref/Round.html
        ///</summary>
        corewolf::engine *Round(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Round[" + arg0 + "]", name);
        }

        ///< summary>
        /// rounds to the nearest multiple of a.
        /// https://reference.wolfram.com/language/ref/Round.html
        ///</summary>
        corewolf::engine *Round(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Round[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is an const std::string &that formats with the expri arranged in a row, potentially extending over several lines.
        /// https://reference.wolfram.com/language/ref/Row.html
        ///</summary>
        corewolf::engine *Row(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Row[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// inserts s as a separator between successive elements.
        /// https://reference.wolfram.com/language/ref/Row.html
        ///</summary>
        corewolf::engine *Row(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Row[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a low-level box construct that represents a row of boxes or strings in a notebook expression.
        /// https://reference.wolfram.com/language/ref/RowBox.html
        ///</summary>
        corewolf::engine *RowBox(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RowBox[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the row‐reduced form of the matrix m.
        /// https://reference.wolfram.com/language/ref/RowReduce.html
        ///</summary>
        corewolf::engine *RowReduce(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RowReduce[" + arg0 + "]", name);
        }

        ///< summary>
        /// solves a recurrence equation for a[n].
        /// https://reference.wolfram.com/language/ref/RSolve.html
        ///</summary>
        corewolf::engine *RSolve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RSolve[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// solves a system of recurrence equations.
        /// https://reference.wolfram.com/language/ref/RSolve.html
        ///</summary>
        corewolf::engine *RSolve(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RSolve[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// solves a partial recurrence equation.
        /// https://reference.wolfram.com/language/ref/RSolve.html
        ///</summary>
        corewolf::engine *RSolve(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RSolve[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of expr determined by a symbolic solution to the ordinary difference equation eqn with independent variable n.
        /// https://reference.wolfram.com/language/ref/RSolveValue.html
        ///</summary>
        corewolf::engine *RSolveValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RSolveValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses a symbolic solution for a list of difference equations.
        /// https://reference.wolfram.com/language/ref/RSolveValue.html
        ///</summary>
        corewolf::engine *RSolveValue(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RSolveValue[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses a solution for the partial recurrence equation eqn.
        /// https://reference.wolfram.com/language/ref/RSolveValue.html
        ///</summary>
        corewolf::engine *RSolveValue(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("RSolveValue[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the n term in the Rudin–Shapiro sequence.
        /// https://reference.wolfram.com/language/ref/RudinShapiro.html
        ///</summary>
        corewolf::engine *RudinShapiro(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RudinShapiro[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the sporadic simple Rudvalis group .
        /// https://reference.wolfram.com/language/ref/RudvalisGroupRu.html
        ///</summary>
        corewolf::engine *RudvalisGroupRu(const std::string &name = "")
        {
            return this->execute("RudvalisGroupRu[]", name);
        }

        ///< summary>
        /// generates a plot representing the rule for the computational system sys.
        /// https://reference.wolfram.com/language/ref/RulePlot.html
        ///</summary>
        corewolf::engine *RulePlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RulePlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a plot of the evolution of the system sys from initial condition init for t steps.
        /// https://reference.wolfram.com/language/ref/RulePlot.html
        ///</summary>
        corewolf::engine *RulePlot(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RulePlot[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a plot of the evolution evol assuming it is derived from a system of the form sys.
        /// https://reference.wolfram.com/language/ref/RulePlot.html
        ///</summary>
        corewolf::engine *RulePlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RulePlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a tree whose root contains data and that has children specified by the rulei.
        /// https://reference.wolfram.com/language/ref/RulesTree.html
        ///</summary>
        corewolf::engine *RulesTree(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RulesTree[" + arg0 + "]", name);
        }

        ///< summary>
        /// runs command as an external operating system command, returning the exit code obtained.
        /// https://reference.wolfram.com/language/ref/Run.html
        ///</summary>
        corewolf::engine *Run(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Run[" + arg0 + "]", name);
        }

        ///< summary>
        /// runs the specified external command, returning information on the outcome.
        /// https://reference.wolfram.com/language/ref/RunProcess.html
        ///</summary>
        corewolf::engine *RunProcess(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("RunProcess[" + arg0 + "]", name);
        }

        ///< summary>
        /// runs the specified command, with command-line arguments argi.
        /// https://reference.wolfram.com/language/ref/RunProcess.html
        ///</summary>
        corewolf::engine *RunProcess(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("RunProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns only the specified property.
        /// https://reference.wolfram.com/language/ref/RunProcess.html
        ///</summary>
        corewolf::engine *RunProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RunProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// feeds the specified initial input to the command.
        /// https://reference.wolfram.com/language/ref/RunProcess.html
        ///</summary>
        corewolf::engine *RunProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("RunProcess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// executes an external command, giving the printed form of expr as input and taking the output, reading it as Wolfram Language input, and returning the result.
        /// https://reference.wolfram.com/language/ref/RunThrough.html
        ///</summary>
        corewolf::engine *RunThrough(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RunThrough[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Russell–Rao dissimilarity between Boolean vectors u and v.
        /// https://reference.wolfram.com/language/ref/RussellRaoDissimilarity.html
        ///</summary>
        corewolf::engine *RussellRaoDissimilarity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("RussellRaoDissimilarity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is an operator form that yields x===y when applied to an expression x.
        /// https://reference.wolfram.com/language/ref/SameAs.html
        ///</summary>
        corewolf::engine *SameAs(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SameAs[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an entity class containing n entities from class.
        /// https://reference.wolfram.com/language/ref/SampledEntityClass.html
        ///</summary>
        corewolf::engine *SampledEntityClass(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SampledEntityClass[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an entity class containing entities m through n of class.
        /// https://reference.wolfram.com/language/ref/SampledEntityClass.html
        ///</summary>
        corewolf::engine *SampledEntityClass(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SampledEntityClass[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is a sound primitive that represents a sound whose amplitude sampled r times a second is generated by applying the function f to successive integers from 1 to n.
        /// https://reference.wolfram.com/language/ref/SampledSoundFunction.html
        ///</summary>
        corewolf::engine *SampledSoundFunction(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SampledSoundFunction[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a sound primitive that represents a sound whose amplitude has levels ai sampled r times a second.
        /// https://reference.wolfram.com/language/ref/SampledSoundList.html
        ///</summary>
        corewolf::engine *SampledSoundList(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SampledSoundList[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a seasonal integrated autoregressive moving-average process with ARIMA coefficients ai, d, and bj; seasonal order s; seasonal ARIMA coefficients αi, δ, and βj; seasonal integration order δ; and normal white noise with variance v.
        /// https://reference.wolfram.com/language/ref/SARIMAProcess.html
        ///</summary>
        corewolf::engine *SARIMAProcess(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::vector<std::string> &arg4, const std::string &arg5, const std::vector<std::string> &arg6, const std::string &arg7, const std::string &name = "")
        {
            return this->execute("SARIMAProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + ", " + arg5 + ", " + std::to_string('{') + engine::_print_vector(arg6) + "}" + ", " + arg7 + "]", name);
        }

        ///< summary>
        /// represents a vector SARIMA process with multiple integration orders di, seasonal orders sj, and seasonal integration orders δk.
        /// https://reference.wolfram.com/language/ref/SARIMAProcess.html
        ///</summary>
        corewolf::engine *SARIMAProcess(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::vector<std::string> &arg4, const std::vector<std::string> &arg5, const std::vector<std::string> &arg6, const std::string &arg7, const std::string &name = "")
        {
            return this->execute("SARIMAProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg5) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg6) + "}" + ", " + arg7 + "]", name);
        }

        ///< summary>
        /// represents a SARIMA process with initial data init.
        /// https://reference.wolfram.com/language/ref/SARIMAProcess.html
        ///</summary>
        corewolf::engine *SARIMAProcess(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::vector<std::string> &arg4, const std::string &arg5, const std::vector<std::string> &arg6, const std::string &arg7, const std::string &arg8, const std::string &name = "")
        {
            return this->execute("SARIMAProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + ", " + arg5 + ", " + std::to_string('{') + engine::_print_vector(arg6) + "}" + ", " + arg7 + ", " + arg8 + "]", name);
        }

        ///< summary>
        /// represents a SARIMA process with constant c.
        /// https://reference.wolfram.com/language/ref/SARIMAProcess.html
        ///</summary>
        corewolf::engine *SARIMAProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SARIMAProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a weakly stationary seasonal autoregressive moving-average process with ARMA coefficients ai and bj, seasonal order s, seasonal ARMA coefficients αi and βj, and normal white noise with variance v.
        /// https://reference.wolfram.com/language/ref/SARMAProcess.html
        ///</summary>
        corewolf::engine *SARMAProcess(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::vector<std::string> &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("SARMAProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// represents a weakly stationary vector SARMA process with multiple seasonal orders si.
        /// https://reference.wolfram.com/language/ref/SARMAProcess.html
        ///</summary>
        corewolf::engine *SARMAProcess(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::vector<std::string> &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("SARMAProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// represents a SARMA process with initial data init.
        /// https://reference.wolfram.com/language/ref/SARMAProcess.html
        ///</summary>
        corewolf::engine *SARMAProcess(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::vector<std::string> &arg4, const std::string &arg5, const std::string &arg6, const std::string &name = "")
        {
            return this->execute("SARMAProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + ", " + arg5 + ", " + arg6 + "]", name);
        }

        ///< summary>
        /// represents a SARMA process with a constant c.
        /// https://reference.wolfram.com/language/ref/SARMAProcess.html
        ///</summary>
        corewolf::engine *SARMAProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SARMAProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a filled triangle with sides of length a and b and angle γ between them.
        /// https://reference.wolfram.com/language/ref/SASTriangle.html
        ///</summary>
        corewolf::engine *SASTriangle(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SASTriangle[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the satellite entity.
        /// https://reference.wolfram.com/language/ref/SatelliteData.html
        ///</summary>
        corewolf::engine *SatelliteData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SatelliteData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified satellite entities.
        /// https://reference.wolfram.com/language/ref/SatelliteData.html
        ///</summary>
        corewolf::engine *SatelliteData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SatelliteData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/SatelliteData.html
        ///</summary>
        corewolf::engine *SatelliteData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SatelliteData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// counts the number of possible combinations of variable values that yield True when supplied as arguments to the Boolean function bf.
        /// https://reference.wolfram.com/language/ref/SatisfiabilityCount.html
        ///</summary>
        corewolf::engine *SatisfiabilityCount(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SatisfiabilityCount[" + arg0 + "]", name);
        }

        ///< summary>
        /// counts the number of possible combinations of the ai that make the Boolean expression expr be true.
        /// https://reference.wolfram.com/language/ref/SatisfiabilityCount.html
        ///</summary>
        corewolf::engine *SatisfiabilityCount(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SatisfiabilityCount[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// attempts to find a choice of variables that makes the Boolean function bf yield True.
        /// https://reference.wolfram.com/language/ref/SatisfiabilityInstances.html
        ///</summary>
        corewolf::engine *SatisfiabilityInstances(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SatisfiabilityInstances[" + arg0 + "]", name);
        }

        ///< summary>
        /// attempts to find a choice of the ai that makes the Boolean expression expr be True.
        /// https://reference.wolfram.com/language/ref/SatisfiabilityInstances.html
        ///</summary>
        corewolf::engine *SatisfiabilityInstances(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SatisfiabilityInstances[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// attempts to find m choices of variables that yield True.
        /// https://reference.wolfram.com/language/ref/SatisfiabilityInstances.html
        ///</summary>
        corewolf::engine *SatisfiabilityInstances(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SatisfiabilityInstances[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives True if a combination of values of variables exists that makes the Boolean function bf yield True.
        /// https://reference.wolfram.com/language/ref/SatisfiableQ.html
        ///</summary>
        corewolf::engine *SatisfiableQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SatisfiableQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if a combination of values of the ai exists that makes the Boolean expression expr yield True.
        /// https://reference.wolfram.com/language/ref/SatisfiableQ.html
        ///</summary>
        corewolf::engine *SatisfiableQ(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SatisfiableQ[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// appends definitions associated with the specified symbol to a file.
        /// https://reference.wolfram.com/language/ref/Save.html
        ///</summary>
        corewolf::engine *Save(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Save[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// appends definitions associated with several objects.
        /// https://reference.wolfram.com/language/ref/Save.html
        ///</summary>
        corewolf::engine *Save(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Save[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a matrix corresponding to a smoothing kernel of radius r for performing polynomial regression of degree k.
        /// https://reference.wolfram.com/language/ref/SavitzkyGolayMatrix.html
        ///</summary>
        corewolf::engine *SavitzkyGolayMatrix(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SavitzkyGolayMatrix[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a matrix for performing polynomial regression of degree k1 over a window of radius r1 along rows, and degree k2 over a window of radius r2 along columns.
        /// https://reference.wolfram.com/language/ref/SavitzkyGolayMatrix.html
        ///</summary>
        corewolf::engine *SavitzkyGolayMatrix(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SavitzkyGolayMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a matrix for performing the n derivative of a polynomial regression of degree k.
        /// https://reference.wolfram.com/language/ref/SavitzkyGolayMatrix.html
        ///</summary>
        corewolf::engine *SavitzkyGolayMatrix(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SavitzkyGolayMatrix[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives an array using the specified parameters for each direction i.
        /// https://reference.wolfram.com/language/ref/SavitzkyGolayMatrix.html
        ///</summary>
        corewolf::engine *SavitzkyGolayMatrix(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SavitzkyGolayMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a sawtooth wave that varies from 0 to 1 with unit period.
        /// https://reference.wolfram.com/language/ref/SawtoothWave.html
        ///</summary>
        corewolf::engine *SawtoothWave(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SawtoothWave[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a sawtooth wave that varies from min to max with unit period.
        /// https://reference.wolfram.com/language/ref/SawtoothWave.html
        ///</summary>
        corewolf::engine *SawtoothWave(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SawtoothWave[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents graphics primitives g scaled by a factor s.
        /// https://reference.wolfram.com/language/ref/Scale.html
        ///</summary>
        corewolf::engine *Scale(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Scale[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// scales with the point {x,y,…} kept fixed.
        /// https://reference.wolfram.com/language/ref/Scale.html
        ///</summary>
        corewolf::engine *Scale(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Scale[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// scales by different factors along different axes.
        /// https://reference.wolfram.com/language/ref/Scale.html
        ///</summary>
        corewolf::engine *Scale(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Scale[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the position of a graphical const std::string &in terms of coordinates scaled to run from 0 to 1 across the whole plot range in each direction.
        /// https://reference.wolfram.com/language/ref/Scaled.html
        ///</summary>
        corewolf::engine *Scaled(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Scaled[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a position obtained by starting at ordinary coordinates {x0,y0,…}, then moving by a scaled offset {dx,dy,…}.
        /// https://reference.wolfram.com/language/ref/Scaled.html
        ///</summary>
        corewolf::engine *Scaled(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Scaled[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the matrix corresponding to scaling by a factor si along each coordinate axis.
        /// https://reference.wolfram.com/language/ref/ScalingMatrix.html
        ///</summary>
        corewolf::engine *ScalingMatrix(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ScalingMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the matrix corresponding to scaling by a factor s along the direction of the vector v.
        /// https://reference.wolfram.com/language/ref/ScalingMatrix.html
        ///</summary>
        corewolf::engine *ScalingMatrix(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ScalingMatrix[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a TransformationFunction that represents scaling by a factor si along each coordinate axis from the origin.
        /// https://reference.wolfram.com/language/ref/ScalingTransform.html
        ///</summary>
        corewolf::engine *ScalingTransform(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ScalingTransform[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives scaling centered at the point p.
        /// https://reference.wolfram.com/language/ref/ScalingTransform.html
        ///</summary>
        corewolf::engine *ScalingTransform(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ScalingTransform[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives scaling by a factor s along the direction of the vector v.
        /// https://reference.wolfram.com/language/ref/ScalingTransform.html
        ///</summary>
        corewolf::engine *ScalingTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ScalingTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives scaling along the direction of v, centered at the point p.
        /// https://reference.wolfram.com/language/ref/ScalingTransform.html
        ///</summary>
        corewolf::engine *ScalingTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ScalingTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// evaluates f applied to each element of expr in turn.
        /// https://reference.wolfram.com/language/ref/Scan.html
        ///</summary>
        corewolf::engine *Scan(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Scan[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f to parts of expr specified by levelspec.
        /// https://reference.wolfram.com/language/ref/Scan.html
        ///</summary>
        corewolf::engine *Scan(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Scan[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of Scan that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/Scan.html
        ///</summary>
        corewolf::engine *Scan(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Scan[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a scheduled task to be evaluated on the schedule defined by timespec.
        /// https://reference.wolfram.com/language/ref/ScheduledTask.html
        ///</summary>
        corewolf::engine *ScheduledTask(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ScheduledTask[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields the Schur decomposition for a numerical matrix m, given as a list {q,t} where q is an orthonormal matrix and t is a block upper‐triangular matrix.
        /// https://reference.wolfram.com/language/ref/SchurDecomposition.html
        ///</summary>
        corewolf::engine *SchurDecomposition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SchurDecomposition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the generalized Schur decomposition of m with respect to a.
        /// https://reference.wolfram.com/language/ref/SchurDecomposition.html
        ///</summary>
        corewolf::engine *SchurDecomposition(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SchurDecomposition[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// prints with all real numbers in expr given in scientific notation.
        /// https://reference.wolfram.com/language/ref/ScientificForm.html
        ///</summary>
        corewolf::engine *ScientificForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ScientificForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints with numbers given to n‐digit precision.
        /// https://reference.wolfram.com/language/ref/ScientificForm.html
        ///</summary>
        corewolf::engine *ScientificForm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ScientificForm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Scorer function .
        /// https://reference.wolfram.com/language/ref/ScorerGi.html
        ///</summary>
        corewolf::engine *ScorerGi(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ScorerGi[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the derivative of the Scorer function .
        /// https://reference.wolfram.com/language/ref/ScorerGiPrime.html
        ///</summary>
        corewolf::engine *ScorerGiPrime(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ScorerGiPrime[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Scorer function .
        /// https://reference.wolfram.com/language/ref/ScorerHi.html
        ///</summary>
        corewolf::engine *ScorerHi(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ScorerHi[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the derivative of the Scorer function .
        /// https://reference.wolfram.com/language/ref/ScorerHiPrime.html
        ///</summary>
        corewolf::engine *ScorerHiPrime(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ScorerHiPrime[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a component of a search query that is to be treated as having weight w.
        /// https://reference.wolfram.com/language/ref/SearchAdjustment.html
        ///</summary>
        corewolf::engine *SearchAdjustment(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SearchAdjustment[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a component of a search query with certain options.
        /// https://reference.wolfram.com/language/ref/SearchAdjustment.html
        ///</summary>
        corewolf::engine *SearchAdjustment(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SearchAdjustment[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a search index object, as created by CreateSearchIndex.
        /// https://reference.wolfram.com/language/ref/SearchIndexObject.html
        ///</summary>
        corewolf::engine *SearchIndexObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SearchIndexObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a list with all the locally stored instances of SearchIndexObject.
        /// https://reference.wolfram.com/language/ref/SearchIndices.html
        ///</summary>
        corewolf::engine *SearchIndices(const std::string &name = "")
        {
            return this->execute("SearchIndices[]", name);
        }

        ///< summary>
        /// represents a search engine-style query in TextSearch and related functions.
        /// https://reference.wolfram.com/language/ref/SearchQueryString.html
        ///</summary>
        corewolf::engine *SearchQueryString(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SearchQueryString[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a result from TextSearch[…] and related functions.
        /// https://reference.wolfram.com/language/ref/SearchResultObject.html
        ///</summary>
        corewolf::engine *SearchResultObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SearchResultObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the secant of z.
        /// https://reference.wolfram.com/language/ref/Sec.html
        ///</summary>
        corewolf::engine *Sec(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Sec[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the hyperbolic secant of z.
        /// https://reference.wolfram.com/language/ref/Sech.html
        ///</summary>
        corewolf::engine *Sech(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Sech[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the hyperbolic secant distribution with location parameter μ and scale parameter σ.
        /// https://reference.wolfram.com/language/ref/SechDistribution.html
        ///</summary>
        corewolf::engine *SechDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SechDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the hyperbolic secant distribution with location parameter 0 and scale parameter 1.
        /// https://reference.wolfram.com/language/ref/SechDistribution.html
        ///</summary>
        corewolf::engine *SechDistribution(const std::string &name = "")
        {
            return this->execute("SechDistribution[]", name);
        }

        ///< summary>
        /// finds values of variables vars that minimize the linear objective f subject to second-order cone and/or linear constraints cons.
        /// https://reference.wolfram.com/language/ref/SecondOrderConeOptimization.html
        ///</summary>
        corewolf::engine *SecondOrderConeOptimization(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SecondOrderConeOptimization[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds a vector  that minimizes  subject to the constraints .
        /// https://reference.wolfram.com/language/ref/SecondOrderConeOptimization.html
        ///</summary>
        corewolf::engine *SecondOrderConeOptimization(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("SecondOrderConeOptimization[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// takes  to be in the domain domi, where domi is Integers or Reals.
        /// https://reference.wolfram.com/language/ref/SecondOrderConeOptimization.html
        ///</summary>
        corewolf::engine *SecondOrderConeOptimization(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SecondOrderConeOptimization[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// specifies what solution property "prop" should be returned.
        /// https://reference.wolfram.com/language/ref/SecondOrderConeOptimization.html
        ///</summary>
        corewolf::engine *SecondOrderConeOptimization(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SecondOrderConeOptimization[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// makes a sector chart with sector angles proportional to xi and radii yi.
        /// https://reference.wolfram.com/language/ref/SectorChart.html
        ///</summary>
        corewolf::engine *SectorChart(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SectorChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a sector chart with sector features defined by the symbolic wrappers wk.
        /// https://reference.wolfram.com/language/ref/SectorChart.html
        ///</summary>
        corewolf::engine *SectorChart(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SectorChart[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// makes a sector chart from multiple datasets datai.
        /// https://reference.wolfram.com/language/ref/SectorChart.html
        ///</summary>
        corewolf::engine *SectorChart(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SectorChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a 3D sector chart with sector angle proportional to xi, radius yi, and height zi.
        /// https://reference.wolfram.com/language/ref/SectorChart3D.html
        ///</summary>
        corewolf::engine *SectorChart3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SectorChart3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a 3D sector chart with sector features defined by the symbolic wrappers wk.
        /// https://reference.wolfram.com/language/ref/SectorChart3D.html
        ///</summary>
        corewolf::engine *SectorChart3D(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SectorChart3D[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// makes a 3D sector chart from multiple datasets datai.
        /// https://reference.wolfram.com/language/ref/SectorChart3D.html
        ///</summary>
        corewolf::engine *SectorChart3D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SectorChart3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a secured authentication key with credentials and details specified by the association assoc.
        /// https://reference.wolfram.com/language/ref/SecuredAuthenticationKey.html
        ///</summary>
        corewolf::engine *SecuredAuthenticationKey(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SecuredAuthenticationKey[" + arg0 + "]", name);
        }

        ///< summary>
        /// retrieves a list of all instances of SecuredAuthenticationKey owned by the currently connected user.
        /// https://reference.wolfram.com/language/ref/SecuredAuthenticationKeys.html
        ///</summary>
        corewolf::engine *SecuredAuthenticationKeys(const std::string &name = "")
        {
            return this->execute("SecuredAuthenticationKeys[]", name);
        }

        ///< summary>
        /// retrieves a SecuredAuthenticationKey identified by "name" owned by the currently connected user, if it exists.
        /// https://reference.wolfram.com/language/ref/SecuredAuthenticationKeys.html
        ///</summary>
        corewolf::engine *SecuredAuthenticationKeys(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SecuredAuthenticationKeys[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the security certificate issued for a public key.
        /// https://reference.wolfram.com/language/ref/SecurityCertificate.html
        ///</summary>
        corewolf::engine *SecurityCertificate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SecurityCertificate[" + arg0 + "]", name);
        }

        ///< summary>
        /// resets the pseudorandom generator, using s as a seed.
        /// https://reference.wolfram.com/language/ref/SeedRandom.html
        ///</summary>
        corewolf::engine *SeedRandom(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SeedRandom[" + arg0 + "]", name);
        }

        ///< summary>
        /// resets the generator, using as a seed the time of day and certain attributes of the current Wolfram System session.
        /// https://reference.wolfram.com/language/ref/SeedRandom.html
        ///</summary>
        corewolf::engine *SeedRandom(const std::string &name = "")
        {
            return this->execute("SeedRandom[]", name);
        }

        ///< summary>
        /// picks out all elements ei of list for which crit[ei] is True.
        /// https://reference.wolfram.com/language/ref/Select.html
        ///</summary>
        corewolf::engine *Select(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Select[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// picks out the first n elements for which crit[ei] is True.
        /// https://reference.wolfram.com/language/ref/Select.html
        ///</summary>
        corewolf::engine *Select(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Select[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of Select that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/Select.html
        ///</summary>
        corewolf::engine *Select(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Select[" + arg0 + "]", name);
        }

        ///< summary>
        /// selects components of image indicated by the label matrix lmat that satisfy crit, replacing other parts with black.
        /// https://reference.wolfram.com/language/ref/SelectComponents.html
        ///</summary>
        corewolf::engine *SelectComponents(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SelectComponents[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// selects connected components of image.
        /// https://reference.wolfram.com/language/ref/SelectComponents.html
        ///</summary>
        corewolf::engine *SelectComponents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SelectComponents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes the property "prop" and selects the first n in sorted order.
        /// https://reference.wolfram.com/language/ref/SelectComponents.html
        ///</summary>
        corewolf::engine *SelectComponents(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SelectComponents[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// sorts computed properties using the ordering function p.
        /// https://reference.wolfram.com/language/ref/SelectComponents.html
        ///</summary>
        corewolf::engine *SelectComponents(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SelectComponents[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// returns a list of CellObject expressions corresponding to the currently selected cells in notebook.
        /// https://reference.wolfram.com/language/ref/SelectedCells.html
        ///</summary>
        corewolf::engine *SelectedCells(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SelectedCells[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the currently selected cells in the notebook in which this function is being evaluated.
        /// https://reference.wolfram.com/language/ref/SelectedCells.html
        ///</summary>
        corewolf::engine *SelectedCells(const std::string &name = "")
        {
            return this->execute("SelectedCells[]", name);
        }

        ///< summary>
        /// gives the currently selected notebook in the front end.
        /// https://reference.wolfram.com/language/ref/SelectedNotebook.html
        ///</summary>
        corewolf::engine *SelectedNotebook(const std::string &name = "")
        {
            return this->execute("SelectedNotebook[]", name);
        }

        ///< summary>
        /// gives the first ei for which crit[ei] is True, or Missing["NotFound"] if none is found.
        /// https://reference.wolfram.com/language/ref/SelectFirst.html
        ///</summary>
        corewolf::engine *SelectFirst(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SelectFirst[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives default if there is no ei such that crit[ei] is True.
        /// https://reference.wolfram.com/language/ref/SelectFirst.html
        ///</summary>
        corewolf::engine *SelectFirst(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SelectFirst[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of SelectFirst that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/SelectFirst.html
        ///</summary>
        corewolf::engine *SelectFirst(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SelectFirst[" + arg0 + "]", name);
        }

        ///< summary>
        /// copies the contents of the current selection in a notebook into a new cell.
        /// https://reference.wolfram.com/language/ref/SelectionCreateCell.html
        ///</summary>
        corewolf::engine *SelectionCreateCell(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SelectionCreateCell[" + arg0 + "]", name);
        }

        ///< summary>
        /// sets the current selection after the copy to be as specified by sel.
        /// https://reference.wolfram.com/language/ref/SelectionCreateCell.html
        ///</summary>
        corewolf::engine *SelectionCreateCell(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SelectionCreateCell[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces the current selection in a notebook with the result obtained by evaluating the contents of the selection in the kernel.
        /// https://reference.wolfram.com/language/ref/SelectionEvaluate.html
        ///</summary>
        corewolf::engine *SelectionEvaluate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SelectionEvaluate[" + arg0 + "]", name);
        }

        ///< summary>
        /// sets the current selection after the evaluation to be as specified by sel.
        /// https://reference.wolfram.com/language/ref/SelectionEvaluate.html
        ///</summary>
        corewolf::engine *SelectionEvaluate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SelectionEvaluate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// takes the current selection in a notebook and creates a new cell containing the result obtained by evaluating the contents of the selection using the kernel.
        /// https://reference.wolfram.com/language/ref/SelectionEvaluateCreateCell.html
        ///</summary>
        corewolf::engine *SelectionEvaluateCreateCell(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SelectionEvaluateCreateCell[" + arg0 + "]", name);
        }

        ///< summary>
        /// sets the current selection after the evaluation to be as specified by sel.
        /// https://reference.wolfram.com/language/ref/SelectionEvaluateCreateCell.html
        ///</summary>
        corewolf::engine *SelectionEvaluateCreateCell(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SelectionEvaluateCreateCell[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// moves the current selection in an open notebook in the front end in the direction dir by the specified unit.
        /// https://reference.wolfram.com/language/ref/SelectionMove.html
        ///</summary>
        corewolf::engine *SelectionMove(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SelectionMove[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// repeats the move n times.
        /// https://reference.wolfram.com/language/ref/SelectionMove.html
        ///</summary>
        corewolf::engine *SelectionMove(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SelectionMove[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// attempts to import a file semantically to give a Dataset object.
        /// https://reference.wolfram.com/language/ref/SemanticImport.html
        ///</summary>
        corewolf::engine *SemanticImport(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SemanticImport[" + arg0 + "]", name);
        }

        ///< summary>
        /// attempts to interpret all elements in the file as being of the specified type.
        /// https://reference.wolfram.com/language/ref/SemanticImport.html
        ///</summary>
        corewolf::engine *SemanticImport(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SemanticImport[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// attempts to interpret elements in successive columns as being of the specified types.
        /// https://reference.wolfram.com/language/ref/SemanticImport.html
        ///</summary>
        corewolf::engine *SemanticImport(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SemanticImport[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// keeps only the columns coli specified by their positions or names.
        /// https://reference.wolfram.com/language/ref/SemanticImport.html
        ///</summary>
        corewolf::engine *SemanticImport(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SemanticImport[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// puts the result in the specified form.
        /// https://reference.wolfram.com/language/ref/SemanticImport.html
        ///</summary>
        corewolf::engine *SemanticImport(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SemanticImport[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// attempts to import a string semantically to give a Dataset object.
        /// https://reference.wolfram.com/language/ref/SemanticImportString.html
        ///</summary>
        corewolf::engine *SemanticImportString(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SemanticImportString[" + arg0 + "]", name);
        }

        ///< summary>
        /// attempts to interpret all elements in the string as being of the specified type.
        /// https://reference.wolfram.com/language/ref/SemanticImportString.html
        ///</summary>
        corewolf::engine *SemanticImportString(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SemanticImportString[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// attempts to interpret elements in successive columns as being of the specified types.
        /// https://reference.wolfram.com/language/ref/SemanticImportString.html
        ///</summary>
        corewolf::engine *SemanticImportString(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SemanticImportString[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// attempts to interpret elements in the named columns as being of the specified types.
        /// https://reference.wolfram.com/language/ref/SemanticImportString.html
        ///</summary>
        corewolf::engine *SemanticImportString(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SemanticImportString[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// puts the result in the specified form.
        /// https://reference.wolfram.com/language/ref/SemanticImportString.html
        ///</summary>
        corewolf::engine *SemanticImportString(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SemanticImportString[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// attempts to give the best semantic interpretation of the specified free-form string as a Wolfram Language expression.
        /// https://reference.wolfram.com/language/ref/SemanticInterpretation.html
        ///</summary>
        corewolf::engine *SemanticInterpretation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SemanticInterpretation[" + arg0 + "]", name);
        }

        ///< summary>
        /// filters possible semantic interpretations, returning the best one that matches the specified pattern.
        /// https://reference.wolfram.com/language/ref/SemanticInterpretation.html
        ///</summary>
        corewolf::engine *SemanticInterpretation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SemanticInterpretation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the semantic interpretation wrapped with the specified head.
        /// https://reference.wolfram.com/language/ref/SemanticInterpretation.html
        ///</summary>
        corewolf::engine *SemanticInterpretation(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SemanticInterpretation[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives at least one sample point in each connected component of the semialgebraic set defined by the inequalities ineqs in the variables x1, x2, ….
        /// https://reference.wolfram.com/language/ref/SemialgebraicComponentInstances.html
        ///</summary>
        corewolf::engine *SemialgebraicComponentInstances(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SemialgebraicComponentInstances[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds values of variables vars that minimize the linear objective f subject to semidefinite constraints cons.
        /// https://reference.wolfram.com/language/ref/SemidefiniteOptimization.html
        ///</summary>
        corewolf::engine *SemidefiniteOptimization(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SemidefiniteOptimization[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds a vector  that minimizes the quantity  subject to the linear matrix inequality constraint .
        /// https://reference.wolfram.com/language/ref/SemidefiniteOptimization.html
        ///</summary>
        corewolf::engine *SemidefiniteOptimization(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SemidefiniteOptimization[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// specifies what solution property "prop" should be returned.
        /// https://reference.wolfram.com/language/ref/SemidefiniteOptimization.html
        ///</summary>
        corewolf::engine *SemidefiniteOptimization(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SemidefiniteOptimization[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sends mail consisting of body to the address specified by $CloudUserID.
        /// https://reference.wolfram.com/language/ref/SendMail.html
        ///</summary>
        corewolf::engine *SendMail(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SendMail[" + arg0 + "]", name);
        }

        ///< summary>
        /// sends mail with the specified subject and no body.
        /// https://reference.wolfram.com/language/ref/SendMail.html
        ///</summary>
        corewolf::engine *SendMail(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SendMail[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// sends mail to the specified To: address.
        /// https://reference.wolfram.com/language/ref/SendMail.html
        ///</summary>
        corewolf::engine *SendMail(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SendMail[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sends mail to multiple To: addresses.
        /// https://reference.wolfram.com/language/ref/SendMail.html
        ///</summary>
        corewolf::engine *SendMail(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SendMail[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// includes the cci as Cc: addresses.
        /// https://reference.wolfram.com/language/ref/SendMail.html
        ///</summary>
        corewolf::engine *SendMail(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SendMail[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// also includes the bcci as Bcc: addresses.
        /// https://reference.wolfram.com/language/ref/SendMail.html
        ///</summary>
        corewolf::engine *SendMail(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SendMail[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// sends a message to the specified channel.
        /// https://reference.wolfram.com/language/ref/SendMessage.html
        ///</summary>
        corewolf::engine *SendMessage(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SendMessage[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a sequence of arguments to be spliced automatically into any function.
        /// https://reference.wolfram.com/language/ref/Sequence.html
        ///</summary>
        corewolf::engine *Sequence(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Sequence[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// finds an optimal alignment of sequences of elements in the strings, lists or biomolecular sequences s1 and s2, and yields a list of successive matching and differing sequences.
        /// https://reference.wolfram.com/language/ref/SequenceAlignment.html
        ///</summary>
        corewolf::engine *SequenceAlignment(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SequenceAlignment[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the sublists in list that match the sequence pattern patt.
        /// https://reference.wolfram.com/language/ref/SequenceCases.html
        ///</summary>
        corewolf::engine *SequenceCases(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SequenceCases[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// includes only the first n matches.
        /// https://reference.wolfram.com/language/ref/SequenceCases.html
        ///</summary>
        corewolf::engine *SequenceCases(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SequenceCases[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a count of the number of times sub appears as a sublist of list.
        /// https://reference.wolfram.com/language/ref/SequenceCount.html
        ///</summary>
        corewolf::engine *SequenceCount(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SequenceCount[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the last element of SequenceFoldList[f,{x1,…,xn},{a1,a2,…}].
        /// https://reference.wolfram.com/language/ref/SequenceFold.html
        ///</summary>
        corewolf::engine *SequenceFold(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SequenceFold[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// applies f to k arguments at each step, with the first n coming from the xi or previous results, and the last k-n coming from the ai.
        /// https://reference.wolfram.com/language/ref/SequenceFold.html
        ///</summary>
        corewolf::engine *SequenceFold(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SequenceFold[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives {x1,…,xn,f[x1,…,xn,a1],f[x2,…,xn,f[x1,…,xn,a1],a2],…}.
        /// https://reference.wolfram.com/language/ref/SequenceFoldList.html
        ///</summary>
        corewolf::engine *SequenceFoldList(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SequenceFoldList[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// applies f to k arguments at each step, with the first n coming from the xi or previous results, and the last k-n coming from the ai.
        /// https://reference.wolfram.com/language/ref/SequenceFoldList.html
        ///</summary>
        corewolf::engine *SequenceFoldList(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SequenceFoldList[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a net layer that produces a list of indices for an input sequence.
        /// https://reference.wolfram.com/language/ref/SequenceIndicesLayer.html
        ///</summary>
        corewolf::engine *SequenceIndicesLayer(const std::string &name = "")
        {
            return this->execute("SequenceIndicesLayer[]", name);
        }

        ///< summary>
        /// represents a net that takes a sequence of inputs and returns the last element of the sequence.
        /// https://reference.wolfram.com/language/ref/SequenceLastLayer.html
        ///</summary>
        corewolf::engine *SequenceLastLayer(const std::string &name = "")
        {
            return this->execute("SequenceLastLayer[]", name);
        }

        ///< summary>
        /// represents a net that takes a sequence of inputs and removes its last element.
        /// https://reference.wolfram.com/language/ref/SequenceMostLayer.html
        ///</summary>
        corewolf::engine *SequenceMostLayer(const std::string &name = "")
        {
            return this->execute("SequenceMostLayer[]", name);
        }

        ///< summary>
        /// gives a list of the starting and ending positions at which sublist appears in list.
        /// https://reference.wolfram.com/language/ref/SequencePosition.html
        ///</summary>
        corewolf::engine *SequencePosition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SequencePosition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// includes only the first n occurrences of patt.
        /// https://reference.wolfram.com/language/ref/SequencePosition.html
        ///</summary>
        corewolf::engine *SequencePosition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SequencePosition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a SequencePredictorFunction[…] based on the sequences given.
        /// https://reference.wolfram.com/language/ref/SequencePredict.html
        ///</summary>
        corewolf::engine *SequencePredict(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SequencePredict[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// attempts to predict the next element in the sequence seq from the training sequences given.
        /// https://reference.wolfram.com/language/ref/SequencePredict.html
        ///</summary>
        corewolf::engine *SequencePredict(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SequencePredict[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives predictions for each of the sequences seqi.
        /// https://reference.wolfram.com/language/ref/SequencePredict.html
        ///</summary>
        corewolf::engine *SequencePredict(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SequencePredict[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// give the specified property of the prediction associated with seq.
        /// https://reference.wolfram.com/language/ref/SequencePredict.html
        ///</summary>
        corewolf::engine *SequencePredict(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SequencePredict[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a function generated by SequencePredict that predicts the next elements from a sequence.
        /// https://reference.wolfram.com/language/ref/SequencePredictorFunction.html
        ///</summary>
        corewolf::engine *SequencePredictorFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SequencePredictorFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// replaces sequences in list according to the specified rule or list of rules.
        /// https://reference.wolfram.com/language/ref/SequenceReplace.html
        ///</summary>
        corewolf::engine *SequenceReplace(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SequenceReplace[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// does only the first n replacements.
        /// https://reference.wolfram.com/language/ref/SequenceReplace.html
        ///</summary>
        corewolf::engine *SequenceReplace(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SequenceReplace[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of SequenceReplace that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/SequenceReplace.html
        ///</summary>
        corewolf::engine *SequenceReplace(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SequenceReplace[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a net that takes a sequence of inputs and removes its first element.
        /// https://reference.wolfram.com/language/ref/SequenceRestLayer.html
        ///</summary>
        corewolf::engine *SequenceRestLayer(const std::string &name = "")
        {
            return this->execute("SequenceRestLayer[]", name);
        }

        ///< summary>
        /// represents a net that reverses the order of an input sequence.
        /// https://reference.wolfram.com/language/ref/SequenceReverseLayer.html
        ///</summary>
        corewolf::engine *SequenceReverseLayer(const std::string &name = "")
        {
            return this->execute("SequenceReverseLayer[]", name);
        }

        ///< summary>
        /// splits list into sublists separated by sequences that match the sequence pattern patt.
        /// https://reference.wolfram.com/language/ref/SequenceSplit.html
        ///</summary>
        corewolf::engine *SequenceSplit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SequenceSplit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// inserts rhsi at the position of each patti.
        /// https://reference.wolfram.com/language/ref/SequenceSplit.html
        ///</summary>
        corewolf::engine *SequenceSplit(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SequenceSplit[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// splits into at most n sublists.
        /// https://reference.wolfram.com/language/ref/SequenceSplit.html
        ///</summary>
        corewolf::engine *SequenceSplit(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SequenceSplit[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a power series expansion for f about the point x=x0 to order (x-x0)n, where n is an explicit integer.
        /// https://reference.wolfram.com/language/ref/Series.html
        ///</summary>
        corewolf::engine *Series(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Series[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates the leading term of a power series expansion for f about the point x=x0.
        /// https://reference.wolfram.com/language/ref/Series.html
        ///</summary>
        corewolf::engine *Series(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Series[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// successively finds series expansions with respect to x, then y, etc.
        /// https://reference.wolfram.com/language/ref/Series.html
        ///</summary>
        corewolf::engine *Series(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Series[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// finds the coefficient of the n -order term in a power series in the form generated by Series.
        /// https://reference.wolfram.com/language/ref/SeriesCoefficient.html
        ///</summary>
        corewolf::engine *SeriesCoefficient(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SeriesCoefficient[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the coefficient of  in the expansion of f about the point .
        /// https://reference.wolfram.com/language/ref/SeriesCoefficient.html
        ///</summary>
        corewolf::engine *SeriesCoefficient(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SeriesCoefficient[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// finds a coefficient in a multivariate series.
        /// https://reference.wolfram.com/language/ref/SeriesCoefficient.html
        ///</summary>
        corewolf::engine *SeriesCoefficient(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SeriesCoefficient[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a power series in the variable x about the point x0. The ai are the coefficients in the power series. The powers of (x-x0) that appear are nmin/den, (nmin+1)/den, …, nmax/den.
        /// https://reference.wolfram.com/language/ref/SeriesData.html
        ///</summary>
        corewolf::engine *SeriesData(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("SeriesData[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// creates a connection to an external service.
        /// https://reference.wolfram.com/language/ref/ServiceConnect.html
        ///</summary>
        corewolf::engine *ServiceConnect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ServiceConnect[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the specified connection identifier.
        /// https://reference.wolfram.com/language/ref/ServiceConnect.html
        ///</summary>
        corewolf::engine *ServiceConnect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ServiceConnect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// disconnects from an external service specified by a ServiceObject.
        /// https://reference.wolfram.com/language/ref/ServiceDisconnect.html
        ///</summary>
        corewolf::engine *ServiceDisconnect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ServiceDisconnect[" + arg0 + "]", name);
        }

        ///< summary>
        /// executes "req" on an external service.
        /// https://reference.wolfram.com/language/ref/ServiceExecute.html
        ///</summary>
        corewolf::engine *ServiceExecute(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ServiceExecute[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// executes "req" with the specified settings for parameters.
        /// https://reference.wolfram.com/language/ref/ServiceExecute.html
        ///</summary>
        corewolf::engine *ServiceExecute(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ServiceExecute[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// executes ServiceRequest req on an external service.
        /// https://reference.wolfram.com/language/ref/ServiceExecute.html
        ///</summary>
        corewolf::engine *ServiceExecute(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ServiceExecute[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an open connection to an external service.
        /// https://reference.wolfram.com/language/ref/ServiceObject.html
        ///</summary>
        corewolf::engine *ServiceObject(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ServiceObject[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a service request built from service, which might be a connected ServiceObject or a valid service name, and request "req".
        /// https://reference.wolfram.com/language/ref/ServiceRequest.html
        ///</summary>
        corewolf::engine *ServiceRequest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ServiceRequest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a service request, built from the service service, request "req" and parameters param.
        /// https://reference.wolfram.com/language/ref/ServiceRequest.html
        ///</summary>
        corewolf::engine *ServiceRequest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ServiceRequest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a service request, built from association assoc.
        /// https://reference.wolfram.com/language/ref/ServiceRequest.html
        ///</summary>
        corewolf::engine *ServiceRequest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ServiceRequest[" + arg0 + "]", name);
        }

        ///< summary>
        /// submits a request to be executed by an external service specified by assoc.
        /// https://reference.wolfram.com/language/ref/ServiceSubmit.html
        ///</summary>
        corewolf::engine *ServiceSubmit(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ServiceSubmit[" + arg0 + "]", name);
        }

        ///< summary>
        /// submits an asynchronous task to evaluate expr in the current session.
        /// https://reference.wolfram.com/language/ref/SessionSubmit.html
        ///</summary>
        corewolf::engine *SessionSubmit(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SessionSubmit[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the total number of seconds of real time that have elapsed since the beginning of your Wolfram System session.
        /// https://reference.wolfram.com/language/ref/SessionTime.html
        ///</summary>
        corewolf::engine *SessionTime(const std::string &name = "")
        {
            return this->execute("SessionTime[]", name);
        }

        ///< summary>
        /// yields a version of expr in which all numbers have been set to have accuracy a.
        /// https://reference.wolfram.com/language/ref/SetAccuracy.html
        ///</summary>
        corewolf::engine *SetAccuracy(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SetAccuracy[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// adds full opacity to color.
        /// https://reference.wolfram.com/language/ref/SetAlphaChannel.html
        ///</summary>
        corewolf::engine *SetAlphaChannel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SetAlphaChannel[" + arg0 + "]", name);
        }

        ///< summary>
        /// adds opacity a to color.
        /// https://reference.wolfram.com/language/ref/SetAlphaChannel.html
        ///</summary>
        corewolf::engine *SetAlphaChannel(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SetAlphaChannel[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// adds attr to the list of attributes of the symbol symbol.
        /// https://reference.wolfram.com/language/ref/SetAttributes.html
        ///</summary>
        corewolf::engine *SetAttributes(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SetAttributes[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sets several attributes at a time.
        /// https://reference.wolfram.com/language/ref/SetAttributes.html
        ///</summary>
        corewolf::engine *SetAttributes(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SetAttributes[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// sets attributes of several symbols at a time.
        /// https://reference.wolfram.com/language/ref/SetAttributes.html
        ///</summary>
        corewolf::engine *SetAttributes(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SetAttributes[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sets the current working directory used for cloud objects to dir.
        /// https://reference.wolfram.com/language/ref/SetCloudDirectory.html
        ///</summary>
        corewolf::engine *SetCloudDirectory(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SetCloudDirectory[" + arg0 + "]", name);
        }

        ///< summary>
        /// sets the current working directory for cloud objects to $CloudRootDirectory.
        /// https://reference.wolfram.com/language/ref/SetCloudDirectory.html
        ///</summary>
        corewolf::engine *SetCloudDirectory(const std::string &name = "")
        {
            return this->execute("SetCloudDirectory[]", name);
        }

        ///< summary>
        /// sets cookies with attributes specified by the association assoc, to be used by functions such as URLExecute.
        /// https://reference.wolfram.com/language/ref/SetCookies.html
        ///</summary>
        corewolf::engine *SetCookies(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SetCookies[" + arg0 + "]", name);
        }

        ///< summary>
        /// sets a list of cookies.
        /// https://reference.wolfram.com/language/ref/SetCookies.html
        ///</summary>
        corewolf::engine *SetCookies(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SetCookies[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// sets the current working directory to dir.
        /// https://reference.wolfram.com/language/ref/SetDirectory.html
        ///</summary>
        corewolf::engine *SetDirectory(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SetDirectory[" + arg0 + "]", name);
        }

        ///< summary>
        /// sets the current working directory to your "home" directory.
        /// https://reference.wolfram.com/language/ref/SetDirectory.html
        ///</summary>
        corewolf::engine *SetDirectory(const std::string &name = "")
        {
            return this->execute("SetDirectory[]", name);
        }

        ///< summary>
        /// sets the value of an operating system environment variable.
        /// https://reference.wolfram.com/language/ref/SetEnvironment.html
        ///</summary>
        corewolf::engine *SetEnvironment(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SetEnvironment[" + arg0 + "]", name);
        }

        ///< summary>
        /// sets values for several environment variables.
        /// https://reference.wolfram.com/language/ref/SetEnvironment.html
        ///</summary>
        corewolf::engine *SetEnvironment(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SetEnvironment[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// sets the modification and access dates for a file to be the current date.
        /// https://reference.wolfram.com/language/ref/SetFileDate.html
        ///</summary>
        corewolf::engine *SetFileDate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SetFileDate[" + arg0 + "]", name);
        }

        ///< summary>
        /// sets the value of a property "prop" for the specified format "fmt".
        /// https://reference.wolfram.com/language/ref/SetFileFormatProperties.html
        ///</summary>
        corewolf::engine *SetFileFormatProperties(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SetFileFormatProperties[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sets the value of multiple properties "propi".
        /// https://reference.wolfram.com/language/ref/SetFileFormatProperties.html
        ///</summary>
        corewolf::engine *SetFileFormatProperties(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SetFileFormatProperties[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// sets the specified default options for a symbol s.
        /// https://reference.wolfram.com/language/ref/SetOptions.html
        ///</summary>
        corewolf::engine *SetOptions(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SetOptions[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// sets options associated with a particular stream.
        /// https://reference.wolfram.com/language/ref/SetOptions.html
        ///</summary>
        corewolf::engine *SetOptions(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SetOptions[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sets permissions for the cloud const std::string &obj to be as specified by the string pstring.
        /// https://reference.wolfram.com/language/ref/SetPermissions.html
        ///</summary>
        corewolf::engine *SetPermissions(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SetPermissions[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sets permissions as specified by pers for the cloud const std::string &corresponding to the current document.
        /// https://reference.wolfram.com/language/ref/SetPermissions.html
        ///</summary>
        corewolf::engine *SetPermissions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SetPermissions[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields a version of expr in which all numbers have been set to have precision p.
        /// https://reference.wolfram.com/language/ref/SetPrecision.html
        ///</summary>
        corewolf::engine *SetPrecision(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SetPrecision[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// makes the notebook corresponding to obj be the currently selected one in the front end.
        /// https://reference.wolfram.com/language/ref/SetSelectedNotebook.html
        ///</summary>
        corewolf::engine *SetSelectedNotebook(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SetSelectedNotebook[" + arg0 + "]", name);
        }

        ///< summary>
        /// declares the symbols fi as shared functions whose downvalues are synchronized among all parallel kernels.
        /// https://reference.wolfram.com/language/ref/SetSharedFunction.html
        ///</summary>
        corewolf::engine *SetSharedFunction(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SetSharedFunction[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// declares the symbols si as shared variables whose values are synchronized among all parallel kernels.
        /// https://reference.wolfram.com/language/ref/SetSharedVariable.html
        ///</summary>
        corewolf::engine *SetSharedVariable(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SetSharedVariable[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// sets the current point in an open stream.
        /// https://reference.wolfram.com/language/ref/SetStreamPosition.html
        ///</summary>
        corewolf::engine *SetStreamPosition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SetStreamPosition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// changes model parameters, initializations or other properties in place.
        /// https://reference.wolfram.com/language/ref/SetSystemModel.html
        ///</summary>
        corewolf::engine *SetSystemModel(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SetSystemModel[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// resets the value for the internal system option with the specified name.
        /// https://reference.wolfram.com/language/ref/SetSystemOptions.html
        ///</summary>
        corewolf::engine *SetSystemOptions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SetSystemOptions[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a setter button whose setting x is set to val when the button is clicked. The button is labeled with val, and appears pressed if the value of x is val, and unpressed otherwise.
        /// https://reference.wolfram.com/language/ref/Setter.html
        ///</summary>
        corewolf::engine *Setter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Setter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// labels the setter button with label.
        /// https://reference.wolfram.com/language/ref/Setter.html
        ///</summary>
        corewolf::engine *Setter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Setter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a setter button that sets x to valn if multiclicked n times.
        /// https://reference.wolfram.com/language/ref/Setter.html
        ///</summary>
        corewolf::engine *Setter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Setter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a setter bar with setting x and with setter buttons for values vali.
        /// https://reference.wolfram.com/language/ref/SetterBar.html
        ///</summary>
        corewolf::engine *SetterBar(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SetterBar[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// replaces forms and control objects such as sliders or popup menus in expr by their settings.
        /// https://reference.wolfram.com/language/ref/Setting.html
        ///</summary>
        corewolf::engine *Setting(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Setting[" + arg0 + "]", name);
        }

        ///< summary>
        /// sets the members of the permissions group group to be {user1,…}.
        /// https://reference.wolfram.com/language/ref/SetUsers.html
        ///</summary>
        corewolf::engine *SetUsers(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SetUsers[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// prints as a shallow form of expr.
        /// https://reference.wolfram.com/language/ref/Shallow.html
        ///</summary>
        corewolf::engine *Shallow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Shallow[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints with all parts of expr below the specified depth given in skeleton form.
        /// https://reference.wolfram.com/language/ref/Shallow.html
        ///</summary>
        corewolf::engine *Shallow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Shallow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// also gives parts whose lengths are above the specified limit in skeleton form.
        /// https://reference.wolfram.com/language/ref/Shallow.html
        ///</summary>
        corewolf::engine *Shallow(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Shallow[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses skeleton form for any parts that match the pattern form.
        /// https://reference.wolfram.com/language/ref/Shallow.html
        ///</summary>
        corewolf::engine *Shallow(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Shallow[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the Shannon wavelet evaluated on the equally spaced interval {-10,10}.
        /// https://reference.wolfram.com/language/ref/ShannonWavelet.html
        ///</summary>
        corewolf::engine *ShannonWavelet(const std::string &name = "")
        {
            return this->execute("ShannonWavelet[]", name);
        }

        ///< summary>
        /// represents the Shannon wavelet evaluated on the equally spaced interval {-lim,lim}.
        /// https://reference.wolfram.com/language/ref/ShannonWavelet.html
        ///</summary>
        corewolf::engine *ShannonWavelet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ShannonWavelet[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether data is normally distributed using the Shapiro–Wilk test.
        /// https://reference.wolfram.com/language/ref/ShapiroWilkTest.html
        ///</summary>
        corewolf::engine *ShapiroWilkTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ShapiroWilkTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/ShapiroWilkTest.html
        ///</summary>
        corewolf::engine *ShapiroWilkTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ShapiroWilkTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// changes the way expr is stored internally, to try and minimize the amount of memory used.
        /// https://reference.wolfram.com/language/ref/Share.html
        ///</summary>
        corewolf::engine *Share(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Share[" + arg0 + "]", name);
        }

        ///< summary>
        /// tries to minimize the memory used to store all expressions.
        /// https://reference.wolfram.com/language/ref/Share.html
        ///</summary>
        corewolf::engine *Share(const std::string &name = "")
        {
            return this->execute("Share[]", name);
        }

        ///< summary>
        /// gives a sharpened version of image.
        /// https://reference.wolfram.com/language/ref/Sharpen.html
        ///</summary>
        corewolf::engine *Sharpen(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Sharpen[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a version of image sharpened over pixel radius r.
        /// https://reference.wolfram.com/language/ref/Sharpen.html
        ///</summary>
        corewolf::engine *Sharpen(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Sharpen[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the matrix corresponding to shearing by θ radians along the direction of the vector v, and normal to the vector n.
        /// https://reference.wolfram.com/language/ref/ShearingMatrix.html
        ///</summary>
        corewolf::engine *ShearingMatrix(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ShearingMatrix[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a TransformationFunction that represents a shear by θ radians along the direction of the vector v, normal to the vector n, and keeping the origin fixed.
        /// https://reference.wolfram.com/language/ref/ShearingTransform.html
        ///</summary>
        corewolf::engine *ShearingTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ShearingTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a shear that keeps the point p fixed, rather than the origin.
        /// https://reference.wolfram.com/language/ref/ShearingTransform.html
        ///</summary>
        corewolf::engine *ShearingTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ShearingTransform[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives a solid shell of a 3D region reg.
        /// https://reference.wolfram.com/language/ref/ShellRegion.html
        ///</summary>
        corewolf::engine *ShellRegion(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ShellRegion[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a solid shell of reg with minimal thickness t.
        /// https://reference.wolfram.com/language/ref/ShellRegion.html
        ///</summary>
        corewolf::engine *ShellRegion(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ShellRegion[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a matrix that corresponds to an exponential kernel of radius r.
        /// https://reference.wolfram.com/language/ref/ShenCastanMatrix.html
        ///</summary>
        corewolf::engine *ShenCastanMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ShenCastanMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a matrix corresponding to an exponential kernel with radius r and region of support specified by σ.
        /// https://reference.wolfram.com/language/ref/ShenCastanMatrix.html
        ///</summary>
        corewolf::engine *ShenCastanMatrix(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ShenCastanMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a matrix formed from the n1 derivative of the exponential with respect to rows and the n2 derivative with respect to columns.
        /// https://reference.wolfram.com/language/ref/ShenCastanMatrix.html
        ///</summary>
        corewolf::engine *ShenCastanMatrix(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ShenCastanMatrix[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a matrix formed from the sums of the ni1 and ni2 derivatives.
        /// https://reference.wolfram.com/language/ref/ShenCastanMatrix.html
        ///</summary>
        corewolf::engine *ShenCastanMatrix(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ShenCastanMatrix[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives an array corresponding to an exponential kernel with radius ri in the i index direction.
        /// https://reference.wolfram.com/language/ref/ShenCastanMatrix.html
        ///</summary>
        corewolf::engine *ShenCastanMatrix(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ShenCastanMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a shifted Gompertz distribution with scale parameter λ and shape parameter ξ.
        /// https://reference.wolfram.com/language/ref/ShiftedGompertzDistribution.html
        ///</summary>
        corewolf::engine *ShiftedGompertzDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ShiftedGompertzDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a complete maximum-length sequence for a size n linear-feedback shift register.
        /// https://reference.wolfram.com/language/ref/ShiftRegisterSequence.html
        ///</summary>
        corewolf::engine *ShiftRegisterSequence(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ShiftRegisterSequence[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the complete sequence for a linear-feedback shift register with size n and taps at positions tapi.
        /// https://reference.wolfram.com/language/ref/ShiftRegisterSequence.html
        ///</summary>
        corewolf::engine *ShiftRegisterSequence(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ShiftRegisterSequence[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the first s elements of the shift register sequence.
        /// https://reference.wolfram.com/language/ref/ShiftRegisterSequence.html
        ///</summary>
        corewolf::engine *ShiftRegisterSequence(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ShiftRegisterSequence[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the shift register sequence starting from state init.
        /// https://reference.wolfram.com/language/ref/ShiftRegisterSequence.html
        ///</summary>
        corewolf::engine *ShiftRegisterSequence(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ShiftRegisterSequence[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// prints as a short form of expr, less than about one line long.
        /// https://reference.wolfram.com/language/ref/Short.html
        ///</summary>
        corewolf::engine *Short(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Short[" + arg0 + "]", name);
        }

        ///< summary>
        /// prints as a form of expr about n lines long.
        /// https://reference.wolfram.com/language/ref/Short.html
        ///</summary>
        corewolf::engine *Short(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Short[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/ShortDownArrow.html
        ///</summary>
        corewolf::engine *ShortDownArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ShortDownArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a pattern const std::string &that matches the shortest sequence consistent with the pattern p.
        /// https://reference.wolfram.com/language/ref/Shortest.html
        ///</summary>
        corewolf::engine *Shortest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Shortest[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a function that gives the shortest path from a source vertex s to target vertex t in a graph.
        /// https://reference.wolfram.com/language/ref/ShortestPathFunction.html
        ///</summary>
        corewolf::engine *ShortestPathFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ShortestPathFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/ShortLeftArrow.html
        ///</summary>
        corewolf::engine *ShortLeftArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ShortLeftArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/ShortRightArrow.html
        ///</summary>
        corewolf::engine *ShortRightArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ShortRightArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the short-time Fourier transform (STFT) of data as a ShortTimeFourierData object.
        /// https://reference.wolfram.com/language/ref/ShortTimeFourier.html
        ///</summary>
        corewolf::engine *ShortTimeFourier(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ShortTimeFourier[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses partitions of length n.
        /// https://reference.wolfram.com/language/ref/ShortTimeFourier.html
        ///</summary>
        corewolf::engine *ShortTimeFourier(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ShortTimeFourier[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses partitions with offset d.
        /// https://reference.wolfram.com/language/ref/ShortTimeFourier.html
        ///</summary>
        corewolf::engine *ShortTimeFourier(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ShortTimeFourier[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies a smoothing window wfun to each partition.
        /// https://reference.wolfram.com/language/ref/ShortTimeFourier.html
        ///</summary>
        corewolf::engine *ShortTimeFourier(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ShortTimeFourier[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// pads partitions with zeros to length m prior to the computation of the transform.
        /// https://reference.wolfram.com/language/ref/ShortTimeFourier.html
        ///</summary>
        corewolf::engine *ShortTimeFourier(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("ShortTimeFourier[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// represents the result and properties of a short-time Fourier transform (STFT) of a signal.
        /// https://reference.wolfram.com/language/ref/ShortTimeFourierData.html
        ///</summary>
        corewolf::engine *ShortTimeFourierData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ShortTimeFourierData[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/ShortUpArrow.html
        ///</summary>
        corewolf::engine *ShortUpArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ShortUpArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// shows graphics with the specified options added.
        /// https://reference.wolfram.com/language/ref/Show.html
        ///</summary>
        corewolf::engine *Show(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Show[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// shows several graphics combined.
        /// https://reference.wolfram.com/language/ref/Show.html
        ///</summary>
        corewolf::engine *Show(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Show[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the right ascension of the local meridian for the current date and location.
        /// https://reference.wolfram.com/language/ref/SiderealTime.html
        ///</summary>
        corewolf::engine *SiderealTime(const std::string &name = "")
        {
            return this->execute("SiderealTime[]", name);
        }

        ///< summary>
        /// gives the right ascension of the local meridian for the specified date.
        /// https://reference.wolfram.com/language/ref/SiderealTime.html
        ///</summary>
        corewolf::engine *SiderealTime(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SiderealTime[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the right ascension of the local meridian for the specified date and location.
        /// https://reference.wolfram.com/language/ref/SiderealTime.html
        ///</summary>
        corewolf::engine *SiderealTime(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SiderealTime[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the right ascensions of the local meridians for all specified locations on the specified dates.
        /// https://reference.wolfram.com/language/ref/SiderealTime.html
        ///</summary>
        corewolf::engine *SiderealTime(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SiderealTime[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses func to determine what to return for extended locations.
        /// https://reference.wolfram.com/language/ref/SiderealTime.html
        ///</summary>
        corewolf::engine *SiderealTime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SiderealTime[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the mean sidereal time for the specified date, location and aggregation function.
        /// https://reference.wolfram.com/language/ref/SiderealTime.html
        ///</summary>
        corewolf::engine *SiderealTime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SiderealTime[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the Siegel theta function  with Riemann modular matrix Ω and vector s.
        /// https://reference.wolfram.com/language/ref/SiegelTheta.html
        ///</summary>
        corewolf::engine *SiegelTheta(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SiegelTheta[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Siegel theta function  with characteristics ν1 and ν2.
        /// https://reference.wolfram.com/language/ref/SiegelTheta.html
        ///</summary>
        corewolf::engine *SiegelTheta(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SiegelTheta[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tests whether the variances of data1 and data2 are equal.
        /// https://reference.wolfram.com/language/ref/SiegelTukeyTest.html
        ///</summary>
        corewolf::engine *SiegelTukeyTest(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SiegelTukeyTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// tests a dispersion measure against .
        /// https://reference.wolfram.com/language/ref/SiegelTukeyTest.html
        ///</summary>
        corewolf::engine *SiegelTukeyTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SiegelTukeyTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/SiegelTukeyTest.html
        ///</summary>
        corewolf::engine *SiegelTukeyTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SiegelTukeyTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the line segments representing the n-step Sierpiński curve.
        /// https://reference.wolfram.com/language/ref/SierpinskiCurve.html
        ///</summary>
        corewolf::engine *SierpinskiCurve(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SierpinskiCurve[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a mesh region representing the n-step Sierpiński triangle.
        /// https://reference.wolfram.com/language/ref/SierpinskiMesh.html
        ///</summary>
        corewolf::engine *SierpinskiMesh(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SierpinskiMesh[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the n-step Sierpiński sponge in dimension d.
        /// https://reference.wolfram.com/language/ref/SierpinskiMesh.html
        ///</summary>
        corewolf::engine *SierpinskiMesh(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SierpinskiMesh[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives -1, 0, or 1 depending on whether x is negative, zero, or positive.
        /// https://reference.wolfram.com/language/ref/Sign.html
        ///</summary>
        corewolf::engine *Sign(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Sign[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the signature of the permutation needed to place the elements of list in canonical order.
        /// https://reference.wolfram.com/language/ref/Signature.html
        ///</summary>
        corewolf::engine *Signature(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Signature[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the median of data is zero.
        /// https://reference.wolfram.com/language/ref/SignedRankTest.html
        ///</summary>
        corewolf::engine *SignedRankTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SignedRankTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the median of data1-data2 is zero.
        /// https://reference.wolfram.com/language/ref/SignedRankTest.html
        ///</summary>
        corewolf::engine *SignedRankTest(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SignedRankTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// tests a location measure against μ0.
        /// https://reference.wolfram.com/language/ref/SignedRankTest.html
        ///</summary>
        corewolf::engine *SignedRankTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SignedRankTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/SignedRankTest.html
        ///</summary>
        corewolf::engine *SignedRankTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SignedRankTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the minimum distance from the point p to the region reg if p is outside the region and the minimum distance to the complement of reg if p is inside the region.
        /// https://reference.wolfram.com/language/ref/SignedRegionDistance.html
        ///</summary>
        corewolf::engine *SignedRegionDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SignedRegionDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a RegionDistanceFunction[…] that can be applied repeatedly to different points.
        /// https://reference.wolfram.com/language/ref/SignedRegionDistance.html
        ///</summary>
        corewolf::engine *SignedRegionDistance(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SignedRegionDistance[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the median of data is zero.
        /// https://reference.wolfram.com/language/ref/SignTest.html
        ///</summary>
        corewolf::engine *SignTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SignTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the median of data1– data2 is zero.
        /// https://reference.wolfram.com/language/ref/SignTest.html
        ///</summary>
        corewolf::engine *SignTest(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SignTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// tests a location measure against μ0.
        /// https://reference.wolfram.com/language/ref/SignTest.html
        ///</summary>
        corewolf::engine *SignTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SignTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/SignTest.html
        ///</summary>
        corewolf::engine *SignTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SignTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the underlying simple graph from the graph g.
        /// https://reference.wolfram.com/language/ref/SimpleGraph.html
        ///</summary>
        corewolf::engine *SimpleGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SimpleGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/SimpleGraph.html
        ///</summary>
        corewolf::engine *SimpleGraph(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SimpleGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is a simple graph and False otherwise.
        /// https://reference.wolfram.com/language/ref/SimpleGraphQ.html
        ///</summary>
        corewolf::engine *SimpleGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SimpleGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if the polygon poly is simple and False otherwise.
        /// https://reference.wolfram.com/language/ref/SimplePolygonQ.html
        ///</summary>
        corewolf::engine *SimplePolygonQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SimplePolygonQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if the polyhedron poly is simple and False otherwise.
        /// https://reference.wolfram.com/language/ref/SimplePolyhedronQ.html
        ///</summary>
        corewolf::engine *SimplePolyhedronQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SimplePolyhedronQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the simplex spanned by points pi.
        /// https://reference.wolfram.com/language/ref/Simplex.html
        ///</summary>
        corewolf::engine *Simplex(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Simplex[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// performs a sequence of algebraic and other transformations on expr and returns the simplest form it finds.
        /// https://reference.wolfram.com/language/ref/Simplify.html
        ///</summary>
        corewolf::engine *Simplify(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Simplify[" + arg0 + "]", name);
        }

        ///< summary>
        /// does simplification using assumptions.
        /// https://reference.wolfram.com/language/ref/Simplify.html
        ///</summary>
        corewolf::engine *Simplify(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Simplify[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the sine of z.
        /// https://reference.wolfram.com/language/ref/Sin.html
        ///</summary>
        corewolf::engine *Sin(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Sin[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives .
        /// https://reference.wolfram.com/language/ref/Sinc.html
        ///</summary>
        corewolf::engine *Sinc(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Sinc[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the Singh–Maddala distribution with shape parameters q and a and scale parameter b.
        /// https://reference.wolfram.com/language/ref/SinghMaddalaDistribution.html
        ///</summary>
        corewolf::engine *SinghMaddalaDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SinghMaddalaDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the singular value decomposition for a numerical matrix m as a list of matrices {u,σ,v}, where σ is a diagonal matrix and m can be written as u.σ.ConjugateTranspose[v].
        /// https://reference.wolfram.com/language/ref/SingularValueDecomposition.html
        ///</summary>
        corewolf::engine *SingularValueDecomposition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SingularValueDecomposition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the generalized singular value decomposition of m with respect to a.
        /// https://reference.wolfram.com/language/ref/SingularValueDecomposition.html
        ///</summary>
        corewolf::engine *SingularValueDecomposition(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SingularValueDecomposition[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the singular value decomposition associated with the k largest singular values of m.
        /// https://reference.wolfram.com/language/ref/SingularValueDecomposition.html
        ///</summary>
        corewolf::engine *SingularValueDecomposition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SingularValueDecomposition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the nonzero singular values of a matrix m.
        /// https://reference.wolfram.com/language/ref/SingularValueList.html
        ///</summary>
        corewolf::engine *SingularValueList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SingularValueList[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the generalized singular values of m with respect to a.
        /// https://reference.wolfram.com/language/ref/SingularValueList.html
        ///</summary>
        corewolf::engine *SingularValueList(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SingularValueList[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the k largest singular values of m.
        /// https://reference.wolfram.com/language/ref/SingularValueList.html
        ///</summary>
        corewolf::engine *SingularValueList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SingularValueList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the k largest generalized singular values of m.
        /// https://reference.wolfram.com/language/ref/SingularValueList.html
        ///</summary>
        corewolf::engine *SingularValueList(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SingularValueList[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a plot of the singular values of the transfer function for the system lsys.
        /// https://reference.wolfram.com/language/ref/SingularValuePlot.html
        ///</summary>
        corewolf::engine *SingularValuePlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SingularValuePlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots for the frequency range ωmin to ωmax.
        /// https://reference.wolfram.com/language/ref/SingularValuePlot.html
        ///</summary>
        corewolf::engine *SingularValuePlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SingularValuePlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the hyperbolic sine of z.
        /// https://reference.wolfram.com/language/ref/Sinh.html
        ///</summary>
        corewolf::engine *Sinh(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Sinh[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the hyperbolic sine integral function .
        /// https://reference.wolfram.com/language/ref/SinhIntegral.html
        ///</summary>
        corewolf::engine *SinhIntegral(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SinhIntegral[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the sine integral function ).
        /// https://reference.wolfram.com/language/ref/SinIntegral.html
        ///</summary>
        corewolf::engine *SinIntegral(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SinIntegral[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the values of the Racah 6‐ symbol.
        /// https://reference.wolfram.com/language/ref/SixJSymbol.html
        ///</summary>
        corewolf::engine *SixJSymbol(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SixJSymbol[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a sequence of n omitted elements in an expression printed with Short or Shallow. The standard print form for Skeleton is n.
        /// https://reference.wolfram.com/language/ref/Skeleton.html
        ///</summary>
        corewolf::engine *Skeleton(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Skeleton[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the skeleton transform of image, in which the value of each skeleton pixel is its distance to the nearest background pixel.
        /// https://reference.wolfram.com/language/ref/SkeletonTransform.html
        ///</summary>
        corewolf::engine *SkeletonTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SkeletonTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// treats values above t as foreground.
        /// https://reference.wolfram.com/language/ref/SkeletonTransform.html
        ///</summary>
        corewolf::engine *SkeletonTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SkeletonTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Skellam distribution with shape parameters μ1 and μ2.
        /// https://reference.wolfram.com/language/ref/SkellamDistribution.html
        ///</summary>
        corewolf::engine *SkellamDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SkellamDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the coefficient of skewness for the elements in list.
        /// https://reference.wolfram.com/language/ref/Skewness.html
        ///</summary>
        corewolf::engine *Skewness(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Skewness[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a skew-normal distribution with shape parameter α, location parameter μ, and scale parameter σ.
        /// https://reference.wolfram.com/language/ref/SkewNormalDistribution.html
        ///</summary>
        corewolf::engine *SkewNormalDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SkewNormalDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// skips one const std::string &of the specified type in an input stream.
        /// https://reference.wolfram.com/language/ref/Skip.html
        ///</summary>
        corewolf::engine *Skip(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Skip[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// skips n objects of the specified type.
        /// https://reference.wolfram.com/language/ref/Skip.html
        ///</summary>
        corewolf::engine *Skip(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Skip[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a contour plot of f over the slice surface surf as a function of x, y, and z.
        /// https://reference.wolfram.com/language/ref/SliceContourPlot3D.html
        ///</summary>
        corewolf::engine *SliceContourPlot3D(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::vector<std::string> &arg4, const std::string &name = "")
        {
            return this->execute("SliceContourPlot3D[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + "]", name);
        }

        ///< summary>
        /// restricts the surface to be within region reg.
        /// https://reference.wolfram.com/language/ref/SliceContourPlot3D.html
        ///</summary>
        corewolf::engine *SliceContourPlot3D(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SliceContourPlot3D[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates contour plots over several slices.
        /// https://reference.wolfram.com/language/ref/SliceContourPlot3D.html
        ///</summary>
        corewolf::engine *SliceContourPlot3D(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SliceContourPlot3D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a density plot of f over the slice surface surf as a function of x, y, and z.
        /// https://reference.wolfram.com/language/ref/SliceDensityPlot3D.html
        ///</summary>
        corewolf::engine *SliceDensityPlot3D(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::vector<std::string> &arg4, const std::string &name = "")
        {
            return this->execute("SliceDensityPlot3D[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + "]", name);
        }

        ///< summary>
        /// restricts the surface to be within region reg.
        /// https://reference.wolfram.com/language/ref/SliceDensityPlot3D.html
        ///</summary>
        corewolf::engine *SliceDensityPlot3D(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SliceDensityPlot3D[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates density plots over several slices.
        /// https://reference.wolfram.com/language/ref/SliceDensityPlot3D.html
        ///</summary>
        corewolf::engine *SliceDensityPlot3D(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SliceDensityPlot3D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the distribution of the process state at time t.
        /// https://reference.wolfram.com/language/ref/SliceDistribution.html
        ///</summary>
        corewolf::engine *SliceDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SliceDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the joint distribution of process states at times t1<⋯<tk.
        /// https://reference.wolfram.com/language/ref/SliceDistribution.html
        ///</summary>
        corewolf::engine *SliceDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SliceDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a vector plot of the field {vx,vy,vz} over the slice surface surf.
        /// https://reference.wolfram.com/language/ref/SliceVectorPlot3D.html
        ///</summary>
        corewolf::engine *SliceVectorPlot3D(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::vector<std::string> &arg4, const std::string &name = "")
        {
            return this->execute("SliceVectorPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg4) + "}" + "]", name);
        }

        ///< summary>
        /// restricts the surface surf to be within the region reg.
        /// https://reference.wolfram.com/language/ref/SliceVectorPlot3D.html
        ///</summary>
        corewolf::engine *SliceVectorPlot3D(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SliceVectorPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates vector plots over several slice surfaces surfi.
        /// https://reference.wolfram.com/language/ref/SliceVectorPlot3D.html
        ///</summary>
        corewolf::engine *SliceVectorPlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SliceVectorPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a slider with setting x in the range 0 to 1.
        /// https://reference.wolfram.com/language/ref/Slider.html
        ///</summary>
        corewolf::engine *Slider(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Slider[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a slider with range xmin to xmax.
        /// https://reference.wolfram.com/language/ref/Slider.html
        ///</summary>
        corewolf::engine *Slider(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Slider[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses intervals of relative widths wi for the ei.
        /// https://reference.wolfram.com/language/ref/Slider.html
        ///</summary>
        corewolf::engine *Slider(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Slider[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a 2D slider with settings x and y in the range 0 to 1.
        /// https://reference.wolfram.com/language/ref/Slider2D.html
        ///</summary>
        corewolf::engine *Slider2D(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Slider2D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// takes the setting to be the dynamically updated current value of pt, with the value of pt being reset if the slider is moved.
        /// https://reference.wolfram.com/language/ref/Slider2D.html
        ///</summary>
        corewolf::engine *Slider2D(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Slider2D[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a 2D slider with range min to max in each direction.
        /// https://reference.wolfram.com/language/ref/Slider2D.html
        ///</summary>
        corewolf::engine *Slider2D(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Slider2D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// specifies different ranges in x and y directions.
        /// https://reference.wolfram.com/language/ref/Slider2D.html
        ///</summary>
        corewolf::engine *Slider2D(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Slider2D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses jumps dx, dy.
        /// https://reference.wolfram.com/language/ref/Slider2D.html
        ///</summary>
        corewolf::engine *Slider2D(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("Slider2D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// is a low-level box construct that represents a slider with setting x in the range 0 to 1.
        /// https://reference.wolfram.com/language/ref/SliderBox.html
        ///</summary>
        corewolf::engine *SliderBox(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SliderBox[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a slider with range xmin to xmax.
        /// https://reference.wolfram.com/language/ref/SliderBox.html
        ///</summary>
        corewolf::engine *SliderBox(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SliderBox[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses intervals of relative widths wi for the ei.
        /// https://reference.wolfram.com/language/ref/SliderBox.html
        ///</summary>
        corewolf::engine *SliderBox(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SliderBox[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates a video iterating through all imagei.
        /// https://reference.wolfram.com/language/ref/SlideShowVideo.html
        ///</summary>
        corewolf::engine *SlideShowVideo(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SlideShowVideo[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// shows each of the imagei for the duration dt.
        /// https://reference.wolfram.com/language/ref/SlideShowVideo.html
        ///</summary>
        corewolf::engine *SlideShowVideo(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SlideShowVideo[" + arg0 + "]", name);
        }

        ///< summary>
        /// shows each of the imagei for the duration dti.
        /// https://reference.wolfram.com/language/ref/SlideShowVideo.html
        ///</summary>
        corewolf::engine *SlideShowVideo(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SlideShowVideo[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an const std::string &in which the expri are set up to be displayed on successive slides.
        /// https://reference.wolfram.com/language/ref/SlideView.html
        ///</summary>
        corewolf::engine *SlideView(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SlideView[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes the i slide be the one currently displayed.
        /// https://reference.wolfram.com/language/ref/SlideView.html
        ///</summary>
        corewolf::engine *SlideView(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SlideView[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/SmallCircle.html
        ///</summary>
        corewolf::engine *SmallCircle(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SmallCircle[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Smith normal form decomposition of an integer matrix .
        /// https://reference.wolfram.com/language/ref/SmithDecomposition.html
        ///</summary>
        corewolf::engine *SmithDecomposition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SmithDecomposition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Smith compensator for the time-delay system sys and the delay-free controller con.
        /// https://reference.wolfram.com/language/ref/SmithDelayCompensator.html
        ///</summary>
        corewolf::engine *SmithDelayCompensator(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SmithDelayCompensator[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a number representing the Smith–Waterman similarity between strings, vectors or bio sequences u and v.
        /// https://reference.wolfram.com/language/ref/SmithWatermanSimilarity.html
        ///</summary>
        corewolf::engine *SmithWatermanSimilarity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SmithWatermanSimilarity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// plots a smooth kernel histogram of the values {xi,yi}.
        /// https://reference.wolfram.com/language/ref/SmoothDensityHistogram.html
        ///</summary>
        corewolf::engine *SmoothDensityHistogram(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SmoothDensityHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots a smooth kernel histogram with estimator specification espec.
        /// https://reference.wolfram.com/language/ref/SmoothDensityHistogram.html
        ///</summary>
        corewolf::engine *SmoothDensityHistogram(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SmoothDensityHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// plots the distribution function dfun.
        /// https://reference.wolfram.com/language/ref/SmoothDensityHistogram.html
        ///</summary>
        corewolf::engine *SmoothDensityHistogram(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SmoothDensityHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// plots a smooth kernel histogram for the PDF of the values xi.
        /// https://reference.wolfram.com/language/ref/SmoothHistogram.html
        ///</summary>
        corewolf::engine *SmoothHistogram(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SmoothHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots a smooth kernel histogram with estimator specification espec.
        /// https://reference.wolfram.com/language/ref/SmoothHistogram.html
        ///</summary>
        corewolf::engine *SmoothHistogram(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SmoothHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// plots the distribution function dfun.
        /// https://reference.wolfram.com/language/ref/SmoothHistogram.html
        ///</summary>
        corewolf::engine *SmoothHistogram(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SmoothHistogram[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// plots a 3D smooth kernel histogram of the values {xi,yi}.
        /// https://reference.wolfram.com/language/ref/SmoothHistogram3D.html
        ///</summary>
        corewolf::engine *SmoothHistogram3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SmoothHistogram3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots a 3D smooth kernel histogram with estimator specification espec.
        /// https://reference.wolfram.com/language/ref/SmoothHistogram3D.html
        ///</summary>
        corewolf::engine *SmoothHistogram3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SmoothHistogram3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// plots the distribution function dfun.
        /// https://reference.wolfram.com/language/ref/SmoothHistogram3D.html
        ///</summary>
        corewolf::engine *SmoothHistogram3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SmoothHistogram3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// plots smooth kernel histograms for multiple datasets datai.
        /// https://reference.wolfram.com/language/ref/SmoothHistogram3D.html
        ///</summary>
        corewolf::engine *SmoothHistogram3D(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SmoothHistogram3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a smooth kernel distribution based on the data values xi.
        /// https://reference.wolfram.com/language/ref/SmoothKernelDistribution.html
        ///</summary>
        corewolf::engine *SmoothKernelDistribution(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SmoothKernelDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a multivariate smooth kernel distribution based on the data values {xi,yi,…}.
        /// https://reference.wolfram.com/language/ref/SmoothKernelDistribution.html
        ///</summary>
        corewolf::engine *SmoothKernelDistribution(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SmoothKernelDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a smooth kernel distribution with bandwidth bw.
        /// https://reference.wolfram.com/language/ref/SmoothKernelDistribution.html
        ///</summary>
        corewolf::engine *SmoothKernelDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SmoothKernelDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a smooth kernel distribution with bandwidth bw and smoothing kernel ker.
        /// https://reference.wolfram.com/language/ref/SmoothKernelDistribution.html
        ///</summary>
        corewolf::engine *SmoothKernelDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SmoothKernelDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// estimates the point density function  for point data pdata.
        /// https://reference.wolfram.com/language/ref/SmoothPointDensity.html
        ///</summary>
        corewolf::engine *SmoothPointDensity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SmoothPointDensity[" + arg0 + "]", name);
        }

        ///< summary>
        /// estimates the density for point data pdata with bandwidth bw.
        /// https://reference.wolfram.com/language/ref/SmoothPointDensity.html
        ///</summary>
        corewolf::engine *SmoothPointDensity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SmoothPointDensity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// estimates the density for point data pdata with bandwidth bw and smoothing kernel ker.
        /// https://reference.wolfram.com/language/ref/SmoothPointDensity.html
        ///</summary>
        corewolf::engine *SmoothPointDensity(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SmoothPointDensity[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the  statistic of the elements in list.
        /// https://reference.wolfram.com/language/ref/SnDispersion.html
        ///</summary>
        corewolf::engine *SnDispersion(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SnDispersion[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the  statistic with scaling factor c.
        /// https://reference.wolfram.com/language/ref/SnDispersion.html
        ///</summary>
        corewolf::engine *SnDispersion(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SnDispersion[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a snippet of text from a document or other content object.
        /// https://reference.wolfram.com/language/ref/Snippet.html
        ///</summary>
        corewolf::engine *Snippet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Snippet[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives about n lines from the beginning.
        /// https://reference.wolfram.com/language/ref/Snippet.html
        ///</summary>
        corewolf::engine *Snippet(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Snippet[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a summary video based on n snippets from video.
        /// https://reference.wolfram.com/language/ref/SnippetsVideo.html
        ///</summary>
        corewolf::engine *SnippetsVideo(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SnippetsVideo[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the snub polyhedron of poly by truncating some corners.
        /// https://reference.wolfram.com/language/ref/SnubPolyhedron.html
        ///</summary>
        corewolf::engine *SnubPolyhedron(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SnubPolyhedron[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes a socket connection to the TCP host at the specified address and returns a SocketObject representing the connection.
        /// https://reference.wolfram.com/language/ref/SocketConnect.html
        ///</summary>
        corewolf::engine *SocketConnect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SocketConnect[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes a connection to the host at address with the specified protocol.
        /// https://reference.wolfram.com/language/ref/SocketConnect.html
        ///</summary>
        corewolf::engine *SocketConnect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SocketConnect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// starts listening on the specified socket, asynchronously applying fun whenever data is received on the socket.
        /// https://reference.wolfram.com/language/ref/SocketListen.html
        ///</summary>
        corewolf::engine *SocketListen(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SocketListen[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// starts listening for active connections defined by spec, but does not set up handler functions, etc.
        /// https://reference.wolfram.com/language/ref/SocketListen.html
        ///</summary>
        corewolf::engine *SocketListen(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SocketListen[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a socket listener created by SocketListen.
        /// https://reference.wolfram.com/language/ref/SocketListener.html
        ///</summary>
        corewolf::engine *SocketListener(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SocketListener[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a network socket connection.
        /// https://reference.wolfram.com/language/ref/SocketObject.html
        ///</summary>
        corewolf::engine *SocketObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SocketObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// opens a socket that accepts TCP connections to localhost:port and returns a SocketObject representing the socket.
        /// https://reference.wolfram.com/language/ref/SocketOpen.html
        ///</summary>
        corewolf::engine *SocketOpen(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SocketOpen[" + arg0 + "]", name);
        }

        ///< summary>
        /// opens a socket that accepts connections with the specified protocol.
        /// https://reference.wolfram.com/language/ref/SocketOpen.html
        ///</summary>
        corewolf::engine *SocketOpen(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SocketOpen[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// opens a socket that accepts connections of the specified protocol and type.
        /// https://reference.wolfram.com/language/ref/SocketOpen.html
        ///</summary>
        corewolf::engine *SocketOpen(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SocketOpen[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// reads the next available message on the specified socket, returning it as a byte array.
        /// https://reference.wolfram.com/language/ref/SocketReadMessage.html
        ///</summary>
        corewolf::engine *SocketReadMessage(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SocketReadMessage[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests if there is any data immediately available to read from the specified socket.
        /// https://reference.wolfram.com/language/ref/SocketReadyQ.html
        ///</summary>
        corewolf::engine *SocketReadyQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SocketReadyQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// waits for up to t seconds to see if data becomes available to read.
        /// https://reference.wolfram.com/language/ref/SocketReadyQ.html
        ///</summary>
        corewolf::engine *SocketReadyQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SocketReadyQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns all active socket connections initiated by your current Wolfram Language session.
        /// https://reference.wolfram.com/language/ref/Sockets.html
        ///</summary>
        corewolf::engine *Sockets(const std::string &name = "")
        {
            return this->execute("Sockets[]", name);
        }

        ///< summary>
        /// returns all sockets connected to your current session, including remote sockets originating outside your current session.
        /// https://reference.wolfram.com/language/ref/Sockets.html
        ///</summary>
        corewolf::engine *Sockets(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Sockets[" + arg0 + "]", name);
        }

        ///< summary>
        /// waits until there is data ready to read on all of the socketi.
        /// https://reference.wolfram.com/language/ref/SocketWaitAll.html
        ///</summary>
        corewolf::engine *SocketWaitAll(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SocketWaitAll[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// waits until there is data ready to read on any of the socketi, then returns that socket.
        /// https://reference.wolfram.com/language/ref/SocketWaitNext.html
        ///</summary>
        corewolf::engine *SocketWaitNext(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SocketWaitNext[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a softmax net layer.
        /// https://reference.wolfram.com/language/ref/SoftmaxLayer.html
        ///</summary>
        corewolf::engine *SoftmaxLayer(const std::string &name = "")
        {
            return this->execute("SoftmaxLayer[]", name);
        }

        ///< summary>
        /// represents a softmax net layer that uses level n as the normalization dimension.
        /// https://reference.wolfram.com/language/ref/SoftmaxLayer.html
        ///</summary>
        corewolf::engine *SoftmaxLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SoftmaxLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Sokal–Sneath dissimilarity between Boolean vectors u and v.
        /// https://reference.wolfram.com/language/ref/SokalSneathDissimilarity.html
        ///</summary>
        corewolf::engine *SokalSneathDissimilarity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SokalSneathDissimilarity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the time of the next solar eclipse.
        /// https://reference.wolfram.com/language/ref/SolarEclipse.html
        ///</summary>
        corewolf::engine *SolarEclipse(const std::string &name = "")
        {
            return this->execute("SolarEclipse[]", name);
        }

        ///< summary>
        /// gives the time for the next solar eclipse after the specified date.
        /// https://reference.wolfram.com/language/ref/SolarEclipse.html
        ///</summary>
        corewolf::engine *SolarEclipse(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SolarEclipse[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the specified property value for the next solar eclipse after the specified date.
        /// https://reference.wolfram.com/language/ref/SolarEclipse.html
        ///</summary>
        corewolf::engine *SolarEclipse(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SolarEclipse[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the solar system feature entity.
        /// https://reference.wolfram.com/language/ref/SolarSystemFeatureData.html
        ///</summary>
        corewolf::engine *SolarSystemFeatureData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SolarSystemFeatureData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified feature entities.
        /// https://reference.wolfram.com/language/ref/SolarSystemFeatureData.html
        ///</summary>
        corewolf::engine *SolarSystemFeatureData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SolarSystemFeatureData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/SolarSystemFeatureData.html
        ///</summary>
        corewolf::engine *SolarSystemFeatureData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SolarSystemFeatureData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the angle on the celestial equator between the Sun and the local antimeridian for the current location and date.
        /// https://reference.wolfram.com/language/ref/SolarTime.html
        ///</summary>
        corewolf::engine *SolarTime(const std::string &name = "")
        {
            return this->execute("SolarTime[]", name);
        }

        ///< summary>
        /// gives the solar time angle for the specified location and current date.
        /// https://reference.wolfram.com/language/ref/SolarTime.html
        ///</summary>
        corewolf::engine *SolarTime(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SolarTime[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the solar time for the specified location and date.
        /// https://reference.wolfram.com/language/ref/SolarTime.html
        ///</summary>
        corewolf::engine *SolarTime(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SolarTime[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the mean solar time for the specified location and date.
        /// https://reference.wolfram.com/language/ref/SolarTime.html
        ///</summary>
        corewolf::engine *SolarTime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SolarTime[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the solid angle at the point p and spanned by the vectors u1,…,ud.
        /// https://reference.wolfram.com/language/ref/SolidAngle.html
        ///</summary>
        corewolf::engine *SolidAngle(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SolidAngle[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the solid angle subtended by the region reg.
        /// https://reference.wolfram.com/language/ref/SolidAngle.html
        ///</summary>
        corewolf::engine *SolidAngle(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SolidAngle[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a boundary load condition for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/SolidBoundaryLoadValue.html
        ///</summary>
        corewolf::engine *SolidBoundaryLoadValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SolidBoundaryLoadValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a boundary load condition with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/SolidBoundaryLoadValue.html
        ///</summary>
        corewolf::engine *SolidBoundaryLoadValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SolidBoundaryLoadValue[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the solid entity.
        /// https://reference.wolfram.com/language/ref/SolidData.html
        ///</summary>
        corewolf::engine *SolidData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SolidData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified solid entities.
        /// https://reference.wolfram.com/language/ref/SolidData.html
        ///</summary>
        corewolf::engine *SolidData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SolidData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/SolidData.html
        ///</summary>
        corewolf::engine *SolidData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SolidData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a prescribed displacement on a solid boundary for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/SolidDisplacementCondition.html
        ///</summary>
        corewolf::engine *SolidDisplacementCondition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SolidDisplacementCondition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a prescribed displacement with local parameters specified in pars[lkey].
        /// https://reference.wolfram.com/language/ref/SolidDisplacementCondition.html
        ///</summary>
        corewolf::engine *SolidDisplacementCondition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SolidDisplacementCondition[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a fully constrained solid boundary for PDEs with predicate pred indicating where it applies, with model variables vars and global parameters pars.
        /// https://reference.wolfram.com/language/ref/SolidFixedCondition.html
        ///</summary>
        corewolf::engine *SolidFixedCondition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SolidFixedCondition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields solid mechanics PDE terms with variables vars and parameters pars.
        /// https://reference.wolfram.com/language/ref/SolidMechanicsPDEComponent.html
        ///</summary>
        corewolf::engine *SolidMechanicsPDEComponent(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SolidMechanicsPDEComponent[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields solid mechanics strain with variables vars, parameters pars and displacements displ.
        /// https://reference.wolfram.com/language/ref/SolidMechanicsStrain.html
        ///</summary>
        corewolf::engine *SolidMechanicsStrain(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SolidMechanicsStrain[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields solid mechanics stress with variables vars, parameters pars and strain strain.
        /// https://reference.wolfram.com/language/ref/SolidMechanicsStress.html
        ///</summary>
        corewolf::engine *SolidMechanicsStress(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SolidMechanicsStress[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields solid mechanics stress for nonlinear material laws.
        /// https://reference.wolfram.com/language/ref/SolidMechanicsStress.html
        ///</summary>
        corewolf::engine *SolidMechanicsStress(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SolidMechanicsStress[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives True if the 3D region reg is a solid region and False otherwise.
        /// https://reference.wolfram.com/language/ref/SolidRegionQ.html
        ///</summary>
        corewolf::engine *SolidRegionQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SolidRegionQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// attempts to solve the system expr of equations or inequalities for the variables vars.
        /// https://reference.wolfram.com/language/ref/Solve.html
        ///</summary>
        corewolf::engine *Solve(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Solve[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// solves over the domain dom. Common choices of dom are Reals, Integers, and Complexes.
        /// https://reference.wolfram.com/language/ref/Solve.html
        ///</summary>
        corewolf::engine *Solve(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Solve[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the values of parameters that make the equations eqns valid for all values of the variables vars.
        /// https://reference.wolfram.com/language/ref/SolveAlways.html
        ///</summary>
        corewolf::engine *SolveAlways(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SolveAlways[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the values of vars determined by the solutions of the system expr.
        /// https://reference.wolfram.com/language/ref/SolveValues.html
        ///</summary>
        corewolf::engine *SolveValues(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SolveValues[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses solutions over the domain dom. Common choices of dom are Reals, Integers and Complexes.
        /// https://reference.wolfram.com/language/ref/SolveValues.html
        ///</summary>
        corewolf::engine *SolveValues(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SolveValues[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// sorts the elements of list into canonical order.
        /// https://reference.wolfram.com/language/ref/Sort.html
        ///</summary>
        corewolf::engine *Sort(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Sort[" + arg0 + "]", name);
        }

        ///< summary>
        /// sorts using the ordering function p.
        /// https://reference.wolfram.com/language/ref/Sort.html
        ///</summary>
        corewolf::engine *Sort(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Sort[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sorts the elements of list in the order defined by applying f to each of them.
        /// https://reference.wolfram.com/language/ref/SortBy.html
        ///</summary>
        corewolf::engine *SortBy(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SortBy[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// breaks ties by successively using the values obtained from the fi.
        /// https://reference.wolfram.com/language/ref/SortBy.html
        ///</summary>
        corewolf::engine *SortBy(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SortBy[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// sorts the elements of list using the function p to compare the results of applying f to each element.
        /// https://reference.wolfram.com/language/ref/SortBy.html
        ///</summary>
        corewolf::engine *SortBy(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SortBy[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of SortBy that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/SortBy.html
        ///</summary>
        corewolf::engine *SortBy(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SortBy[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an entity class derived from class by sorting according to the values of the property prop.
        /// https://reference.wolfram.com/language/ref/SortedEntityClass.html
        ///</summary>
        corewolf::engine *SortedEntityClass(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SortedEntityClass[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// breaks ties by successively using the values of the property specifications propi.
        /// https://reference.wolfram.com/language/ref/SortedEntityClass.html
        ///</summary>
        corewolf::engine *SortedEntityClass(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SortedEntityClass[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents the first n entities of class when sorted by sortspec.
        /// https://reference.wolfram.com/language/ref/SortedEntityClass.html
        ///</summary>
        corewolf::engine *SortedEntityClass(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SortedEntityClass[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the entities m through n of class when sorted by sortspec.
        /// https://reference.wolfram.com/language/ref/SortedEntityClass.html
        ///</summary>
        corewolf::engine *SortedEntityClass(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SortedEntityClass[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a sound.
        /// https://reference.wolfram.com/language/ref/Sound.html
        ///</summary>
        corewolf::engine *Sound(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Sound[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies that the sound should have duration t.
        /// https://reference.wolfram.com/language/ref/Sound.html
        ///</summary>
        corewolf::engine *Sound(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Sound[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies that the sound should extend from time tmin to time tmax.
        /// https://reference.wolfram.com/language/ref/Sound.html
        ///</summary>
        corewolf::engine *Sound(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Sound[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a music-like sound note with the specified pitch.
        /// https://reference.wolfram.com/language/ref/SoundNote.html
        ///</summary>
        corewolf::engine *SoundNote(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SoundNote[" + arg0 + "]", name);
        }

        ///< summary>
        /// takes the note to have duration t.
        /// https://reference.wolfram.com/language/ref/SoundNote.html
        ///</summary>
        corewolf::engine *SoundNote(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SoundNote[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// takes the note to occupy the time interval tmin to tmax.
        /// https://reference.wolfram.com/language/ref/SoundNote.html
        ///</summary>
        corewolf::engine *SoundNote(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SoundNote[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// takes the note to be in the specified style.
        /// https://reference.wolfram.com/language/ref/SoundNote.html
        ///</summary>
        corewolf::engine *SoundNote(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SoundNote[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses the specified rendering options for the note.
        /// https://reference.wolfram.com/language/ref/SoundNote.html
        ///</summary>
        corewolf::engine *SoundNote(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SoundNote[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a source term  with source coefficient  and model variables vars.
        /// https://reference.wolfram.com/language/ref/SourcePDETerm.html
        ///</summary>
        corewolf::engine *SourcePDETerm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SourcePDETerm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses model parameters pars.
        /// https://reference.wolfram.com/language/ref/SourcePDETerm.html
        ///</summary>
        corewolf::engine *SourcePDETerm(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SourcePDETerm[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// specifies that e should be collected by the nearest enclosing Reap.
        /// https://reference.wolfram.com/language/ref/Sow.html
        ///</summary>
        corewolf::engine *Sow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Sow[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies that e should be collected by the nearest enclosing Reap whose pattern matches tag.
        /// https://reference.wolfram.com/language/ref/Sow.html
        ///</summary>
        corewolf::engine *Sow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Sow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies that e should be collected once for each pattern that matches a tagi.
        /// https://reference.wolfram.com/language/ref/Sow.html
        ///</summary>
        corewolf::engine *Sow(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Sow[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the space curve entity.
        /// https://reference.wolfram.com/language/ref/SpaceCurveData.html
        ///</summary>
        corewolf::engine *SpaceCurveData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpaceCurveData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified space curve entities.
        /// https://reference.wolfram.com/language/ref/SpaceCurveData.html
        ///</summary>
        corewolf::engine *SpaceCurveData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpaceCurveData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/SpaceCurveData.html
        ///</summary>
        corewolf::engine *SpaceCurveData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SpaceCurveData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as a spacer w printer's points wide.
        /// https://reference.wolfram.com/language/ref/Spacer.html
        ///</summary>
        corewolf::engine *Spacer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Spacer[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as a spacer w points wide and a total of h points high.
        /// https://reference.wolfram.com/language/ref/Spacer.html
        ///</summary>
        corewolf::engine *Spacer(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Spacer[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// yields a sparse array with all elements zero except for values vi at positions posi.
        /// https://reference.wolfram.com/language/ref/SparseArray.html
        ///</summary>
        corewolf::engine *SparseArray(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SparseArray[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// yields a sparse array version of list.
        /// https://reference.wolfram.com/language/ref/SparseArray.html
        ///</summary>
        corewolf::engine *SparseArray(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SparseArray[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields a sparse array representing a d1×d2×… array.
        /// https://reference.wolfram.com/language/ref/SparseArray.html
        ///</summary>
        corewolf::engine *SparseArray(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SparseArray[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields a sparse array in which unspecified elements are taken to have value val.
        /// https://reference.wolfram.com/language/ref/SparseArray.html
        ///</summary>
        corewolf::engine *SparseArray(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SparseArray[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields True if s is a valid SparseArray const std::string &and False otherwise.
        /// https://reference.wolfram.com/language/ref/SparseArrayQ.html
        ///</summary>
        corewolf::engine *SparseArrayQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SparseArrayQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents values vali associated with disjoint regions regi.
        /// https://reference.wolfram.com/language/ref/SpatialBinnedPointData.html
        ///</summary>
        corewolf::engine *SpatialBinnedPointData(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SpatialBinnedPointData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the overall observation region reg.
        /// https://reference.wolfram.com/language/ref/SpatialBinnedPointData.html
        ///</summary>
        corewolf::engine *SpatialBinnedPointData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpatialBinnedPointData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a spatial prediction from values vali given at locations loci.
        /// https://reference.wolfram.com/language/ref/SpatialEstimate.html
        ///</summary>
        corewolf::engine *SpatialEstimate(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SpatialEstimate[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a function generated by SpatialEstimate and predicts spatial field values from locations.
        /// https://reference.wolfram.com/language/ref/SpatialEstimatorFunction.html
        ///</summary>
        corewolf::engine *SpatialEstimatorFunction(const std::string &name = "")
        {
            return this->execute("SpatialEstimatorFunction[]", name);
        }

        ///< summary>
        /// represents a spatial distribution for graphs with n vertices uniformly distributed over the unit square and edges between vertices that are at distance at most r.
        /// https://reference.wolfram.com/language/ref/SpatialGraphDistribution.html
        ///</summary>
        corewolf::engine *SpatialGraphDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpatialGraphDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a spatial distribution for graphs with vertices uniformly distributed over the d-dimensional unit square.
        /// https://reference.wolfram.com/language/ref/SpatialGraphDistribution.html
        ///</summary>
        corewolf::engine *SpatialGraphDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SpatialGraphDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// estimates the  function  for point data pdata at radius r.
        /// https://reference.wolfram.com/language/ref/SpatialJ.html
        ///</summary>
        corewolf::engine *SpatialJ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpatialJ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates the function  that can be applied repeatedly to different radii r.
        /// https://reference.wolfram.com/language/ref/SpatialJ.html
        ///</summary>
        corewolf::engine *SpatialJ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SpatialJ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the spatial median of the elements .
        /// https://reference.wolfram.com/language/ref/SpatialMedian.html
        ///</summary>
        corewolf::engine *SpatialMedian(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SpatialMedian[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the spatial median for several different forms of data.
        /// https://reference.wolfram.com/language/ref/SpatialMedian.html
        ///</summary>
        corewolf::engine *SpatialMedian(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SpatialMedian[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the geometric or geographic region reg can be an observation in spatial statistics.
        /// https://reference.wolfram.com/language/ref/SpatialObservationRegionQ.html
        ///</summary>
        corewolf::engine *SpatialObservationRegionQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SpatialObservationRegionQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a collection of spatial locations points.
        /// https://reference.wolfram.com/language/ref/SpatialPointData.html
        ///</summary>
        corewolf::engine *SpatialPointData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SpatialPointData[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a collection of points within the region reg.
        /// https://reference.wolfram.com/language/ref/SpatialPointData.html
        ///</summary>
        corewolf::engine *SpatialPointData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpatialPointData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// associates the key-value annotations keyivalsi.
        /// https://reference.wolfram.com/language/ref/SpatialPointData.html
        ///</summary>
        corewolf::engine *SpatialPointData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SpatialPointData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the spatial point collection {p1,p2,…} with associated values {data1,data2,…}.
        /// https://reference.wolfram.com/language/ref/SpatialPointData.html
        ///</summary>
        corewolf::engine *SpatialPointData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpatialPointData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// selects a subset of the SpatialPointData spdata according to crit.
        /// https://reference.wolfram.com/language/ref/SpatialPointSelect.html
        ///</summary>
        corewolf::engine *SpatialPointSelect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpatialPointSelect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether the point collection pdata is distributed uniformly over the observation region.
        /// https://reference.wolfram.com/language/ref/SpatialRandomnessTest.html
        ///</summary>
        corewolf::engine *SpatialRandomnessTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SpatialRandomnessTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/SpatialRandomnessTest.html
        ///</summary>
        corewolf::engine *SpatialRandomnessTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpatialRandomnessTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a net layer that applies an affine transformation to an input of size c×h0×w0 and returns an output of size c×h×w.
        /// https://reference.wolfram.com/language/ref/SpatialTransformationLayer.html
        ///</summary>
        corewolf::engine *SpatialTransformationLayer(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SpatialTransformationLayer[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// speaks a spoken representation of the expression expr.
        /// https://reference.wolfram.com/language/ref/Speak.html
        ///</summary>
        corewolf::engine *Speak(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Speak[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if speaker features in audio match the one from reference ref and returns False otherwise.
        /// https://reference.wolfram.com/language/ref/SpeakerMatchQ.html
        ///</summary>
        corewolf::engine *SpeakerMatchQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpeakerMatchQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of results for each of audioi.
        /// https://reference.wolfram.com/language/ref/SpeakerMatchQ.html
        ///</summary>
        corewolf::engine *SpeakerMatchQ(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpeakerMatchQ[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of SpeakerMatchQ that can be applied to an audio object.
        /// https://reference.wolfram.com/language/ref/SpeakerMatchQ.html
        ///</summary>
        corewolf::engine *SpeakerMatchQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SpeakerMatchQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the vectors v1 and v2 are independent.
        /// https://reference.wolfram.com/language/ref/SpearmanRankTest.html
        ///</summary>
        corewolf::engine *SpearmanRankTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpearmanRankTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives Spearman's rank correlation coefficient  for the vectors v1 and v2.
        /// https://reference.wolfram.com/language/ref/SpearmanRho.html
        ///</summary>
        corewolf::engine *SpearmanRho(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpearmanRho[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives Spearman's rank correlation coefficient  for the matrix m.
        /// https://reference.wolfram.com/language/ref/SpearmanRho.html
        ///</summary>
        corewolf::engine *SpearmanRho(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SpearmanRho[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the  Spearman rank correlation for the multivariate symbolic distribution dist.
        /// https://reference.wolfram.com/language/ref/SpearmanRho.html
        ///</summary>
        corewolf::engine *SpearmanRho(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SpearmanRho[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the species entity.
        /// https://reference.wolfram.com/language/ref/SpeciesData.html
        ///</summary>
        corewolf::engine *SpeciesData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpeciesData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified species entities.
        /// https://reference.wolfram.com/language/ref/SpeciesData.html
        ///</summary>
        corewolf::engine *SpeciesData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpeciesData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/SpeciesData.html
        ///</summary>
        corewolf::engine *SpeciesData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SpeciesData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the values of all known properties for an atomic state or state transition.
        /// https://reference.wolfram.com/language/ref/SpectralLineData.html
        ///</summary>
        corewolf::engine *SpectralLineData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SpectralLineData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the given entity.
        /// https://reference.wolfram.com/language/ref/SpectralLineData.html
        ///</summary>
        corewolf::engine *SpectralLineData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpectralLineData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the entities in spec that fall within the range specified between quantity1 and quantity2.
        /// https://reference.wolfram.com/language/ref/SpectralLineData.html
        ///</summary>
        corewolf::engine *SpectralLineData(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SpectralLineData[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots the spectrogram of list.
        /// https://reference.wolfram.com/language/ref/Spectrogram.html
        ///</summary>
        corewolf::engine *Spectrogram(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Spectrogram[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses partitions of length n.
        /// https://reference.wolfram.com/language/ref/Spectrogram.html
        ///</summary>
        corewolf::engine *Spectrogram(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Spectrogram[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses partitions with offset d.
        /// https://reference.wolfram.com/language/ref/Spectrogram.html
        ///</summary>
        corewolf::engine *Spectrogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Spectrogram[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies a smoothing window wfun to each partition.
        /// https://reference.wolfram.com/language/ref/Spectrogram.html
        ///</summary>
        corewolf::engine *Spectrogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Spectrogram[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// pads partitions with zeros to length m prior to the computation of the transform.
        /// https://reference.wolfram.com/language/ref/Spectrogram.html
        ///</summary>
        corewolf::engine *Spectrogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("Spectrogram[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// returns the spectrogram data of list.
        /// https://reference.wolfram.com/language/ref/SpectrogramArray.html
        ///</summary>
        corewolf::engine *SpectrogramArray(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SpectrogramArray[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses partitions of length n.
        /// https://reference.wolfram.com/language/ref/SpectrogramArray.html
        ///</summary>
        corewolf::engine *SpectrogramArray(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpectrogramArray[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses partitions with offset d.
        /// https://reference.wolfram.com/language/ref/SpectrogramArray.html
        ///</summary>
        corewolf::engine *SpectrogramArray(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SpectrogramArray[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies a smoothing window wfun to each partition.
        /// https://reference.wolfram.com/language/ref/SpectrogramArray.html
        ///</summary>
        corewolf::engine *SpectrogramArray(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SpectrogramArray[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// pads partitions with zeros to length m prior to the computation of the transform.
        /// https://reference.wolfram.com/language/ref/SpectrogramArray.html
        ///</summary>
        corewolf::engine *SpectrogramArray(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("SpectrogramArray[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// is a graphics directive which specifies that surfaces of 3D graphics objects which follow are to be taken to have specularity s.
        /// https://reference.wolfram.com/language/ref/Specularity.html
        ///</summary>
        corewolf::engine *Specularity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Specularity[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses specular exponent n.
        /// https://reference.wolfram.com/language/ref/Specularity.html
        ///</summary>
        corewolf::engine *Specularity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Specularity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of cases of text identified as being of type form that appear in the transcription of audio.
        /// https://reference.wolfram.com/language/ref/SpeechCases.html
        ///</summary>
        corewolf::engine *SpeechCases(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpeechCases[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an association of results for all the types formi.
        /// https://reference.wolfram.com/language/ref/SpeechCases.html
        ///</summary>
        corewolf::engine *SpeechCases(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SpeechCases[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the first n cases found.
        /// https://reference.wolfram.com/language/ref/SpeechCases.html
        ///</summary>
        corewolf::engine *SpeechCases(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SpeechCases[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an interpreter const std::string &that can be applied to a speech input to try to interpret it as an const std::string &of the specified form.
        /// https://reference.wolfram.com/language/ref/SpeechInterpreter.html
        ///</summary>
        corewolf::engine *SpeechInterpreter(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SpeechInterpreter[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the interpreted const std::string &only if applying test to it yields True; otherwise, it returns a Failure object.
        /// https://reference.wolfram.com/language/ref/SpeechInterpreter.html
        ///</summary>
        corewolf::engine *SpeechInterpreter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpeechInterpreter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the result of applying the function fail if the test fails.
        /// https://reference.wolfram.com/language/ref/SpeechInterpreter.html
        ///</summary>
        corewolf::engine *SpeechInterpreter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SpeechInterpreter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// recognizes speech in audio and returns it as a string.
        /// https://reference.wolfram.com/language/ref/SpeechRecognize.html
        ///</summary>
        corewolf::engine *SpeechRecognize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SpeechRecognize[" + arg0 + "]", name);
        }

        ///< summary>
        /// synthesizes the contents of expr as an Audio object.
        /// https://reference.wolfram.com/language/ref/SpeechSynthesize.html
        ///</summary>
        corewolf::engine *SpeechSynthesize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SpeechSynthesize[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the specified voice to synthesize the speech signal.
        /// https://reference.wolfram.com/language/ref/SpeechSynthesize.html
        ///</summary>
        corewolf::engine *SpeechSynthesize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SpeechSynthesize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of possible spelling corrections for "word".
        /// https://reference.wolfram.com/language/ref/SpellingCorrectionList.html
        ///</summary>
        corewolf::engine *SpellingCorrectionList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SpellingCorrectionList[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a unit sphere centered at the point p.
        /// https://reference.wolfram.com/language/ref/Sphere.html
        ///</summary>
        corewolf::engine *Sphere(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Sphere[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a sphere of radius r centered at the point p.
        /// https://reference.wolfram.com/language/ref/Sphere.html
        ///</summary>
        corewolf::engine *Sphere(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Sphere[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a collection of spheres of radius r.
        /// https://reference.wolfram.com/language/ref/Sphere.html
        ///</summary>
        corewolf::engine *Sphere(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Sphere[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the positions of n uniformly distributed points on the surface of a unit sphere.
        /// https://reference.wolfram.com/language/ref/SpherePoints.html
        ///</summary>
        corewolf::engine *SpherePoints(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SpherePoints[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the spherical Bessel function of the first kind .
        /// https://reference.wolfram.com/language/ref/SphericalBesselJ.html
        ///</summary>
        corewolf::engine *SphericalBesselJ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SphericalBesselJ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the spherical Bessel function of the second kind .
        /// https://reference.wolfram.com/language/ref/SphericalBesselY.html
        ///</summary>
        corewolf::engine *SphericalBesselY(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SphericalBesselY[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the spherical Hankel function of the first kind .
        /// https://reference.wolfram.com/language/ref/SphericalHankelH1.html
        ///</summary>
        corewolf::engine *SphericalHankelH1(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SphericalHankelH1[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the spherical Hankel function of the second kind .
        /// https://reference.wolfram.com/language/ref/SphericalHankelH2.html
        ///</summary>
        corewolf::engine *SphericalHankelH2(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SphericalHankelH2[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the spherical harmonic .
        /// https://reference.wolfram.com/language/ref/SphericalHarmonicY.html
        ///</summary>
        corewolf::engine *SphericalHarmonicY(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SphericalHarmonicY[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// generates a 3D plot with a spherical radius r as a function of spherical coordinates θ and ϕ.
        /// https://reference.wolfram.com/language/ref/SphericalPlot3D.html
        ///</summary>
        corewolf::engine *SphericalPlot3D(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SphericalPlot3D[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a 3D spherical plot over the specified ranges of spherical coordinates.
        /// https://reference.wolfram.com/language/ref/SphericalPlot3D.html
        ///</summary>
        corewolf::engine *SphericalPlot3D(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SphericalPlot3D[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates a 3D spherical plot with multiple surfaces.
        /// https://reference.wolfram.com/language/ref/SphericalPlot3D.html
        ///</summary>
        corewolf::engine *SphericalPlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SphericalPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a filled spherical shell centered at c with inner radius rinner and outer radius router.
        /// https://reference.wolfram.com/language/ref/SphericalShell.html
        ///</summary>
        corewolf::engine *SphericalShell(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SphericalShell[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the spheroidal eigenvalue with degree  and order .
        /// https://reference.wolfram.com/language/ref/SpheroidalEigenvalue.html
        ///</summary>
        corewolf::engine *SpheroidalEigenvalue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SpheroidalEigenvalue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the spheroidal joining factor with degree  and order .
        /// https://reference.wolfram.com/language/ref/SpheroidalJoiningFactor.html
        ///</summary>
        corewolf::engine *SpheroidalJoiningFactor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SpheroidalJoiningFactor[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the angular spheroidal function  of the first kind.
        /// https://reference.wolfram.com/language/ref/SpheroidalPS.html
        ///</summary>
        corewolf::engine *SpheroidalPS(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SpheroidalPS[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the derivative with respect to  of the angular spheroidal function  of the first kind.
        /// https://reference.wolfram.com/language/ref/SpheroidalPSPrime.html
        ///</summary>
        corewolf::engine *SpheroidalPSPrime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SpheroidalPSPrime[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the angular spheroidal function  of the second kind.
        /// https://reference.wolfram.com/language/ref/SpheroidalQS.html
        ///</summary>
        corewolf::engine *SpheroidalQS(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SpheroidalQS[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the derivative with respect to  of the angular spheroidal function  of the second kind.
        /// https://reference.wolfram.com/language/ref/SpheroidalQSPrime.html
        ///</summary>
        corewolf::engine *SpheroidalQSPrime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SpheroidalQSPrime[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the spheroidal radial factor with degree  and order .
        /// https://reference.wolfram.com/language/ref/SpheroidalRadialFactor.html
        ///</summary>
        corewolf::engine *SpheroidalRadialFactor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SpheroidalRadialFactor[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the radial spheroidal function  of the first kind.
        /// https://reference.wolfram.com/language/ref/SpheroidalS1.html
        ///</summary>
        corewolf::engine *SpheroidalS1(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SpheroidalS1[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the derivative with respect to  of the radial spheroidal function  of the first kind.
        /// https://reference.wolfram.com/language/ref/SpheroidalS1Prime.html
        ///</summary>
        corewolf::engine *SpheroidalS1Prime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SpheroidalS1Prime[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the radial spheroidal function  of the second kind.
        /// https://reference.wolfram.com/language/ref/SpheroidalS2.html
        ///</summary>
        corewolf::engine *SpheroidalS2(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SpheroidalS2[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the derivative with respect to  of the radial spheroidal function  of the second kind.
        /// https://reference.wolfram.com/language/ref/SpheroidalS2Prime.html
        ///</summary>
        corewolf::engine *SpheroidalS2Prime(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SpheroidalS2Prime[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an expression that will automatically be spliced into any list in which it appears as the sequence of elements ei.
        /// https://reference.wolfram.com/language/ref/Splice.html
        ///</summary>
        corewolf::engine *Splice(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Splice[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents an expression that will automatically be spliced into any expression whose head matches the pattern hpatt.
        /// https://reference.wolfram.com/language/ref/Splice.html
        ///</summary>
        corewolf::engine *Splice(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Splice[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the distribution obtained by splicing the distributions dist1, dist2, … truncated on the intervals {c0,c1}, {c1,c2}, … with weights w1, w2, … .
        /// https://reference.wolfram.com/language/ref/SplicedDistribution.html
        ///</summary>
        corewolf::engine *SplicedDistribution(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SplicedDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// splits list into sublists consisting of runs of identical elements.
        /// https://reference.wolfram.com/language/ref/Split.html
        ///</summary>
        corewolf::engine *Split(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Split[" + arg0 + "]", name);
        }

        ///< summary>
        /// treats pairs of adjacent elements as identical whenever applying the function test to them yields True.
        /// https://reference.wolfram.com/language/ref/Split.html
        ///</summary>
        corewolf::engine *Split(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Split[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// splits list into sublists consisting of runs of successive elements that give the same value when f is applied.
        /// https://reference.wolfram.com/language/ref/SplitBy.html
        ///</summary>
        corewolf::engine *SplitBy(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SplitBy[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// recursively splits list into sublists by testing elements successively with each of the fi.
        /// https://reference.wolfram.com/language/ref/SplitBy.html
        ///</summary>
        corewolf::engine *SplitBy(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SplitBy[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a string of text corresponding to a spoken representation of the expression expr.
        /// https://reference.wolfram.com/language/ref/SpokenString.html
        ///</summary>
        corewolf::engine *SpokenString(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SpokenString[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a three-dimensional graphics directive to use in coloring 3D surfaces that specifies the spotlight of color col at position pt aimed at the center with half-angle α.
        /// https://reference.wolfram.com/language/ref/SpotLight.html
        ///</summary>
        corewolf::engine *SpotLight(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SpotLight[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses the spotlight at position pt1 aimed at pt2 with half-angle α.
        /// https://reference.wolfram.com/language/ref/SpotLight.html
        ///</summary>
        corewolf::engine *SpotLight(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SpotLight[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses the spotlight with spot exponent s and attenuation att.
        /// https://reference.wolfram.com/language/ref/SpotLight.html
        ///</summary>
        corewolf::engine *SpotLight(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SpotLight[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// or  gives the square root of z.
        /// https://reference.wolfram.com/language/ref/Sqrt.html
        ///</summary>
        corewolf::engine *Sqrt(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Sqrt[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a low-level box construct that represents the displayed const std::string & in notebook expressions.
        /// https://reference.wolfram.com/language/ref/SqrtBox.html
        ///</summary>
        corewolf::engine *SqrtBox(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SqrtBox[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Square.html
        ///</summary>
        corewolf::engine *Square(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Square[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the squared Euclidean distance between vectors u and v.
        /// https://reference.wolfram.com/language/ref/SquaredEuclideanDistance.html
        ///</summary>
        corewolf::engine *SquaredEuclideanDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SquaredEuclideanDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if expr is a square-free polynomial or number, and False otherwise.
        /// https://reference.wolfram.com/language/ref/SquareFreeQ.html
        ///</summary>
        corewolf::engine *SquareFreeQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SquareFreeQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if expr is square-free with respect to the variables vars.
        /// https://reference.wolfram.com/language/ref/SquareFreeQ.html
        ///</summary>
        corewolf::engine *SquareFreeQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SquareFreeQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/SquareIntersection.html
        ///</summary>
        corewolf::engine *SquareIntersection(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SquareIntersection[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives True if m is a square matrix, and False otherwise.
        /// https://reference.wolfram.com/language/ref/SquareMatrixQ.html
        ///</summary>
        corewolf::engine *SquareMatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SquareMatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a square array of elements of type spec in an interpreter, API or form specification.
        /// https://reference.wolfram.com/language/ref/SquareRepeatingElement.html
        ///</summary>
        corewolf::engine *SquareRepeatingElement(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SquareRepeatingElement[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a square array of elements of maximum size max×max.
        /// https://reference.wolfram.com/language/ref/SquareRepeatingElement.html
        ///</summary>
        corewolf::engine *SquareRepeatingElement(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SquareRepeatingElement[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a square array of elements of size between min and max.
        /// https://reference.wolfram.com/language/ref/SquareRepeatingElement.html
        ///</summary>
        corewolf::engine *SquareRepeatingElement(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SquareRepeatingElement[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the number of ways  to represent the integer n as a sum of d squares.
        /// https://reference.wolfram.com/language/ref/SquaresR.html
        ///</summary>
        corewolf::engine *SquaresR(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SquaresR[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/SquareSubset.html
        ///</summary>
        corewolf::engine *SquareSubset(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SquareSubset[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/SquareSubsetEqual.html
        ///</summary>
        corewolf::engine *SquareSubsetEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SquareSubsetEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/SquareSuperset.html
        ///</summary>
        corewolf::engine *SquareSuperset(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SquareSuperset[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/SquareSupersetEqual.html
        ///</summary>
        corewolf::engine *SquareSupersetEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SquareSupersetEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/SquareUnion.html
        ///</summary>
        corewolf::engine *SquareUnion(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SquareUnion[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a square wave that alternates between  and  with unit period.
        /// https://reference.wolfram.com/language/ref/SquareWave.html
        ///</summary>
        corewolf::engine *SquareWave(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SquareWave[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a square wave that alternates between y1 and y2 with unit period.
        /// https://reference.wolfram.com/language/ref/SquareWave.html
        ///</summary>
        corewolf::engine *SquareWave(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SquareWave[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a filled triangle with sides of lengths a, b, and c.
        /// https://reference.wolfram.com/language/ref/SSSTriangle.html
        ///</summary>
        corewolf::engine *SSSTriangle(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SSSTriangle[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the stable distribution Stype with index of stability α, skewness parameter β, location parameter μ, and scale parameter σ.
        /// https://reference.wolfram.com/language/ref/StableDistribution.html
        ///</summary>
        corewolf::engine *StableDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("StableDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// shows the current evaluation stack, giving a list of the tags associated with evaluations that are currently being done.
        /// https://reference.wolfram.com/language/ref/Stack.html
        ///</summary>
        corewolf::engine *Stack(const std::string &name = "")
        {
            return this->execute("Stack[]", name);
        }

        ///< summary>
        /// gives a list of expressions currently being evaluated which match the pattern.
        /// https://reference.wolfram.com/language/ref/Stack.html
        ///</summary>
        corewolf::engine *Stack(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Stack[" + arg0 + "]", name);
        }

        ///< summary>
        /// evaluates expr, starting a fresh evaluation stack.
        /// https://reference.wolfram.com/language/ref/StackBegin.html
        ///</summary>
        corewolf::engine *StackBegin(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StackBegin[" + arg0 + "]", name);
        }

        ///< summary>
        /// evaluates expr with intermediate expressions in evaluation chains included on the stack.
        /// https://reference.wolfram.com/language/ref/StackComplete.html
        ///</summary>
        corewolf::engine *StackComplete(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StackComplete[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots points with values vi at a sequence of dates.
        /// https://reference.wolfram.com/language/ref/StackedDateListPlot.html
        ///</summary>
        corewolf::engine *StackedDateListPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StackedDateListPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots points with dates at equal intervals specified by datespec.
        /// https://reference.wolfram.com/language/ref/StackedDateListPlot.html
        ///</summary>
        corewolf::engine *StackedDateListPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StackedDateListPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// plots the time series tseries.
        /// https://reference.wolfram.com/language/ref/StackedDateListPlot.html
        ///</summary>
        corewolf::engine *StackedDateListPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StackedDateListPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots data from all the datai.
        /// https://reference.wolfram.com/language/ref/StackedDateListPlot.html
        ///</summary>
        corewolf::engine *StackedDateListPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("StackedDateListPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// plots lines for each of the datai, with the i curve being the accumulation of values in data1 through datai.
        /// https://reference.wolfram.com/language/ref/StackedListPlot.html
        ///</summary>
        corewolf::engine *StackedListPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("StackedListPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates expr without modifying the evaluation stack.
        /// https://reference.wolfram.com/language/ref/StackInhibit.html
        ///</summary>
        corewolf::engine *StackInhibit(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StackInhibit[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a stadium of radius r between the points {x1,y1} and {x2,y2}.
        /// https://reference.wolfram.com/language/ref/StadiumShape.html
        ///</summary>
        corewolf::engine *StadiumShape(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StadiumShape[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the value of the property at the specified geometrical altitude for the chosen model of the standard Earth atmosphere.
        /// https://reference.wolfram.com/language/ref/StandardAtmosphereData.html
        ///</summary>
        corewolf::engine *StandardAtmosphereData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StandardAtmosphereData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the sample standard deviation of the elements in list.
        /// https://reference.wolfram.com/language/ref/StandardDeviation.html
        ///</summary>
        corewolf::engine *StandardDeviation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StandardDeviation[" + arg0 + "]", name);
        }

        ///< summary>
        /// filters data by replacing every value by the standard deviations of the values in its range-r neighborhood.
        /// https://reference.wolfram.com/language/ref/StandardDeviationFilter.html
        ///</summary>
        corewolf::engine *StandardDeviationFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StandardDeviationFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses ri for filtering the dimension in data.
        /// https://reference.wolfram.com/language/ref/StandardDeviationFilter.html
        ///</summary>
        corewolf::engine *StandardDeviationFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StandardDeviationFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// prints as the standard Wolfram Language two-dimensional representation of expr.
        /// https://reference.wolfram.com/language/ref/StandardForm.html
        ///</summary>
        corewolf::engine *StandardForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StandardForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// shifts and rescales the elements of list to have zero mean and unit sample variance.
        /// https://reference.wolfram.com/language/ref/Standardize.html
        ///</summary>
        corewolf::engine *Standardize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Standardize[" + arg0 + "]", name);
        }

        ///< summary>
        /// shifts the elements in list by f1[list] and rescales them to have unit sample variance.
        /// https://reference.wolfram.com/language/ref/Standardize.html
        ///</summary>
        corewolf::engine *Standardize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Standardize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// shifts by f1[list] and scales by f2[list].
        /// https://reference.wolfram.com/language/ref/Standardize.html
        ///</summary>
        corewolf::engine *Standardize(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Standardize[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the thermodynamic properties of seawater for the specified parameters.
        /// https://reference.wolfram.com/language/ref/StandardOceanData.html
        ///</summary>
        corewolf::engine *StandardOceanData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StandardOceanData[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the specified property for the given parameters.
        /// https://reference.wolfram.com/language/ref/StandardOceanData.html
        ///</summary>
        corewolf::engine *StandardOceanData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StandardOceanData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a standby distribution with component lifetime distributions disti. When component  fails, component  will become active.
        /// https://reference.wolfram.com/language/ref/StandbyDistribution.html
        ///</summary>
        corewolf::engine *StandbyDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StandbyDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a standby distribution where switching from component  to component  succeeds with probability p.
        /// https://reference.wolfram.com/language/ref/StandbyDistribution.html
        ///</summary>
        corewolf::engine *StandbyDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StandbyDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a standby distribution where the  component lifetime distribution follows disti,inactive in inactive mode and disti,active in active mode.
        /// https://reference.wolfram.com/language/ref/StandbyDistribution.html
        ///</summary>
        corewolf::engine *StandbyDistribution(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("StandbyDistribution[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Star.html
        ///</summary>
        corewolf::engine *Star(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Star[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the star cluster entity.
        /// https://reference.wolfram.com/language/ref/StarClusterData.html
        ///</summary>
        corewolf::engine *StarClusterData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StarClusterData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified star cluster entities.
        /// https://reference.wolfram.com/language/ref/StarClusterData.html
        ///</summary>
        corewolf::engine *StarClusterData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StarClusterData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/StarClusterData.html
        ///</summary>
        corewolf::engine *StarClusterData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StarClusterData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the star entity.
        /// https://reference.wolfram.com/language/ref/StarData.html
        ///</summary>
        corewolf::engine *StarData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StarData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified star entities.
        /// https://reference.wolfram.com/language/ref/StarData.html
        ///</summary>
        corewolf::engine *StarData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StarData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the property.
        /// https://reference.wolfram.com/language/ref/StarData.html
        ///</summary>
        corewolf::engine *StarData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StarData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the star graph with n vertices .
        /// https://reference.wolfram.com/language/ref/StarGraph.html
        ///</summary>
        corewolf::engine *StarGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StarGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// starts an external session using the external evaluator sys, returning an external session object.
        /// https://reference.wolfram.com/language/ref/StartExternalSession.html
        ///</summary>
        corewolf::engine *StartExternalSession(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StartExternalSession[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the options opts for the external evaluator.
        /// https://reference.wolfram.com/language/ref/StartExternalSession.html
        ///</summary>
        corewolf::engine *StartExternalSession(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("StartExternalSession[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// executes an external program, yielding a ProcessObject to represent the resulting subprocess.
        /// https://reference.wolfram.com/language/ref/StartProcess.html
        ///</summary>
        corewolf::engine *StartProcess(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StartProcess[" + arg0 + "]", name);
        }

        ///< summary>
        /// executes an external program, passing it the specified arguments argi.
        /// https://reference.wolfram.com/language/ref/StartProcess.html
        ///</summary>
        corewolf::engine *StartProcess(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("StartProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// starts a web session and returns a web session object.
        /// https://reference.wolfram.com/language/ref/StartWebSession.html
        ///</summary>
        corewolf::engine *StartWebSession(const std::string &name = "")
        {
            return this->execute("StartWebSession[]", name);
        }

        ///< summary>
        /// starts a web session using the specified browser.
        /// https://reference.wolfram.com/language/ref/StartWebSession.html
        ///</summary>
        corewolf::engine *StartWebSession(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StartWebSession[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the state feedback gains for the system specification sspec to place its closed-loop poles at pi.
        /// https://reference.wolfram.com/language/ref/StateFeedbackGains.html
        ///</summary>
        corewolf::engine *StateFeedbackGains(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StateFeedbackGains[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value of the property "prop".
        /// https://reference.wolfram.com/language/ref/StateFeedbackGains.html
        ///</summary>
        corewolf::engine *StateFeedbackGains(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StateFeedbackGains[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// constructs an estimator for the StateSpaceModel ssm, with estimator gain matrix l.
        /// https://reference.wolfram.com/language/ref/StateOutputEstimator.html
        ///</summary>
        corewolf::engine *StateOutputEstimator(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StateOutputEstimator[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses only sensors as the measurements of ssm.
        /// https://reference.wolfram.com/language/ref/StateOutputEstimator.html
        ///</summary>
        corewolf::engine *StateOutputEstimator(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StateOutputEstimator[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the numeric state response of the state-space model sys to input u for tmin≤t≤tmax.
        /// https://reference.wolfram.com/language/ref/StateResponse.html
        ///</summary>
        corewolf::engine *StateResponse(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("StateResponse[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the response of the discrete-time state-space model sys to the input sequence u[i].
        /// https://reference.wolfram.com/language/ref/StateResponse.html
        ///</summary>
        corewolf::engine *StateResponse(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StateResponse[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the symbolic state response as a function of time t.
        /// https://reference.wolfram.com/language/ref/StateResponse.html
        ///</summary>
        corewolf::engine *StateResponse(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StateResponse[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the state response for multiple inputs ui.
        /// https://reference.wolfram.com/language/ref/StateResponse.html
        ///</summary>
        corewolf::engine *StateResponse(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StateResponse[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the response with initial states xi0.
        /// https://reference.wolfram.com/language/ref/StateResponse.html
        ///</summary>
        corewolf::engine *StateResponse(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("StateResponse[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents the standard state-space model with state matrix a, input matrix b, output matrix c, and transmission matrix d.
        /// https://reference.wolfram.com/language/ref/StateSpaceModel.html
        ///</summary>
        corewolf::engine *StateSpaceModel(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("StateSpaceModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a state-space model corresponding to the systems model sys.
        /// https://reference.wolfram.com/language/ref/StateSpaceModel.html
        ///</summary>
        corewolf::engine *StateSpaceModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StateSpaceModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the state-space model obtained by Taylor linearization about the point (xi0,ui0) of the differential or difference equations eqns with outputs gi and independent variable τ.
        /// https://reference.wolfram.com/language/ref/StateSpaceModel.html
        ///</summary>
        corewolf::engine *StateSpaceModel(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("StateSpaceModel[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// transforms the state-space model sys using the matrices p and q.
        /// https://reference.wolfram.com/language/ref/StateSpaceTransform.html
        ///</summary>
        corewolf::engine *StateSpaceTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StateSpaceTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// transforms using the variable transformations {x1p1[z],…} and {z1q1[x],…}.
        /// https://reference.wolfram.com/language/ref/StateSpaceTransform.html
        ///</summary>
        corewolf::engine *StateSpaceTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("StateSpaceTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// linearizes the AffineStateSpaceModel asys by state transformation.
        /// https://reference.wolfram.com/language/ref/StateTransformationLinearize.html
        ///</summary>
        corewolf::engine *StateTransformationLinearize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StateTransformationLinearize[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies the new states z and form of linearization lform.
        /// https://reference.wolfram.com/language/ref/StateTransformationLinearize.html
        ///</summary>
        corewolf::engine *StateTransformationLinearize(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StateTransformationLinearize[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// computes the property "prop".
        /// https://reference.wolfram.com/language/ref/StateTransformationLinearize.html
        ///</summary>
        corewolf::engine *StateTransformationLinearize(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StateTransformationLinearize[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the stationary distribution of the process proc, when it exists.
        /// https://reference.wolfram.com/language/ref/StationaryDistribution.html
        ///</summary>
        corewolf::engine *StationaryDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StationaryDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the stationary wavelet packet transform (SWPT) of an array of data.
        /// https://reference.wolfram.com/language/ref/StationaryWaveletPacketTransform.html
        ///</summary>
        corewolf::engine *StationaryWaveletPacketTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StationaryWaveletPacketTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the stationary wavelet packet transform using the wavelet wave.
        /// https://reference.wolfram.com/language/ref/StationaryWaveletPacketTransform.html
        ///</summary>
        corewolf::engine *StationaryWaveletPacketTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StationaryWaveletPacketTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the stationary wavelet packet transform using r levels of refinement.
        /// https://reference.wolfram.com/language/ref/StationaryWaveletPacketTransform.html
        ///</summary>
        corewolf::engine *StationaryWaveletPacketTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StationaryWaveletPacketTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the stationary wavelet transform (SWT) of an array of data.
        /// https://reference.wolfram.com/language/ref/StationaryWaveletTransform.html
        ///</summary>
        corewolf::engine *StationaryWaveletTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StationaryWaveletTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the stationary wavelet transform using the wavelet wave.
        /// https://reference.wolfram.com/language/ref/StationaryWaveletTransform.html
        ///</summary>
        corewolf::engine *StationaryWaveletTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StationaryWaveletTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the stationary wavelet transform using r levels of refinement.
        /// https://reference.wolfram.com/language/ref/StationaryWaveletTransform.html
        ///</summary>
        corewolf::engine *StationaryWaveletTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StationaryWaveletTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays string in the status area of the current notebook when the mouse pointer is in the region where expr appears.
        /// https://reference.wolfram.com/language/ref/StatusArea.html
        ///</summary>
        corewolf::engine *StatusArea(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StatusArea[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of status centralities for the vertices in the graph g.
        /// https://reference.wolfram.com/language/ref/StatusCentrality.html
        ///</summary>
        corewolf::engine *StatusCentrality(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StatusCentrality[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/StatusCentrality.html
        ///</summary>
        corewolf::engine *StatusCentrality(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("StatusCentrality[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Stieltjes constant .
        /// https://reference.wolfram.com/language/ref/StieltjesGamma.html
        ///</summary>
        corewolf::engine *StieltjesGamma(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StieltjesGamma[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the generalized Stieltjes constant .
        /// https://reference.wolfram.com/language/ref/StieltjesGamma.html
        ///</summary>
        corewolf::engine *StieltjesGamma(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StieltjesGamma[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a three-dimensional graphics directive specifying that objects that follow are to be drawn using small dots.
        /// https://reference.wolfram.com/language/ref/StippleShading.html
        ///</summary>
        corewolf::engine *StippleShading(const std::string &name = "")
        {
            return this->execute("StippleShading[]", name);
        }

        ///< summary>
        /// uses the density d of shading.
        /// https://reference.wolfram.com/language/ref/StippleShading.html
        ///</summary>
        corewolf::engine *StippleShading(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StippleShading[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses dots of color col with the density d of shading.
        /// https://reference.wolfram.com/language/ref/StippleShading.html
        ///</summary>
        corewolf::engine *StippleShading(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StippleShading[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Stirling number of the first kind .
        /// https://reference.wolfram.com/language/ref/StirlingS1.html
        ///</summary>
        corewolf::engine *StirlingS1(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StirlingS1[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Stirling number of the second kind .
        /// https://reference.wolfram.com/language/ref/StirlingS2.html
        ///</summary>
        corewolf::engine *StirlingS2(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StirlingS2[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specific property for the substance for the specified particle and the energy of that particle.
        /// https://reference.wolfram.com/language/ref/StoppingPowerData.html
        ///</summary>
        corewolf::engine *StoppingPowerData(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StoppingPowerData[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Stratonovich process , where .
        /// https://reference.wolfram.com/language/ref/StratonovichProcess.html
        ///</summary>
        corewolf::engine *StratonovichProcess(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StratonovichProcess[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Stratonovich process with initial condition .
        /// https://reference.wolfram.com/language/ref/StratonovichProcess.html
        ///</summary>
        corewolf::engine *StratonovichProcess(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("StratonovichProcess[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// uses a Wiener process , with covariance Σ.
        /// https://reference.wolfram.com/language/ref/StratonovichProcess.html
        ///</summary>
        corewolf::engine *StratonovichProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("StratonovichProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// converts proc to a standard Stratonovich process whenever possible.
        /// https://reference.wolfram.com/language/ref/StratonovichProcess.html
        ///</summary>
        corewolf::engine *StratonovichProcess(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StratonovichProcess[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Stratonovich process specified by a stochastic differential equation sdeqns, output expression expr, with state x and time t, driven by w following the process dproc.
        /// https://reference.wolfram.com/language/ref/StratonovichProcess.html
        ///</summary>
        corewolf::engine *StratonovichProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("StratonovichProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// represents a Strauss hardcore point process with constant intensity μ, interaction parameter γ, hard-core interaction radius rh and Strauss interaction radius rs in .
        /// https://reference.wolfram.com/language/ref/StraussHardcorePointProcess.html
        ///</summary>
        corewolf::engine *StraussHardcorePointProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("StraussHardcorePointProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// represents a Strauss point process with constant intensity μ, interaction parameter γ and interaction radius rs in d.
        /// https://reference.wolfram.com/language/ref/StraussPointProcess.html
        ///</summary>
        corewolf::engine *StraussPointProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("StraussPointProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// generates a stream plot of the vector field {vx,vy} as a function of x and y, superimposed on a background density plot of the scalar field s.
        /// https://reference.wolfram.com/language/ref/StreamDensityPlot.html
        ///</summary>
        corewolf::engine *StreamDensityPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("StreamDensityPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates plots of several vector fields.
        /// https://reference.wolfram.com/language/ref/StreamDensityPlot.html
        ///</summary>
        corewolf::engine *StreamDensityPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("StreamDensityPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// takes the variables {x,y} to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/StreamDensityPlot.html
        ///</summary>
        corewolf::engine *StreamDensityPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StreamDensityPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a stream plot of the vector field {vx,vy} as a function of x and y.
        /// https://reference.wolfram.com/language/ref/StreamPlot.html
        ///</summary>
        corewolf::engine *StreamPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("StreamPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// generates plots of several vector fields.
        /// https://reference.wolfram.com/language/ref/StreamPlot.html
        ///</summary>
        corewolf::engine *StreamPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("StreamPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// takes the variables {x,y} to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/StreamPlot.html
        ///</summary>
        corewolf::engine *StreamPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StreamPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// plots streamlines for the vector field {vx,vy,vz} as functions of x, y and z.
        /// https://reference.wolfram.com/language/ref/StreamPlot3D.html
        ///</summary>
        corewolf::engine *StreamPlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("StreamPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// takes the variables {x,y,z} to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/StreamPlot3D.html
        ///</summary>
        corewolf::engine *StreamPlot3D(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StreamPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns an integer that specifies the position of the current point in an open stream.
        /// https://reference.wolfram.com/language/ref/StreamPosition.html
        ///</summary>
        corewolf::engine *StreamPosition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StreamPosition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of all streams that are currently open.
        /// https://reference.wolfram.com/language/ref/Streams.html
        ///</summary>
        corewolf::engine *Streams(const std::string &name = "")
        {
            return this->execute("Streams[]", name);
        }

        ///< summary>
        /// lists only streams with the specified name.
        /// https://reference.wolfram.com/language/ref/Streams.html
        ///</summary>
        corewolf::engine *Streams(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Streams[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of the substrings in "string" that match the string expression patt.
        /// https://reference.wolfram.com/language/ref/StringCases.html
        ///</summary>
        corewolf::engine *StringCases(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringCases[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// includes only the first n substrings that match.
        /// https://reference.wolfram.com/language/ref/StringCases.html
        ///</summary>
        corewolf::engine *StringCases(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StringCases[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives substrings that match any of the pi.
        /// https://reference.wolfram.com/language/ref/StringCases.html
        ///</summary>
        corewolf::engine *StringCases(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StringCases[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the list of results for each of the si.
        /// https://reference.wolfram.com/language/ref/StringCases.html
        ///</summary>
        corewolf::engine *StringCases(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringCases[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of StringCases that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/StringCases.html
        ///</summary>
        corewolf::engine *StringCases(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringCases[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if any part of string matches the string pattern patt, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/StringContainsQ.html
        ///</summary>
        corewolf::engine *StringContainsQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringContainsQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the results for each of the stringi.
        /// https://reference.wolfram.com/language/ref/StringContainsQ.html
        ///</summary>
        corewolf::engine *StringContainsQ(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringContainsQ[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of StringContainsQ that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/StringContainsQ.html
        ///</summary>
        corewolf::engine *StringContainsQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringContainsQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a count of the number of times "sub" appears as a substring of "string".
        /// https://reference.wolfram.com/language/ref/StringCount.html
        ///</summary>
        corewolf::engine *StringCount(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringCount[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// counts the number of occurrences of any of the patti.
        /// https://reference.wolfram.com/language/ref/StringCount.html
        ///</summary>
        corewolf::engine *StringCount(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StringCount[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the list of results for each of the si.
        /// https://reference.wolfram.com/language/ref/StringCount.html
        ///</summary>
        corewolf::engine *StringCount(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringCount[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields the string obtained by deleting from string all occurrences of anything matching the string pattern patt.
        /// https://reference.wolfram.com/language/ref/StringDelete.html
        ///</summary>
        corewolf::engine *StringDelete(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringDelete[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of StringDelete that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/StringDelete.html
        ///</summary>
        corewolf::engine *StringDelete(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringDelete[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives "string" with its first n characters dropped.
        /// https://reference.wolfram.com/language/ref/StringDrop.html
        ///</summary>
        corewolf::engine *StringDrop(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringDrop[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives "string" with its n character dropped.
        /// https://reference.wolfram.com/language/ref/StringDrop.html
        ///</summary>
        corewolf::engine *StringDrop(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StringDrop[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the list of results for each of the .
        /// https://reference.wolfram.com/language/ref/StringDrop.html
        ///</summary>
        corewolf::engine *StringDrop(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringDrop[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if the end of string matches the string pattern patt, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/StringEndsQ.html
        ///</summary>
        corewolf::engine *StringEndsQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringEndsQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the results for each of the stringi.
        /// https://reference.wolfram.com/language/ref/StringEndsQ.html
        ///</summary>
        corewolf::engine *StringEndsQ(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringEndsQ[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of StringEndsQ that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/StringEndsQ.html
        ///</summary>
        corewolf::engine *StringEndsQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringEndsQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a sequence of strings and symbolic string objects si.
        /// https://reference.wolfram.com/language/ref/StringExpression.html
        ///</summary>
        corewolf::engine *StringExpression(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StringExpression[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// extracts the n block of characters in string, where blocks of characters are defined as delimited by whitespace.
        /// https://reference.wolfram.com/language/ref/StringExtract.html
        ///</summary>
        corewolf::engine *StringExtract(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringExtract[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// extracts blocks at several positions in string.
        /// https://reference.wolfram.com/language/ref/StringExtract.html
        ///</summary>
        corewolf::engine *StringExtract(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StringExtract[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// extracts blocks at positions posi, delimiting with whitespace for the lowest level, newlines for the next level, and a successively increasing number of newlines thereafter.
        /// https://reference.wolfram.com/language/ref/StringExtract.html
        ///</summary>
        corewolf::engine *StringExtract(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("StringExtract[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// prints as the text of the controlstring, with the printed forms of the expri embedded.
        /// https://reference.wolfram.com/language/ref/StringForm.html
        ///</summary>
        corewolf::engine *StringForm(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StringForm[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// attempts to determine what ImportString format could be used to import the string "string".
        /// https://reference.wolfram.com/language/ref/StringFormat.html
        ///</summary>
        corewolf::engine *StringFormat(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringFormat[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if the string "string" might be imported as format "fmt" and gives False otherwise.
        /// https://reference.wolfram.com/language/ref/StringFormatQ.html
        ///</summary>
        corewolf::engine *StringFormatQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringFormatQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if "string" might be imported as one of "fmti".
        /// https://reference.wolfram.com/language/ref/StringFormatQ.html
        ///</summary>
        corewolf::engine *StringFormatQ(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StringFormatQ[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if no substring in "string" matches the string expression patt, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/StringFreeQ.html
        ///</summary>
        corewolf::engine *StringFreeQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringFreeQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if no substring matches any of the patti.
        /// https://reference.wolfram.com/language/ref/StringFreeQ.html
        ///</summary>
        corewolf::engine *StringFreeQ(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StringFreeQ[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the list of results for each of the si.
        /// https://reference.wolfram.com/language/ref/StringFreeQ.html
        ///</summary>
        corewolf::engine *StringFreeQ(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringFreeQ[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of StringFreeQ that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/StringFreeQ.html
        ///</summary>
        corewolf::engine *StringFreeQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringFreeQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields a string with "snew" inserted starting at position  in "string".
        /// https://reference.wolfram.com/language/ref/StringInsert.html
        ///</summary>
        corewolf::engine *StringInsert(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StringInsert[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// inserts a copy of "snew" at each of the positions .
        /// https://reference.wolfram.com/language/ref/StringInsert.html
        ///</summary>
        corewolf::engine *StringInsert(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("StringInsert[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the list of results for each of the .
        /// https://reference.wolfram.com/language/ref/StringInsert.html
        ///</summary>
        corewolf::engine *StringInsert(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StringInsert[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the number of characters in a string.
        /// https://reference.wolfram.com/language/ref/StringLength.html
        ///</summary>
        corewolf::engine *StringLength(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringLength[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether "string" matches the string pattern patt.
        /// https://reference.wolfram.com/language/ref/StringMatchQ.html
        ///</summary>
        corewolf::engine *StringMatchQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringMatchQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of results for each of the si.
        /// https://reference.wolfram.com/language/ref/StringMatchQ.html
        ///</summary>
        corewolf::engine *StringMatchQ(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringMatchQ[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of StringMatchQ that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/StringMatchQ.html
        ///</summary>
        corewolf::engine *StringMatchQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringMatchQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes string be of length n, padding it on the left with spaces or truncating it if necessary.
        /// https://reference.wolfram.com/language/ref/StringPadLeft.html
        ///</summary>
        corewolf::engine *StringPadLeft(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringPadLeft[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// pads by repeating copies of the string padding.
        /// https://reference.wolfram.com/language/ref/StringPadLeft.html
        ///</summary>
        corewolf::engine *StringPadLeft(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StringPadLeft[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// pads strings with spaces on the left to make them all the same length.
        /// https://reference.wolfram.com/language/ref/StringPadLeft.html
        ///</summary>
        corewolf::engine *StringPadLeft(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("StringPadLeft[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// pads or truncates to make all strings of length n.
        /// https://reference.wolfram.com/language/ref/StringPadLeft.html
        ///</summary>
        corewolf::engine *StringPadLeft(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StringPadLeft[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// makes string be of length n, padding it on the right with spaces or truncating it if necessary.
        /// https://reference.wolfram.com/language/ref/StringPadRight.html
        ///</summary>
        corewolf::engine *StringPadRight(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringPadRight[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// pads by repeating copies of the string padding.
        /// https://reference.wolfram.com/language/ref/StringPadRight.html
        ///</summary>
        corewolf::engine *StringPadRight(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StringPadRight[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// pads strings with spaces on the right to make them all the same length.
        /// https://reference.wolfram.com/language/ref/StringPadRight.html
        ///</summary>
        corewolf::engine *StringPadRight(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("StringPadRight[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// pads or truncates to make all strings of length n.
        /// https://reference.wolfram.com/language/ref/StringPadRight.html
        ///</summary>
        corewolf::engine *StringPadRight(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StringPadRight[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the n character in "string".
        /// https://reference.wolfram.com/language/ref/StringPart.html
        ///</summary>
        corewolf::engine *StringPart(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringPart[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the ni characters in "string".
        /// https://reference.wolfram.com/language/ref/StringPart.html
        ///</summary>
        corewolf::engine *StringPart(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StringPart[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the list of results for each of the si.
        /// https://reference.wolfram.com/language/ref/StringPart.html
        ///</summary>
        corewolf::engine *StringPart(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringPart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// partitions string into nonoverlapping substrings of length n.
        /// https://reference.wolfram.com/language/ref/StringPartition.html
        ///</summary>
        corewolf::engine *StringPartition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringPartition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates substrings with offset d.
        /// https://reference.wolfram.com/language/ref/StringPartition.html
        ///</summary>
        corewolf::engine *StringPartition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StringPartition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of the starting and ending character positions at which "sub" appears as a substring of "string".
        /// https://reference.wolfram.com/language/ref/StringPosition.html
        ///</summary>
        corewolf::engine *StringPosition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringPosition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// includes only the first n occurrences of patt.
        /// https://reference.wolfram.com/language/ref/StringPosition.html
        ///</summary>
        corewolf::engine *StringPosition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StringPosition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives positions of all the patti.
        /// https://reference.wolfram.com/language/ref/StringPosition.html
        ///</summary>
        corewolf::engine *StringPosition(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StringPosition[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the list of results for each of the si.
        /// https://reference.wolfram.com/language/ref/StringPosition.html
        ///</summary>
        corewolf::engine *StringPosition(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringPosition[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of StringPosition that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/StringPosition.html
        ///</summary>
        corewolf::engine *StringPosition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringPosition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if expr is a string, and False otherwise.
        /// https://reference.wolfram.com/language/ref/StringQ.html
        ///</summary>
        corewolf::engine *StringQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a string consisting of "str" repeated n times.
        /// https://reference.wolfram.com/language/ref/StringRepeat.html
        ///</summary>
        corewolf::engine *StringRepeat(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringRepeat[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a string consisting of up to n copies of "str", truncated to be of maximum total length at most max.
        /// https://reference.wolfram.com/language/ref/StringRepeat.html
        ///</summary>
        corewolf::engine *StringRepeat(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StringRepeat[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// replaces the string expression s by sp wherever it appears in "string".
        /// https://reference.wolfram.com/language/ref/StringReplace.html
        ///</summary>
        corewolf::engine *StringReplace(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringReplace[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces the string expressions si by spi whenever they appear as substrings of "string".
        /// https://reference.wolfram.com/language/ref/StringReplace.html
        ///</summary>
        corewolf::engine *StringReplace(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StringReplace[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// does only the first n replacements.
        /// https://reference.wolfram.com/language/ref/StringReplace.html
        ///</summary>
        corewolf::engine *StringReplace(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StringReplace[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the list of results for each of the si.
        /// https://reference.wolfram.com/language/ref/StringReplace.html
        ///</summary>
        corewolf::engine *StringReplace(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringReplace[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of StringReplace that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/StringReplace.html
        ///</summary>
        corewolf::engine *StringReplace(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringReplace[" + arg0 + "]", name);
        }

        ///< summary>
        /// replaces the characters at positions m through n in "string" by "snew".
        /// https://reference.wolfram.com/language/ref/StringReplacePart.html
        ///</summary>
        corewolf::engine *StringReplacePart(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("StringReplacePart[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// inserts copies of "snew" at several positions.
        /// https://reference.wolfram.com/language/ref/StringReplacePart.html
        ///</summary>
        corewolf::engine *StringReplacePart(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("StringReplacePart[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// replaces characters at positions mi through ni in "string" by "snewi".
        /// https://reference.wolfram.com/language/ref/StringReplacePart.html
        ///</summary>
        corewolf::engine *StringReplacePart(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("StringReplacePart[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// represents an operator form of StringReplacePart that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/StringReplacePart.html
        ///</summary>
        corewolf::engine *StringReplacePart(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StringReplacePart[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// reverses the order of the characters in "string".
        /// https://reference.wolfram.com/language/ref/StringReverse.html
        ///</summary>
        corewolf::engine *StringReverse(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringReverse[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a string by concatenating all the si, with spaces inserted between them.
        /// https://reference.wolfram.com/language/ref/StringRiffle.html
        ///</summary>
        corewolf::engine *StringRiffle(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("StringRiffle[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// creates a string by concatenating the sij, and inserting spaces at the lowest level and newlines at the higher level.
        /// https://reference.wolfram.com/language/ref/StringRiffle.html
        ///</summary>
        corewolf::engine *StringRiffle(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StringRiffle[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// inserts the separator sep between all elements in list.
        /// https://reference.wolfram.com/language/ref/StringRiffle.html
        ///</summary>
        corewolf::engine *StringRiffle(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringRiffle[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// use left and right as delimiters after concatenation.
        /// https://reference.wolfram.com/language/ref/StringRiffle.html
        ///</summary>
        corewolf::engine *StringRiffle(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StringRiffle[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// inserts separator sepi between elements of list at level i.
        /// https://reference.wolfram.com/language/ref/StringRiffle.html
        ///</summary>
        corewolf::engine *StringRiffle(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("StringRiffle[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// cycles the characters in string n positions to the left.
        /// https://reference.wolfram.com/language/ref/StringRotateLeft.html
        ///</summary>
        corewolf::engine *StringRotateLeft(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringRotateLeft[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// cycles one position to the left.
        /// https://reference.wolfram.com/language/ref/StringRotateLeft.html
        ///</summary>
        corewolf::engine *StringRotateLeft(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringRotateLeft[" + arg0 + "]", name);
        }

        ///< summary>
        /// cycles the characters in string n positions to the right.
        /// https://reference.wolfram.com/language/ref/StringRotateRight.html
        ///</summary>
        corewolf::engine *StringRotateRight(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringRotateRight[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// cycles one position to the right.
        /// https://reference.wolfram.com/language/ref/StringRotateRight.html
        ///</summary>
        corewolf::engine *StringRotateRight(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringRotateRight[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a sequence of n omitted characters in a string printed with Short. The standard print form for StringSkeleton is an ellipsis.
        /// https://reference.wolfram.com/language/ref/StringSkeleton.html
        ///</summary>
        corewolf::engine *StringSkeleton(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringSkeleton[" + arg0 + "]", name);
        }

        ///< summary>
        /// splits "string" into a list of substrings separated by whitespace.
        /// https://reference.wolfram.com/language/ref/StringSplit.html
        ///</summary>
        corewolf::engine *StringSplit(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringSplit[" + arg0 + "]", name);
        }

        ///< summary>
        /// splits into substrings separated by delimiters matching the string expression patt.
        /// https://reference.wolfram.com/language/ref/StringSplit.html
        ///</summary>
        corewolf::engine *StringSplit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringSplit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// splits at any of the pi.
        /// https://reference.wolfram.com/language/ref/StringSplit.html
        ///</summary>
        corewolf::engine *StringSplit(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StringSplit[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// splits into at most n substrings.
        /// https://reference.wolfram.com/language/ref/StringSplit.html
        ///</summary>
        corewolf::engine *StringSplit(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StringSplit[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the list of results for each of the si.
        /// https://reference.wolfram.com/language/ref/StringSplit.html
        ///</summary>
        corewolf::engine *StringSplit(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringSplit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if the beginning of string matches the string pattern patt, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/StringStartsQ.html
        ///</summary>
        corewolf::engine *StringStartsQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringStartsQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the results for each of the stringi.
        /// https://reference.wolfram.com/language/ref/StringStartsQ.html
        ///</summary>
        corewolf::engine *StringStartsQ(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringStartsQ[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of StringStartsQ that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/StringStartsQ.html
        ///</summary>
        corewolf::engine *StringStartsQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringStartsQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a string containing the first n characters in "string".
        /// https://reference.wolfram.com/language/ref/StringTake.html
        ///</summary>
        corewolf::engine *StringTake(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringTake[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the n  character in "string".
        /// https://reference.wolfram.com/language/ref/StringTake.html
        ///</summary>
        corewolf::engine *StringTake(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StringTake[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the list of results for each of the si.
        /// https://reference.wolfram.com/language/ref/StringTake.html
        ///</summary>
        corewolf::engine *StringTake(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringTake[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a pair of strings containing the first n characters in "string" and the remaining characters.
        /// https://reference.wolfram.com/language/ref/StringTakeDrop.html
        ///</summary>
        corewolf::engine *StringTakeDrop(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringTakeDrop[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields a TemplateObject expression that represents a string template to be applied to arguments.
        /// https://reference.wolfram.com/language/ref/StringTemplate.html
        ///</summary>
        corewolf::engine *StringTemplate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringTemplate[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields a TemplateObject with arguments, suitable for cloud deployment or other evaluation.
        /// https://reference.wolfram.com/language/ref/StringTemplate.html
        ///</summary>
        corewolf::engine *StringTemplate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringTemplate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a byte array corresponding to the UTF-8 encoding of the specified string.
        /// https://reference.wolfram.com/language/ref/StringToByteArray.html
        ///</summary>
        corewolf::engine *StringToByteArray(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringToByteArray[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the specified character encoding.
        /// https://reference.wolfram.com/language/ref/StringToByteArray.html
        ///</summary>
        corewolf::engine *StringToByteArray(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringToByteArray[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// opens an input stream for reading from a string.
        /// https://reference.wolfram.com/language/ref/StringToStream.html
        ///</summary>
        corewolf::engine *StringToStream(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringToStream[" + arg0 + "]", name);
        }

        ///< summary>
        /// trims whitespace from the beginning and end of "string".
        /// https://reference.wolfram.com/language/ref/StringTrim.html
        ///</summary>
        corewolf::engine *StringTrim(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StringTrim[" + arg0 + "]", name);
        }

        ///< summary>
        /// trims substrings matching patt from the beginning and end.
        /// https://reference.wolfram.com/language/ref/StringTrim.html
        ///</summary>
        corewolf::engine *StringTrim(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StringTrim[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// will strip out unnecessary boxes, spaces, and styles from a format expression.
        /// https://reference.wolfram.com/language/ref/StripBoxes.html
        ///</summary>
        corewolf::engine *StripBoxes(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StripBoxes[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the structural importances for all components in the ReliabilityDistribution rdist.
        /// https://reference.wolfram.com/language/ref/StructuralImportance.html
        ///</summary>
        corewolf::engine *StructuralImportance(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StructuralImportance[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the structural importance for the components x1, x2, … in the Boolean expression bexpr.
        /// https://reference.wolfram.com/language/ref/StructuralImportance.html
        ///</summary>
        corewolf::engine *StructuralImportance(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("StructuralImportance[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Struve function .
        /// https://reference.wolfram.com/language/ref/StruveH.html
        ///</summary>
        corewolf::engine *StruveH(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StruveH[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the modified Struve function .
        /// https://reference.wolfram.com/language/ref/StruveL.html
        ///</summary>
        corewolf::engine *StruveL(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StruveL[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Student  distribution with ν degrees of freedom.
        /// https://reference.wolfram.com/language/ref/StudentTDistribution.html
        ///</summary>
        corewolf::engine *StudentTDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StudentTDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Student  distribution with location parameter μ, scale parameter σ, and ν degrees of freedom.
        /// https://reference.wolfram.com/language/ref/StudentTDistribution.html
        ///</summary>
        corewolf::engine *StudentTDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("StudentTDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays with expr formatted using the specified option settings.
        /// https://reference.wolfram.com/language/ref/Style.html
        ///</summary>
        corewolf::engine *Style(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Style[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// display with fonts that are tiny, small, etc.
        /// https://reference.wolfram.com/language/ref/Style.html
        ///</summary>
        corewolf::engine *Style(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Style[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a low-level representation of boxes to be shown with the specified option settings.
        /// https://reference.wolfram.com/language/ref/StyleBox.html
        ///</summary>
        corewolf::engine *StyleBox(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StyleBox[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a low-level representation of the contents of a style definition cell.
        /// https://reference.wolfram.com/language/ref/StyleData.html
        ///</summary>
        corewolf::engine *StyleData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("StyleData[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the contents of a style definition cell in the style environment "environment".
        /// https://reference.wolfram.com/language/ref/StyleData.html
        ///</summary>
        corewolf::engine *StyleData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("StyleData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates the list {0,1/n,2/n,…,1}.
        /// https://reference.wolfram.com/language/ref/Subdivide.html
        ///</summary>
        corewolf::engine *Subdivide(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Subdivide[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates the list of values obtained by subdividing the interval 0 to xmax into n equal parts.
        /// https://reference.wolfram.com/language/ref/Subdivide.html
        ///</summary>
        corewolf::engine *Subdivide(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Subdivide[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates the list of values from subdividing the interval xmin to xmax.
        /// https://reference.wolfram.com/language/ref/Subdivide.html
        ///</summary>
        corewolf::engine *Subdivide(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Subdivide[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the number of permutations of n objects that leave no const std::string &fixed.
        /// https://reference.wolfram.com/language/ref/Subfactorial.html
        ///</summary>
        corewolf::engine *Subfactorial(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Subfactorial[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the subgraph of the graph g generated by the vertices vi.
        /// https://reference.wolfram.com/language/ref/Subgraph.html
        ///</summary>
        corewolf::engine *Subgraph(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Subgraph[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the subgraph generated by the vertices and edges that match the pattern patt.
        /// https://reference.wolfram.com/language/ref/Subgraph.html
        ///</summary>
        corewolf::engine *Subgraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Subgraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/Subgraph.html
        ///</summary>
        corewolf::engine *Subgraph(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Subgraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as expr-.
        /// https://reference.wolfram.com/language/ref/SubMinus.html
        ///</summary>
        corewolf::engine *SubMinus(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SubMinus[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as expr+.
        /// https://reference.wolfram.com/language/ref/SubPlus.html
        ///</summary>
        corewolf::engine *SubPlus(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SubPlus[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the subresultant polynomial remainder sequence of the polynomials poly1 and poly2 with respect to the variable var.
        /// https://reference.wolfram.com/language/ref/SubresultantPolynomialRemainders.html
        ///</summary>
        corewolf::engine *SubresultantPolynomialRemainders(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SubresultantPolynomialRemainders[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes the subresultant polynomial remainder sequence modulo the prime p.
        /// https://reference.wolfram.com/language/ref/SubresultantPolynomialRemainders.html
        ///</summary>
        corewolf::engine *SubresultantPolynomialRemainders(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SubresultantPolynomialRemainders[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// generates a list of subresultant polynomials of the polynomials poly1 and poly2 with respect to the variable var.
        /// https://reference.wolfram.com/language/ref/SubresultantPolynomials.html
        ///</summary>
        corewolf::engine *SubresultantPolynomials(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SubresultantPolynomials[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes the subresultant polynomials modulo the prime p.
        /// https://reference.wolfram.com/language/ref/SubresultantPolynomials.html
        ///</summary>
        corewolf::engine *SubresultantPolynomials(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SubresultantPolynomials[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// generates a list of the principal subresultant coefficients of the polynomials poly1 and poly2 with respect to the variable var.
        /// https://reference.wolfram.com/language/ref/Subresultants.html
        ///</summary>
        corewolf::engine *Subresultants(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Subresultants[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes the principal subresultant coefficients modulo the prime p.
        /// https://reference.wolfram.com/language/ref/Subresultants.html
        ///</summary>
        corewolf::engine *Subresultants(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Subresultants[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// is an const std::string &that formats as .
        /// https://reference.wolfram.com/language/ref/Subscript.html
        ///</summary>
        corewolf::engine *Subscript(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Subscript[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// formats as .
        /// https://reference.wolfram.com/language/ref/Subscript.html
        ///</summary>
        corewolf::engine *Subscript(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Subscript[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// is the low‐level box representation for xy in notebook expressions.
        /// https://reference.wolfram.com/language/ref/SubscriptBox.html
        ///</summary>
        corewolf::engine *SubscriptBox(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SubscriptBox[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of all possible subsequences of list.
        /// https://reference.wolfram.com/language/ref/Subsequences.html
        ///</summary>
        corewolf::engine *Subsequences(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Subsequences[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives all subsequences containing at most n elements.
        /// https://reference.wolfram.com/language/ref/Subsequences.html
        ///</summary>
        corewolf::engine *Subsequences(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Subsequences[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives all subsequences containing exactly n elements.
        /// https://reference.wolfram.com/language/ref/Subsequences.html
        ///</summary>
        corewolf::engine *Subsequences(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Subsequences[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// limits the result to the first s subsequences.
        /// https://reference.wolfram.com/language/ref/Subsequences.html
        ///</summary>
        corewolf::engine *Subsequences(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Subsequences[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives if possible the s  subsequence.
        /// https://reference.wolfram.com/language/ref/Subsequences.html
        ///</summary>
        corewolf::engine *Subsequences(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Subsequences[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Subset.html
        ///</summary>
        corewolf::engine *Subset(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Subset[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of the sublists in list that match the pattern patt in any order.
        /// https://reference.wolfram.com/language/ref/SubsetCases.html
        ///</summary>
        corewolf::engine *SubsetCases(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SubsetCases[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// includes only the first n matches.
        /// https://reference.wolfram.com/language/ref/SubsetCases.html
        ///</summary>
        corewolf::engine *SubsetCases(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SubsetCases[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a count of the number of times sub appears in any order as a sublist of list.
        /// https://reference.wolfram.com/language/ref/SubsetCount.html
        ///</summary>
        corewolf::engine *SubsetCount(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SubsetCount[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/SubsetEqual.html
        ///</summary>
        corewolf::engine *SubsetEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SubsetEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields an expression in which the elements ei, ej, … in the list {e1,e2,…} are replaced with the corresponding elements of the list obtained by evaluating f[{ei,ej,…}].
        /// https://reference.wolfram.com/language/ref/SubsetMap.html
        ///</summary>
        corewolf::engine *SubsetMap(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SubsetMap[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// replaces elements of expr at positions pos1, pos2, ….
        /// https://reference.wolfram.com/language/ref/SubsetMap.html
        ///</summary>
        corewolf::engine *SubsetMap(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SubsetMap[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents an operator form of SubsetMap that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/SubsetMap.html
        ///</summary>
        corewolf::engine *SubsetMap(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SubsetMap[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of positions at which sublist appears in list in any order.
        /// https://reference.wolfram.com/language/ref/SubsetPosition.html
        ///</summary>
        corewolf::engine *SubsetPosition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SubsetPosition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// includes only the first n positions.
        /// https://reference.wolfram.com/language/ref/SubsetPosition.html
        ///</summary>
        corewolf::engine *SubsetPosition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SubsetPosition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields True if list2 is a subset of list1, and False otherwise.
        /// https://reference.wolfram.com/language/ref/SubsetQ.html
        ///</summary>
        corewolf::engine *SubsetQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SubsetQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces sublists in list according to the specified rule or list of rules.
        /// https://reference.wolfram.com/language/ref/SubsetReplace.html
        ///</summary>
        corewolf::engine *SubsetReplace(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SubsetReplace[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// does only the first n replacements.
        /// https://reference.wolfram.com/language/ref/SubsetReplace.html
        ///</summary>
        corewolf::engine *SubsetReplace(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SubsetReplace[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of SubsetReplace that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/SubsetReplace.html
        ///</summary>
        corewolf::engine *SubsetReplace(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SubsetReplace[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of all possible subsets of list.
        /// https://reference.wolfram.com/language/ref/Subsets.html
        ///</summary>
        corewolf::engine *Subsets(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Subsets[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives all subsets containing at most n elements.
        /// https://reference.wolfram.com/language/ref/Subsets.html
        ///</summary>
        corewolf::engine *Subsets(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Subsets[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives all subsets containing exactly n elements.
        /// https://reference.wolfram.com/language/ref/Subsets.html
        ///</summary>
        corewolf::engine *Subsets(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Subsets[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// limits the result to the first s subsets.
        /// https://reference.wolfram.com/language/ref/Subsets.html
        ///</summary>
        corewolf::engine *Subsets(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Subsets[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives if possible the s  subset.
        /// https://reference.wolfram.com/language/ref/Subsets.html
        ///</summary>
        corewolf::engine *Subsets(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Subsets[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// displays as expr*.
        /// https://reference.wolfram.com/language/ref/SubStar.html
        ///</summary>
        corewolf::engine *SubStar(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SubStar[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a list representing the evolution of the substitution system with the specified rule from initial condition init for t steps.
        /// https://reference.wolfram.com/language/ref/SubstitutionSystem.html
        ///</summary>
        corewolf::engine *SubstitutionSystem(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SubstitutionSystem[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the result of evolving init for one step.
        /// https://reference.wolfram.com/language/ref/SubstitutionSystem.html
        ///</summary>
        corewolf::engine *SubstitutionSystem(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SubstitutionSystem[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is an operator form of SubstitutionSystem that corresponds to one step of evolution.
        /// https://reference.wolfram.com/language/ref/SubstitutionSystem.html
        ///</summary>
        corewolf::engine *SubstitutionSystem(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SubstitutionSystem[" + arg0 + "]", name);
        }

        ///< summary>
        /// is an const std::string &that formats as .
        /// https://reference.wolfram.com/language/ref/Subsuperscript.html
        ///</summary>
        corewolf::engine *Subsuperscript(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Subsuperscript[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is the low‐level box representation for  in notebook expressions.
        /// https://reference.wolfram.com/language/ref/SubsuperscriptBox.html
        ///</summary>
        corewolf::engine *SubsuperscriptBox(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SubsuperscriptBox[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// subtracts x from each side of the equation or inequality rel.
        /// https://reference.wolfram.com/language/ref/SubtractSides.html
        ///</summary>
        corewolf::engine *SubtractSides(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SubtractSides[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// subtracts the right-hand side of rel from each side, producing a zero right-hand side.
        /// https://reference.wolfram.com/language/ref/SubtractSides.html
        ///</summary>
        corewolf::engine *SubtractSides(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SubtractSides[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of transformation rules corresponding to all subvalues (values for f[…][…]…) defined for the symbol f.
        /// https://reference.wolfram.com/language/ref/SubValues.html
        ///</summary>
        corewolf::engine *SubValues(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SubValues[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Succeeds.html
        ///</summary>
        corewolf::engine *Succeeds(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Succeeds[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/SucceedsEqual.html
        ///</summary>
        corewolf::engine *SucceedsEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SucceedsEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/SucceedsSlantEqual.html
        ///</summary>
        corewolf::engine *SucceedsSlantEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SucceedsSlantEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/SucceedsTilde.html
        ///</summary>
        corewolf::engine *SucceedsTilde(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SucceedsTilde[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a success of a type indicated by tag, with details given by the association assoc.
        /// https://reference.wolfram.com/language/ref/Success.html
        ///</summary>
        corewolf::engine *Success(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Success[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/SuchThat.html
        ///</summary>
        corewolf::engine *SuchThat(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SuchThat[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates the sum .
        /// https://reference.wolfram.com/language/ref/Sum.html
        ///</summary>
        corewolf::engine *Sum(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Sum[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses successive values , , ….
        /// https://reference.wolfram.com/language/ref/Sum.html
        ///</summary>
        corewolf::engine *Sum(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Sum[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates the multiple sum .
        /// https://reference.wolfram.com/language/ref/Sum.html
        ///</summary>
        corewolf::engine *Sum(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Sum[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the indefinite sum .
        /// https://reference.wolfram.com/language/ref/Sum.html
        ///</summary>
        corewolf::engine *Sum(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Sum[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives conditions for the sum  to be convergent.
        /// https://reference.wolfram.com/language/ref/SumConvergence.html
        ///</summary>
        corewolf::engine *SumConvergence(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SumConvergence[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives conditions for the multiple sum  to be convergent.
        /// https://reference.wolfram.com/language/ref/SumConvergence.html
        ///</summary>
        corewolf::engine *SumConvergence(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SumConvergence[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a net layer that sums all of its input elements.
        /// https://reference.wolfram.com/language/ref/SummationLayer.html
        ///</summary>
        corewolf::engine *SummationLayer(const std::string &name = "")
        {
            return this->execute("SummationLayer[]", name);
        }

        ///< summary>
        /// gives the position of the Sun for the current date and location.
        /// https://reference.wolfram.com/language/ref/SunPosition.html
        ///</summary>
        corewolf::engine *SunPosition(const std::string &name = "")
        {
            return this->execute("SunPosition[]", name);
        }

        ///< summary>
        /// gives the position of the Sun for the specified date.
        /// https://reference.wolfram.com/language/ref/SunPosition.html
        ///</summary>
        corewolf::engine *SunPosition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SunPosition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the position of the Sun for the specified date and location.
        /// https://reference.wolfram.com/language/ref/SunPosition.html
        ///</summary>
        corewolf::engine *SunPosition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SunPosition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the positions of the Sun for all specified locations on the specified dates.
        /// https://reference.wolfram.com/language/ref/SunPosition.html
        ///</summary>
        corewolf::engine *SunPosition(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SunPosition[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses func to determine what to return for extended locations.
        /// https://reference.wolfram.com/language/ref/SunPosition.html
        ///</summary>
        corewolf::engine *SunPosition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SunPosition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the time of the next sunrise for the current date and location.
        /// https://reference.wolfram.com/language/ref/Sunrise.html
        ///</summary>
        corewolf::engine *Sunrise(const std::string &name = "")
        {
            return this->execute("Sunrise[]", name);
        }

        ///< summary>
        /// gives the times of the next sunrise for the specified dates.
        /// https://reference.wolfram.com/language/ref/Sunrise.html
        ///</summary>
        corewolf::engine *Sunrise(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Sunrise[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the time of the next sunrise for the specified date and location.
        /// https://reference.wolfram.com/language/ref/Sunrise.html
        ///</summary>
        corewolf::engine *Sunrise(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Sunrise[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the times of the next sunrise for all specified locations on the specified dates.
        /// https://reference.wolfram.com/language/ref/Sunrise.html
        ///</summary>
        corewolf::engine *Sunrise(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Sunrise[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses func to determine what to return for extended locations.
        /// https://reference.wolfram.com/language/ref/Sunrise.html
        ///</summary>
        corewolf::engine *Sunrise(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Sunrise[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the time of the next sunset for the current date and location.
        /// https://reference.wolfram.com/language/ref/Sunset.html
        ///</summary>
        corewolf::engine *Sunset(const std::string &name = "")
        {
            return this->execute("Sunset[]", name);
        }

        ///< summary>
        /// gives the time of the next sunset for the specified dates.
        /// https://reference.wolfram.com/language/ref/Sunset.html
        ///</summary>
        corewolf::engine *Sunset(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Sunset[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the time of the next sunset for the specified date and location.
        /// https://reference.wolfram.com/language/ref/Sunset.html
        ///</summary>
        corewolf::engine *Sunset(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Sunset[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the times of the next sunset for all specified locations on the specified dates.
        /// https://reference.wolfram.com/language/ref/Sunset.html
        ///</summary>
        corewolf::engine *Sunset(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Sunset[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses func to determine what to return for extended locations.
        /// https://reference.wolfram.com/language/ref/Sunset.html
        ///</summary>
        corewolf::engine *Sunset(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Sunset[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as expr†.
        /// https://reference.wolfram.com/language/ref/SuperDagger.html
        ///</summary>
        corewolf::engine *SuperDagger(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SuperDagger[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as expr-.
        /// https://reference.wolfram.com/language/ref/SuperMinus.html
        ///</summary>
        corewolf::engine *SuperMinus(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SuperMinus[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the supernova entity.
        /// https://reference.wolfram.com/language/ref/SupernovaData.html
        ///</summary>
        corewolf::engine *SupernovaData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SupernovaData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified supernova entities.
        /// https://reference.wolfram.com/language/ref/SupernovaData.html
        ///</summary>
        corewolf::engine *SupernovaData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SupernovaData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/SupernovaData.html
        ///</summary>
        corewolf::engine *SupernovaData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SupernovaData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as expr+.
        /// https://reference.wolfram.com/language/ref/SuperPlus.html
        ///</summary>
        corewolf::engine *SuperPlus(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SuperPlus[" + arg0 + "]", name);
        }

        ///< summary>
        /// is an const std::string &that formats as .
        /// https://reference.wolfram.com/language/ref/Superscript.html
        ///</summary>
        corewolf::engine *Superscript(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Superscript[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is the low‐level box representation for xy in notebook expressions.
        /// https://reference.wolfram.com/language/ref/SuperscriptBox.html
        ///</summary>
        corewolf::engine *SuperscriptBox(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SuperscriptBox[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Superset.html
        ///</summary>
        corewolf::engine *Superset(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Superset[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/SupersetEqual.html
        ///</summary>
        corewolf::engine *SupersetEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SupersetEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as expr*.
        /// https://reference.wolfram.com/language/ref/SuperStar.html
        ///</summary>
        corewolf::engine *SuperStar(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SuperStar[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the real-valued  root of x.
        /// https://reference.wolfram.com/language/ref/Surd.html
        ///</summary>
        corewolf::engine *Surd(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Surd[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the surface area of the three-dimensional region reg.
        /// https://reference.wolfram.com/language/ref/SurfaceArea.html
        ///</summary>
        corewolf::engine *SurfaceArea(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SurfaceArea[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the surface area of the parametrized region whose Cartesian coordinates xi are functions of s, t, u.
        /// https://reference.wolfram.com/language/ref/SurfaceArea.html
        ///</summary>
        corewolf::engine *SurfaceArea(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("SurfaceArea[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// interprets the xi as coordinates in the specified coordinate chart.
        /// https://reference.wolfram.com/language/ref/SurfaceArea.html
        ///</summary>
        corewolf::engine *SurfaceArea(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("SurfaceArea[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the surface entity.
        /// https://reference.wolfram.com/language/ref/SurfaceData.html
        ///</summary>
        corewolf::engine *SurfaceData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SurfaceData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified surface entities.
        /// https://reference.wolfram.com/language/ref/SurfaceData.html
        ///</summary>
        corewolf::engine *SurfaceData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SurfaceData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/SurfaceData.html
        ///</summary>
        corewolf::engine *SurfaceData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SurfaceData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a survival distribution with event times ei.
        /// https://reference.wolfram.com/language/ref/SurvivalDistribution.html
        ///</summary>
        corewolf::engine *SurvivalDistribution(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SurvivalDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the survival function for the distribution dist evaluated at x.
        /// https://reference.wolfram.com/language/ref/SurvivalFunction.html
        ///</summary>
        corewolf::engine *SurvivalFunction(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SurvivalFunction[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the multivariate survival function for the distribution dist evaluated at {x1,x2,…}.
        /// https://reference.wolfram.com/language/ref/SurvivalFunction.html
        ///</summary>
        corewolf::engine *SurvivalFunction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SurvivalFunction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the survival function as a pure function.
        /// https://reference.wolfram.com/language/ref/SurvivalFunction.html
        ///</summary>
        corewolf::engine *SurvivalFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SurvivalFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the symbolic survival model obtained from functions like SurvivalModelFit.
        /// https://reference.wolfram.com/language/ref/SurvivalModel.html
        ///</summary>
        corewolf::engine *SurvivalModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SurvivalModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a survival model for event times ei.
        /// https://reference.wolfram.com/language/ref/SurvivalModelFit.html
        ///</summary>
        corewolf::engine *SurvivalModelFit(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SurvivalModelFit[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the Suzuki distribution with shape parameters μ and ν.
        /// https://reference.wolfram.com/language/ref/SuzukiDistribution.html
        ///</summary>
        corewolf::engine *SuzukiDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SuzukiDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the sporadic simple Suzuki group .
        /// https://reference.wolfram.com/language/ref/SuzukiGroupSuz.html
        ///</summary>
        corewolf::engine *SuzukiGroupSuz(const std::string &name = "")
        {
            return this->execute("SuzukiGroupSuz[]", name);
        }

        ///< summary>
        /// generates a legend that associates swatches of colors coli with labels lbli.
        /// https://reference.wolfram.com/language/ref/SwatchLegend.html
        ///</summary>
        corewolf::engine *SwatchLegend(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SwatchLegend[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// generates a legend with placeholder labels for the colors coli.
        /// https://reference.wolfram.com/language/ref/SwatchLegend.html
        ///</summary>
        corewolf::engine *SwatchLegend(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SwatchLegend[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a legend with inherited colors within visualization functions.
        /// https://reference.wolfram.com/language/ref/SwatchLegend.html
        ///</summary>
        corewolf::engine *SwatchLegend(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SwatchLegend[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// evaluates expr, then compares it with each of the formi in turn, evaluating and returning the valuei corresponding to the first match found.
        /// https://reference.wolfram.com/language/ref/Switch.html
        ///</summary>
        corewolf::engine *Switch(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &arg5, const std::string &name = "")
        {
            return this->execute("Switch[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + "]", name);
        }

        ///< summary>
        /// refers to a symbol with the specified name.
        /// https://reference.wolfram.com/language/ref/Symbol.html
        ///</summary>
        corewolf::engine *Symbol(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Symbol[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the name of the specified symbol.
        /// https://reference.wolfram.com/language/ref/SymbolName.html
        ///</summary>
        corewolf::engine *SymbolName(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SymbolName[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the Symlet wavelet of order 4.
        /// https://reference.wolfram.com/language/ref/SymletWavelet.html
        ///</summary>
        corewolf::engine *SymletWavelet(const std::string &name = "")
        {
            return this->execute("SymletWavelet[]", name);
        }

        ///< summary>
        /// represents the Symlet wavelet of order n.
        /// https://reference.wolfram.com/language/ref/SymletWavelet.html
        ///</summary>
        corewolf::engine *SymletWavelet(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SymletWavelet[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the symmetry of a tensor that is symmetric in the slots si.
        /// https://reference.wolfram.com/language/ref/Symmetric.html
        ///</summary>
        corewolf::engine *Symmetric(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Symmetric[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the symmetric difference of the lists listi.
        /// https://reference.wolfram.com/language/ref/SymmetricDifference.html
        ///</summary>
        corewolf::engine *SymmetricDifference(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SymmetricDifference[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the symmetric group of degree n.
        /// https://reference.wolfram.com/language/ref/SymmetricGroup.html
        ///</summary>
        corewolf::engine *SymmetricGroup(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SymmetricGroup[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents all the information needed for encryption, decryption, and other operations in a symmetric cryptographic system.
        /// https://reference.wolfram.com/language/ref/SymmetricKey.html
        ///</summary>
        corewolf::engine *SymmetricKey(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SymmetricKey[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if m is explicitly symmetric, and False otherwise.
        /// https://reference.wolfram.com/language/ref/SymmetricMatrixQ.html
        ///</summary>
        corewolf::engine *SymmetricMatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SymmetricMatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the k elementary symmetric polynomial in the variables x1,…,xn.
        /// https://reference.wolfram.com/language/ref/SymmetricPolynomial.html
        ///</summary>
        corewolf::engine *SymmetricPolynomial(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SymmetricPolynomial[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a pair of polynomials  in  such that , where  is the symmetric part and  is the remainder.
        /// https://reference.wolfram.com/language/ref/SymmetricReduction.html
        ///</summary>
        corewolf::engine *SymmetricReduction(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SymmetricReduction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the pair  with the elementary symmetric polynomials in  replaced by .
        /// https://reference.wolfram.com/language/ref/SymmetricReduction.html
        ///</summary>
        corewolf::engine *SymmetricReduction(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SymmetricReduction[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// returns the symmetrization of tensor under the symmetry sym.
        /// https://reference.wolfram.com/language/ref/Symmetrize.html
        ///</summary>
        corewolf::engine *Symmetrize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Symmetrize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields an array of dimensions dims whose entries are given by those in the rules posivali or through the symmetry sym.
        /// https://reference.wolfram.com/language/ref/SymmetrizedArray.html
        ///</summary>
        corewolf::engine *SymmetrizedArray(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("SymmetrizedArray[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields a symmetrized array version of list.
        /// https://reference.wolfram.com/language/ref/SymmetrizedArray.html
        ///</summary>
        corewolf::engine *SymmetrizedArray(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SymmetrizedArray[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a list of rules posivali of the symmetrized array sa.
        /// https://reference.wolfram.com/language/ref/SymmetrizedArrayRules.html
        ///</summary>
        corewolf::engine *SymmetrizedArrayRules(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SymmetrizedArrayRules[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a list of rules posivali of the array a after being symmetrized with symmetry sym.
        /// https://reference.wolfram.com/language/ref/SymmetrizedArrayRules.html
        ///</summary>
        corewolf::engine *SymmetrizedArrayRules(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SymmetrizedArrayRules[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of components that are equivalent to the component comp by the symmetry sym.
        /// https://reference.wolfram.com/language/ref/SymmetrizedDependentComponents.html
        ///</summary>
        corewolf::engine *SymmetrizedDependentComponents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SymmetrizedDependentComponents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of independent components of an array of dimensions dims with the symmetry sym.
        /// https://reference.wolfram.com/language/ref/SymmetrizedIndependentComponents.html
        ///</summary>
        corewolf::engine *SymmetrizedIndependentComponents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SymmetrizedIndependentComponents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces independent values of the symmetrized array sa as given by the rules posivali.
        /// https://reference.wolfram.com/language/ref/SymmetrizedReplacePart.html
        ///</summary>
        corewolf::engine *SymmetrizedReplacePart(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SymmetrizedReplacePart[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns the synonyms associated with the specified word.
        /// https://reference.wolfram.com/language/ref/Synonyms.html
        ///</summary>
        corewolf::engine *Synonyms(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Synonyms[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives information used to generate syntax coloring and other advisories when f[…] is entered as input.
        /// https://reference.wolfram.com/language/ref/SyntaxInformation.html
        ///</summary>
        corewolf::engine *SyntaxInformation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SyntaxInformation[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds the number of characters starting at the beginning of a string that correspond to syntactically correct input for a single Wolfram Language expression.
        /// https://reference.wolfram.com/language/ref/SyntaxLength.html
        ///</summary>
        corewolf::engine *SyntaxLength(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SyntaxLength[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a WSTP packet where integer indicates the position at which a syntax error was detected in the input line.
        /// https://reference.wolfram.com/language/ref/SyntaxPacket.html
        ///</summary>
        corewolf::engine *SyntaxPacket(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SyntaxPacket[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns True if the string corresponds to syntactically correct input for a single Wolfram Language expression, and returns False otherwise.
        /// https://reference.wolfram.com/language/ref/SyntaxQ.html
        ///</summary>
        corewolf::engine *SyntaxQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SyntaxQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses interpretation rules corresponding to the specified form.
        /// https://reference.wolfram.com/language/ref/SyntaxQ.html
        ///</summary>
        corewolf::engine *SyntaxQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SyntaxQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces missing values in each example by generated values.
        /// https://reference.wolfram.com/language/ref/SynthesizeMissingValues.html
        ///</summary>
        corewolf::engine *SynthesizeMissingValues(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SynthesizeMissingValues[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// uses the distribution dist to generate values.
        /// https://reference.wolfram.com/language/ref/SynthesizeMissingValues.html
        ///</summary>
        corewolf::engine *SynthesizeMissingValues(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SynthesizeMissingValues[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the expression stored under "keyname" in secure storage.
        /// https://reference.wolfram.com/language/ref/SystemCredential.html
        ///</summary>
        corewolf::engine *SystemCredential(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemCredential[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents data intended for secure credential storage.
        /// https://reference.wolfram.com/language/ref/SystemCredentialData.html
        ///</summary>
        corewolf::engine *SystemCredentialData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SystemCredentialData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of keys in secure storage that match patt.
        /// https://reference.wolfram.com/language/ref/SystemCredentialKeys.html
        ///</summary>
        corewolf::engine *SystemCredentialKeys(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemCredentialKeys[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a credential store.
        /// https://reference.wolfram.com/language/ref/SystemCredentialStoreObject.html
        ///</summary>
        corewolf::engine *SystemCredentialStoreObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemCredentialStoreObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// brings up an interactive system dialog and returns the value chosen in the dialog.
        /// https://reference.wolfram.com/language/ref/SystemDialogInput.html
        ///</summary>
        corewolf::engine *SystemDialogInput(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemDialogInput[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses init as the initial setting in the dialog.
        /// https://reference.wolfram.com/language/ref/SystemDialogInput.html
        ///</summary>
        corewolf::engine *SystemDialogInput(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SystemDialogInput[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives detailed information about the Wolfram System being run.
        /// https://reference.wolfram.com/language/ref/SystemInformation.html
        ///</summary>
        corewolf::engine *SystemInformation(const std::string &name = "")
        {
            return this->execute("SystemInformation[]", name);
        }

        ///< summary>
        /// gives a list of rules with information about the component "comp".
        /// https://reference.wolfram.com/language/ref/SystemInformation.html
        ///</summary>
        corewolf::engine *SystemInformation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemInformation[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of property "prop" for component "comp".
        /// https://reference.wolfram.com/language/ref/SystemInformation.html
        ///</summary>
        corewolf::engine *SystemInformation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SystemInformation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// downloads and installs the software package pack on your machine.
        /// https://reference.wolfram.com/language/ref/SystemInstall.html
        ///</summary>
        corewolf::engine *SystemInstall(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemInstall[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a representation of the model "model", usable as input to other functions.
        /// https://reference.wolfram.com/language/ref/SystemModel.html
        ///</summary>
        corewolf::engine *SystemModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// starts SystemModeler.
        /// https://reference.wolfram.com/language/ref/SystemModeler.html
        ///</summary>
        corewolf::engine *SystemModeler(const std::string &name = "")
        {
            return this->execute("SystemModeler[]", name);
        }

        ///< summary>
        /// starts SystemModeler and opens the SystemModel model.
        /// https://reference.wolfram.com/language/ref/SystemModeler.html
        ///</summary>
        corewolf::engine *SystemModeler(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemModeler[" + arg0 + "]", name);
        }

        ///< summary>
        /// starts SystemModeler and completes "action".
        /// https://reference.wolfram.com/language/ref/SystemModeler.html
        ///</summary>
        corewolf::engine *SystemModeler(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SystemModeler[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// shows an interactive browser of system modeling example models.
        /// https://reference.wolfram.com/language/ref/SystemModelExamples.html
        ///</summary>
        corewolf::engine *SystemModelExamples(const std::string &name = "")
        {
            return this->execute("SystemModelExamples[]", name);
        }

        ///< summary>
        /// lists all example models.
        /// https://reference.wolfram.com/language/ref/SystemModelExamples.html
        ///</summary>
        corewolf::engine *SystemModelExamples(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemModelExamples[" + arg0 + "]", name);
        }

        ///< summary>
        /// lists models with names matching string pattern patt.
        /// https://reference.wolfram.com/language/ref/SystemModelExamples.html
        ///</summary>
        corewolf::engine *SystemModelExamples(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SystemModelExamples[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a linearized StateSpaceModel for model at an equilibrium.
        /// https://reference.wolfram.com/language/ref/SystemModelLinearize.html
        ///</summary>
        corewolf::engine *SystemModelLinearize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemModelLinearize[" + arg0 + "]", name);
        }

        ///< summary>
        /// linearizes at the operating point op.
        /// https://reference.wolfram.com/language/ref/SystemModelLinearize.html
        ///</summary>
        corewolf::engine *SystemModelLinearize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SystemModelLinearize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// simulates model for the variable v with parameters pi.
        /// https://reference.wolfram.com/language/ref/SystemModelParametricSimulate.html
        ///</summary>
        corewolf::engine *SystemModelParametricSimulate(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SystemModelParametricSimulate[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// simulates model for multiple variables vi.
        /// https://reference.wolfram.com/language/ref/SystemModelParametricSimulate.html
        ///</summary>
        corewolf::engine *SystemModelParametricSimulate(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SystemModelParametricSimulate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// simulates from 0 to tmax.
        /// https://reference.wolfram.com/language/ref/SystemModelParametricSimulate.html
        ///</summary>
        corewolf::engine *SystemModelParametricSimulate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SystemModelParametricSimulate[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// simulates from tmin to tmax.
        /// https://reference.wolfram.com/language/ref/SystemModelParametricSimulate.html
        ///</summary>
        corewolf::engine *SystemModelParametricSimulate(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SystemModelParametricSimulate[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// shows default plots from the SystemModelSimulationData const std::string &sim.
        /// https://reference.wolfram.com/language/ref/SystemModelPlot.html
        ///</summary>
        corewolf::engine *SystemModelPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemModelPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// shows model plot with identifier or name "id".
        /// https://reference.wolfram.com/language/ref/SystemModelPlot.html
        ///</summary>
        corewolf::engine *SystemModelPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SystemModelPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a plot of the variables vi in sim.
        /// https://reference.wolfram.com/language/ref/SystemModelPlot.html
        ///</summary>
        corewolf::engine *SystemModelPlot(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SystemModelPlot[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// plots variables from several simulations.
        /// https://reference.wolfram.com/language/ref/SystemModelPlot.html
        ///</summary>
        corewolf::engine *SystemModelPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SystemModelPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// retrieves the lifetime distribution for model.
        /// https://reference.wolfram.com/language/ref/SystemModelReliability.html
        ///</summary>
        corewolf::engine *SystemModelReliability(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemModelReliability[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of components in ReliabilityDistribution or FailureDistribution.
        /// https://reference.wolfram.com/language/ref/SystemModelReliability.html
        ///</summary>
        corewolf::engine *SystemModelReliability(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SystemModelReliability[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns a list of loaded system models.
        /// https://reference.wolfram.com/language/ref/SystemModels.html
        ///</summary>
        corewolf::engine *SystemModels(const std::string &name = "")
        {
            return this->execute("SystemModels[]", name);
        }

        ///< summary>
        /// returns the models matching the string pattern patt.
        /// https://reference.wolfram.com/language/ref/SystemModels.html
        ///</summary>
        corewolf::engine *SystemModels(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemModels[" + arg0 + "]", name);
        }

        ///< summary>
        /// only returns specialized models of the kind "spec".
        /// https://reference.wolfram.com/language/ref/SystemModels.html
        ///</summary>
        corewolf::engine *SystemModels(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SystemModels[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// simulates model according to experiment settings.
        /// https://reference.wolfram.com/language/ref/SystemModelSimulate.html
        ///</summary>
        corewolf::engine *SystemModelSimulate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemModelSimulate[" + arg0 + "]", name);
        }

        ///< summary>
        /// simulates from 0 to tmax.
        /// https://reference.wolfram.com/language/ref/SystemModelSimulate.html
        ///</summary>
        corewolf::engine *SystemModelSimulate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SystemModelSimulate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// simulates from tmin to tmax.
        /// https://reference.wolfram.com/language/ref/SystemModelSimulate.html
        ///</summary>
        corewolf::engine *SystemModelSimulate(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SystemModelSimulate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// stores only simulation data for the variables vars.
        /// https://reference.wolfram.com/language/ref/SystemModelSimulate.html
        ///</summary>
        corewolf::engine *SystemModelSimulate(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SystemModelSimulate[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// simulates model and sensitivities to parameters pi following experiment settings.
        /// https://reference.wolfram.com/language/ref/SystemModelSimulateSensitivity.html
        ///</summary>
        corewolf::engine *SystemModelSimulateSensitivity(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SystemModelSimulateSensitivity[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// simulates from 0 to tmax.
        /// https://reference.wolfram.com/language/ref/SystemModelSimulateSensitivity.html
        ///</summary>
        corewolf::engine *SystemModelSimulateSensitivity(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SystemModelSimulateSensitivity[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// simulates from tmin to tmax.
        /// https://reference.wolfram.com/language/ref/SystemModelSimulateSensitivity.html
        ///</summary>
        corewolf::engine *SystemModelSimulateSensitivity(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SystemModelSimulateSensitivity[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// stores only simulation data for the variables vars.
        /// https://reference.wolfram.com/language/ref/SystemModelSimulateSensitivity.html
        ///</summary>
        corewolf::engine *SystemModelSimulateSensitivity(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("SystemModelSimulateSensitivity[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// represents simulation data from functions such as SystemModelSimulate etc.
        /// https://reference.wolfram.com/language/ref/SystemModelSimulationData.html
        ///</summary>
        corewolf::engine *SystemModelSimulationData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemModelSimulationData[" + arg0 + "]", name);
        }

        ///< summary>
        /// opens the specified file, URL, or other target with the associated program on your computer system.
        /// https://reference.wolfram.com/language/ref/SystemOpen.html
        ///</summary>
        corewolf::engine *SystemOpen(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemOpen[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the current setting for the internal system option with the specified name.
        /// https://reference.wolfram.com/language/ref/SystemOptions.html
        ///</summary>
        corewolf::engine *SystemOptions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemOptions[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the current settings for all settable internal system options.
        /// https://reference.wolfram.com/language/ref/SystemOptions.html
        ///</summary>
        corewolf::engine *SystemOptions(const std::string &name = "")
        {
            return this->execute("SystemOptions[]", name);
        }

        ///< summary>
        /// gives a dataset of information about processes that you are running on your computer system.
        /// https://reference.wolfram.com/language/ref/SystemProcessData.html
        ///</summary>
        corewolf::engine *SystemProcessData(const std::string &name = "")
        {
            return this->execute("SystemProcessData[]", name);
        }

        ///< summary>
        /// gives information about all processes running on your computer system.
        /// https://reference.wolfram.com/language/ref/SystemProcessData.html
        ///</summary>
        corewolf::engine *SystemProcessData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemProcessData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives information about processes for which property propi has value vali.
        /// https://reference.wolfram.com/language/ref/SystemProcessData.html
        ///</summary>
        corewolf::engine *SystemProcessData(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SystemProcessData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of processes that you are running on your computer system.
        /// https://reference.wolfram.com/language/ref/SystemProcesses.html
        ///</summary>
        corewolf::engine *SystemProcesses(const std::string &name = "")
        {
            return this->execute("SystemProcesses[]", name);
        }

        ///< summary>
        /// gives a list of all processes that are running on your computer system.
        /// https://reference.wolfram.com/language/ref/SystemProcesses.html
        ///</summary>
        corewolf::engine *SystemProcesses(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemProcesses[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of all processes for which property propi has value vali.
        /// https://reference.wolfram.com/language/ref/SystemProcesses.html
        ///</summary>
        corewolf::engine *SystemProcesses(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SystemProcesses[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a model with inputs ins and outputs outs obtained by connecting the systems models sysi using connections conxs.
        /// https://reference.wolfram.com/language/ref/SystemsConnectionsModel.html
        ///</summary>
        corewolf::engine *SystemsConnectionsModel(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("SystemsConnectionsModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents controller data generated by functions LQGRegulator, PIDTune, etc.
        /// https://reference.wolfram.com/language/ref/SystemsModelControllerData.html
        ///</summary>
        corewolf::engine *SystemsModelControllerData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemsModelControllerData[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a time delay of δ in a StateSpaceModel or TransferFunctionModel.
        /// https://reference.wolfram.com/language/ref/SystemsModelDelay.html
        ///</summary>
        corewolf::engine *SystemsModelDelay(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemsModelDelay[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a delay-free system by using approximations of order ord of the time delays in system sys.
        /// https://reference.wolfram.com/language/ref/SystemsModelDelayApproximate.html
        ///</summary>
        corewolf::engine *SystemsModelDelayApproximate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SystemsModelDelayApproximate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// deletes the subsystem of the systems model sys associated with inputs at position ini.
        /// https://reference.wolfram.com/language/ref/SystemsModelDelete.html
        ///</summary>
        corewolf::engine *SystemsModelDelete(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SystemsModelDelete[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// also deletes the subsystem associated with outputs at positions outi.
        /// https://reference.wolfram.com/language/ref/SystemsModelDelete.html
        ///</summary>
        corewolf::engine *SystemsModelDelete(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SystemsModelDelete[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// deletes the subsystem of the state-space model sys associated with inputs, outputs, and states at ini, outi, and si, respectively.
        /// https://reference.wolfram.com/language/ref/SystemsModelDelete.html
        ///</summary>
        corewolf::engine *SystemsModelDelete(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("SystemsModelDelete[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// gives the number of inputs and outputs of the systems model sys.
        /// https://reference.wolfram.com/language/ref/SystemsModelDimensions.html
        ///</summary>
        corewolf::engine *SystemsModelDimensions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemsModelDimensions[" + arg0 + "]", name);
        }

        ///< summary>
        /// extracts the subsystem of the systems model sys associated with inputs at position ini.
        /// https://reference.wolfram.com/language/ref/SystemsModelExtract.html
        ///</summary>
        corewolf::engine *SystemsModelExtract(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SystemsModelExtract[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// extracts the subsystem associated with inputs and outputs at positions ini and outi, respectively.
        /// https://reference.wolfram.com/language/ref/SystemsModelExtract.html
        ///</summary>
        corewolf::engine *SystemsModelExtract(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SystemsModelExtract[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// extracts the subsystem of the state-space model sys associated with inputs, outputs, and states at ini, outi, and si, respectively.
        /// https://reference.wolfram.com/language/ref/SystemsModelExtract.html
        ///</summary>
        corewolf::engine *SystemsModelExtract(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("SystemsModelExtract[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// connects the outputs from sys to the inputs with negative feedback.
        /// https://reference.wolfram.com/language/ref/SystemsModelFeedbackConnect.html
        ///</summary>
        corewolf::engine *SystemsModelFeedbackConnect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemsModelFeedbackConnect[" + arg0 + "]", name);
        }

        ///< summary>
        /// only feedback connect the outputs and inputs in coni.
        /// https://reference.wolfram.com/language/ref/SystemsModelFeedbackConnect.html
        ///</summary>
        corewolf::engine *SystemsModelFeedbackConnect(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("SystemsModelFeedbackConnect[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// connects the outputs of sys1 to sys2 and the outputs of sys2 to the inputs of sys1 in feedback.
        /// https://reference.wolfram.com/language/ref/SystemsModelFeedbackConnect.html
        ///</summary>
        corewolf::engine *SystemsModelFeedbackConnect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SystemsModelFeedbackConnect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// connects output outi of sys1 to the i input of sys2 and the j output of sys2 to input inj of sys1 with feedback type ftypej.
        /// https://reference.wolfram.com/language/ref/SystemsModelFeedbackConnect.html
        ///</summary>
        corewolf::engine *SystemsModelFeedbackConnect(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("SystemsModelFeedbackConnect[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// gives the linearity of the systems model sys.
        /// https://reference.wolfram.com/language/ref/SystemsModelLinearity.html
        ///</summary>
        corewolf::engine *SystemsModelLinearity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemsModelLinearity[" + arg0 + "]", name);
        }

        ///< summary>
        /// only considers the subsystem associated with inputs ini, outputs outj, and states sk.
        /// https://reference.wolfram.com/language/ref/SystemsModelLinearity.html
        ///</summary>
        corewolf::engine *SystemsModelLinearity(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("SystemsModelLinearity[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// merges the systems models sysj.
        /// https://reference.wolfram.com/language/ref/SystemsModelMerge.html
        ///</summary>
        corewolf::engine *SystemsModelMerge(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("SystemsModelMerge[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the order of the state-space model sys.
        /// https://reference.wolfram.com/language/ref/SystemsModelOrder.html
        ///</summary>
        corewolf::engine *SystemsModelOrder(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemsModelOrder[" + arg0 + "]", name);
        }

        ///< summary>
        /// connects the systems models sys1 and sys2 in parallel.
        /// https://reference.wolfram.com/language/ref/SystemsModelParallelConnect.html
        ///</summary>
        corewolf::engine *SystemsModelParallelConnect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SystemsModelParallelConnect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// connects the inputs in1i to inputs in2i and sums the outputs out1k and outputs out2k.
        /// https://reference.wolfram.com/language/ref/SystemsModelParallelConnect.html
        ///</summary>
        corewolf::engine *SystemsModelParallelConnect(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("SystemsModelParallelConnect[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// connects systems models sys1 and sys2 in series.
        /// https://reference.wolfram.com/language/ref/SystemsModelSeriesConnect.html
        ///</summary>
        corewolf::engine *SystemsModelSeriesConnect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SystemsModelSeriesConnect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// connects outputs out1i of sys1 to inputs in2i of sys2.
        /// https://reference.wolfram.com/language/ref/SystemsModelSeriesConnect.html
        ///</summary>
        corewolf::engine *SystemsModelSeriesConnect(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("SystemsModelSeriesConnect[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// connects the states of the systems model sys to the controller con and the outputs of con to the inputs of sys in feedback.
        /// https://reference.wolfram.com/language/ref/SystemsModelStateFeedbackConnect.html
        ///</summary>
        corewolf::engine *SystemsModelStateFeedbackConnect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("SystemsModelStateFeedbackConnect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// connects state si of sys to the i input of con and the j output of con to input inj of sys with feedback type ftypej
        /// https://reference.wolfram.com/language/ref/SystemsModelStateFeedbackConnect.html
        ///</summary>
        corewolf::engine *SystemsModelStateFeedbackConnect(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("SystemsModelStateFeedbackConnect[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// gives the vector-relative orders of the systems model sys.
        /// https://reference.wolfram.com/language/ref/SystemsModelVectorRelativeOrders.html
        ///</summary>
        corewolf::engine *SystemsModelVectorRelativeOrders(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("SystemsModelVectorRelativeOrders[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a list of n copies of expr.
        /// https://reference.wolfram.com/language/ref/Table.html
        ///</summary>
        corewolf::engine *Table(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Table[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a list of the values of expr when i runs from 1 to imax.
        /// https://reference.wolfram.com/language/ref/Table.html
        ///</summary>
        corewolf::engine *Table(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Table[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses the successive values i1, i2, ….
        /// https://reference.wolfram.com/language/ref/Table.html
        ///</summary>
        corewolf::engine *Table(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Table[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives a nested list. The list associated with i is outermost. »
        /// https://reference.wolfram.com/language/ref/Table.html
        ///</summary>
        corewolf::engine *Table(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Table[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// prints with the elements of list arranged in an array of rectangular cells.
        /// https://reference.wolfram.com/language/ref/TableForm.html
        ///</summary>
        corewolf::engine *TableForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TableForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as a spreadsheet-like table view for editing and viewing exprij.
        /// https://reference.wolfram.com/language/ref/TableView.html
        ///</summary>
        corewolf::engine *TableView(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TableView[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// takes the contents of the table view to be the dynamically updated current value of x, with the value of x being reset as the table view is interactively edited.
        /// https://reference.wolfram.com/language/ref/TableView.html
        ///</summary>
        corewolf::engine *TableView(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TableView[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the specified type by default to represent newly edited or created entries in the table view.
        /// https://reference.wolfram.com/language/ref/TableView.html
        ///</summary>
        corewolf::engine *TableView(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TableView[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays an empty table view.
        /// https://reference.wolfram.com/language/ref/TableView.html
        ///</summary>
        corewolf::engine *TableView(const std::string &name = "")
        {
            return this->execute("TableView[]", name);
        }

        ///< summary>
        /// represents an const std::string &in which clicking the tab with label lbli displays expri.
        /// https://reference.wolfram.com/language/ref/TabView.html
        ///</summary>
        corewolf::engine *TabView(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TabView[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes the i tab be the one currently selected.
        /// https://reference.wolfram.com/language/ref/TabView.html
        ///</summary>
        corewolf::engine *TabView(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TabView[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// associates values vi with successive tabs, and makes the tab with value v be the one currently selected.
        /// https://reference.wolfram.com/language/ref/TabView.html
        ///</summary>
        corewolf::engine *TabView(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TabView[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a low-level box construct that displays as boxes but maintains tag to guide the interpretation of boxes on input.
        /// https://reference.wolfram.com/language/ref/TagBox.html
        ///</summary>
        corewolf::engine *TagBox(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TagBox[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the first n elements of list.
        /// https://reference.wolfram.com/language/ref/Take.html
        ///</summary>
        corewolf::engine *Take(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Take[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives elements m through n of list.
        /// https://reference.wolfram.com/language/ref/Take.html
        ///</summary>
        corewolf::engine *Take(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Take[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a nested list in which elements specified by seqi are taken at level i in list.
        /// https://reference.wolfram.com/language/ref/Take.html
        ///</summary>
        corewolf::engine *Take(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Take[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the pair {list1,list2}, where list1 contains the first n elements of list and list2 contains the rest.
        /// https://reference.wolfram.com/language/ref/TakeDrop.html
        ///</summary>
        corewolf::engine *TakeDrop(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TakeDrop[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the n numerically largest elements in list, sorted in descending order.
        /// https://reference.wolfram.com/language/ref/TakeLargest.html
        ///</summary>
        corewolf::engine *TakeLargest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TakeLargest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of TakeLargest that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/TakeLargest.html
        ///</summary>
        corewolf::engine *TakeLargest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TakeLargest[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the n elements ei in list for which f[ei] is largest, sorted in descending order.
        /// https://reference.wolfram.com/language/ref/TakeLargestBy.html
        ///</summary>
        corewolf::engine *TakeLargestBy(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TakeLargestBy[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of TakeLargestBy that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/TakeLargestBy.html
        ///</summary>
        corewolf::engine *TakeLargestBy(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TakeLargestBy[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of results obtained by successively taking ni elements from list.
        /// https://reference.wolfram.com/language/ref/TakeList.html
        ///</summary>
        corewolf::engine *TakeList(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TakeList[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a nested list in which elements specified by the lists seqsi are taken at level i in list.
        /// https://reference.wolfram.com/language/ref/TakeList.html
        ///</summary>
        corewolf::engine *TakeList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("TakeList[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the n numerically smallest elements in list, sorted in ascending order.
        /// https://reference.wolfram.com/language/ref/TakeSmallest.html
        ///</summary>
        corewolf::engine *TakeSmallest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TakeSmallest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of TakeSmallest that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/TakeSmallest.html
        ///</summary>
        corewolf::engine *TakeSmallest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TakeSmallest[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the n elements ei in list for which f[ei] is smallest, sorted in ascending order.
        /// https://reference.wolfram.com/language/ref/TakeSmallestBy.html
        ///</summary>
        corewolf::engine *TakeSmallestBy(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TakeSmallestBy[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of TakeSmallestBy that can be applied to an expression.
        /// https://reference.wolfram.com/language/ref/TakeSmallestBy.html
        ///</summary>
        corewolf::engine *TakeSmallestBy(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TakeSmallestBy[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives elements ei from the beginning of list, continuing so long as crit[ei] is True.
        /// https://reference.wolfram.com/language/ref/TakeWhile.html
        ///</summary>
        corewolf::engine *TakeWhile(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TakeWhile[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tallies the elements in list, listing all distinct elements together with their multiplicities.
        /// https://reference.wolfram.com/language/ref/Tally.html
        ///</summary>
        corewolf::engine *Tally(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Tally[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses test to determine whether pairs of elements should be considered equivalent, and gives a list of the first representatives of each equivalence class, together with their multiplicities.
        /// https://reference.wolfram.com/language/ref/Tally.html
        ///</summary>
        corewolf::engine *Tally(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Tally[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the tangent of .
        /// https://reference.wolfram.com/language/ref/Tan.html
        ///</summary>
        corewolf::engine *Tan(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Tan[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the hyperbolic tangent of .
        /// https://reference.wolfram.com/language/ref/Tanh.html
        ///</summary>
        corewolf::engine *Tanh(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Tanh[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates an interrupt to abort the current execution of a task.
        /// https://reference.wolfram.com/language/ref/TaskAbort.html
        ///</summary>
        corewolf::engine *TaskAbort(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TaskAbort[" + arg0 + "]", name);
        }

        ///< summary>
        /// immediately executes an instance of the specified task, independently of any schedule given.
        /// https://reference.wolfram.com/language/ref/TaskExecute.html
        ///</summary>
        corewolf::engine *TaskExecute(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TaskExecute[" + arg0 + "]", name);
        }

        ///< summary>
        /// is an const std::string &that represents a background task.
        /// https://reference.wolfram.com/language/ref/TaskObject.html
        ///</summary>
        corewolf::engine *TaskObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TaskObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// terminates and removes the specified task.
        /// https://reference.wolfram.com/language/ref/TaskRemove.html
        ///</summary>
        corewolf::engine *TaskRemove(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TaskRemove[" + arg0 + "]", name);
        }

        ///< summary>
        /// resumes execution of the specified task.
        /// https://reference.wolfram.com/language/ref/TaskResume.html
        ///</summary>
        corewolf::engine *TaskResume(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TaskResume[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of TaskObject expressions representing currently submitted tasks of given type.
        /// https://reference.wolfram.com/language/ref/Tasks.html
        ///</summary>
        corewolf::engine *Tasks(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Tasks[" + arg0 + "]", name);
        }

        ///< summary>
        /// suspends the execution of the specified task.
        /// https://reference.wolfram.com/language/ref/TaskSuspend.html
        ///</summary>
        corewolf::engine *TaskSuspend(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TaskSuspend[" + arg0 + "]", name);
        }

        ///< summary>
        /// waits for the specified task to be completely finished.
        /// https://reference.wolfram.com/language/ref/TaskWait.html
        ///</summary>
        corewolf::engine *TaskWait(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TaskWait[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if all combinations of values of variables make the Boolean function bf yield True.
        /// https://reference.wolfram.com/language/ref/TautologyQ.html
        ///</summary>
        corewolf::engine *TautologyQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TautologyQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if all combinations of values of the ai make the Boolean expression expr yield True.
        /// https://reference.wolfram.com/language/ref/TautologyQ.html
        ///</summary>
        corewolf::engine *TautologyQ(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TautologyQ[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a telegraph process with rate μ.
        /// https://reference.wolfram.com/language/ref/TelegraphProcess.html
        ///</summary>
        corewolf::engine *TelegraphProcess(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TelegraphProcess[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies a template, evaluating all template elements it contains.
        /// https://reference.wolfram.com/language/ref/TemplateApply.html
        ///</summary>
        corewolf::engine *TemplateApply(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TemplateApply[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies a template, using args to fill slots in the template.
        /// https://reference.wolfram.com/language/ref/TemplateApply.html
        ///</summary>
        corewolf::engine *TemplateApply(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TemplateApply[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a low-level box structure that parameterizes the display and evaluation of the boxes boxi.
        /// https://reference.wolfram.com/language/ref/TemplateBox.html
        ///</summary>
        corewolf::engine *TemplateBox(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TemplateBox[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// allows the use of arbitrary expressions that may or may not be boxes.
        /// https://reference.wolfram.com/language/ref/TemplateBox.html
        ///</summary>
        corewolf::engine *TemplateBox(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("TemplateBox[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an expression held until a template is applied, and then evaluated.
        /// https://reference.wolfram.com/language/ref/TemplateExpression.html
        ///</summary>
        corewolf::engine *TemplateExpression(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TemplateExpression[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an element of a template const std::string &that inserts tclause if the condition evaluates to True.
        /// https://reference.wolfram.com/language/ref/TemplateIf.html
        ///</summary>
        corewolf::engine *TemplateIf(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TemplateIf[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// inserts fclause if the condition does not evaluate to True.
        /// https://reference.wolfram.com/language/ref/TemplateIf.html
        ///</summary>
        corewolf::engine *TemplateIf(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TemplateIf[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a template const std::string &to be applied using functions like TemplateApply.
        /// https://reference.wolfram.com/language/ref/TemplateObject.html
        ///</summary>
        corewolf::engine *TemplateObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TemplateObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields a TemplateObject with arguments, suitable for cloud deployment or other evaluation.
        /// https://reference.wolfram.com/language/ref/TemplateObject.html
        ///</summary>
        corewolf::engine *TemplateObject(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TemplateObject[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an element of a template const std::string &that yields a sequence consisting of body applied to each element in list.
        /// https://reference.wolfram.com/language/ref/TemplateSequence.html
        ///</summary>
        corewolf::engine *TemplateSequence(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TemplateSequence[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a template slot to be filled from the n argument when the template is applied.
        /// https://reference.wolfram.com/language/ref/TemplateSlot.html
        ///</summary>
        corewolf::engine *TemplateSlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TemplateSlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an element of a template const std::string &that evaluates expr after replacing TemplateSlot["name"] with value.
        /// https://reference.wolfram.com/language/ref/TemplateWith.html
        ///</summary>
        corewolf::engine *TemplateWith(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TemplateWith[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates expr with a list of key-value pairs.
        /// https://reference.wolfram.com/language/ref/TemplateWith.html
        ///</summary>
        corewolf::engine *TemplateWith(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TemplateWith[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents temporal data with values vi at times specified by tspec.
        /// https://reference.wolfram.com/language/ref/TemporalData.html
        ///</summary>
        corewolf::engine *TemporalData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TemporalData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a temporal data collection with values vij at times specified by tspec.
        /// https://reference.wolfram.com/language/ref/TemporalData.html
        ///</summary>
        corewolf::engine *TemporalData(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TemporalData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents temporal data specified by time-value pairs {ti,vi}.
        /// https://reference.wolfram.com/language/ref/TemporalData.html
        ///</summary>
        corewolf::engine *TemporalData(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TemporalData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a temporal data collection given as lists of time-value pairs {tij,vij}.
        /// https://reference.wolfram.com/language/ref/TemporalData.html
        ///</summary>
        corewolf::engine *TemporalData(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("TemporalData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// yields the contraction of tensor in the pairs {si1,si2} of slots.
        /// https://reference.wolfram.com/language/ref/TensorContract.html
        ///</summary>
        corewolf::engine *TensorContract(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("TensorContract[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the list of dimensions of tensor.
        /// https://reference.wolfram.com/language/ref/TensorDimensions.html
        ///</summary>
        corewolf::engine *TensorDimensions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TensorDimensions[" + arg0 + "]", name);
        }

        ///< summary>
        /// expands out tensor-related products in the symbolic tensor expression texpr.
        /// https://reference.wolfram.com/language/ref/TensorExpand.html
        ///</summary>
        corewolf::engine *TensorExpand(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TensorExpand[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the tensor product of the tensori.
        /// https://reference.wolfram.com/language/ref/TensorProduct.html
        ///</summary>
        corewolf::engine *TensorProduct(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TensorProduct[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the rank of tensor.
        /// https://reference.wolfram.com/language/ref/TensorRank.html
        ///</summary>
        corewolf::engine *TensorRank(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TensorRank[" + arg0 + "]", name);
        }

        ///< summary>
        /// attempts to return a canonical form for the symbolic tensor expression texpr.
        /// https://reference.wolfram.com/language/ref/TensorReduce.html
        ///</summary>
        corewolf::engine *TensorReduce(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TensorReduce[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the symmetry of tensor under permutations of its slots.
        /// https://reference.wolfram.com/language/ref/TensorSymmetry.html
        ///</summary>
        corewolf::engine *TensorSymmetry(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TensorSymmetry[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the symmetry under permutation of the specified list of slots.
        /// https://reference.wolfram.com/language/ref/TensorSymmetry.html
        ///</summary>
        corewolf::engine *TensorSymmetry(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TensorSymmetry[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the tensor obtained by transposing the slots of tensor as given by the permutation perm.
        /// https://reference.wolfram.com/language/ref/TensorTranspose.html
        ///</summary>
        corewolf::engine *TensorTranspose(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TensorTranspose[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the antisymmetrized tensor product of the tensori.
        /// https://reference.wolfram.com/language/ref/TensorWedge.html
        ///</summary>
        corewolf::engine *TensorWedge(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TensorWedge[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// plots a list of points with specified u, v and w coordinates in a barycentric coordinate system.
        /// https://reference.wolfram.com/language/ref/TernaryListPlot.html
        ///</summary>
        corewolf::engine *TernaryListPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("TernaryListPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// plots a ternary plot with several datasets datai.
        /// https://reference.wolfram.com/language/ref/TernaryListPlot.html
        ///</summary>
        corewolf::engine *TernaryListPlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TernaryListPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// runs tests from a file, returning an analysis of the completed test run.
        /// https://reference.wolfram.com/language/ref/TestReport.html
        ///</summary>
        corewolf::engine *TestReport(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TestReport[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a report of the results of the tests testi.
        /// https://reference.wolfram.com/language/ref/TestReport.html
        ///</summary>
        corewolf::engine *TestReport(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TestReport[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives an const std::string &that represents the results of a VerificationTest.
        /// https://reference.wolfram.com/language/ref/TestResultObject.html
        ///</summary>
        corewolf::engine *TestResultObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TestResultObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a regular tetrahedron centered at the origin with unit edge length.
        /// https://reference.wolfram.com/language/ref/Tetrahedron.html
        ///</summary>
        corewolf::engine *Tetrahedron(const std::string &name = "")
        {
            return this->execute("Tetrahedron[]", name);
        }

        ///< summary>
        /// represents a tetrahedron with edge length l.
        /// https://reference.wolfram.com/language/ref/Tetrahedron.html
        ///</summary>
        corewolf::engine *Tetrahedron(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Tetrahedron[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a tetrahedron rotated by an angle θ with respect to the z axis and angle ϕ with respect to the y axis.
        /// https://reference.wolfram.com/language/ref/Tetrahedron.html
        ///</summary>
        corewolf::engine *Tetrahedron(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Tetrahedron[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a general filled tetrahedron with corners p1, p2, p3 and p4.
        /// https://reference.wolfram.com/language/ref/Tetrahedron.html
        ///</summary>
        corewolf::engine *Tetrahedron(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Tetrahedron[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a collection of tetrahedra.
        /// https://reference.wolfram.com/language/ref/Tetrahedron.html
        ///</summary>
        corewolf::engine *Tetrahedron(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Tetrahedron[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// prints as a  version of expr.
        /// https://reference.wolfram.com/language/ref/TeXForm.html
        ///</summary>
        corewolf::engine *TeXForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TeXForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays with expr in plain text format.
        /// https://reference.wolfram.com/language/ref/Text.html
        ///</summary>
        corewolf::engine *Text(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Text[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a graphics primitive that displays the textual form of expr centered at the point specified by coords.
        /// https://reference.wolfram.com/language/ref/Text.html
        ///</summary>
        corewolf::engine *Text(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Text[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of all cases of text identified as being of type form that appear in text.
        /// https://reference.wolfram.com/language/ref/TextCases.html
        ///</summary>
        corewolf::engine *TextCases(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TextCases[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an association of results for all the types formi.
        /// https://reference.wolfram.com/language/ref/TextCases.html
        ///</summary>
        corewolf::engine *TextCases(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TextCases[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the first n cases found.
        /// https://reference.wolfram.com/language/ref/TextCases.html
        ///</summary>
        corewolf::engine *TextCases(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TextCases[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a text cell that can appear in a Wolfram System notebook.
        /// https://reference.wolfram.com/language/ref/TextCell.html
        ///</summary>
        corewolf::engine *TextCell(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TextCell[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a text cell with the specified style.
        /// https://reference.wolfram.com/language/ref/TextCell.html
        ///</summary>
        corewolf::engine *TextCell(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TextCell[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a text cell with multiple styles applied to it.
        /// https://reference.wolfram.com/language/ref/TextCell.html
        ///</summary>
        corewolf::engine *TextCell(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("TextCell[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives a dataset of information about entities, dates, quantities and other content-related elements found in text.
        /// https://reference.wolfram.com/language/ref/TextContents.html
        ///</summary>
        corewolf::engine *TextContents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TextContents[" + arg0 + "]", name);
        }

        ///< summary>
        /// searches for cases of the type form.
        /// https://reference.wolfram.com/language/ref/TextContents.html
        ///</summary>
        corewolf::engine *TextContents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TextContents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// searches for cases of types form1, form2, …
        /// https://reference.wolfram.com/language/ref/TextContents.html
        ///</summary>
        corewolf::engine *TextContents(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TextContents[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// includes the property props for each const std::string &in the dataset produced.
        /// https://reference.wolfram.com/language/ref/TextContents.html
        ///</summary>
        corewolf::engine *TextContents(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TextContents[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a low-level representation of the contents of a textual cell.
        /// https://reference.wolfram.com/language/ref/TextData.html
        ///</summary>
        corewolf::engine *TextData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TextData[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an element of text with the specified properties.
        /// https://reference.wolfram.com/language/ref/TextElement.html
        ///</summary>
        corewolf::engine *TextElement(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TextElement[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents text formed from a sequence of elements.
        /// https://reference.wolfram.com/language/ref/TextElement.html
        ///</summary>
        corewolf::engine *TextElement(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TextElement[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents text where no properties are specified.
        /// https://reference.wolfram.com/language/ref/TextElement.html
        ///</summary>
        corewolf::engine *TextElement(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TextElement[" + arg0 + "]", name);
        }

        ///< summary>
        /// is an const std::string &that formats exprij textually and arranged in a two-dimensional grid.
        /// https://reference.wolfram.com/language/ref/TextGrid.html
        ///</summary>
        corewolf::engine *TextGrid(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TextGrid[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// is a WSTP packet containing string, the text output from the Wolfram System as produced by functions such as Print.
        /// https://reference.wolfram.com/language/ref/TextPacket.html
        ///</summary>
        corewolf::engine *TextPacket(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TextPacket[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of the starting and ending positions at which instances of form occur in text.
        /// https://reference.wolfram.com/language/ref/TextPosition.html
        ///</summary>
        corewolf::engine *TextPosition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TextPosition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an association of results for all the types formi.
        /// https://reference.wolfram.com/language/ref/TextPosition.html
        ///</summary>
        corewolf::engine *TextPosition(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TextPosition[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the positions of the first n cases found.
        /// https://reference.wolfram.com/language/ref/TextPosition.html
        ///</summary>
        corewolf::engine *TextPosition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TextPosition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// recognizes text in image and returns it as a string.
        /// https://reference.wolfram.com/language/ref/TextRecognize.html
        ///</summary>
        corewolf::engine *TextRecognize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TextRecognize[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a list of strings at the specified structural level.
        /// https://reference.wolfram.com/language/ref/TextRecognize.html
        ///</summary>
        corewolf::engine *TextRecognize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TextRecognize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns prop for text at the given level.
        /// https://reference.wolfram.com/language/ref/TextRecognize.html
        ///</summary>
        corewolf::engine *TextRecognize(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TextRecognize[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// searches for files referenced by source that contain text matching form.
        /// https://reference.wolfram.com/language/ref/TextSearch.html
        ///</summary>
        corewolf::engine *TextSearch(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TextSearch[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the property prop for each result.
        /// https://reference.wolfram.com/language/ref/TextSearch.html
        ///</summary>
        corewolf::engine *TextSearch(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TextSearch[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a structured report of files referenced by source that contain text matching form.
        /// https://reference.wolfram.com/language/ref/TextSearchReport.html
        ///</summary>
        corewolf::engine *TextSearchReport(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TextSearchReport[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the runs of characters identified as sentences in string.
        /// https://reference.wolfram.com/language/ref/TextSentences.html
        ///</summary>
        corewolf::engine *TextSentences(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TextSentences[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the first n sentences in string.
        /// https://reference.wolfram.com/language/ref/TextSentences.html
        ///</summary>
        corewolf::engine *TextSentences(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TextSentences[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a human-readable string representation of expr.
        /// https://reference.wolfram.com/language/ref/TextString.html
        ///</summary>
        corewolf::engine *TextString(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TextString[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a nested collection of TextElement objects representing the grammatical structure of natural language text.
        /// https://reference.wolfram.com/language/ref/TextStructure.html
        ///</summary>
        corewolf::engine *TextStructure(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TextStructure[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a representation of the type specified by form of the grammatical structure of text.
        /// https://reference.wolfram.com/language/ref/TextStructure.html
        ///</summary>
        corewolf::engine *TextStructure(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TextStructure[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// translates text into the current default language.
        /// https://reference.wolfram.com/language/ref/TextTranslation.html
        ///</summary>
        corewolf::engine *TextTranslation(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TextTranslation[" + arg0 + "]", name);
        }

        ///< summary>
        /// translates text into the language specified by lang.
        /// https://reference.wolfram.com/language/ref/TextTranslation.html
        ///</summary>
        corewolf::engine *TextTranslation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TextTranslation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a graphics directive that specifies that obj should be used as a texture on faces of polygons and other filled graphics objects.
        /// https://reference.wolfram.com/language/ref/Texture.html
        ///</summary>
        corewolf::engine *Texture(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Texture[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of the runs of characters identified as words in string.
        /// https://reference.wolfram.com/language/ref/TextWords.html
        ///</summary>
        corewolf::engine *TextWords(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TextWords[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the first n words in string.
        /// https://reference.wolfram.com/language/ref/TextWords.html
        ///</summary>
        corewolf::engine *TextWords(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TextWords[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Therefore.html
        ///</summary>
        corewolf::engine *Therefore(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Therefore[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specific property for the substance "name".
        /// https://reference.wolfram.com/language/ref/ThermodynamicData.html
        ///</summary>
        corewolf::engine *ThermodynamicData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ThermodynamicData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specific property for the substance "name" at the specified parameters.
        /// https://reference.wolfram.com/language/ref/ThermodynamicData.html
        ///</summary>
        corewolf::engine *ThermodynamicData(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ThermodynamicData[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// draws a thermometer showing value in a range of 0 to 1.
        /// https://reference.wolfram.com/language/ref/ThermometerGauge.html
        ///</summary>
        corewolf::engine *ThermometerGauge(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ThermometerGauge[" + arg0 + "]", name);
        }

        ///< summary>
        /// draws a thermometer showing value in a range of min to max.
        /// https://reference.wolfram.com/language/ref/ThermometerGauge.html
        ///</summary>
        corewolf::engine *ThermometerGauge(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ThermometerGauge[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// allows value to be set interactively using the thermometer.
        /// https://reference.wolfram.com/language/ref/ThermometerGauge.html
        ///</summary>
        corewolf::engine *ThermometerGauge(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ThermometerGauge[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a graphics directive which specifies that lines which follow are to be drawn with thickness r. The thickness r is given as a fraction of the horizontal plot range.
        /// https://reference.wolfram.com/language/ref/Thickness.html
        ///</summary>
        corewolf::engine *Thickness(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Thickness[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds the skeletons of foreground regions in image by applying morphological thinning until convergence.
        /// https://reference.wolfram.com/language/ref/Thinning.html
        ///</summary>
        corewolf::engine *Thinning(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Thinning[" + arg0 + "]", name);
        }

        ///< summary>
        /// performs n iterations of morphological thinning.
        /// https://reference.wolfram.com/language/ref/Thinning.html
        ///</summary>
        corewolf::engine *Thinning(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Thinning[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// treats values above t as foreground.
        /// https://reference.wolfram.com/language/ref/Thinning.html
        ///</summary>
        corewolf::engine *Thinning(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Thinning[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Thomas cluster point process with density μ, cluster mean λ and scale parameter σ in .
        /// https://reference.wolfram.com/language/ref/ThomasPointProcess.html
        ///</summary>
        corewolf::engine *ThomasPointProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ThomasPointProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents the sporadic simple Thompson group .
        /// https://reference.wolfram.com/language/ref/ThompsonGroupTh.html
        ///</summary>
        corewolf::engine *ThompsonGroupTh(const std::string &name = "")
        {
            return this->execute("ThompsonGroupTh[]", name);
        }

        ///< summary>
        /// "threads" f over any lists that appear in args.
        /// https://reference.wolfram.com/language/ref/Thread.html
        ///</summary>
        corewolf::engine *Thread(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Thread[" + arg0 + "]", name);
        }

        ///< summary>
        /// threads f over any objects with head h that appear in args.
        /// https://reference.wolfram.com/language/ref/Thread.html
        ///</summary>
        corewolf::engine *Thread(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Thread[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// threads f over objects with head h that appear in the first n args.
        /// https://reference.wolfram.com/language/ref/Thread.html
        ///</summary>
        corewolf::engine *Thread(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Thread[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is an const std::string &whose elements will automatically be threaded into the lowest level of an array when used in a listable operation such as Plus.
        /// https://reference.wolfram.com/language/ref/Threaded.html
        ///</summary>
        corewolf::engine *Threaded(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Threaded[" + arg0 + "]", name);
        }

        ///< summary>
        /// adds elements at level alev of a.
        /// https://reference.wolfram.com/language/ref/Threaded.html
        ///</summary>
        corewolf::engine *Threaded(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Threaded[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a net layer that takes several input arrays and applies a function f to corresponding array elements.
        /// https://reference.wolfram.com/language/ref/ThreadingLayer.html
        ///</summary>
        corewolf::engine *ThreadingLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ThreadingLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// allows array shapes to be conformed according to broadcasting specification bspec.
        /// https://reference.wolfram.com/language/ref/ThreadingLayer.html
        ///</summary>
        corewolf::engine *ThreadingLayer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ThreadingLayer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the values of the Wigner 3‐ symbol.
        /// https://reference.wolfram.com/language/ref/ThreeJSymbol.html
        ///</summary>
        corewolf::engine *ThreeJSymbol(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ThreeJSymbol[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// thresholds data by replacing values close to zero by zero.
        /// https://reference.wolfram.com/language/ref/Threshold.html
        ///</summary>
        corewolf::engine *Threshold(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Threshold[" + arg0 + "]", name);
        }

        ///< summary>
        /// thresholds data using threshold specification tspec.
        /// https://reference.wolfram.com/language/ref/Threshold.html
        ///</summary>
        corewolf::engine *Threshold(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Threshold[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives p[f1[x],f2[x]].
        /// https://reference.wolfram.com/language/ref/Through.html
        ///</summary>
        corewolf::engine *Through(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Through[" + arg0 + "]", name);
        }

        ///< summary>
        /// performs the transformation wherever h occurs in the head of expr.
        /// https://reference.wolfram.com/language/ref/Through.html
        ///</summary>
        corewolf::engine *Through(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Through[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// stops evaluation and returns value as the value of the nearest enclosing Catch.
        /// https://reference.wolfram.com/language/ref/Throw.html
        ///</summary>
        corewolf::engine *Throw(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Throw[" + arg0 + "]", name);
        }

        ///< summary>
        /// is caught only by Catch[expr,form], where tag matches form.
        /// https://reference.wolfram.com/language/ref/Throw.html
        ///</summary>
        corewolf::engine *Throw(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Throw[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns f[value,tag] as the top-level value if no appropriate Catch is found.
        /// https://reference.wolfram.com/language/ref/Throw.html
        ///</summary>
        corewolf::engine *Throw(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Throw[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the n term in the Thue–Morse sequence.
        /// https://reference.wolfram.com/language/ref/ThueMorse.html
        ///</summary>
        corewolf::engine *ThueMorse(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ThueMorse[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a thumbnail version of an image.
        /// https://reference.wolfram.com/language/ref/Thumbnail.html
        ///</summary>
        corewolf::engine *Thumbnail(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Thumbnail[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a thumbnail with the specified maximum pixel size.
        /// https://reference.wolfram.com/language/ref/Thumbnail.html
        ///</summary>
        corewolf::engine *Thumbnail(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Thumbnail[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the tidal properties for a location or a set of tidal parameters.
        /// https://reference.wolfram.com/language/ref/TideData.html
        ///</summary>
        corewolf::engine *TideData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TideData[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the specified property for the location or tidal parameters indicated.
        /// https://reference.wolfram.com/language/ref/TideData.html
        ///</summary>
        corewolf::engine *TideData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TideData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of a specified property for a date or set of dates.
        /// https://reference.wolfram.com/language/ref/TideData.html
        ///</summary>
        corewolf::engine *TideData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TideData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Tilde.html
        ///</summary>
        corewolf::engine *Tilde(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Tilde[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/TildeEqual.html
        ///</summary>
        corewolf::engine *TildeEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TildeEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/TildeFullEqual.html
        ///</summary>
        corewolf::engine *TildeFullEqual(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TildeFullEqual[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/TildeTilde.html
        ///</summary>
        corewolf::engine *TildeTilde(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TildeTilde[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// evaluates expr, stopping after t seconds.
        /// https://reference.wolfram.com/language/ref/TimeConstrained.html
        ///</summary>
        corewolf::engine *TimeConstrained(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TimeConstrained[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns failexpr if the time constraint is not met.
        /// https://reference.wolfram.com/language/ref/TimeConstrained.html
        ///</summary>
        corewolf::engine *TimeConstrained(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TimeConstrained[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// makes a timeline plot with dates date1, date2, ….
        /// https://reference.wolfram.com/language/ref/TimelinePlot.html
        ///</summary>
        corewolf::engine *TimelinePlot(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TimelinePlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents the current time.
        /// https://reference.wolfram.com/language/ref/TimeObject.html
        ///</summary>
        corewolf::engine *TimeObject(const std::string &name = "")
        {
            return this->execute("TimeObject[]", name);
        }

        ///< summary>
        /// represents a time const std::string &of standard normalized form.
        /// https://reference.wolfram.com/language/ref/TimeObject.html
        ///</summary>
        corewolf::engine *TimeObject(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TimeObject[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the time component of the specified date representation.
        /// https://reference.wolfram.com/language/ref/TimeObject.html
        ///</summary>
        corewolf::engine *TimeObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TimeObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the time const std::string &of granularity gran that includes the reference time rtime.
        /// https://reference.wolfram.com/language/ref/TimeObject.html
        ///</summary>
        corewolf::engine *TimeObject(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TimeObject[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if expr is a TimeObject with valid arguments, and False otherwise.
        /// https://reference.wolfram.com/language/ref/TimeObjectQ.html
        ///</summary>
        corewolf::engine *TimeObjectQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TimeObjectQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number of seconds remaining until the earliest enclosing TimeConstrained will request the current computation to stop.
        /// https://reference.wolfram.com/language/ref/TimeRemaining.html
        ///</summary>
        corewolf::engine *TimeRemaining(const std::string &name = "")
        {
            return this->execute("TimeRemaining[]", name);
        }

        ///< summary>
        /// represents a time series specified by time-value pairs {ti,vi}.
        /// https://reference.wolfram.com/language/ref/TimeSeries.html
        ///</summary>
        corewolf::engine *TimeSeries(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TimeSeries[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a time series with values vi at times specified by tspec.
        /// https://reference.wolfram.com/language/ref/TimeSeries.html
        ///</summary>
        corewolf::engine *TimeSeries(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TimeSeries[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// computes the mean value of tseries over non-overlapping windows of width dt.
        /// https://reference.wolfram.com/language/ref/TimeSeriesAggregate.html
        ///</summary>
        corewolf::engine *TimeSeriesAggregate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TimeSeriesAggregate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies the function f to the values of tseries in non-overlapping windows of width dt.
        /// https://reference.wolfram.com/language/ref/TimeSeriesAggregate.html
        ///</summary>
        corewolf::engine *TimeSeriesAggregate(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TimeSeriesAggregate[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the k-step-ahead forecast beyond data according to the time series process tproc.
        /// https://reference.wolfram.com/language/ref/TimeSeriesForecast.html
        ///</summary>
        corewolf::engine *TimeSeriesForecast(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TimeSeriesForecast[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the k-step-ahead forecast for TimeSeriesModel tsmod.
        /// https://reference.wolfram.com/language/ref/TimeSeriesForecast.html
        ///</summary>
        corewolf::engine *TimeSeriesForecast(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TimeSeriesForecast[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// inserts a value v at time t in the time series tseries.
        /// https://reference.wolfram.com/language/ref/TimeSeriesInsert.html
        ///</summary>
        corewolf::engine *TimeSeriesInsert(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TimeSeriesInsert[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// inserts the time-value pairs from tseries2 into tseries1.
        /// https://reference.wolfram.com/language/ref/TimeSeriesInsert.html
        ///</summary>
        corewolf::engine *TimeSeriesInsert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TimeSeriesInsert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives conditions for the time series process tproc to be invertible.
        /// https://reference.wolfram.com/language/ref/TimeSeriesInvertibility.html
        ///</summary>
        corewolf::engine *TimeSeriesInvertibility(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TimeSeriesInvertibility[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies f to the values in tseries.
        /// https://reference.wolfram.com/language/ref/TimeSeriesMap.html
        ///</summary>
        corewolf::engine *TimeSeriesMap(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TimeSeriesMap[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives {{t1,f[t1,x1]},{t2,f[t2,x2]},…} for the time series tseries.
        /// https://reference.wolfram.com/language/ref/TimeSeriesMapThread.html
        ///</summary>
        corewolf::engine *TimeSeriesMapThread(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TimeSeriesMapThread[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives {{t1,f[t1,x1,a1,b1,…]},{t2,f[t2,x2,a2,b2,…]},…} for the time series tseries.
        /// https://reference.wolfram.com/language/ref/TimeSeriesMapThread.html
        ///</summary>
        corewolf::engine *TimeSeriesMapThread(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("TimeSeriesMapThread[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// represents the symbolic time series model obtained from TimeSeriesModelFit.
        /// https://reference.wolfram.com/language/ref/TimeSeriesModel.html
        ///</summary>
        corewolf::engine *TimeSeriesModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TimeSeriesModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// constructs a time series model for data from an automatically selected model family.
        /// https://reference.wolfram.com/language/ref/TimeSeriesModelFit.html
        ///</summary>
        corewolf::engine *TimeSeriesModelFit(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TimeSeriesModelFit[" + arg0 + "]", name);
        }

        ///< summary>
        /// constructs a time series model for data from a model family specified by mspec.
        /// https://reference.wolfram.com/language/ref/TimeSeriesModelFit.html
        ///</summary>
        corewolf::engine *TimeSeriesModelFit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TimeSeriesModelFit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uniformly resamples tseries according to its minimum time increment.
        /// https://reference.wolfram.com/language/ref/TimeSeriesResample.html
        ///</summary>
        corewolf::engine *TimeSeriesResample(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TimeSeriesResample[" + arg0 + "]", name);
        }

        ///< summary>
        /// resamples tseries according to rspec.
        /// https://reference.wolfram.com/language/ref/TimeSeriesResample.html
        ///</summary>
        corewolf::engine *TimeSeriesResample(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TimeSeriesResample[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// rescales the times in time series tseries to run from tmin to tmax.
        /// https://reference.wolfram.com/language/ref/TimeSeriesRescale.html
        ///</summary>
        corewolf::engine *TimeSeriesRescale(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TimeSeriesRescale[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// shifts the time series tseries to the left or right according to shift.
        /// https://reference.wolfram.com/language/ref/TimeSeriesShift.html
        ///</summary>
        corewolf::engine *TimeSeriesShift(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TimeSeriesShift[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// combines the tseriesi using the function f.
        /// https://reference.wolfram.com/language/ref/TimeSeriesThread.html
        ///</summary>
        corewolf::engine *TimeSeriesThread(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TimeSeriesThread[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the elements of the time series tseries that fall between tmin and tmax.
        /// https://reference.wolfram.com/language/ref/TimeSeriesWindow.html
        ///</summary>
        corewolf::engine *TimeSeriesWindow(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TimeSeriesWindow[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the elements of the time series tseries that satisfy the window specification windowspec.
        /// https://reference.wolfram.com/language/ref/TimeSeriesWindow.html
        ///</summary>
        corewolf::engine *TimeSeriesWindow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TimeSeriesWindow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts the date const std::string &date to the specified time system tsys.
        /// https://reference.wolfram.com/language/ref/TimeSystemConvert.html
        ///</summary>
        corewolf::engine *TimeSystemConvert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TimeSystemConvert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts to the default time system.
        /// https://reference.wolfram.com/language/ref/TimeSystemConvert.html
        ///</summary>
        corewolf::engine *TimeSystemConvert(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TimeSystemConvert[" + arg0 + "]", name);
        }

        ///< summary>
        /// converts date1 through daten to the specified time system.
        /// https://reference.wolfram.com/language/ref/TimeSystemConvert.html
        ///</summary>
        corewolf::engine *TimeSystemConvert(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TimeSystemConvert[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the total number of seconds of CPU time used so far in the current Wolfram System session.
        /// https://reference.wolfram.com/language/ref/TimeUsed.html
        ///</summary>
        corewolf::engine *TimeUsed(const std::string &name = "")
        {
            return this->execute("TimeUsed[]", name);
        }

        ///< summary>
        /// calculates the time value of a security s at time t for an interest specified by i.
        /// https://reference.wolfram.com/language/ref/TimeValue.html
        ///</summary>
        corewolf::engine *TimeValue(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TimeValue[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// converts the date or time const std::string &time to the specified time zone timezone.
        /// https://reference.wolfram.com/language/ref/TimeZoneConvert.html
        ///</summary>
        corewolf::engine *TimeZoneConvert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TimeZoneConvert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts to the current $TimeZone value.
        /// https://reference.wolfram.com/language/ref/TimeZoneConvert.html
        ///</summary>
        corewolf::engine *TimeZoneConvert(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TimeZoneConvert[" + arg0 + "]", name);
        }

        ///< summary>
        /// converts time1 through timen to the specified timezone.
        /// https://reference.wolfram.com/language/ref/TimeZoneConvert.html
        ///</summary>
        corewolf::engine *TimeZoneConvert(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TimeZoneConvert[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the numeric offset between the time zone tz and GMT on the current date.
        /// https://reference.wolfram.com/language/ref/TimeZoneOffset.html
        ///</summary>
        corewolf::engine *TimeZoneOffset(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TimeZoneOffset[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the numeric offset between tz and the specified base time zone.
        /// https://reference.wolfram.com/language/ref/TimeZoneOffset.html
        ///</summary>
        corewolf::engine *TimeZoneOffset(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TimeZoneOffset[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the numeric offset between tz and base on the specified date.
        /// https://reference.wolfram.com/language/ref/TimeZoneOffset.html
        ///</summary>
        corewolf::engine *TimeZoneOffset(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TimeZoneOffset[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// evaluates expr, and returns a list of the time in seconds used, together with the result obtained.
        /// https://reference.wolfram.com/language/ref/Timing.html
        ///</summary>
        corewolf::engine *Timing(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Timing[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the simple Tits group .
        /// https://reference.wolfram.com/language/ref/TitsGroupT.html
        ///</summary>
        corewolf::engine *TitsGroupT(const std::string &name = "")
        {
            return this->execute("TitsGroupT[]", name);
        }

        ///< summary>
        /// generates boxes corresponding to the printed form of expr in StandardForm.
        /// https://reference.wolfram.com/language/ref/ToBoxes.html
        ///</summary>
        corewolf::engine *ToBoxes(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ToBoxes[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the boxes corresponding to output in the specified form.
        /// https://reference.wolfram.com/language/ref/ToBoxes.html
        ///</summary>
        corewolf::engine *ToBoxes(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ToBoxes[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of the integer codes corresponding to the characters in a string.
        /// https://reference.wolfram.com/language/ref/ToCharacterCode.html
        ///</summary>
        corewolf::engine *ToCharacterCode(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ToCharacterCode[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives integer codes according to the specified encoding.
        /// https://reference.wolfram.com/language/ref/ToCharacterCode.html
        ///</summary>
        corewolf::engine *ToCharacterCode(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ToCharacterCode[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the continuous-time approximation of the discrete-time systems models lsys.
        /// https://reference.wolfram.com/language/ref/ToContinuousTimeModel.html
        ///</summary>
        corewolf::engine *ToContinuousTimeModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ToContinuousTimeModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies the transform variable s.
        /// https://reference.wolfram.com/language/ref/ToContinuousTimeModel.html
        ///</summary>
        corewolf::engine *ToContinuousTimeModel(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ToContinuousTimeModel[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the discrete-time approximation, with sampling period τ, of the continuous-time systems models lsys.
        /// https://reference.wolfram.com/language/ref/ToDiscreteTimeModel.html
        ///</summary>
        corewolf::engine *ToDiscreteTimeModel(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ToDiscreteTimeModel[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies the transform variable z.
        /// https://reference.wolfram.com/language/ref/ToDiscreteTimeModel.html
        ///</summary>
        corewolf::engine *ToDiscreteTimeModel(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ToDiscreteTimeModel[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns an entity const std::string &corresponding to the given expression.
        /// https://reference.wolfram.com/language/ref/ToEntity.html
        ///</summary>
        corewolf::engine *ToEntity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ToEntity[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns an entity const std::string &of the specified type corresponding to expr.
        /// https://reference.wolfram.com/language/ref/ToEntity.html
        ///</summary>
        corewolf::engine *ToEntity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ToEntity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the n×n Toeplitz matrix with first row and first column being successive integers.
        /// https://reference.wolfram.com/language/ref/ToeplitzMatrix.html
        ///</summary>
        corewolf::engine *ToeplitzMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ToeplitzMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Toeplitz matrix whose first column consists of elements c1, c2, ….
        /// https://reference.wolfram.com/language/ref/ToeplitzMatrix.html
        ///</summary>
        corewolf::engine *ToeplitzMatrix(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ToeplitzMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Toeplitz matrix with elements ci down the first column, and ri across the first row.
        /// https://reference.wolfram.com/language/ref/ToeplitzMatrix.html
        ///</summary>
        corewolf::engine *ToeplitzMatrix(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("ToeplitzMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the expression obtained by interpreting strings or boxes as Wolfram Language input.
        /// https://reference.wolfram.com/language/ref/ToExpression.html
        ///</summary>
        corewolf::engine *ToExpression(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ToExpression[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses interpretation rules corresponding to the specified form.
        /// https://reference.wolfram.com/language/ref/ToExpression.html
        ///</summary>
        corewolf::engine *ToExpression(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ToExpression[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// wraps the head h around the expression produced before evaluating it.
        /// https://reference.wolfram.com/language/ref/ToExpression.html
        ///</summary>
        corewolf::engine *ToExpression(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ToExpression[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// puts terms in a sum over a common denominator, and cancels factors in the result.
        /// https://reference.wolfram.com/language/ref/Together.html
        ///</summary>
        corewolf::engine *Together(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Together[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a toggler button with setting x, that toggles between True and False.
        /// https://reference.wolfram.com/language/ref/Toggler.html
        ///</summary>
        corewolf::engine *Toggler(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Toggler[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a toggler button that cycles through any sequence of values vali.
        /// https://reference.wolfram.com/language/ref/Toggler.html
        ///</summary>
        corewolf::engine *Toggler(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Toggler[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// displays as dpict if x is none of the vali.
        /// https://reference.wolfram.com/language/ref/Toggler.html
        ///</summary>
        corewolf::engine *Toggler(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Toggler[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a toggler bar with setting x and with toggler buttons for values vali to include in the list x.
        /// https://reference.wolfram.com/language/ref/TogglerBar.html
        ///</summary>
        corewolf::engine *TogglerBar(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TogglerBar[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns an invertible version of a time series process tproc.
        /// https://reference.wolfram.com/language/ref/ToInvertibleTimeSeries.html
        ///</summary>
        corewolf::engine *ToInvertibleTimeSeries(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ToInvertibleTimeSeries[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields a string in which all letters have been converted to lowercase.
        /// https://reference.wolfram.com/language/ref/ToLowerCase.html
        ///</summary>
        corewolf::engine *ToLowerCase(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ToLowerCase[" + arg0 + "]", name);
        }

        ///< summary>
        /// expresses the algebraic number a in the number field generated by θ.
        /// https://reference.wolfram.com/language/ref/ToNumberField.html
        ///</summary>
        corewolf::engine *ToNumberField(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ToNumberField[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// expresses the ai in the field generated by θ.
        /// https://reference.wolfram.com/language/ref/ToNumberField.html
        ///</summary>
        corewolf::engine *ToNumberField(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ToNumberField[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// expresses the ai in a common extension field generated by a single algebraic number.
        /// https://reference.wolfram.com/language/ref/ToNumberField.html
        ///</summary>
        corewolf::engine *ToNumberField(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ToNumberField[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// displays label as a tooltip while the mouse pointer is in the area where expr is displayed.
        /// https://reference.wolfram.com/language/ref/Tooltip.html
        ///</summary>
        corewolf::engine *Tooltip(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Tooltip[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is a three-dimensional graphics directive specifying that surfaces that follow are to be drawn to emulate two-dimensional flat objects.
        /// https://reference.wolfram.com/language/ref/ToonShading.html
        ///</summary>
        corewolf::engine *ToonShading(const std::string &name = "")
        {
            return this->execute("ToonShading[]", name);
        }

        ///< summary>
        /// uses the color col as base color.
        /// https://reference.wolfram.com/language/ref/ToonShading.html
        ///</summary>
        corewolf::engine *ToonShading(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ToonShading[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the dark color dcol, the base color bcol and highlight color hcol.
        /// https://reference.wolfram.com/language/ref/ToonShading.html
        ///</summary>
        corewolf::engine *ToonShading(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ToonShading[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the morphological top-hat transform of image with respect to structuring element ker.
        /// https://reference.wolfram.com/language/ref/TopHatTransform.html
        ///</summary>
        corewolf::engine *TopHatTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TopHatTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the {r,θ} polar coordinates corresponding to the Cartesian coordinates {x,y}.
        /// https://reference.wolfram.com/language/ref/ToPolarCoordinates.html
        ///</summary>
        corewolf::engine *ToPolarCoordinates(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ToPolarCoordinates[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of vertices of g in topologically sorted order for a directed acyclic graph g.
        /// https://reference.wolfram.com/language/ref/TopologicalSort.html
        ///</summary>
        corewolf::engine *TopologicalSort(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TopologicalSort[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/TopologicalSort.html
        ///</summary>
        corewolf::engine *TopologicalSort(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TopologicalSort[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// attempts to express all Root objects in expr in terms of radicals.
        /// https://reference.wolfram.com/language/ref/ToRadicals.html
        ///</summary>
        corewolf::engine *ToRadicals(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ToRadicals[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a new pointer const std::string &in compiled code, suitable for use with external libraries.
        /// https://reference.wolfram.com/language/ref/ToRawPointer.html
        ///</summary>
        corewolf::engine *ToRawPointer(const std::string &name = "")
        {
            return this->execute("ToRawPointer[]", name);
        }

        ///< summary>
        /// creates a new const std::string &pointing to the initial value val.
        /// https://reference.wolfram.com/language/ref/ToRawPointer.html
        ///</summary>
        corewolf::engine *ToRawPointer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ToRawPointer[" + arg0 + "]", name);
        }

        ///< summary>
        /// stores val in the pointer p.
        /// https://reference.wolfram.com/language/ref/ToRawPointer.html
        ///</summary>
        corewolf::engine *ToRawPointer(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ToRawPointer[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// stores val in the "CArray" array at the given offset.
        /// https://reference.wolfram.com/language/ref/ToRawPointer.html
        ///</summary>
        corewolf::engine *ToRawPointer(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ToRawPointer[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// takes logical combinations of equations, in the form generated by Roots and Reduce, and converts them to lists of rules, of the form produced by Solve.
        /// https://reference.wolfram.com/language/ref/ToRules.html
        ///</summary>
        corewolf::engine *ToRules(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ToRules[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a torus centered at {x,y,z} with inner radius rinner and outer radius router.
        /// https://reference.wolfram.com/language/ref/Torus.html
        ///</summary>
        corewolf::engine *Torus(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Torus[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the k-dimensional torus graph with n1×n2×…×nk vertices.
        /// https://reference.wolfram.com/language/ref/TorusGraph.html
        ///</summary>
        corewolf::engine *TorusGraph(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TorusGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the {r,θ,ϕ} spherical coordinates corresponding to the Cartesian coordinates {x,y,z}.
        /// https://reference.wolfram.com/language/ref/ToSphericalCoordinates.html
        ///</summary>
        corewolf::engine *ToSphericalCoordinates(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ToSphericalCoordinates[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a string corresponding to the printed form of expr in OutputForm.
        /// https://reference.wolfram.com/language/ref/ToString.html
        ///</summary>
        corewolf::engine *ToString(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ToString[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the string corresponding to output in the specified form.
        /// https://reference.wolfram.com/language/ref/ToString.html
        ///</summary>
        corewolf::engine *ToString(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ToString[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the total of the elements in list.
        /// https://reference.wolfram.com/language/ref/Total.html
        ///</summary>
        corewolf::engine *Total(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Total[" + arg0 + "]", name);
        }

        ///< summary>
        /// totals all elements down to level n.
        /// https://reference.wolfram.com/language/ref/Total.html
        ///</summary>
        corewolf::engine *Total(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Total[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// totals elements at level n.
        /// https://reference.wolfram.com/language/ref/Total.html
        ///</summary>
        corewolf::engine *Total(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Total[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a net layer taking a list of input arrays and performing elementwise addition on them.
        /// https://reference.wolfram.com/language/ref/TotalLayer.html
        ///</summary>
        corewolf::engine *TotalLayer(const std::string &name = "")
        {
            return this->execute("TotalLayer[]", name);
        }

        ///< summary>
        /// iteratively reduces noise while preserving rapid transitions in data.
        /// https://reference.wolfram.com/language/ref/TotalVariationFilter.html
        ///</summary>
        corewolf::engine *TotalVariationFilter(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TotalVariationFilter[" + arg0 + "]", name);
        }

        ///< summary>
        /// assumes a regularization parameter value param.
        /// https://reference.wolfram.com/language/ref/TotalVariationFilter.html
        ///</summary>
        corewolf::engine *TotalVariationFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TotalVariationFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of current positions being touched in the notebook front end.
        /// https://reference.wolfram.com/language/ref/TouchPosition.html
        ///</summary>
        corewolf::engine *TouchPosition(const std::string &name = "")
        {
            return this->execute("TouchPosition[]", name);
        }

        ///< summary>
        /// gives the touch positions with respect to the specified coordinate system.
        /// https://reference.wolfram.com/language/ref/TouchPosition.html
        ///</summary>
        corewolf::engine *TouchPosition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TouchPosition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the position of the n position being touched in an const std::string &in the specified coordinate system.
        /// https://reference.wolfram.com/language/ref/TouchPosition.html
        ///</summary>
        corewolf::engine *TouchPosition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TouchPosition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns def if there are not n positions being touched.
        /// https://reference.wolfram.com/language/ref/TouchPosition.html
        ///</summary>
        corewolf::engine *TouchPosition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TouchPosition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields a string in which all letters have been converted to uppercase.
        /// https://reference.wolfram.com/language/ref/ToUpperCase.html
        ///</summary>
        corewolf::engine *ToUpperCase(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ToUpperCase[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a video by taking a tour at steps stepi around graphics.
        /// https://reference.wolfram.com/language/ref/TourVideo.html
        ///</summary>
        corewolf::engine *TourVideo(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TourVideo[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// takes a tour with steps stepi at times ti around graphics.
        /// https://reference.wolfram.com/language/ref/TourVideo.html
        ///</summary>
        corewolf::engine *TourVideo(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("TourVideo[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// samples the function func to generate step specifications for each frame.
        /// https://reference.wolfram.com/language/ref/TourVideo.html
        ///</summary>
        corewolf::engine *TourVideo(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TourVideo[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds the trace of the matrix or tensor list.
        /// https://reference.wolfram.com/language/ref/Tr.html
        ///</summary>
        corewolf::engine *Tr(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Tr[" + arg0 + "]", name);
        }

        ///< summary>
        /// finds a generalized trace, combining terms with f instead of Plus.
        /// https://reference.wolfram.com/language/ref/Tr.html
        ///</summary>
        corewolf::engine *Tr(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Tr[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// goes down to level n in list.
        /// https://reference.wolfram.com/language/ref/Tr.html
        ///</summary>
        corewolf::engine *Tr(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Tr[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a list of all expressions used in the evaluation of expr.
        /// https://reference.wolfram.com/language/ref/Trace.html
        ///</summary>
        corewolf::engine *Trace(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Trace[" + arg0 + "]", name);
        }

        ///< summary>
        /// includes only those expressions that match form.
        /// https://reference.wolfram.com/language/ref/Trace.html
        ///</summary>
        corewolf::engine *Trace(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Trace[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// initiates a dialog for every expression used in the evaluation of expr.
        /// https://reference.wolfram.com/language/ref/TraceDialog.html
        ///</summary>
        corewolf::engine *TraceDialog(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TraceDialog[" + arg0 + "]", name);
        }

        ///< summary>
        /// initiates a dialog only for expressions which match form.
        /// https://reference.wolfram.com/language/ref/TraceDialog.html
        ///</summary>
        corewolf::engine *TraceDialog(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TraceDialog[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// prints all expressions used in the evaluation of expr.
        /// https://reference.wolfram.com/language/ref/TracePrint.html
        ///</summary>
        corewolf::engine *TracePrint(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TracePrint[" + arg0 + "]", name);
        }

        ///< summary>
        /// includes only those expressions which match form.
        /// https://reference.wolfram.com/language/ref/TracePrint.html
        ///</summary>
        corewolf::engine *TracePrint(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TracePrint[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f to all expressions used in the evaluation of expr.
        /// https://reference.wolfram.com/language/ref/TraceScan.html
        ///</summary>
        corewolf::engine *TraceScan(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TraceScan[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// includes only those expressions which match form.
        /// https://reference.wolfram.com/language/ref/TraceScan.html
        ///</summary>
        corewolf::engine *TraceScan(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TraceScan[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies f before evaluation and fp after evaluation to expressions used in the evaluation of expr.
        /// https://reference.wolfram.com/language/ref/TraceScan.html
        ///</summary>
        corewolf::engine *TraceScan(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("TraceScan[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a Tracy–Widom distribution with Dyson index β.
        /// https://reference.wolfram.com/language/ref/TracyWidomDistribution.html
        ///</summary>
        corewolf::engine *TracyWidomDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TracyWidomDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes a chart showing prices and volume for each date.
        /// https://reference.wolfram.com/language/ref/TradingChart.html
        ///</summary>
        corewolf::engine *TradingChart(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TradingChart[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes a financial chart for the financial entity "name" over the daterange.
        /// https://reference.wolfram.com/language/ref/TradingChart.html
        ///</summary>
        corewolf::engine *TradingChart(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TradingChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// makes a financial chart with indicators ind1, ind2, ….
        /// https://reference.wolfram.com/language/ref/TradingChart.html
        ///</summary>
        corewolf::engine *TradingChart(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TradingChart[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// prints as an approximation to the traditional mathematical notation for expr.
        /// https://reference.wolfram.com/language/ref/TraditionalForm.html
        ///</summary>
        corewolf::engine *TraditionalForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TraditionalForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// trains a ContentDetectorFunction[…] based on the examples given.
        /// https://reference.wolfram.com/language/ref/TrainImageContentDetector.html
        ///</summary>
        corewolf::engine *TrainImageContentDetector(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TrainImageContentDetector[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// trains a ContentDetectorFunction[…] based on the examples given.
        /// https://reference.wolfram.com/language/ref/TrainTextContentDetector.html
        ///</summary>
        corewolf::engine *TrainTextContentDetector(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TrainTextContentDetector[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// cancels common poles and zeros in the TransferFunctionModel tfm.
        /// https://reference.wolfram.com/language/ref/TransferFunctionCancel.html
        ///</summary>
        corewolf::engine *TransferFunctionCancel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TransferFunctionCancel[" + arg0 + "]", name);
        }

        ///< summary>
        /// cancels only common pole-zero pairs ei for which crit[ei] is True.
        /// https://reference.wolfram.com/language/ref/TransferFunctionCancel.html
        ///</summary>
        corewolf::engine *TransferFunctionCancel(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TransferFunctionCancel[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// expands polynomial terms in the numerators and denominators of the TransferFunctionModel tfm.
        /// https://reference.wolfram.com/language/ref/TransferFunctionExpand.html
        ///</summary>
        corewolf::engine *TransferFunctionExpand(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TransferFunctionExpand[" + arg0 + "]", name);
        }

        ///< summary>
        /// factors the polynomial terms in the numerators and denominators of the TransferFunctionModel tfm.
        /// https://reference.wolfram.com/language/ref/TransferFunctionFactor.html
        ///</summary>
        corewolf::engine *TransferFunctionFactor(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TransferFunctionFactor[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the model of the transfer-function matrix m with complex variable s.
        /// https://reference.wolfram.com/language/ref/TransferFunctionModel.html
        ///</summary>
        corewolf::engine *TransferFunctionModel(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TransferFunctionModel[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies the numerator num and denominator den of a transfer-function model.
        /// https://reference.wolfram.com/language/ref/TransferFunctionModel.html
        ///</summary>
        corewolf::engine *TransferFunctionModel(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TransferFunctionModel[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the transfer-function model of the systems model sys.
        /// https://reference.wolfram.com/language/ref/TransferFunctionModel.html
        ///</summary>
        corewolf::engine *TransferFunctionModel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TransferFunctionModel[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a matrix of roots of the denominators in the TransferFunctionModel tfm.
        /// https://reference.wolfram.com/language/ref/TransferFunctionPoles.html
        ///</summary>
        corewolf::engine *TransferFunctionPoles(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TransferFunctionPoles[" + arg0 + "]", name);
        }

        ///< summary>
        /// only gives the roots inside the region reg on the complex plane.
        /// https://reference.wolfram.com/language/ref/TransferFunctionPoles.html
        ///</summary>
        corewolf::engine *TransferFunctionPoles(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TransferFunctionPoles[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// transforms the TransferFunctionModel const std::string &tf using the transformation function f.
        /// https://reference.wolfram.com/language/ref/TransferFunctionTransform.html
        ///</summary>
        corewolf::engine *TransferFunctionTransform(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TransferFunctionTransform[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a matrix of roots of the numerators in the TransferFunctionModel tfm.
        /// https://reference.wolfram.com/language/ref/TransferFunctionZeros.html
        ///</summary>
        corewolf::engine *TransferFunctionZeros(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TransferFunctionZeros[" + arg0 + "]", name);
        }

        ///< summary>
        /// only gives the roots inside the region reg on the complex plane.
        /// https://reference.wolfram.com/language/ref/TransferFunctionZeros.html
        ///</summary>
        corewolf::engine *TransferFunctionZeros(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TransferFunctionZeros[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a transformation function that applies geometric and other transformations.
        /// https://reference.wolfram.com/language/ref/TransformationFunction.html
        ///</summary>
        corewolf::engine *TransformationFunction(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TransformationFunction[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the homogeneous matrix associated with a TransformationFunction object.
        /// https://reference.wolfram.com/language/ref/TransformationMatrix.html
        ///</summary>
        corewolf::engine *TransformationMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TransformationMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the transformed distribution of expr where the random variable x follows the distribution dist.
        /// https://reference.wolfram.com/language/ref/TransformedDistribution.html
        ///</summary>
        corewolf::engine *TransformedDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TransformedDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a transformed distribution where x1, x2, … are independent and follow the distributions dist1, dist2, ….
        /// https://reference.wolfram.com/language/ref/TransformedDistribution.html
        ///</summary>
        corewolf::engine *TransformedDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TransformedDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses the coordinate transformation t to transform the scalar, vector, or tensor field f from coordinates xi to yi.
        /// https://reference.wolfram.com/language/ref/TransformedField.html
        ///</summary>
        corewolf::engine *TransformedField(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("TransformedField[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents the transformed process of expr where the variable x follows the random process proc and t denotes the time.
        /// https://reference.wolfram.com/language/ref/TransformedProcess.html
        ///</summary>
        corewolf::engine *TransformedProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TransformedProcess[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a transformed process where x1, x2, … are independent and follow the processes proc1, proc2, ….
        /// https://reference.wolfram.com/language/ref/TransformedProcess.html
        ///</summary>
        corewolf::engine *TransformedProcess(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TransformedProcess[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the transformed region , where reg is a region and f is a function.
        /// https://reference.wolfram.com/language/ref/TransformedRegion.html
        ///</summary>
        corewolf::engine *TransformedRegion(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TransformedRegion[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the transitive closure of the graph g.
        /// https://reference.wolfram.com/language/ref/TransitiveClosureGraph.html
        ///</summary>
        corewolf::engine *TransitiveClosureGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TransitiveClosureGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/TransitiveClosureGraph.html
        ///</summary>
        corewolf::engine *TransitiveClosureGraph(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TransitiveClosureGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a transitive reduction of the graph g.
        /// https://reference.wolfram.com/language/ref/TransitiveReductionGraph.html
        ///</summary>
        corewolf::engine *TransitiveReductionGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TransitiveReductionGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/TransitiveReductionGraph.html
        ///</summary>
        corewolf::engine *TransitiveReductionGraph(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TransitiveReductionGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents graphics primitives g translated by the vector {x,y,…}.
        /// https://reference.wolfram.com/language/ref/Translate.html
        ///</summary>
        corewolf::engine *Translate(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Translate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents multiple copies of g translated by a collection of vectors.
        /// https://reference.wolfram.com/language/ref/Translate.html
        ///</summary>
        corewolf::engine *Translate(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("Translate[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives a TransformationFunction that represents translation of points by a vector v.
        /// https://reference.wolfram.com/language/ref/TranslationTransform.html
        ///</summary>
        corewolf::engine *TranslationTransform(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TranslationTransform[" + arg0 + "]", name);
        }

        ///< summary>
        /// attempts to transliterate string into plain ASCII.
        /// https://reference.wolfram.com/language/ref/Transliterate.html
        ///</summary>
        corewolf::engine *Transliterate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Transliterate[" + arg0 + "]", name);
        }

        ///< summary>
        /// attempts to transliterate string into the specified writing script script.
        /// https://reference.wolfram.com/language/ref/Transliterate.html
        ///</summary>
        corewolf::engine *Transliterate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Transliterate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// transposes the first two levels in list.
        /// https://reference.wolfram.com/language/ref/Transpose.html
        ///</summary>
        corewolf::engine *Transpose(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Transpose[" + arg0 + "]", name);
        }

        ///< summary>
        /// transposes list so that the k level in list is the nk level in the result.
        /// https://reference.wolfram.com/language/ref/Transpose.html
        ///</summary>
        corewolf::engine *Transpose(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Transpose[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// transposes levels m and n in list, leaving all other levels unchanged.
        /// https://reference.wolfram.com/language/ref/Transpose.html
        ///</summary>
        corewolf::engine *Transpose(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Transpose[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a net layer that transposes the first two levels of its input.
        /// https://reference.wolfram.com/language/ref/TransposeLayer.html
        ///</summary>
        corewolf::engine *TransposeLayer(const std::string &name = "")
        {
            return this->execute("TransposeLayer[]", name);
        }

        ///< summary>
        /// represents a net layer that transposes levels m and n of its input.
        /// https://reference.wolfram.com/language/ref/TransposeLayer.html
        ///</summary>
        corewolf::engine *TransposeLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TransposeLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a net layer that sequentially transposes levels mi and ni of its input.
        /// https://reference.wolfram.com/language/ref/TransposeLayer.html
        ///</summary>
        corewolf::engine *TransposeLayer(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TransposeLayer[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// generates directions for travel from loc1 to loc2, ….
        /// https://reference.wolfram.com/language/ref/TravelDirections.html
        ///</summary>
        corewolf::engine *TravelDirections(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TravelDirections[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the property prop of travel directions.
        /// https://reference.wolfram.com/language/ref/TravelDirections.html
        ///</summary>
        corewolf::engine *TravelDirections(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TravelDirections[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents travel directions generated by TravelDirections.
        /// https://reference.wolfram.com/language/ref/TravelDirectionsData.html
        ///</summary>
        corewolf::engine *TravelDirectionsData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TravelDirectionsData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the estimated distance for travel from loc1 to loc2, ….
        /// https://reference.wolfram.com/language/ref/TravelDistance.html
        ///</summary>
        corewolf::engine *TravelDistance(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TravelDistance[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns the list {TravelDistance[loc1,loc2],…,TravelDistance[locn-1,locn]}.
        /// https://reference.wolfram.com/language/ref/TravelDistanceList.html
        ///</summary>
        corewolf::engine *TravelDistanceList(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TravelDistanceList[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the estimated time to travel from loc1 to loc2, ….
        /// https://reference.wolfram.com/language/ref/TravelTime.html
        ///</summary>
        corewolf::engine *TravelTime(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TravelTime[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a tree with a list of child subtrees subtreei.
        /// https://reference.wolfram.com/language/ref/Tree.html
        ///</summary>
        corewolf::engine *Tree(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Tree[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// specifies the children as an association with keys keyi.
        /// https://reference.wolfram.com/language/ref/Tree.html
        ///</summary>
        corewolf::engine *Tree(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Tree[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a tree containing data in its root, with children given by subtrees.
        /// https://reference.wolfram.com/language/ref/Tree.html
        ///</summary>
        corewolf::engine *Tree(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Tree[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of subtrees of tree with data matching pattern.
        /// https://reference.wolfram.com/language/ref/TreeCases.html
        ///</summary>
        corewolf::engine *TreeCases(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TreeCases[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of all subtrees of tree on levels specified by levelspec with data that matches the pattern.
        /// https://reference.wolfram.com/language/ref/TreeCases.html
        ///</summary>
        corewolf::engine *TreeCases(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TreeCases[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the first n subtrees in tree with data that matches the pattern.
        /// https://reference.wolfram.com/language/ref/TreeCases.html
        ///</summary>
        corewolf::engine *TreeCases(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("TreeCases[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an operator form of TreeCases that can be applied to a tree.
        /// https://reference.wolfram.com/language/ref/TreeCases.html
        ///</summary>
        corewolf::engine *TreeCases(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeCases[" + arg0 + "]", name);
        }

        ///< summary>
        /// extracts the children of the root of the Tree const std::string &tree.
        /// https://reference.wolfram.com/language/ref/TreeChildren.html
        ///</summary>
        corewolf::engine *TreeChildren(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeChildren[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number of subtrees of tree whose data matches pattern.
        /// https://reference.wolfram.com/language/ref/TreeCount.html
        ///</summary>
        corewolf::engine *TreeCount(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TreeCount[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the total number of subtrees with data matching pattern that appear at the levels in tree specified by levelspec.
        /// https://reference.wolfram.com/language/ref/TreeCount.html
        ///</summary>
        corewolf::engine *TreeCount(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TreeCount[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of TreeCount that can be applied to a tree.
        /// https://reference.wolfram.com/language/ref/TreeCount.html
        ///</summary>
        corewolf::engine *TreeCount(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeCount[" + arg0 + "]", name);
        }

        ///< summary>
        /// extracts the data in the root of the Tree const std::string &tree.
        /// https://reference.wolfram.com/language/ref/TreeData.html
        ///</summary>
        corewolf::engine *TreeData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeData[" + arg0 + "]", name);
        }

        ///< summary>
        /// deletes the subtree of tree at the position specified by pos.
        /// https://reference.wolfram.com/language/ref/TreeDelete.html
        ///</summary>
        corewolf::engine *TreeDelete(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TreeDelete[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// deletes subtrees at several positions.
        /// https://reference.wolfram.com/language/ref/TreeDelete.html
        ///</summary>
        corewolf::engine *TreeDelete(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TreeDelete[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an operator form of TreeDelete that can be applied to a tree.
        /// https://reference.wolfram.com/language/ref/TreeDelete.html
        ///</summary>
        corewolf::engine *TreeDelete(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeDelete[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the maximum level of tree.
        /// https://reference.wolfram.com/language/ref/TreeDepth.html
        ///</summary>
        corewolf::engine *TreeDepth(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeDepth[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the maximum level of the subtree with data matching pattern.
        /// https://reference.wolfram.com/language/ref/TreeDepth.html
        ///</summary>
        corewolf::engine *TreeDepth(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TreeDepth[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an expression from the structure of the Tree const std::string &tree.
        /// https://reference.wolfram.com/language/ref/TreeExpression.html
        ///</summary>
        corewolf::engine *TreeExpression(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeExpression[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an expression with data and subtrees of tree interpreted as specified by struct.
        /// https://reference.wolfram.com/language/ref/TreeExpression.html
        ///</summary>
        corewolf::engine *TreeExpression(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TreeExpression[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// extracts the subtree of tree at the position specified by pos.
        /// https://reference.wolfram.com/language/ref/TreeExtract.html
        ///</summary>
        corewolf::engine *TreeExtract(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TreeExtract[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// extracts a list of subtrees of tree.
        /// https://reference.wolfram.com/language/ref/TreeExtract.html
        ///</summary>
        corewolf::engine *TreeExtract(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TreeExtract[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// extracts subtrees of tree, applying h to each subtree.
        /// https://reference.wolfram.com/language/ref/TreeExtract.html
        ///</summary>
        corewolf::engine *TreeExtract(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TreeExtract[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of TreeExtract that can be applied to a tree.
        /// https://reference.wolfram.com/language/ref/TreeExtract.html
        ///</summary>
        corewolf::engine *TreeExtract(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeExtract[" + arg0 + "]", name);
        }

        ///< summary>
        /// successively folds the subtrees of tree, applying f to both the data of each subtree and the list of results for its children.
        /// https://reference.wolfram.com/language/ref/TreeFold.html
        ///</summary>
        corewolf::engine *TreeFold(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TreeFold[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f to h[tree] instead of the data of tree.
        /// https://reference.wolfram.com/language/ref/TreeFold.html
        ///</summary>
        corewolf::engine *TreeFold(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TreeFold[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies f-1 at the last level and f at each inner level.
        /// https://reference.wolfram.com/language/ref/TreeFold.html
        ///</summary>
        corewolf::engine *TreeFold(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TreeFold[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of TreeFold that can be applied to a tree.
        /// https://reference.wolfram.com/language/ref/TreeFold.html
        ///</summary>
        corewolf::engine *TreeFold(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeFold[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays expr as a tree with different levels at different depths.
        /// https://reference.wolfram.com/language/ref/TreeForm.html
        ///</summary>
        corewolf::engine *TreeForm(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeForm[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays expr as a tree only down to level n.
        /// https://reference.wolfram.com/language/ref/TreeForm.html
        ///</summary>
        corewolf::engine *TreeForm(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TreeForm[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields a tree where ui is the predecessor of vi.
        /// https://reference.wolfram.com/language/ref/TreeGraph.html
        ///</summary>
        corewolf::engine *TreeGraph(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TreeGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// yields a tree with edges ej.
        /// https://reference.wolfram.com/language/ref/TreeGraph.html
        ///</summary>
        corewolf::engine *TreeGraph(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TreeGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is a tree and False otherwise.
        /// https://reference.wolfram.com/language/ref/TreeGraphQ.html
        ///</summary>
        corewolf::engine *TreeGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// inserts child at the position specified by pos in tree.
        /// https://reference.wolfram.com/language/ref/TreeInsert.html
        ///</summary>
        corewolf::engine *TreeInsert(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TreeInsert[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// inserts child at several positions.
        /// https://reference.wolfram.com/language/ref/TreeInsert.html
        ///</summary>
        corewolf::engine *TreeInsert(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("TreeInsert[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents an operator form of TreeInsert that can be applied to a tree.
        /// https://reference.wolfram.com/language/ref/TreeInsert.html
        ///</summary>
        corewolf::engine *TreeInsert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TreeInsert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the number of leaves of tree.
        /// https://reference.wolfram.com/language/ref/TreeLeafCount.html
        ///</summary>
        corewolf::engine *TreeLeafCount(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeLeafCount[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if tree is a Tree const std::string &with no children, and gives False otherwise.
        /// https://reference.wolfram.com/language/ref/TreeLeafQ.html
        ///</summary>
        corewolf::engine *TreeLeafQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeLeafQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the list of leaves of the tree tree.
        /// https://reference.wolfram.com/language/ref/TreeLeaves.html
        ///</summary>
        corewolf::engine *TreeLeaves(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeLeaves[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of all subtrees of tree on levels specified by levelspec.
        /// https://reference.wolfram.com/language/ref/TreeLevel.html
        ///</summary>
        corewolf::engine *TreeLevel(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TreeLevel[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an operator form of TreeLevel that can be applied to a tree.
        /// https://reference.wolfram.com/language/ref/TreeLevel.html
        ///</summary>
        corewolf::engine *TreeLevel(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeLevel[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies f to the data of each subtree of tree.
        /// https://reference.wolfram.com/language/ref/TreeMap.html
        ///</summary>
        corewolf::engine *TreeMap(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TreeMap[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f to the data of subtrees on levels of tree specified by levelspec.
        /// https://reference.wolfram.com/language/ref/TreeMap.html
        ///</summary>
        corewolf::engine *TreeMap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TreeMap[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of TreeMap that can be applied to a tree.
        /// https://reference.wolfram.com/language/ref/TreeMap.html
        ///</summary>
        corewolf::engine *TreeMap(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeMap[" + arg0 + "]", name);
        }

        ///< summary>
        /// applies f to the data at the position specified by pos in tree.
        /// https://reference.wolfram.com/language/ref/TreeMapAt.html
        ///</summary>
        corewolf::engine *TreeMapAt(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TreeMapAt[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies f to the data at several positions.
        /// https://reference.wolfram.com/language/ref/TreeMapAt.html
        ///</summary>
        corewolf::engine *TreeMapAt(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("TreeMapAt[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents an operator form of TreeMapAt that can be applied to a tree.
        /// https://reference.wolfram.com/language/ref/TreeMapAt.html
        ///</summary>
        corewolf::engine *TreeMapAt(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TreeMapAt[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an outline of the data in tree as a nested OpenerView.
        /// https://reference.wolfram.com/language/ref/TreeOutline.html
        ///</summary>
        corewolf::engine *TreeOutline(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeOutline[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an outline of the data in tree initially opened to the subtree at the position specified by pos.
        /// https://reference.wolfram.com/language/ref/TreeOutline.html
        ///</summary>
        corewolf::engine *TreeOutline(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TreeOutline[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// opens the outline to several positions.
        /// https://reference.wolfram.com/language/ref/TreeOutline.html
        ///</summary>
        corewolf::engine *TreeOutline(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TreeOutline[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of the positions of subtrees of tree whose data matches pattern.
        /// https://reference.wolfram.com/language/ref/TreePosition.html
        ///</summary>
        corewolf::engine *TreePosition(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TreePosition[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// finds only matches that appear on levels of tree specified by levelspec.
        /// https://reference.wolfram.com/language/ref/TreePosition.html
        ///</summary>
        corewolf::engine *TreePosition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TreePosition[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the positions of the first n matches found.
        /// https://reference.wolfram.com/language/ref/TreePosition.html
        ///</summary>
        corewolf::engine *TreePosition(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("TreePosition[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an operator form of TreePosition that can be applied to a tree.
        /// https://reference.wolfram.com/language/ref/TreePosition.html
        ///</summary>
        corewolf::engine *TreePosition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreePosition[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if tree is a valid Tree const std::string &and False otherwise.
        /// https://reference.wolfram.com/language/ref/TreeQ.html
        ///</summary>
        corewolf::engine *TreeQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a tree in which the subtree of tree at the position specified by pos is replaced with new.
        /// https://reference.wolfram.com/language/ref/TreeReplacePart.html
        ///</summary>
        corewolf::engine *TreeReplacePart(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TreeReplacePart[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces subtrees at positions specified by posi with newi.
        /// https://reference.wolfram.com/language/ref/TreeReplacePart.html
        ///</summary>
        corewolf::engine *TreeReplacePart(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TreeReplacePart[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents an operator form of TreeReplacePart that can be applied to a tree.
        /// https://reference.wolfram.com/language/ref/TreeReplacePart.html
        ///</summary>
        corewolf::engine *TreeReplacePart(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeReplacePart[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the rules associated with the Tree const std::string &tree.
        /// https://reference.wolfram.com/language/ref/TreeRules.html
        ///</summary>
        corewolf::engine *TreeRules(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeRules[" + arg0 + "]", name);
        }

        ///< summary>
        /// evaluates f applied to the data of each subtree of tree in turn.
        /// https://reference.wolfram.com/language/ref/TreeScan.html
        ///</summary>
        corewolf::engine *TreeScan(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TreeScan[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f to the data of subtrees on levels of tree specified by levelspec.
        /// https://reference.wolfram.com/language/ref/TreeScan.html
        ///</summary>
        corewolf::engine *TreeScan(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TreeScan[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of TreeScan that can be applied to a tree.
        /// https://reference.wolfram.com/language/ref/TreeScan.html
        ///</summary>
        corewolf::engine *TreeScan(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeScan[" + arg0 + "]", name);
        }

        ///< summary>
        /// picks out all subtrees treei of tree for which crit[treei] is True.
        /// https://reference.wolfram.com/language/ref/TreeSelect.html
        ///</summary>
        corewolf::engine *TreeSelect(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TreeSelect[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// picks out the first n subtrees for which crit[treei] is True.
        /// https://reference.wolfram.com/language/ref/TreeSelect.html
        ///</summary>
        corewolf::engine *TreeSelect(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TreeSelect[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// picks out subtrees on levels specified by levelspec.
        /// https://reference.wolfram.com/language/ref/TreeSelect.html
        ///</summary>
        corewolf::engine *TreeSelect(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("TreeSelect[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents an operator form of TreeSelect that can be applied to a tree.
        /// https://reference.wolfram.com/language/ref/TreeSelect.html
        ///</summary>
        corewolf::engine *TreeSelect(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeSelect[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the number of subtrees of tree.
        /// https://reference.wolfram.com/language/ref/TreeSize.html
        ///</summary>
        corewolf::engine *TreeSize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TreeSize[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a filled triangle with corner points p1, p2, and p3.
        /// https://reference.wolfram.com/language/ref/Triangle.html
        ///</summary>
        corewolf::engine *Triangle(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Triangle[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the specified type of center for the triangle tri.
        /// https://reference.wolfram.com/language/ref/TriangleCenter.html
        ///</summary>
        corewolf::engine *TriangleCenter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TriangleCenter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the centroid of the triangle.
        /// https://reference.wolfram.com/language/ref/TriangleCenter.html
        ///</summary>
        corewolf::engine *TriangleCenter(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TriangleCenter[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the specified type of construct for the triangle tri.
        /// https://reference.wolfram.com/language/ref/TriangleConstruct.html
        ///</summary>
        corewolf::engine *TriangleConstruct(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TriangleConstruct[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified type of measurement for the triangle tri.
        /// https://reference.wolfram.com/language/ref/TriangleMeasurement.html
        ///</summary>
        corewolf::engine *TriangleMeasurement(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TriangleMeasurement[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a triangle wave that varies between  and  with unit period.
        /// https://reference.wolfram.com/language/ref/TriangleWave.html
        ///</summary>
        corewolf::engine *TriangleWave(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TriangleWave[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a triangle wave that varies between min and max with unit period.
        /// https://reference.wolfram.com/language/ref/TriangleWave.html
        ///</summary>
        corewolf::engine *TriangleWave(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TriangleWave[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a symmetric triangular statistical distribution giving values between min and max.
        /// https://reference.wolfram.com/language/ref/TriangularDistribution.html
        ///</summary>
        corewolf::engine *TriangularDistribution(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TriangularDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a symmetric triangular statistical distribution giving values between 0 and 1.
        /// https://reference.wolfram.com/language/ref/TriangularDistribution.html
        ///</summary>
        corewolf::engine *TriangularDistribution(const std::string &name = "")
        {
            return this->execute("TriangularDistribution[]", name);
        }

        ///< summary>
        /// represents a triangular distribution with mode at c.
        /// https://reference.wolfram.com/language/ref/TriangularDistribution.html
        ///</summary>
        corewolf::engine *TriangularDistribution(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TriangularDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a triangulation of the mesh region mr.
        /// https://reference.wolfram.com/language/ref/TriangulateMesh.html
        ///</summary>
        corewolf::engine *TriangulateMesh(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TriangulateMesh[" + arg0 + "]", name);
        }

        ///< summary>
        /// expands out trigonometric functions in expr.
        /// https://reference.wolfram.com/language/ref/TrigExpand.html
        ///</summary>
        corewolf::engine *TrigExpand(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TrigExpand[" + arg0 + "]", name);
        }

        ///< summary>
        /// factors trigonometric functions in expr.
        /// https://reference.wolfram.com/language/ref/TrigFactor.html
        ///</summary>
        corewolf::engine *TrigFactor(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TrigFactor[" + arg0 + "]", name);
        }

        ///< summary>
        /// factors trigonometric functions in expr, yielding a list of lists containing trigonometric monomials and exponents.
        /// https://reference.wolfram.com/language/ref/TrigFactorList.html
        ///</summary>
        corewolf::engine *TrigFactorList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TrigFactorList[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a trigger that can be pressed to make the dynamically updated value of u be continually increased with time from 0 to 1.
        /// https://reference.wolfram.com/language/ref/Trigger.html
        ///</summary>
        corewolf::engine *Trigger(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Trigger[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes u vary from umin to umax when triggered.
        /// https://reference.wolfram.com/language/ref/Trigger.html
        ///</summary>
        corewolf::engine *Trigger(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Trigger[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// makes the value of u increase at a rate of ups units per second when triggered.
        /// https://reference.wolfram.com/language/ref/Trigger.html
        ///</summary>
        corewolf::engine *Trigger(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Trigger[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// rewrites products and powers of trigonometric functions in expr in terms of trigonometric functions with combined arguments.
        /// https://reference.wolfram.com/language/ref/TrigReduce.html
        ///</summary>
        corewolf::engine *TrigReduce(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TrigReduce[" + arg0 + "]", name);
        }

        ///< summary>
        /// converts trigonometric functions in expr to exponentials.
        /// https://reference.wolfram.com/language/ref/TrigToExp.html
        ///</summary>
        corewolf::engine *TrigToExp(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TrigToExp[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the mean of the elements in list after dropping a fraction f of the smallest and largest elements.
        /// https://reference.wolfram.com/language/ref/TrimmedMean.html
        ///</summary>
        corewolf::engine *TrimmedMean(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TrimmedMean[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the mean when a fraction f1 of the smallest elements and a fraction f2 of the largest elements are removed.
        /// https://reference.wolfram.com/language/ref/TrimmedMean.html
        ///</summary>
        corewolf::engine *TrimmedMean(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TrimmedMean[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the 5% trimmed mean TrimmedMean[list,0.05].
        /// https://reference.wolfram.com/language/ref/TrimmedMean.html
        ///</summary>
        corewolf::engine *TrimmedMean(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TrimmedMean[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the variance of the elements in list after dropping a fraction f of the smallest and largest elements.
        /// https://reference.wolfram.com/language/ref/TrimmedVariance.html
        ///</summary>
        corewolf::engine *TrimmedVariance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TrimmedVariance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the variance when a fraction f1 of the smallest elements and a fraction f2 of the largest elements are removed.
        /// https://reference.wolfram.com/language/ref/TrimmedVariance.html
        ///</summary>
        corewolf::engine *TrimmedVariance(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TrimmedVariance[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the 5% trimmed variance TrimmedVariance[list,0.05].
        /// https://reference.wolfram.com/language/ref/TrimmedVariance.html
        ///</summary>
        corewolf::engine *TrimmedVariance(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TrimmedVariance[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the tropical storm entity.
        /// https://reference.wolfram.com/language/ref/TropicalStormData.html
        ///</summary>
        corewolf::engine *TropicalStormData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TropicalStormData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified tropical storm entities.
        /// https://reference.wolfram.com/language/ref/TropicalStormData.html
        ///</summary>
        corewolf::engine *TropicalStormData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TropicalStormData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/TropicalStormData.html
        ///</summary>
        corewolf::engine *TropicalStormData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TropicalStormData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields True if expr is True, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/TrueQ.html
        ///</summary>
        corewolf::engine *TrueQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TrueQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the distribution obtained by truncating the values of dist to lie between xmin and xmax.
        /// https://reference.wolfram.com/language/ref/TruncatedDistribution.html
        ///</summary>
        corewolf::engine *TruncatedDistribution(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TruncatedDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the distribution obtained by truncating the values of the multivariate distribution dist to lie between xmin and xmax, ymin and ymax, etc.
        /// https://reference.wolfram.com/language/ref/TruncatedDistribution.html
        ///</summary>
        corewolf::engine *TruncatedDistribution(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TruncatedDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the truncated polyhedron of poly by truncating all vertices.
        /// https://reference.wolfram.com/language/ref/TruncatedPolyhedron.html
        ///</summary>
        corewolf::engine *TruncatedPolyhedron(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TruncatedPolyhedron[" + arg0 + "]", name);
        }

        ///< summary>
        /// truncates the polyhedron poly by a length ratio l at its vertices.
        /// https://reference.wolfram.com/language/ref/TruncatedPolyhedron.html
        ///</summary>
        corewolf::engine *TruncatedPolyhedron(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TruncatedPolyhedron[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Tsallis -exponential distribution with scale inversely proportional to parameter λ.
        /// https://reference.wolfram.com/language/ref/TsallisQExponentialDistribution.html
        ///</summary>
        corewolf::engine *TsallisQExponentialDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TsallisQExponentialDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Tsallis -Gaussian distribution with mean μ, scale parameter β, and deformation parameter q.
        /// https://reference.wolfram.com/language/ref/TsallisQGaussianDistribution.html
        ///</summary>
        corewolf::engine *TsallisQGaussianDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TsallisQGaussianDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Tsallis -Gaussian distribution with mean 0 and scale parameter 1.
        /// https://reference.wolfram.com/language/ref/TsallisQGaussianDistribution.html
        ///</summary>
        corewolf::engine *TsallisQGaussianDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TsallisQGaussianDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the mean of data is zero.
        /// https://reference.wolfram.com/language/ref/TTest.html
        ///</summary>
        corewolf::engine *TTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the means of data1 and data2 are equal.
        /// https://reference.wolfram.com/language/ref/TTest.html
        ///</summary>
        corewolf::engine *TTest(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("TTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// tests the mean against μ0.
        /// https://reference.wolfram.com/language/ref/TTest.html
        ///</summary>
        corewolf::engine *TTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/TTest.html
        ///</summary>
        corewolf::engine *TTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a 3D tube around the line joining a sequence of points.
        /// https://reference.wolfram.com/language/ref/Tube.html
        ///</summary>
        corewolf::engine *Tube(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("Tube[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a tube of radius r.
        /// https://reference.wolfram.com/language/ref/Tube.html
        ///</summary>
        corewolf::engine *Tube(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Tube[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a collection of tubes.
        /// https://reference.wolfram.com/language/ref/Tube.html
        ///</summary>
        corewolf::engine *Tube(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Tube[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a tube around the specified 3D curve.
        /// https://reference.wolfram.com/language/ref/Tube.html
        ///</summary>
        corewolf::engine *Tube(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Tube[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents Tukey's lambda distribution with shape parameter λ.
        /// https://reference.wolfram.com/language/ref/TukeyLambdaDistribution.html
        ///</summary>
        corewolf::engine *TukeyLambdaDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TukeyLambdaDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents Tukey's lambda distribution with location parameter μ and scale parameter σ.
        /// https://reference.wolfram.com/language/ref/TukeyLambdaDistribution.html
        ///</summary>
        corewolf::engine *TukeyLambdaDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TukeyLambdaDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the generalized Tukey's lambda distribution with location parameter μ, scale parameters σ1 and σ2, and shape parameters λ1 and λ2.
        /// https://reference.wolfram.com/language/ref/TukeyLambdaDistribution.html
        ///</summary>
        corewolf::engine *TukeyLambdaDistribution(const std::vector<std::string> &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("TukeyLambdaDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a Tukey window function of x.
        /// https://reference.wolfram.com/language/ref/TukeyWindow.html
        ///</summary>
        corewolf::engine *TukeyWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TukeyWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the parameter α.
        /// https://reference.wolfram.com/language/ref/TukeyWindow.html
        ///</summary>
        corewolf::engine *TukeyWindow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TukeyWindow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the tunnel entity.
        /// https://reference.wolfram.com/language/ref/TunnelData.html
        ///</summary>
        corewolf::engine *TunnelData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TunnelData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified tunnel entities.
        /// https://reference.wolfram.com/language/ref/TunnelData.html
        ///</summary>
        corewolf::engine *TunnelData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TunnelData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/TunnelData.html
        ///</summary>
        corewolf::engine *TunnelData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TunnelData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a list of all possible n‐tuples of elements from list.
        /// https://reference.wolfram.com/language/ref/Tuples.html
        ///</summary>
        corewolf::engine *Tuples(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Tuples[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a list of all possible tuples whose i element is from listi.
        /// https://reference.wolfram.com/language/ref/Tuples.html
        ///</summary>
        corewolf::engine *Tuples(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Tuples[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the k-partite Turán graph with n vertices .
        /// https://reference.wolfram.com/language/ref/TuranGraph.html
        ///</summary>
        corewolf::engine *TuranGraph(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TuranGraph[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a list representing the evolution of the Turing machine with the specified rule from initial condition init for t steps.
        /// https://reference.wolfram.com/language/ref/TuringMachine.html
        ///</summary>
        corewolf::engine *TuringMachine(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TuringMachine[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the result of evolving init for one step.
        /// https://reference.wolfram.com/language/ref/TuringMachine.html
        ///</summary>
        corewolf::engine *TuringMachine(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TuringMachine[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is an operator form of TuringMachine that corresponds to one step of evolution.
        /// https://reference.wolfram.com/language/ref/TuringMachine.html
        ///</summary>
        corewolf::engine *TuringMachine(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TuringMachine[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Tutte polynomial of the graph g.
        /// https://reference.wolfram.com/language/ref/TuttePolynomial.html
        ///</summary>
        corewolf::engine *TuttePolynomial(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TuttePolynomial[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/TuttePolynomial.html
        ///</summary>
        corewolf::engine *TuttePolynomial(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TuttePolynomial[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an expression that should be assumed to be of a specified type for compilation and other purposes.
        /// https://reference.wolfram.com/language/ref/Typed.html
        ///</summary>
        corewolf::engine *Typed(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Typed[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a declaration of a product type with the specified fields.
        /// https://reference.wolfram.com/language/ref/TypeDeclaration.html
        ///</summary>
        corewolf::engine *TypeDeclaration(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("TypeDeclaration[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// represents a declaration of the abstract type name.
        /// https://reference.wolfram.com/language/ref/TypeDeclaration.html
        ///</summary>
        corewolf::engine *TypeDeclaration(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TypeDeclaration[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a declaration of the type name using the internal representation of targetType.
        /// https://reference.wolfram.com/language/ref/TypeDeclaration.html
        ///</summary>
        corewolf::engine *TypeDeclaration(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("TypeDeclaration[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a type created by evaluating expr.
        /// https://reference.wolfram.com/language/ref/TypeEvaluate.html
        ///</summary>
        corewolf::engine *TypeEvaluate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TypeEvaluate[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the type of expr without evaluating it.
        /// https://reference.wolfram.com/language/ref/TypeOf.html
        ///</summary>
        corewolf::engine *TypeOf(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TypeOf[" + arg0 + "]", name);
        }

        ///< summary>
        /// assumes that instances of x in expr have type ty.
        /// https://reference.wolfram.com/language/ref/TypeOf.html
        ///</summary>
        corewolf::engine *TypeOf(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TypeOf[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// assumes that xi has type tyi.
        /// https://reference.wolfram.com/language/ref/TypeOf.html
        ///</summary>
        corewolf::engine *TypeOf(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("TypeOf[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a type.
        /// https://reference.wolfram.com/language/ref/TypeSpecifier.html
        ///</summary>
        corewolf::engine *TypeSpecifier(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("TypeSpecifier[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a compound type.
        /// https://reference.wolfram.com/language/ref/TypeSpecifier.html
        ///</summary>
        corewolf::engine *TypeSpecifier(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("TypeSpecifier[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether the Boolean expression bexpr is positive unate in the variables x1, x2, … .
        /// https://reference.wolfram.com/language/ref/UnateQ.html
        ///</summary>
        corewolf::engine *UnateQ(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("UnateQ[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// recovers an expression from a compressed string representation generated by Compress.
        /// https://reference.wolfram.com/language/ref/Uncompress.html
        ///</summary>
        corewolf::engine *Uncompress(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Uncompress[" + arg0 + "]", name);
        }

        ///< summary>
        /// wraps the head h around the expression produced before evaluating it.
        /// https://reference.wolfram.com/language/ref/Uncompress.html
        ///</summary>
        corewolf::engine *Uncompress(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Uncompress[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays with a bar under expr.
        /// https://reference.wolfram.com/language/ref/UnderBar.html
        ///</summary>
        corewolf::engine *UnderBar(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UnderBar[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a number too small to represent explicitly on your computer system.
        /// https://reference.wolfram.com/language/ref/Underflow.html
        ///</summary>
        corewolf::engine *Underflow(const std::string &name = "")
        {
            return this->execute("Underflow[]", name);
        }

        ///< summary>
        /// is an const std::string &that formats as .
        /// https://reference.wolfram.com/language/ref/Underoverscript.html
        ///</summary>
        corewolf::engine *Underoverscript(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Underoverscript[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is the low‐level box representation for  in notebook expressions.
        /// https://reference.wolfram.com/language/ref/UnderoverscriptBox.html
        ///</summary>
        corewolf::engine *UnderoverscriptBox(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UnderoverscriptBox[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is an const std::string &that formats as .
        /// https://reference.wolfram.com/language/ref/Underscript.html
        ///</summary>
        corewolf::engine *Underscript(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Underscript[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is the low‐level box representation for  in notebook expressions.
        /// https://reference.wolfram.com/language/ref/UnderscriptBox.html
        ///</summary>
        corewolf::engine *UnderscriptBox(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("UnderscriptBox[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the undersea feature entity.
        /// https://reference.wolfram.com/language/ref/UnderseaFeatureData.html
        ///</summary>
        corewolf::engine *UnderseaFeatureData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("UnderseaFeatureData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified undersea feature entities.
        /// https://reference.wolfram.com/language/ref/UnderseaFeatureData.html
        ///</summary>
        corewolf::engine *UnderseaFeatureData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("UnderseaFeatureData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/UnderseaFeatureData.html
        ///</summary>
        corewolf::engine *UnderseaFeatureData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UnderseaFeatureData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives an undirected graph from the directed graph g.
        /// https://reference.wolfram.com/language/ref/UndirectedGraph.html
        ///</summary>
        corewolf::engine *UndirectedGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UndirectedGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/UndirectedGraph.html
        ///</summary>
        corewolf::engine *UndirectedGraph(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("UndirectedGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is an undirected graph and False otherwise.
        /// https://reference.wolfram.com/language/ref/UndirectedGraphQ.html
        ///</summary>
        corewolf::engine *UndirectedGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UndirectedGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// is an operator form that yields x≠y when applied to an expression x.
        /// https://reference.wolfram.com/language/ref/UnequalTo.html
        ///</summary>
        corewolf::engine *UnequalTo(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UnequalTo[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the unevaluated form of expr when it appears as the argument to a function.
        /// https://reference.wolfram.com/language/ref/Unevaluated.html
        ///</summary>
        corewolf::engine *Unevaluated(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Unevaluated[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a continuous uniform statistical distribution giving values between min and max.
        /// https://reference.wolfram.com/language/ref/UniformDistribution.html
        ///</summary>
        corewolf::engine *UniformDistribution(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("UniformDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents a uniform distribution giving values between 0 and 1.
        /// https://reference.wolfram.com/language/ref/UniformDistribution.html
        ///</summary>
        corewolf::engine *UniformDistribution(const std::string &name = "")
        {
            return this->execute("UniformDistribution[]", name);
        }

        ///< summary>
        /// represents a multivariate uniform distribution over the region {{xmin,xmax},{ymin,ymax},…}.
        /// https://reference.wolfram.com/language/ref/UniformDistribution.html
        ///</summary>
        corewolf::engine *UniformDistribution(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("UniformDistribution[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a multivariate uniform distribution over the standard n dimensional unit hypercube.
        /// https://reference.wolfram.com/language/ref/UniformDistribution.html
        ///</summary>
        corewolf::engine *UniformDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UniformDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a uniform graph distribution on n-vertex, m-edge graphs.
        /// https://reference.wolfram.com/language/ref/UniformGraphDistribution.html
        ///</summary>
        corewolf::engine *UniformGraphDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("UniformGraphDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the uniform polyhedron with the given name.
        /// https://reference.wolfram.com/language/ref/UniformPolyhedron.html
        ///</summary>
        corewolf::engine *UniformPolyhedron(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UniformPolyhedron[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the uniform polyhedron with n sides of each face and m faces meeting at each vertex point.
        /// https://reference.wolfram.com/language/ref/UniformPolyhedron.html
        ///</summary>
        corewolf::engine *UniformPolyhedron(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("UniformPolyhedron[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// rescales the uniform polyhedron by a factor r and rotates by an angle θ with respect to the z axis and angle ϕ with respect to the y axis.
        /// https://reference.wolfram.com/language/ref/UniformPolyhedron.html
        ///</summary>
        corewolf::engine *UniformPolyhedron(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("UniformPolyhedron[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// centers the uniform polyhedron at {x,y,z}.
        /// https://reference.wolfram.com/language/ref/UniformPolyhedron.html
        ///</summary>
        corewolf::engine *UniformPolyhedron(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UniformPolyhedron[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the distribution of a sum of n random variables uniformly distributed from 0 to 1.
        /// https://reference.wolfram.com/language/ref/UniformSumDistribution.html
        ///</summary>
        corewolf::engine *UniformSumDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UniformSumDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the distribution of a sum of n random variables uniformly distributed from min to max.
        /// https://reference.wolfram.com/language/ref/UniformSumDistribution.html
        ///</summary>
        corewolf::engine *UniformSumDistribution(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("UniformSumDistribution[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// terminates an external program started by Install, and removes Wolfram Language definitions set up by it.
        /// https://reference.wolfram.com/language/ref/Uninstall.html
        ///</summary>
        corewolf::engine *Uninstall(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Uninstall[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a sorted list of all the distinct elements that appear in any of the listi.
        /// https://reference.wolfram.com/language/ref/Union.html
        ///</summary>
        corewolf::engine *Union(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Union[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a sorted version of a list, in which all duplicated elements have been dropped.
        /// https://reference.wolfram.com/language/ref/Union.html
        ///</summary>
        corewolf::engine *Union(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Union[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an entity class containing all the distinct entities in all the classi.
        /// https://reference.wolfram.com/language/ref/UnionedEntityClass.html
        ///</summary>
        corewolf::engine *UnionedEntityClass(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("UnionedEntityClass[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as x⊎y⊎….
        /// https://reference.wolfram.com/language/ref/UnionPlus.html
        ///</summary>
        corewolf::engine *UnionPlus(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UnionPlus[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a new symbol, whose name is of the form $nnn.
        /// https://reference.wolfram.com/language/ref/Unique.html
        ///</summary>
        corewolf::engine *Unique(const std::string &name = "")
        {
            return this->execute("Unique[]", name);
        }

        ///< summary>
        /// generates a new symbol, with a name of the form x$nnn.
        /// https://reference.wolfram.com/language/ref/Unique.html
        ///</summary>
        corewolf::engine *Unique(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Unique[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a list of new symbols.
        /// https://reference.wolfram.com/language/ref/Unique.html
        ///</summary>
        corewolf::engine *Unique(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Unique[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the elements for each listi that are not in any other list.
        /// https://reference.wolfram.com/language/ref/UniqueElements.html
        ///</summary>
        corewolf::engine *UniqueElements(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("UniqueElements[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// uses test to determine whether pairs of elements should be considered equivalent.
        /// https://reference.wolfram.com/language/ref/UniqueElements.html
        ///</summary>
        corewolf::engine *UniqueElements(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("UniqueElements[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if m is a unitary matrix, and False otherwise.
        /// https://reference.wolfram.com/language/ref/UnitaryMatrixQ.html
        ///</summary>
        corewolf::engine *UnitaryMatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UnitaryMatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the unit box function, equal to 1 for  and 0 otherwise.
        /// https://reference.wolfram.com/language/ref/UnitBox.html
        ///</summary>
        corewolf::engine *UnitBox(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UnitBox[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the multidimensional unit box function, equal to 1 if  and 0 otherwise.
        /// https://reference.wolfram.com/language/ref/UnitBox.html
        ///</summary>
        corewolf::engine *UnitBox(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UnitBox[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// attempts to convert the specified quantity to the specified targetunit.
        /// https://reference.wolfram.com/language/ref/UnitConvert.html
        ///</summary>
        corewolf::engine *UnitConvert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("UnitConvert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts the specified quantity to SI base units.
        /// https://reference.wolfram.com/language/ref/UnitConvert.html
        ///</summary>
        corewolf::engine *UnitConvert(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UnitConvert[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a list of base dimensions associated with the specified unit.
        /// https://reference.wolfram.com/language/ref/UnitDimensions.html
        ///</summary>
        corewolf::engine *UnitDimensions(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UnitDimensions[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives 0 when x is zero, and 1 when x has any other numerical value.
        /// https://reference.wolfram.com/language/ref/Unitize.html
        ///</summary>
        corewolf::engine *Unitize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Unitize[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether data came from an autoregressive time series process with unit root.
        /// https://reference.wolfram.com/language/ref/UnitRootTest.html
        ///</summary>
        corewolf::engine *UnitRootTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UnitRootTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the value of "property" for a given model.
        /// https://reference.wolfram.com/language/ref/UnitRootTest.html
        ///</summary>
        corewolf::engine *UnitRootTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UnitRootTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// attempts to simplify the units of the specified quantity.
        /// https://reference.wolfram.com/language/ref/UnitSimplify.html
        ///</summary>
        corewolf::engine *UnitSimplify(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UnitSimplify[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the unit step function, equal to 0 for  and 1 for .
        /// https://reference.wolfram.com/language/ref/UnitStep.html
        ///</summary>
        corewolf::engine *UnitStep(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UnitStep[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the multidimensional unit step function which is 1 only if none of the  are negative.
        /// https://reference.wolfram.com/language/ref/UnitStep.html
        ///</summary>
        corewolf::engine *UnitStep(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UnitStep[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the unit triangle function on the interval  .
        /// https://reference.wolfram.com/language/ref/UnitTriangle.html
        ///</summary>
        corewolf::engine *UnitTriangle(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UnitTriangle[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the multidimensional unit triangle function on the interval .
        /// https://reference.wolfram.com/language/ref/UnitTriangle.html
        ///</summary>
        corewolf::engine *UnitTriangle(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UnitTriangle[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the two-dimensional unit vector in the k direction.
        /// https://reference.wolfram.com/language/ref/UnitVector.html
        ///</summary>
        corewolf::engine *UnitVector(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UnitVector[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the n-dimensional unit vector in the k direction.
        /// https://reference.wolfram.com/language/ref/UnitVector.html
        ///</summary>
        corewolf::engine *UnitVector(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("UnitVector[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a net layer that transforms integers between 1 and n into n-dimensional unit vectors.
        /// https://reference.wolfram.com/language/ref/UnitVectorLayer.html
        ///</summary>
        corewolf::engine *UnitVectorLayer(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UnitVectorLayer[" + arg0 + "]", name);
        }

        ///< summary>
        /// leaves the n to be inferred from context.
        /// https://reference.wolfram.com/language/ref/UnitVectorLayer.html
        ///</summary>
        corewolf::engine *UnitVectorLayer(const std::string &name = "")
        {
            return this->execute("UnitVectorLayer[]", name);
        }

        ///< summary>
        /// returns properties of the universe based on the default model at specification defined by the time after the Big Bang, the distance to the comoving object, or the redshift of such an object.
        /// https://reference.wolfram.com/language/ref/UniverseModelData.html
        ///</summary>
        corewolf::engine *UniverseModelData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UniverseModelData[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns properties of universe model at spec.
        /// https://reference.wolfram.com/language/ref/UniverseModelData.html
        ///</summary>
        corewolf::engine *UniverseModelData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("UniverseModelData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the specified property at the time or distance spec for the universe model.
        /// https://reference.wolfram.com/language/ref/UniverseModelData.html
        ///</summary>
        corewolf::engine *UniverseModelData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UniverseModelData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the university entity.
        /// https://reference.wolfram.com/language/ref/UniversityData.html
        ///</summary>
        corewolf::engine *UniversityData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("UniversityData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified university entities.
        /// https://reference.wolfram.com/language/ref/UniversityData.html
        ///</summary>
        corewolf::engine *UniversityData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("UniversityData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/UniversityData.html
        ///</summary>
        corewolf::engine *UniversityData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UniversityData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the total number of seconds since the beginning of January 1, 1970, in the GMT time zone.
        /// https://reference.wolfram.com/language/ref/UnixTime.html
        ///</summary>
        corewolf::engine *UnixTime(const std::string &name = "")
        {
            return this->execute("UnixTime[]", name);
        }

        ///< summary>
        /// gives the Unix time specification corresponding to a date list.
        /// https://reference.wolfram.com/language/ref/UnixTime.html
        ///</summary>
        corewolf::engine *UnixTime(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("UnixTime[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Unix time specification corresponding to a DateObject.
        /// https://reference.wolfram.com/language/ref/UnixTime.html
        ///</summary>
        corewolf::engine *UnixTime(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UnixTime[" + arg0 + "]", name);
        }

        ///< summary>
        /// takes the date string to contain the elements "ei".
        /// https://reference.wolfram.com/language/ref/UnixTime.html
        ///</summary>
        corewolf::engine *UnixTime(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("UnixTime[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns a tree of the same shape as tree in which the nodes and edges are displayed without labels.
        /// https://reference.wolfram.com/language/ref/UnlabeledTree.html
        ///</summary>
        corewolf::engine *UnlabeledTree(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UnlabeledTree[" + arg0 + "]", name);
        }

        ///< summary>
        /// takes ownership of memory wrapped in a "Managed" object, suitable for use in compiled code.
        /// https://reference.wolfram.com/language/ref/UnmanageObject.html
        ///</summary>
        corewolf::engine *UnmanageObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UnmanageObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// removes the attribute Protected for the symbols si.
        /// https://reference.wolfram.com/language/ref/Unprotect.html
        ///</summary>
        corewolf::engine *Unprotect(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Unprotect[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// unprotects any symbols that are equal to or match any of the speci.
        /// https://reference.wolfram.com/language/ref/Unprotect.html
        ///</summary>
        corewolf::engine *Unprotect(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Unprotect[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// unregisters the external evaluator referenced by target for system sys so that it is not used by ExternalEvaluate and related functions.
        /// https://reference.wolfram.com/language/ref/UnregisterExternalEvaluator.html
        ///</summary>
        corewolf::engine *UnregisterExternalEvaluator(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("UnregisterExternalEvaluator[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// unregisters the external evaluator with the specified registration UUID.
        /// https://reference.wolfram.com/language/ref/UnregisterExternalEvaluator.html
        ///</summary>
        corewolf::engine *UnregisterExternalEvaluator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UnregisterExternalEvaluator[" + arg0 + "]", name);
        }

        ///< summary>
        /// stops the sharing of the variables or functions si among parallel kernels.
        /// https://reference.wolfram.com/language/ref/UnsetShared.html
        ///</summary>
        corewolf::engine *UnsetShared(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UnsetShared[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// stops the sharing of all variables and functions whose names match the string pattern patt.
        /// https://reference.wolfram.com/language/ref/UnsetShared.html
        ///</summary>
        corewolf::engine *UnsetShared(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UnsetShared[" + arg0 + "]", name);
        }

        ///< summary>
        /// evaluates body and then test, repetitively, until test first gives True.
        /// https://reference.wolfram.com/language/ref/Until.html
        ///</summary>
        corewolf::engine *Until(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Until[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as x↑y↑.
        /// https://reference.wolfram.com/language/ref/UpArrow.html
        ///</summary>
        corewolf::engine *UpArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UpArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⤒y⤒….
        /// https://reference.wolfram.com/language/ref/UpArrowBar.html
        ///</summary>
        corewolf::engine *UpArrowBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UpArrowBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⇅y⇅….
        /// https://reference.wolfram.com/language/ref/UpArrowDownArrow.html
        ///</summary>
        corewolf::engine *UpArrowDownArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UpArrowDownArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// tells the Wolfram Language that hidden changes have been made that could affect values associated with a symbol.
        /// https://reference.wolfram.com/language/ref/Update.html
        ///</summary>
        corewolf::engine *Update(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Update[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies that the value of any symbol could be affected.
        /// https://reference.wolfram.com/language/ref/Update.html
        ///</summary>
        corewolf::engine *Update(const std::string &name = "")
        {
            return this->execute("Update[]", name);
        }

        ///< summary>
        /// updates the given search index object.
        /// https://reference.wolfram.com/language/ref/UpdateSearchIndex.html
        ///</summary>
        corewolf::engine *UpdateSearchIndex(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UpdateSearchIndex[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as x↕y↕….
        /// https://reference.wolfram.com/language/ref/UpDownArrow.html
        ///</summary>
        corewolf::engine *UpDownArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UpDownArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x⥮y⥮….
        /// https://reference.wolfram.com/language/ref/UpEquilibrium.html
        ///</summary>
        corewolf::engine *UpEquilibrium(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UpEquilibrium[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields True if all the characters in the string are uppercase letters, and yields False otherwise.
        /// https://reference.wolfram.com/language/ref/UpperCaseQ.html
        ///</summary>
        corewolf::engine *UpperCaseQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UpperCaseQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as x↖y↖….
        /// https://reference.wolfram.com/language/ref/UpperLeftArrow.html
        ///</summary>
        corewolf::engine *UpperLeftArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UpperLeftArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// displays as x↗y↗….
        /// https://reference.wolfram.com/language/ref/UpperRightArrow.html
        ///</summary>
        corewolf::engine *UpperRightArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UpperRightArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a matrix in which all but the upper triangular elements of m are replaced with zeros.
        /// https://reference.wolfram.com/language/ref/UpperTriangularize.html
        ///</summary>
        corewolf::engine *UpperTriangularize(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UpperTriangularize[" + arg0 + "]", name);
        }

        ///< summary>
        /// replaces with zeros only the elements below the k subdiagonal of m.
        /// https://reference.wolfram.com/language/ref/UpperTriangularize.html
        ///</summary>
        corewolf::engine *UpperTriangularize(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("UpperTriangularize[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts the upper triangular matrix umat to a structured array.
        /// https://reference.wolfram.com/language/ref/UpperTriangularMatrix.html
        ///</summary>
        corewolf::engine *UpperTriangularMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UpperTriangularMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if m is upper triangular, and False otherwise.
        /// https://reference.wolfram.com/language/ref/UpperTriangularMatrixQ.html
        ///</summary>
        corewolf::engine *UpperTriangularMatrixQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UpperTriangularMatrixQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if m is upper triangular starting up from the k diagonal, and False otherwise.
        /// https://reference.wolfram.com/language/ref/UpperTriangularMatrixQ.html
        ///</summary>
        corewolf::engine *UpperTriangularMatrixQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("UpperTriangularMatrixQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns an upsampled version of the array by inserting  zeros between array elements.
        /// https://reference.wolfram.com/language/ref/Upsample.html
        ///</summary>
        corewolf::engine *Upsample(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Upsample[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// shifts array so that its first element moves to the position offset in the resulting array.
        /// https://reference.wolfram.com/language/ref/Upsample.html
        ///</summary>
        corewolf::engine *Upsample(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Upsample[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// inserts  elements of value val between array elements.
        /// https://reference.wolfram.com/language/ref/Upsample.html
        ///</summary>
        corewolf::engine *Upsample(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Upsample[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/UpTee.html
        ///</summary>
        corewolf::engine *UpTee(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("UpTee[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as x↥y↥….
        /// https://reference.wolfram.com/language/ref/UpTeeArrow.html
        ///</summary>
        corewolf::engine *UpTeeArrow(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("UpTeeArrow[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is a symbolic specification that represents up to n objects or positions. If n objects or positions are available, all are used. If fewer are available, only those available are used.
        /// https://reference.wolfram.com/language/ref/UpTo.html
        ///</summary>
        corewolf::engine *UpTo(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UpTo[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of transformation rules corresponding to all upvalues (values for g[…,f[…],…]) defined for the symbol f.
        /// https://reference.wolfram.com/language/ref/UpValues.html
        ///</summary>
        corewolf::engine *UpValues(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UpValues[" + arg0 + "]", name);
        }

        ///< summary>
        /// is a symbolic representation of a URL.
        /// https://reference.wolfram.com/language/ref/URL.html
        ///</summary>
        corewolf::engine *URL(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("URL[" + arg0 + "]", name);
        }

        ///< summary>
        /// builds a URL with the specified path and query parameters and values parami and vali.
        /// https://reference.wolfram.com/language/ref/URLBuild.html
        ///</summary>
        corewolf::engine *URLBuild(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("URLBuild[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// builds a URL from the path components pathi.
        /// https://reference.wolfram.com/language/ref/URLBuild.html
        ///</summary>
        corewolf::engine *URLBuild(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("URLBuild[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// builds a URL from a specification of a path and query parameters.
        /// https://reference.wolfram.com/language/ref/URLBuild.html
        ///</summary>
        corewolf::engine *URLBuild(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("URLBuild[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// builds a URL from an association of components.
        /// https://reference.wolfram.com/language/ref/URLBuild.html
        ///</summary>
        corewolf::engine *URLBuild(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("URLBuild[" + arg0 + "]", name);
        }

        ///< summary>
        /// decodes a URL-style percent-encoded string.
        /// https://reference.wolfram.com/language/ref/URLDecode.html
        ///</summary>
        corewolf::engine *URLDecode(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("URLDecode[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a dispatcher for deployed URLs that specifies that URLs with relative paths matching the string patterns patti should give content represented by contenti.
        /// https://reference.wolfram.com/language/ref/URLDispatcher.html
        ///</summary>
        corewolf::engine *URLDispatcher(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("URLDispatcher[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// downloads the content of the specified URL to a local temporary file.
        /// https://reference.wolfram.com/language/ref/URLDownload.html
        ///</summary>
        corewolf::engine *URLDownload(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("URLDownload[" + arg0 + "]", name);
        }

        ///< summary>
        /// downloads the contents of the specified URLs to files in a local temporary directory.
        /// https://reference.wolfram.com/language/ref/URLDownload.html
        ///</summary>
        corewolf::engine *URLDownload(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("URLDownload[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// downloads to a specified file.
        /// https://reference.wolfram.com/language/ref/URLDownload.html
        ///</summary>
        corewolf::engine *URLDownload(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("URLDownload[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// downloads to a specified directory.
        /// https://reference.wolfram.com/language/ref/URLDownload.html
        ///</summary>
        corewolf::engine *URLDownload(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("URLDownload[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns only the element elem from the response.
        /// https://reference.wolfram.com/language/ref/URLDownload.html
        ///</summary>
        corewolf::engine *URLDownload(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("URLDownload[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns an association of the values of the elements elemi.
        /// https://reference.wolfram.com/language/ref/URLDownload.html
        ///</summary>
        corewolf::engine *URLDownload(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("URLDownload[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// submits the specified URL to be downloaded asynchronously to the file given.
        /// https://reference.wolfram.com/language/ref/URLDownloadSubmit.html
        ///</summary>
        corewolf::engine *URLDownloadSubmit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("URLDownloadSubmit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// submits the specified URL, adding elements with names parami and values vali.
        /// https://reference.wolfram.com/language/ref/URLDownloadSubmit.html
        ///</summary>
        corewolf::engine *URLDownloadSubmit(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("URLDownloadSubmit[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// converts "string" into a URL-style, percent-encoded ASCII string.
        /// https://reference.wolfram.com/language/ref/URLEncode.html
        ///</summary>
        corewolf::engine *URLEncode(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("URLEncode[" + arg0 + "]", name);
        }

        ///< summary>
        /// executes the specified URL, importing whatever result is generated.
        /// https://reference.wolfram.com/language/ref/URLExecute.html
        ///</summary>
        corewolf::engine *URLExecute(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("URLExecute[" + arg0 + "]", name);
        }

        ///< summary>
        /// executes the specified URL, adding elements with names parami and values vali.
        /// https://reference.wolfram.com/language/ref/URLExecute.html
        ///</summary>
        corewolf::engine *URLExecute(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("URLExecute[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// imports the result using the specified format.
        /// https://reference.wolfram.com/language/ref/URLExecute.html
        ///</summary>
        corewolf::engine *URLExecute(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("URLExecute[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// executes a cloud const std::string &with current authentication settings.
        /// https://reference.wolfram.com/language/ref/URLExecute.html
        ///</summary>
        corewolf::engine *URLExecute(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("URLExecute[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// expands a shortened "url".
        /// https://reference.wolfram.com/language/ref/URLExpand.html
        ///</summary>
        corewolf::engine *URLExpand(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("URLExpand[" + arg0 + "]", name);
        }

        ///< summary>
        /// takes a well-formed URL and gives an association whose values correspond to the components of the URL.
        /// https://reference.wolfram.com/language/ref/URLParse.html
        ///</summary>
        corewolf::engine *URLParse(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("URLParse[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns only the specified component.
        /// https://reference.wolfram.com/language/ref/URLParse.html
        ///</summary>
        corewolf::engine *URLParse(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("URLParse[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns only the specified component list.
        /// https://reference.wolfram.com/language/ref/URLParse.html
        ///</summary>
        corewolf::engine *URLParse(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("URLParse[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// decodes a URL-style query string into a list of key-value rules.
        /// https://reference.wolfram.com/language/ref/URLQueryDecode.html
        ///</summary>
        corewolf::engine *URLQueryDecode(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("URLQueryDecode[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a URL-style query string from an association of keys and values.
        /// https://reference.wolfram.com/language/ref/URLQueryEncode.html
        ///</summary>
        corewolf::engine *URLQueryEncode(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("URLQueryEncode[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// creates a query string from a list of rules.
        /// https://reference.wolfram.com/language/ref/URLQueryEncode.html
        ///</summary>
        corewolf::engine *URLQueryEncode(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("URLQueryEncode[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// sends a request to a URL and reads back the response, returning it as a response object.
        /// https://reference.wolfram.com/language/ref/URLRead.html
        ///</summary>
        corewolf::engine *URLRead(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("URLRead[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns only the element elem from the response.
        /// https://reference.wolfram.com/language/ref/URLRead.html
        ///</summary>
        corewolf::engine *URLRead(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("URLRead[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns an association of the values of the elements elemi.
        /// https://reference.wolfram.com/language/ref/URLRead.html
        ///</summary>
        corewolf::engine *URLRead(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("URLRead[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// sends the requests reqi in parallel, giving a list of the results obtained.
        /// https://reference.wolfram.com/language/ref/URLRead.html
        ///</summary>
        corewolf::engine *URLRead(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("URLRead[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the total number of seconds to request one byte from the specified URL.
        /// https://reference.wolfram.com/language/ref/URLResponseTime.html
        ///</summary>
        corewolf::engine *URLResponseTime(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("URLResponseTime[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the specified timing.
        /// https://reference.wolfram.com/language/ref/URLResponseTime.html
        ///</summary>
        corewolf::engine *URLResponseTime(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("URLResponseTime[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// creates a shortened URL that redirects to "url".
        /// https://reference.wolfram.com/language/ref/URLShorten.html
        ///</summary>
        corewolf::engine *URLShorten(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("URLShorten[" + arg0 + "]", name);
        }

        ///< summary>
        /// submits the specified URL to be executed asynchronously.
        /// https://reference.wolfram.com/language/ref/URLSubmit.html
        ///</summary>
        corewolf::engine *URLSubmit(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("URLSubmit[" + arg0 + "]", name);
        }

        ///< summary>
        /// submits the specified URL, adding elements with names parami and values vali.
        /// https://reference.wolfram.com/language/ref/URLSubmit.html
        ///</summary>
        corewolf::engine *URLSubmit(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("URLSubmit[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// submits the cloud const std::string &obj.
        /// https://reference.wolfram.com/language/ref/URLSubmit.html
        ///</summary>
        corewolf::engine *URLSubmit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("URLSubmit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates expr, making use of a front end if necessary.
        /// https://reference.wolfram.com/language/ref/UsingFrontEnd.html
        ///</summary>
        corewolf::engine *UsingFrontEnd(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("UsingFrontEnd[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True if a value has been defined for expr, and gives False otherwise.
        /// https://reference.wolfram.com/language/ref/ValueQ.html
        ///</summary>
        corewolf::engine *ValueQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ValueQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of the values vali in an association.
        /// https://reference.wolfram.com/language/ref/Values.html
        ///</summary>
        corewolf::engine *Values(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Values[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of the vali in a list of rules.
        /// https://reference.wolfram.com/language/ref/Values.html
        ///</summary>
        corewolf::engine *Values(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("Values[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a list of values in expr, wrapping each of them with head h before evaluation.
        /// https://reference.wolfram.com/language/ref/Values.html
        ///</summary>
        corewolf::engine *Values(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Values[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of all independent variables in a polynomial.
        /// https://reference.wolfram.com/language/ref/Variables.html
        ///</summary>
        corewolf::engine *Variables(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Variables[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the sample variance of the elements in list.
        /// https://reference.wolfram.com/language/ref/Variance.html
        ///</summary>
        corewolf::engine *Variance(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Variance[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the variances of the datai are equal.
        /// https://reference.wolfram.com/language/ref/VarianceEquivalenceTest.html
        ///</summary>
        corewolf::engine *VarianceEquivalenceTest(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("VarianceEquivalenceTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/VarianceEquivalenceTest.html
        ///</summary>
        corewolf::engine *VarianceEquivalenceTest(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VarianceEquivalenceTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a variance‐gamma distribution with location parameter μ, skewness parameter β, and shape parameters λ and α.
        /// https://reference.wolfram.com/language/ref/VarianceGammaDistribution.html
        ///</summary>
        corewolf::engine *VarianceGammaDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("VarianceGammaDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents a variance gamma cluster point process with density μ, cluster mean λ and shape parameters α and β in .
        /// https://reference.wolfram.com/language/ref/VarianceGammaPointProcess.html
        ///</summary>
        corewolf::engine *VarianceGammaPointProcess(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("VarianceGammaPointProcess[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// tests whether the variance of the data is one.
        /// https://reference.wolfram.com/language/ref/VarianceTest.html
        ///</summary>
        corewolf::engine *VarianceTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VarianceTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the variances of data1 and data2 are equal.
        /// https://reference.wolfram.com/language/ref/VarianceTest.html
        ///</summary>
        corewolf::engine *VarianceTest(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("VarianceTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// tests a dispersion measure against σ02.
        /// https://reference.wolfram.com/language/ref/VarianceTest.html
        ///</summary>
        corewolf::engine *VarianceTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VarianceTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/VarianceTest.html
        ///</summary>
        corewolf::engine *VarianceTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VarianceTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the function for the variogram model specified by "model".
        /// https://reference.wolfram.com/language/ref/VariogramModel.html
        ///</summary>
        corewolf::engine *VariogramModel(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VariogramModel[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the angle between the vectors u and v.
        /// https://reference.wolfram.com/language/ref/VectorAngle.html
        ///</summary>
        corewolf::engine *VectorAngle(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VectorAngle[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a vector of uncorrelated approximate numbers or quantities with values xi and uncertainties δi.
        /// https://reference.wolfram.com/language/ref/VectorAround.html
        ///</summary>
        corewolf::engine *VectorAround(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VectorAround[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents a vector of approximate numbers or quantities with values xi and covariance matrix Δ.
        /// https://reference.wolfram.com/language/ref/VectorAround.html
        ///</summary>
        corewolf::engine *VectorAround(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("VectorAround[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents a vector of approximate numbers or quantities with uncertainties δi and correlation matrix R.
        /// https://reference.wolfram.com/language/ref/VectorAround.html
        ///</summary>
        corewolf::engine *VectorAround(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("VectorAround[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// generates a vector plot of the vector field {vx,vy} as a function of x and y, superimposed on a density plot of the scalar field s.
        /// https://reference.wolfram.com/language/ref/VectorDensityPlot.html
        ///</summary>
        corewolf::engine *VectorDensityPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("VectorDensityPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// plots several vector fields.
        /// https://reference.wolfram.com/language/ref/VectorDensityPlot.html
        ///</summary>
        corewolf::engine *VectorDensityPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("VectorDensityPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// takes the variables {x,y} to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/VectorDensityPlot.html
        ///</summary>
        corewolf::engine *VectorDensityPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VectorDensityPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a displacement plot for the vector field {vx,vy} as a function of x and y.
        /// https://reference.wolfram.com/language/ref/VectorDisplacementPlot.html
        ///</summary>
        corewolf::engine *VectorDisplacementPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("VectorDisplacementPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// plots the displacement over the geometric region reg.
        /// https://reference.wolfram.com/language/ref/VectorDisplacementPlot.html
        ///</summary>
        corewolf::engine *VectorDisplacementPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VectorDisplacementPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a displacement plot of the vector field {vx,vy,vz} as a function of x, y and z.
        /// https://reference.wolfram.com/language/ref/VectorDisplacementPlot3D.html
        ///</summary>
        corewolf::engine *VectorDisplacementPlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("VectorDisplacementPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// plots the displacement over the geometric region reg.
        /// https://reference.wolfram.com/language/ref/VectorDisplacementPlot3D.html
        ///</summary>
        corewolf::engine *VectorDisplacementPlot3D(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VectorDisplacementPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True for vectors of length n if xi>yi for all components .
        /// https://reference.wolfram.com/language/ref/VectorGreater.html
        ///</summary>
        corewolf::engine *VectorGreater(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VectorGreater[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True for x and y if , where κ is a proper convex cone.
        /// https://reference.wolfram.com/language/ref/VectorGreater.html
        ///</summary>
        corewolf::engine *VectorGreater(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VectorGreater[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True for vectors of length n if xi≥yi for all components .
        /// https://reference.wolfram.com/language/ref/VectorGreaterEqual.html
        ///</summary>
        corewolf::engine *VectorGreaterEqual(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VectorGreaterEqual[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True for x and y if x-y∈κ, where κ is a proper convex cone.
        /// https://reference.wolfram.com/language/ref/VectorGreaterEqual.html
        ///</summary>
        corewolf::engine *VectorGreaterEqual(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VectorGreaterEqual[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True for vectors of length n if xi<yi for all components .
        /// https://reference.wolfram.com/language/ref/VectorLess.html
        ///</summary>
        corewolf::engine *VectorLess(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VectorLess[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True for x and y if , where κ is a proper convex cone.
        /// https://reference.wolfram.com/language/ref/VectorLess.html
        ///</summary>
        corewolf::engine *VectorLess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VectorLess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True for vectors of length n if xi≤yi for all components .
        /// https://reference.wolfram.com/language/ref/VectorLessEqual.html
        ///</summary>
        corewolf::engine *VectorLessEqual(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VectorLessEqual[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True for x and y if y-x∈κ, where κ is a proper convex cone.
        /// https://reference.wolfram.com/language/ref/VectorLessEqual.html
        ///</summary>
        corewolf::engine *VectorLessEqual(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VectorLessEqual[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a vector plot of the vector field {vx,vy} as a function of x and y.
        /// https://reference.wolfram.com/language/ref/VectorPlot.html
        ///</summary>
        corewolf::engine *VectorPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("VectorPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// plots several vector fields.
        /// https://reference.wolfram.com/language/ref/VectorPlot.html
        ///</summary>
        corewolf::engine *VectorPlot(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("VectorPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// takes the variables {x,y} to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/VectorPlot.html
        ///</summary>
        corewolf::engine *VectorPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VectorPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// generates a 3D vector plot of the vector field {vx,vy,vz} as a function of x, y, and z.
        /// https://reference.wolfram.com/language/ref/VectorPlot3D.html
        ///</summary>
        corewolf::engine *VectorPlot3D(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("VectorPlot3D[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// takes the variables {x,y,z} to be in the geometric region reg.
        /// https://reference.wolfram.com/language/ref/VectorPlot3D.html
        ///</summary>
        corewolf::engine *VectorPlot3D(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VectorPlot3D[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives True if expr is a list or a one‐dimensional SparseArray object, none of whose elements are themselves lists, and gives False otherwise.
        /// https://reference.wolfram.com/language/ref/VectorQ.html
        ///</summary>
        corewolf::engine *VectorQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VectorQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives True only if test yields True when applied to each of the elements in expr.
        /// https://reference.wolfram.com/language/ref/VectorQ.html
        ///</summary>
        corewolf::engine *VectorQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VectorQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the domain of vectors of dimension d.
        /// https://reference.wolfram.com/language/ref/Vectors.html
        ///</summary>
        corewolf::engine *Vectors(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Vectors[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the domain of vectors of dimension d, with components in the domain dom.
        /// https://reference.wolfram.com/language/ref/Vectors.html
        ///</summary>
        corewolf::engine *Vectors(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Vectors[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/Vee.html
        ///</summary>
        corewolf::engine *Vee(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Vee[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents expr in pattern matching, requiring that expr be matched exactly as it appears, with no substitutions for blanks or other transformations.
        /// https://reference.wolfram.com/language/ref/Verbatim.html
        ///</summary>
        corewolf::engine *Verbatim(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Verbatim[" + arg0 + "]", name);
        }

        ///< summary>
        /// runs a verification test to determine whether input evaluates to True, without issuing messages.
        /// https://reference.wolfram.com/language/ref/VerificationTest.html
        ///</summary>
        corewolf::engine *VerificationTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VerificationTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether input evaluates to expected, without issuing messages.
        /// https://reference.wolfram.com/language/ref/VerificationTest.html
        ///</summary>
        corewolf::engine *VerificationTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VerificationTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether input evaluates to expected, generating the list of message names messages.
        /// https://reference.wolfram.com/language/ref/VerificationTest.html
        ///</summary>
        corewolf::engine *VerificationTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VerificationTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// verifies that password matches the password used to generate the derived key.
        /// https://reference.wolfram.com/language/ref/VerifyDerivedKey.html
        ///</summary>
        corewolf::engine *VerifyDerivedKey(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VerifyDerivedKey[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// verifies the digital signature sig for expr using the specified public key.
        /// https://reference.wolfram.com/language/ref/VerifyDigitalSignature.html
        ///</summary>
        corewolf::engine *VerifyDigitalSignature(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VerifyDigitalSignature[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// verifies the digital signatures sigi for each of the expri, all using the specified public key.
        /// https://reference.wolfram.com/language/ref/VerifyDigitalSignature.html
        ///</summary>
        corewolf::engine *VerifyDigitalSignature(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VerifyDigitalSignature[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is an operator form of VerifyDigitalSignature, suitable for application to {expr,sig} or a list of such pairs.
        /// https://reference.wolfram.com/language/ref/VerifyDigitalSignature.html
        ///</summary>
        corewolf::engine *VerifyDigitalSignature(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VerifyDigitalSignature[" + arg0 + "]", name);
        }

        ///< summary>
        /// verifies the digital signature sig for file using the specified public key.
        /// https://reference.wolfram.com/language/ref/VerifyFileSignature.html
        ///</summary>
        corewolf::engine *VerifyFileSignature(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VerifyFileSignature[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// verifies the digital signatures sigi for each of rangei of bytes in the filei, all using the specified public key.
        /// https://reference.wolfram.com/language/ref/VerifyFileSignature.html
        ///</summary>
        corewolf::engine *VerifyFileSignature(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VerifyFileSignature[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an operator form of VerifyFileSignature that can be applied to files.
        /// https://reference.wolfram.com/language/ref/VerifyFileSignature.html
        ///</summary>
        corewolf::engine *VerifyFileSignature(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VerifyFileSignature[" + arg0 + "]", name);
        }

        ///< summary>
        /// makes a graph by adding the vertex v to the graph g.
        /// https://reference.wolfram.com/language/ref/VertexAdd.html
        ///</summary>
        corewolf::engine *VertexAdd(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexAdd[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// adds a collection of vertices to g.
        /// https://reference.wolfram.com/language/ref/VertexAdd.html
        ///</summary>
        corewolf::engine *VertexAdd(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VertexAdd[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexAdd.html
        ///</summary>
        corewolf::engine *VertexAdd(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexAdd[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the chromatic number for the vertices of the graph g.
        /// https://reference.wolfram.com/language/ref/VertexChromaticNumber.html
        ///</summary>
        corewolf::engine *VertexChromaticNumber(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VertexChromaticNumber[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the vertices in the graph g that have a path to at least one of v1, v2, … .
        /// https://reference.wolfram.com/language/ref/VertexComponent.html
        ///</summary>
        corewolf::engine *VertexComponent(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VertexComponent[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the vertices with a path to at least one of v1, v2, … of at most length k.
        /// https://reference.wolfram.com/language/ref/VertexComponent.html
        ///</summary>
        corewolf::engine *VertexComponent(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VertexComponent[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the vertices at length exactly k.
        /// https://reference.wolfram.com/language/ref/VertexComponent.html
        ///</summary>
        corewolf::engine *VertexComponent(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("VertexComponent[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexComponent.html
        ///</summary>
        corewolf::engine *VertexComponent(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexComponent[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the vertex connectivity of the graph g.
        /// https://reference.wolfram.com/language/ref/VertexConnectivity.html
        ///</summary>
        corewolf::engine *VertexConnectivity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VertexConnectivity[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the s-t vertex connectivity of the graph g.
        /// https://reference.wolfram.com/language/ref/VertexConnectivity.html
        ///</summary>
        corewolf::engine *VertexConnectivity(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VertexConnectivity[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexConnectivity.html
        ///</summary>
        corewolf::engine *VertexConnectivity(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexConnectivity[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// contracts a collection of vertices v1, v2, … into a single vertex of the graph g.
        /// https://reference.wolfram.com/language/ref/VertexContract.html
        ///</summary>
        corewolf::engine *VertexContract(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VertexContract[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexContract.html
        ///</summary>
        corewolf::engine *VertexContract(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexContract[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the correlation similarity between vertices u and v of the graph g.
        /// https://reference.wolfram.com/language/ref/VertexCorrelationSimilarity.html
        ///</summary>
        corewolf::engine *VertexCorrelationSimilarity(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VertexCorrelationSimilarity[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexCorrelationSimilarity.html
        ///</summary>
        corewolf::engine *VertexCorrelationSimilarity(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexCorrelationSimilarity[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the cosine similarity between vertices u and v of the graph g.
        /// https://reference.wolfram.com/language/ref/VertexCosineSimilarity.html
        ///</summary>
        corewolf::engine *VertexCosineSimilarity(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VertexCosineSimilarity[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexCosineSimilarity.html
        ///</summary>
        corewolf::engine *VertexCosineSimilarity(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexCosineSimilarity[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a count of the number of vertices in the graph g.
        /// https://reference.wolfram.com/language/ref/VertexCount.html
        ///</summary>
        corewolf::engine *VertexCount(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VertexCount[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a count of the number of vertices that match the pattern patt.
        /// https://reference.wolfram.com/language/ref/VertexCount.html
        ///</summary>
        corewolf::engine *VertexCount(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexCount[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexCount.html
        ///</summary>
        corewolf::engine *VertexCount(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexCount[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if the vertex list vlist is a vertex cover of the graph g, and False otherwise.
        /// https://reference.wolfram.com/language/ref/VertexCoverQ.html
        ///</summary>
        corewolf::engine *VertexCoverQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexCoverQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of vertex degrees for all vertices in the graph g.
        /// https://reference.wolfram.com/language/ref/VertexDegree.html
        ///</summary>
        corewolf::engine *VertexDegree(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VertexDegree[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the vertex degree for the vertex v.
        /// https://reference.wolfram.com/language/ref/VertexDegree.html
        ///</summary>
        corewolf::engine *VertexDegree(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexDegree[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexDegree.html
        ///</summary>
        corewolf::engine *VertexDegree(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexDegree[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// makes a graph by deleting the vertex ν and all edges connected to v from the graph g.
        /// https://reference.wolfram.com/language/ref/VertexDelete.html
        ///</summary>
        corewolf::engine *VertexDelete(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexDelete[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// deletes a collection of vertices from g.
        /// https://reference.wolfram.com/language/ref/VertexDelete.html
        ///</summary>
        corewolf::engine *VertexDelete(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VertexDelete[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexDelete.html
        ///</summary>
        corewolf::engine *VertexDelete(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexDelete[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Dice similarity between vertices u and v of the graph g.
        /// https://reference.wolfram.com/language/ref/VertexDiceSimilarity.html
        ///</summary>
        corewolf::engine *VertexDiceSimilarity(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VertexDiceSimilarity[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexDiceSimilarity.html
        ///</summary>
        corewolf::engine *VertexDiceSimilarity(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexDiceSimilarity[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the length of the longest shortest path from the source s to every other vertex in the graph g.
        /// https://reference.wolfram.com/language/ref/VertexEccentricity.html
        ///</summary>
        corewolf::engine *VertexEccentricity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexEccentricity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexEccentricity.html
        ///</summary>
        corewolf::engine *VertexEccentricity(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexEccentricity[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the vertices in the graph g that have a directed path to at least one of v1, v2, … .
        /// https://reference.wolfram.com/language/ref/VertexInComponent.html
        ///</summary>
        corewolf::engine *VertexInComponent(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VertexInComponent[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the vertices with a directed path to at least one of v1, v2, … of at most length k.
        /// https://reference.wolfram.com/language/ref/VertexInComponent.html
        ///</summary>
        corewolf::engine *VertexInComponent(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VertexInComponent[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the vertices at length exactly k.
        /// https://reference.wolfram.com/language/ref/VertexInComponent.html
        ///</summary>
        corewolf::engine *VertexInComponent(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("VertexInComponent[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexInComponent.html
        ///</summary>
        corewolf::engine *VertexInComponent(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexInComponent[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the subgraph of the graph g generated by the vertices that have a directed path to at least one of v1,v2,….
        /// https://reference.wolfram.com/language/ref/VertexInComponentGraph.html
        ///</summary>
        corewolf::engine *VertexInComponentGraph(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VertexInComponentGraph[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the subgraph of g generated by vertices with a directed path of at most length k to at least one of v1,v2,….
        /// https://reference.wolfram.com/language/ref/VertexInComponentGraph.html
        ///</summary>
        corewolf::engine *VertexInComponentGraph(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VertexInComponentGraph[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the subgraph of g generated by vertices of length exactly k.
        /// https://reference.wolfram.com/language/ref/VertexInComponentGraph.html
        ///</summary>
        corewolf::engine *VertexInComponentGraph(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("VertexInComponentGraph[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexInComponentGraph.html
        ///</summary>
        corewolf::engine *VertexInComponentGraph(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexInComponentGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of vertex in-degrees for all vertices in the graph g.
        /// https://reference.wolfram.com/language/ref/VertexInDegree.html
        ///</summary>
        corewolf::engine *VertexInDegree(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VertexInDegree[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the vertex in-degree for the vertex v.
        /// https://reference.wolfram.com/language/ref/VertexInDegree.html
        ///</summary>
        corewolf::engine *VertexInDegree(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexInDegree[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexInDegree.html
        ///</summary>
        corewolf::engine *VertexInDegree(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexInDegree[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the integer index for the vertex v in the graph g.
        /// https://reference.wolfram.com/language/ref/VertexIndex.html
        ///</summary>
        corewolf::engine *VertexIndex(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexIndex[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexIndex.html
        ///</summary>
        corewolf::engine *VertexIndex(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexIndex[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Jaccard similarity between vertices u and v of the graph g.
        /// https://reference.wolfram.com/language/ref/VertexJaccardSimilarity.html
        ///</summary>
        corewolf::engine *VertexJaccardSimilarity(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VertexJaccardSimilarity[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexJaccardSimilarity.html
        ///</summary>
        corewolf::engine *VertexJaccardSimilarity(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexJaccardSimilarity[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of vertices for the graph g.
        /// https://reference.wolfram.com/language/ref/VertexList.html
        ///</summary>
        corewolf::engine *VertexList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VertexList[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of vertices that match the pattern patt.
        /// https://reference.wolfram.com/language/ref/VertexList.html
        ///</summary>
        corewolf::engine *VertexList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexList.html
        ///</summary>
        corewolf::engine *VertexList(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexList[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the vertices in the graph g that have a directed path from at least one of v1, v2, ….
        /// https://reference.wolfram.com/language/ref/VertexOutComponent.html
        ///</summary>
        corewolf::engine *VertexOutComponent(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VertexOutComponent[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the vertices with a directed path from at least one of v1, v2, … of at most length k.
        /// https://reference.wolfram.com/language/ref/VertexOutComponent.html
        ///</summary>
        corewolf::engine *VertexOutComponent(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VertexOutComponent[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the vertices at length exactly k.
        /// https://reference.wolfram.com/language/ref/VertexOutComponent.html
        ///</summary>
        corewolf::engine *VertexOutComponent(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("VertexOutComponent[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexOutComponent.html
        ///</summary>
        corewolf::engine *VertexOutComponent(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexOutComponent[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the subgraph of the graph g generated by the vertices that have a directed path from at least one of v1,v2,….
        /// https://reference.wolfram.com/language/ref/VertexOutComponentGraph.html
        ///</summary>
        corewolf::engine *VertexOutComponentGraph(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VertexOutComponentGraph[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the subgraph of g generated by vertices with a directed path of at most length k from at least one of v1,v2,….
        /// https://reference.wolfram.com/language/ref/VertexOutComponentGraph.html
        ///</summary>
        corewolf::engine *VertexOutComponentGraph(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VertexOutComponentGraph[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the subgraph of g generated by vertices of length exactly k.
        /// https://reference.wolfram.com/language/ref/VertexOutComponentGraph.html
        ///</summary>
        corewolf::engine *VertexOutComponentGraph(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("VertexOutComponentGraph[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexOutComponentGraph.html
        ///</summary>
        corewolf::engine *VertexOutComponentGraph(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexOutComponentGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the list of vertex out-degrees for all vertices in the graph g.
        /// https://reference.wolfram.com/language/ref/VertexOutDegree.html
        ///</summary>
        corewolf::engine *VertexOutDegree(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VertexOutDegree[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the vertex out-degree for the vertex v.
        /// https://reference.wolfram.com/language/ref/VertexOutDegree.html
        ///</summary>
        corewolf::engine *VertexOutDegree(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexOutDegree[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexOutDegree.html
        ///</summary>
        corewolf::engine *VertexOutDegree(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexOutDegree[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if v is a vertex in the graph g and False otherwise.
        /// https://reference.wolfram.com/language/ref/VertexQ.html
        ///</summary>
        corewolf::engine *VertexQ(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexQ[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces each vertex vi in the graph g by wi.
        /// https://reference.wolfram.com/language/ref/VertexReplace.html
        ///</summary>
        corewolf::engine *VertexReplace(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VertexReplace[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/VertexReplace.html
        ///</summary>
        corewolf::engine *VertexReplace(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VertexReplace[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is a vertex–transitive graph and False otherwise.
        /// https://reference.wolfram.com/language/ref/VertexTransitiveGraphQ.html
        ///</summary>
        corewolf::engine *VertexTransitiveGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VertexTransitiveGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is a vertex-weighted graph, and False otherwise.
        /// https://reference.wolfram.com/language/ref/VertexWeightedGraphQ.html
        ///</summary>
        corewolf::engine *VertexWeightedGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VertexWeightedGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/VerticalBar.html
        ///</summary>
        corewolf::engine *VerticalBar(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VerticalBar[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// draws a linear gauge showing value in a range of 0 to 1.
        /// https://reference.wolfram.com/language/ref/VerticalGauge.html
        ///</summary>
        corewolf::engine *VerticalGauge(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VerticalGauge[" + arg0 + "]", name);
        }

        ///< summary>
        /// draws a linear gauge showing value in a range of min to max.
        /// https://reference.wolfram.com/language/ref/VerticalGauge.html
        ///</summary>
        corewolf::engine *VerticalGauge(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VerticalGauge[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// allows value to be set interactively using the gauge.
        /// https://reference.wolfram.com/language/ref/VerticalGauge.html
        ///</summary>
        corewolf::engine *VerticalGauge(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VerticalGauge[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// draws a gauge showing multiple values.
        /// https://reference.wolfram.com/language/ref/VerticalGauge.html
        ///</summary>
        corewolf::engine *VerticalGauge(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VerticalGauge[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/VerticalSeparator.html
        ///</summary>
        corewolf::engine *VerticalSeparator(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VerticalSeparator[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a vertical slider at position y with range 0 to 1.
        /// https://reference.wolfram.com/language/ref/VerticalSlider.html
        ///</summary>
        corewolf::engine *VerticalSlider(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VerticalSlider[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a vertical slider with range ymin to ymax.
        /// https://reference.wolfram.com/language/ref/VerticalSlider.html
        ///</summary>
        corewolf::engine *VerticalSlider(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VerticalSlider[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses intervals of relative heights hi for the ei.
        /// https://reference.wolfram.com/language/ref/VerticalSlider.html
        ///</summary>
        corewolf::engine *VerticalSlider(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("VerticalSlider[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// displays as .
        /// https://reference.wolfram.com/language/ref/VerticalTilde.html
        ///</summary>
        corewolf::engine *VerticalTilde(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VerticalTilde[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents video stored in the given file.
        /// https://reference.wolfram.com/language/ref/Video.html
        ///</summary>
        corewolf::engine *Video(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Video[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a temporary interactive interface for capturing a video from an imaging device.
        /// https://reference.wolfram.com/language/ref/VideoCapture.html
        ///</summary>
        corewolf::engine *VideoCapture(const std::string &name = "")
        {
            return this->execute("VideoCapture[]", name);
        }

        ///< summary>
        /// creates a non-blocking asynchronous interface to capture video and saves the result in var.
        /// https://reference.wolfram.com/language/ref/VideoCapture.html
        ///</summary>
        corewolf::engine *VideoCapture(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VideoCapture[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a multi-track video by combining all tracks of Video or Audio objects obji.
        /// https://reference.wolfram.com/language/ref/VideoCombine.html
        ///</summary>
        corewolf::engine *VideoCombine(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("VideoCombine[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// deletes the first t seconds of video.
        /// https://reference.wolfram.com/language/ref/VideoDelete.html
        ///</summary>
        corewolf::engine *VideoDelete(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VideoDelete[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// deletes from time t1 to time t2, returning the remaining video as a single Video object.
        /// https://reference.wolfram.com/language/ref/VideoDelete.html
        ///</summary>
        corewolf::engine *VideoDelete(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VideoDelete[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// extracts a frame at time t from video.
        /// https://reference.wolfram.com/language/ref/VideoExtractFrames.html
        ///</summary>
        corewolf::engine *VideoExtractFrames(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VideoExtractFrames[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of n images extracted from video.
        /// https://reference.wolfram.com/language/ref/VideoFrameList.html
        ///</summary>
        corewolf::engine *VideoFrameList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VideoFrameList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f to each frame of the Video const std::string &video, returning a new Video object.
        /// https://reference.wolfram.com/language/ref/VideoFrameMap.html
        ///</summary>
        corewolf::engine *VideoFrameMap(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VideoFrameMap[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f to overlapping partitions of n video frames.
        /// https://reference.wolfram.com/language/ref/VideoFrameMap.html
        ///</summary>
        corewolf::engine *VideoFrameMap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VideoFrameMap[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies f to partitions with offset d.
        /// https://reference.wolfram.com/language/ref/VideoFrameMap.html
        ///</summary>
        corewolf::engine *VideoFrameMap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("VideoFrameMap[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// applies f to a list of inputs extracted from each videoi.
        /// https://reference.wolfram.com/language/ref/VideoFrameMap.html
        ///</summary>
        corewolf::engine *VideoFrameMap(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VideoFrameMap[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates one second of video of a given model.
        /// https://reference.wolfram.com/language/ref/VideoGenerator.html
        ///</summary>
        corewolf::engine *VideoGenerator(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VideoGenerator[" + arg0 + "]", name);
        }

        ///< summary>
        /// generates a video of duration dur.
        /// https://reference.wolfram.com/language/ref/VideoGenerator.html
        ///</summary>
        corewolf::engine *VideoGenerator(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VideoGenerator[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// inserts the video new at time t.
        /// https://reference.wolfram.com/language/ref/VideoInsert.html
        ///</summary>
        corewolf::engine *VideoInsert(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VideoInsert[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// inserts multiple videos at different positions.
        /// https://reference.wolfram.com/language/ref/VideoInsert.html
        ///</summary>
        corewolf::engine *VideoInsert(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VideoInsert[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns time intervals of video for which the criterion crit is satisfied.
        /// https://reference.wolfram.com/language/ref/VideoIntervals.html
        ///</summary>
        corewolf::engine *VideoIntervals(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VideoIntervals[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates criterion crit on partitions of n video frames.
        /// https://reference.wolfram.com/language/ref/VideoIntervals.html
        ///</summary>
        corewolf::engine *VideoIntervals(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VideoIntervals[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// evaluates crit on partitions with offset d.
        /// https://reference.wolfram.com/language/ref/VideoIntervals.html
        ///</summary>
        corewolf::engine *VideoIntervals(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("VideoIntervals[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// applies crit to a list of inputs extracted from each videoi.
        /// https://reference.wolfram.com/language/ref/VideoIntervals.html
        ///</summary>
        corewolf::engine *VideoIntervals(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VideoIntervals[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// concatenates all videoi and returns a video object.
        /// https://reference.wolfram.com/language/ref/VideoJoin.html
        ///</summary>
        corewolf::engine *VideoJoin(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VideoJoin[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies f to partial video and audio data corresponding to one frame of video, returning a new video.
        /// https://reference.wolfram.com/language/ref/VideoMap.html
        ///</summary>
        corewolf::engine *VideoMap(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VideoMap[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f to data corresponding to overlapping partitions of n video frames.
        /// https://reference.wolfram.com/language/ref/VideoMap.html
        ///</summary>
        corewolf::engine *VideoMap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VideoMap[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies f to partitions with offset d.
        /// https://reference.wolfram.com/language/ref/VideoMap.html
        ///</summary>
        corewolf::engine *VideoMap(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("VideoMap[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// applies f to a list of inputs extracted from each videoi.
        /// https://reference.wolfram.com/language/ref/VideoMap.html
        ///</summary>
        corewolf::engine *VideoMap(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VideoMap[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies f to a chunk of data corresponding to one frame from the Video const std::string &video, returning a list of results.
        /// https://reference.wolfram.com/language/ref/VideoMapList.html
        ///</summary>
        corewolf::engine *VideoMapList(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VideoMapList[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f to overlapping partitions corresponding to n video frames.
        /// https://reference.wolfram.com/language/ref/VideoMapList.html
        ///</summary>
        corewolf::engine *VideoMapList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VideoMapList[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies f to partitions with offset d.
        /// https://reference.wolfram.com/language/ref/VideoMapList.html
        ///</summary>
        corewolf::engine *VideoMapList(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("VideoMapList[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// applies f to a list of inputs extracted from each videoi.
        /// https://reference.wolfram.com/language/ref/VideoMapList.html
        ///</summary>
        corewolf::engine *VideoMapList(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VideoMapList[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies f to each frame of the Video const std::string &video, returning a time series.
        /// https://reference.wolfram.com/language/ref/VideoMapTimeSeries.html
        ///</summary>
        corewolf::engine *VideoMapTimeSeries(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VideoMapTimeSeries[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f to overlapping partitions of n video frames.
        /// https://reference.wolfram.com/language/ref/VideoMapTimeSeries.html
        ///</summary>
        corewolf::engine *VideoMapTimeSeries(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VideoMapTimeSeries[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// applies f to partitions with offset d.
        /// https://reference.wolfram.com/language/ref/VideoMapTimeSeries.html
        ///</summary>
        corewolf::engine *VideoMapTimeSeries(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("VideoMapTimeSeries[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// applies f to a list of inputs extracted from each videoi.
        /// https://reference.wolfram.com/language/ref/VideoMapTimeSeries.html
        ///</summary>
        corewolf::engine *VideoMapTimeSeries(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VideoMapTimeSeries[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// pauses the playback of all VideoStream objects.
        /// https://reference.wolfram.com/language/ref/VideoPause.html
        ///</summary>
        corewolf::engine *VideoPause(const std::string &name = "")
        {
            return this->execute("VideoPause[]", name);
        }

        ///< summary>
        /// pauses the playback of the VideoStream const std::string &vstream.
        /// https://reference.wolfram.com/language/ref/VideoPause.html
        ///</summary>
        corewolf::engine *VideoPause(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VideoPause[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a new VideoStream const std::string &from video and starts the playback.
        /// https://reference.wolfram.com/language/ref/VideoPlay.html
        ///</summary>
        corewolf::engine *VideoPlay(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VideoPlay[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields True if video has the form of a valid Video object, and False otherwise.
        /// https://reference.wolfram.com/language/ref/VideoQ.html
        ///</summary>
        corewolf::engine *VideoQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VideoQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a VideoStream const std::string &and records from source.
        /// https://reference.wolfram.com/language/ref/VideoRecord.html
        ///</summary>
        corewolf::engine *VideoRecord(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VideoRecord[" + arg0 + "]", name);
        }

        ///< summary>
        /// replaces the video between t1 and t2 with the new video new.
        /// https://reference.wolfram.com/language/ref/VideoReplace.html
        ///</summary>
        corewolf::engine *VideoReplace(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VideoReplace[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// replaces multiple intervals.
        /// https://reference.wolfram.com/language/ref/VideoReplace.html
        ///</summary>
        corewolf::engine *VideoReplace(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VideoReplace[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses the specified durfitting method to replace an interval of a different duration.
        /// https://reference.wolfram.com/language/ref/VideoReplace.html
        ///</summary>
        corewolf::engine *VideoReplace(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VideoReplace[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// creates a temporary interactive interface for capturing from the main screen into a video.
        /// https://reference.wolfram.com/language/ref/VideoScreenCapture.html
        ///</summary>
        corewolf::engine *VideoScreenCapture(const std::string &name = "")
        {
            return this->execute("VideoScreenCapture[]", name);
        }

        ///< summary>
        /// captures from a screen or part of a screen specified by source.
        /// https://reference.wolfram.com/language/ref/VideoScreenCapture.html
        ///</summary>
        corewolf::engine *VideoScreenCapture(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VideoScreenCapture[" + arg0 + "]", name);
        }

        ///< summary>
        /// captures asynchronously from the specified source.
        /// https://reference.wolfram.com/language/ref/VideoScreenCapture.html
        ///</summary>
        corewolf::engine *VideoScreenCapture(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VideoScreenCapture[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// splits video at time t.
        /// https://reference.wolfram.com/language/ref/VideoSplit.html
        ///</summary>
        corewolf::engine *VideoSplit(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VideoSplit[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// splits video at times ti.
        /// https://reference.wolfram.com/language/ref/VideoSplit.html
        ///</summary>
        corewolf::engine *VideoSplit(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VideoSplit[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// stops the playback of all VideoStream objects.
        /// https://reference.wolfram.com/language/ref/VideoStop.html
        ///</summary>
        corewolf::engine *VideoStop(const std::string &name = "")
        {
            return this->execute("VideoStop[]", name);
        }

        ///< summary>
        /// stops the playback of the VideoStream const std::string &vstream.
        /// https://reference.wolfram.com/language/ref/VideoStop.html
        ///</summary>
        corewolf::engine *VideoStop(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VideoStop[" + arg0 + "]", name);
        }

        ///< summary>
        /// creates a new VideoStream const std::string &from source.
        /// https://reference.wolfram.com/language/ref/VideoStream.html
        ///</summary>
        corewolf::engine *VideoStream(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VideoStream[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns all existing video streams.
        /// https://reference.wolfram.com/language/ref/VideoStreams.html
        ///</summary>
        corewolf::engine *VideoStreams(const std::string &name = "")
        {
            return this->execute("VideoStreams[]", name);
        }

        ///< summary>
        /// applies time stretching to video using the specified spec.
        /// https://reference.wolfram.com/language/ref/VideoTimeStretch.html
        ///</summary>
        corewolf::engine *VideoTimeStretch(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VideoTimeStretch[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts video to the specified format.
        /// https://reference.wolfram.com/language/ref/VideoTranscode.html
        ///</summary>
        corewolf::engine *VideoTranscode(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VideoTranscode[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the first t seconds of video.
        /// https://reference.wolfram.com/language/ref/VideoTrim.html
        ///</summary>
        corewolf::engine *VideoTrim(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VideoTrim[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns video starting at time t1 and ending at time t2 of video.
        /// https://reference.wolfram.com/language/ref/VideoTrim.html
        ///</summary>
        corewolf::engine *VideoTrim(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VideoTrim[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the list of available voices for speech synthesis.
        /// https://reference.wolfram.com/language/ref/VoiceStyleData.html
        ///</summary>
        corewolf::engine *VoiceStyleData(const std::string &name = "")
        {
            return this->execute("VoiceStyleData[]", name);
        }

        ///< summary>
        /// returns all properties for the specified voice.
        /// https://reference.wolfram.com/language/ref/VoiceStyleData.html
        ///</summary>
        corewolf::engine *VoiceStyleData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("VoiceStyleData[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns the specified property prop for voice.
        /// https://reference.wolfram.com/language/ref/VoiceStyleData.html
        ///</summary>
        corewolf::engine *VoiceStyleData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VoiceStyleData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents Voigt distribution with parameters δ and σ.
        /// https://reference.wolfram.com/language/ref/VoigtDistribution.html
        ///</summary>
        corewolf::engine *VoigtDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VoigtDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the volcano entity.
        /// https://reference.wolfram.com/language/ref/VolcanoData.html
        ///</summary>
        corewolf::engine *VolcanoData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VolcanoData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified volcano entities.
        /// https://reference.wolfram.com/language/ref/VolcanoData.html
        ///</summary>
        corewolf::engine *VolcanoData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VolcanoData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/VolcanoData.html
        ///</summary>
        corewolf::engine *VolcanoData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("VolcanoData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the volume of the three-dimensional region reg.
        /// https://reference.wolfram.com/language/ref/Volume.html
        ///</summary>
        corewolf::engine *Volume(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Volume[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the volume of the parametrized region whose Cartesian coordinates xi are functions of s, t, u.
        /// https://reference.wolfram.com/language/ref/Volume.html
        ///</summary>
        corewolf::engine *Volume(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &name = "")
        {
            return this->execute("Volume[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + "]", name);
        }

        ///< summary>
        /// interprets the xi as coordinates in the specified coordinate chart.
        /// https://reference.wolfram.com/language/ref/Volume.html
        ///</summary>
        corewolf::engine *Volume(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::vector<std::string> &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("Volume[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg3) + "}" + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// represents a von Mises distribution with mean μ and concentration κ.
        /// https://reference.wolfram.com/language/ref/VonMisesDistribution.html
        ///</summary>
        corewolf::engine *VonMisesDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("VonMisesDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a MeshRegion representing the Voronoi mesh from the points p1, p2, ….
        /// https://reference.wolfram.com/language/ref/VoronoiMesh.html
        ///</summary>
        corewolf::engine *VoronoiMesh(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("VoronoiMesh[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// clips the mesh to the bounds .
        /// https://reference.wolfram.com/language/ref/VoronoiMesh.html
        ///</summary>
        corewolf::engine *VoronoiMesh(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("VoronoiMesh[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// waits for all concurrent evaluations represented by EvaluationObject expressions in expr to finish, then returns the resulting expression obtained.
        /// https://reference.wolfram.com/language/ref/WaitAll.html
        ///</summary>
        corewolf::engine *WaitAll(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WaitAll[" + arg0 + "]", name);
        }

        ///< summary>
        /// waits until the first evaluation represented by any of the eidi finishes, then returns its result, the corresponding eidi, and the list of remaining eidk.
        /// https://reference.wolfram.com/language/ref/WaitNext.html
        ///</summary>
        corewolf::engine *WaitNext(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WaitNext[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// wraps the head h around the result before returning it.
        /// https://reference.wolfram.com/language/ref/WaitNext.html
        ///</summary>
        corewolf::engine *WaitNext(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WaitNext[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents Wakeby distribution with shape parameters β and δ, scale parameters α and γ, and location parameter μ.
        /// https://reference.wolfram.com/language/ref/WakebyDistribution.html
        ///</summary>
        corewolf::engine *WakebyDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("WakebyDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// represents a Wallenius noncentral hypergeometric distribution.
        /// https://reference.wolfram.com/language/ref/WalleniusHypergeometricDistribution.html
        ///</summary>
        corewolf::engine *WalleniusHypergeometricDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("WalleniusHypergeometricDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// represents the Yule distribution with shape parameter α.
        /// https://reference.wolfram.com/language/ref/WaringYuleDistribution.html
        ///</summary>
        corewolf::engine *WaringYuleDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WaringYuleDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the Waring distribution with shape parameters α and β.
        /// https://reference.wolfram.com/language/ref/WaringYuleDistribution.html
        ///</summary>
        corewolf::engine *WaringYuleDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WaringYuleDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the time warping (DTW) similarity path between sequences s1 and s2.
        /// https://reference.wolfram.com/language/ref/WarpingCorrespondence.html
        ///</summary>
        corewolf::engine *WarpingCorrespondence(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WarpingCorrespondence[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses a window specified by win for local search.
        /// https://reference.wolfram.com/language/ref/WarpingCorrespondence.html
        ///</summary>
        corewolf::engine *WarpingCorrespondence(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WarpingCorrespondence[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the dynamic time warping (DTW) distance between sequences s1 and s2.
        /// https://reference.wolfram.com/language/ref/WarpingDistance.html
        ///</summary>
        corewolf::engine *WarpingDistance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WarpingDistance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses a window specified by win for local search.
        /// https://reference.wolfram.com/language/ref/WarpingDistance.html
        ///</summary>
        corewolf::engine *WarpingDistance(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WarpingDistance[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes the watershed transform of image, returning the result as an array in which positive integers label the catchment basins.
        /// https://reference.wolfram.com/language/ref/WatershedComponents.html
        ///</summary>
        corewolf::engine *WatershedComponents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WatershedComponents[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses a binary image marker to indicate regions where basins may be created.
        /// https://reference.wolfram.com/language/ref/WatershedComponents.html
        ///</summary>
        corewolf::engine *WatershedComponents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WatershedComponents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether data is normally distributed using the Watson  test.
        /// https://reference.wolfram.com/language/ref/WatsonUSquareTest.html
        ///</summary>
        corewolf::engine *WatsonUSquareTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WatsonUSquareTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether data is distributed according to dist using the Watson  test.
        /// https://reference.wolfram.com/language/ref/WatsonUSquareTest.html
        ///</summary>
        corewolf::engine *WatsonUSquareTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WatsonUSquareTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/WatsonUSquareTest.html
        ///</summary>
        corewolf::engine *WatsonUSquareTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WatsonUSquareTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the Watts–Strogatz graph distribution for n-vertex graphs with rewiring probability p.
        /// https://reference.wolfram.com/language/ref/WattsStrogatzGraphDistribution.html
        ///</summary>
        corewolf::engine *WattsStrogatzGraphDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WattsStrogatzGraphDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the Watts–Strogatz graph distribution for n-vertex graphs with rewiring probability p starting from a 2k-regular graph.
        /// https://reference.wolfram.com/language/ref/WattsStrogatzGraphDistribution.html
        ///</summary>
        corewolf::engine *WattsStrogatzGraphDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WattsStrogatzGraphDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// computes a best basis representation in the DiscreteWaveletData const std::string &dwd.
        /// https://reference.wolfram.com/language/ref/WaveletBestBasis.html
        ///</summary>
        corewolf::engine *WaveletBestBasis(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WaveletBestBasis[" + arg0 + "]", name);
        }

        ///< summary>
        /// computes a best basis representation using the cost specification cspec.
        /// https://reference.wolfram.com/language/ref/WaveletBestBasis.html
        ///</summary>
        corewolf::engine *WaveletBestBasis(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WaveletBestBasis[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the filter coefficients for the symbolic wavelet wave of type filt.
        /// https://reference.wolfram.com/language/ref/WaveletFilterCoefficients.html
        ///</summary>
        corewolf::engine *WaveletFilterCoefficients(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WaveletFilterCoefficients[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// plots the basis tree of wavelet image coefficients in the DiscreteWaveletData dwd.
        /// https://reference.wolfram.com/language/ref/WaveletImagePlot.html
        ///</summary>
        corewolf::engine *WaveletImagePlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WaveletImagePlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots coefficients up to refinement level r.
        /// https://reference.wolfram.com/language/ref/WaveletImagePlot.html
        ///</summary>
        corewolf::engine *WaveletImagePlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WaveletImagePlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies the image function ifunc to coefficients and wavelet indexes before plotting.
        /// https://reference.wolfram.com/language/ref/WaveletImagePlot.html
        ///</summary>
        corewolf::engine *WaveletImagePlot(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WaveletImagePlot[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// plots wavelet transform coefficients in the DiscreteWaveletData dwd.
        /// https://reference.wolfram.com/language/ref/WaveletListPlot.html
        ///</summary>
        corewolf::engine *WaveletListPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WaveletListPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots wavelet transform coefficients corresponding to the wavelet index specification wind.
        /// https://reference.wolfram.com/language/ref/WaveletListPlot.html
        ///</summary>
        corewolf::engine *WaveletListPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WaveletListPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies func to coefficients before plotting.
        /// https://reference.wolfram.com/language/ref/WaveletListPlot.html
        ///</summary>
        corewolf::engine *WaveletListPlot(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WaveletListPlot[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// plots wavelet transform coefficients from several DiscreteWaveletData objects dwd1, dwd2, ….
        /// https://reference.wolfram.com/language/ref/WaveletListPlot.html
        ///</summary>
        corewolf::engine *WaveletListPlot(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WaveletListPlot[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies the function f to the arrays of coefficients and indices of a ContinuousWaveletData or DiscreteWaveletData object.
        /// https://reference.wolfram.com/language/ref/WaveletMapIndexed.html
        ///</summary>
        corewolf::engine *WaveletMapIndexed(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WaveletMapIndexed[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies f to the DiscreteWaveletData coefficients specified by wind.
        /// https://reference.wolfram.com/language/ref/WaveletMapIndexed.html
        ///</summary>
        corewolf::engine *WaveletMapIndexed(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WaveletMapIndexed[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// plots the basis tree of wavelet matrix coefficients in the DiscreteWaveletData dwd.
        /// https://reference.wolfram.com/language/ref/WaveletMatrixPlot.html
        ///</summary>
        corewolf::engine *WaveletMatrixPlot(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WaveletMatrixPlot[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots coefficients up to refinement level r.
        /// https://reference.wolfram.com/language/ref/WaveletMatrixPlot.html
        ///</summary>
        corewolf::engine *WaveletMatrixPlot(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WaveletMatrixPlot[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies func to coefficients before plotting.
        /// https://reference.wolfram.com/language/ref/WaveletMatrixPlot.html
        ///</summary>
        corewolf::engine *WaveletMatrixPlot(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WaveletMatrixPlot[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the scaling function  for the symbolic wavelet wave evaluated at x.
        /// https://reference.wolfram.com/language/ref/WaveletPhi.html
        ///</summary>
        corewolf::engine *WaveletPhi(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WaveletPhi[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the scaling function as a pure function.
        /// https://reference.wolfram.com/language/ref/WaveletPhi.html
        ///</summary>
        corewolf::engine *WaveletPhi(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WaveletPhi[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the wavelet function  for the symbolic wavelet wave evaluated at x.
        /// https://reference.wolfram.com/language/ref/WaveletPsi.html
        ///</summary>
        corewolf::engine *WaveletPsi(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WaveletPsi[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the wavelet function as a pure function.
        /// https://reference.wolfram.com/language/ref/WaveletPsi.html
        ///</summary>
        corewolf::engine *WaveletPsi(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WaveletPsi[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots wavelet vector coefficients in a DiscreteWaveletData or ContinuousWaveletData const std::string &wd.
        /// https://reference.wolfram.com/language/ref/WaveletScalogram.html
        ///</summary>
        corewolf::engine *WaveletScalogram(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WaveletScalogram[" + arg0 + "]", name);
        }

        ///< summary>
        /// plots wavelet coefficients corresponding to the wavelet index specification wind.
        /// https://reference.wolfram.com/language/ref/WaveletScalogram.html
        ///</summary>
        corewolf::engine *WaveletScalogram(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WaveletScalogram[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// applies func to coefficients before plotting.
        /// https://reference.wolfram.com/language/ref/WaveletScalogram.html
        ///</summary>
        corewolf::engine *WaveletScalogram(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WaveletScalogram[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// thresholds the detail wavelet coefficients in the DiscreteWaveletData const std::string &dwd.
        /// https://reference.wolfram.com/language/ref/WaveletThreshold.html
        ///</summary>
        corewolf::engine *WaveletThreshold(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WaveletThreshold[" + arg0 + "]", name);
        }

        ///< summary>
        /// thresholds the coefficients using the thresholding specification tspec.
        /// https://reference.wolfram.com/language/ref/WaveletThreshold.html
        ///</summary>
        corewolf::engine *WaveletThreshold(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WaveletThreshold[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// thresholds the wavelet coefficients given by the wavelet indices wind.
        /// https://reference.wolfram.com/language/ref/WaveletThreshold.html
        ///</summary>
        corewolf::engine *WaveletThreshold(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WaveletThreshold[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// yields a wave equation PDE term  with model variables vars and model parameters pars.
        /// https://reference.wolfram.com/language/ref/WavePDEComponent.html
        ///</summary>
        corewolf::engine *WavePDEComponent(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WavePDEComponent[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the weakly connected components of the graph g.
        /// https://reference.wolfram.com/language/ref/WeaklyConnectedComponents.html
        ///</summary>
        corewolf::engine *WeaklyConnectedComponents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WeaklyConnectedComponents[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the weakly connected components that include at least one of the vertices v1, v2, ….
        /// https://reference.wolfram.com/language/ref/WeaklyConnectedComponents.html
        ///</summary>
        corewolf::engine *WeaklyConnectedComponents(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("WeaklyConnectedComponents[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the connected components that include a vertex that matches the pattern patt.
        /// https://reference.wolfram.com/language/ref/WeaklyConnectedComponents.html
        ///</summary>
        corewolf::engine *WeaklyConnectedComponents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WeaklyConnectedComponents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/WeaklyConnectedComponents.html
        ///</summary>
        corewolf::engine *WeaklyConnectedComponents(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WeaklyConnectedComponents[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the weakly connected components of the graph g.
        /// https://reference.wolfram.com/language/ref/WeaklyConnectedGraphComponents.html
        ///</summary>
        corewolf::engine *WeaklyConnectedGraphComponents(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WeaklyConnectedGraphComponents[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the weakly connected components that include at least one of the vertices v1, v2, … .
        /// https://reference.wolfram.com/language/ref/WeaklyConnectedGraphComponents.html
        ///</summary>
        corewolf::engine *WeaklyConnectedGraphComponents(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("WeaklyConnectedGraphComponents[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the connected components that include a vertex that matches the pattern patt.
        /// https://reference.wolfram.com/language/ref/WeaklyConnectedGraphComponents.html
        ///</summary>
        corewolf::engine *WeaklyConnectedGraphComponents(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WeaklyConnectedGraphComponents[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/WeaklyConnectedGraphComponents.html
        ///</summary>
        corewolf::engine *WeaklyConnectedGraphComponents(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WeaklyConnectedGraphComponents[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is weakly connected, and False otherwise.
        /// https://reference.wolfram.com/language/ref/WeaklyConnectedGraphQ.html
        ///</summary>
        corewolf::engine *WeaklyConnectedGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WeaklyConnectedGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives conditions for the process proc to be weakly stationary.
        /// https://reference.wolfram.com/language/ref/WeakStationarity.html
        ///</summary>
        corewolf::engine *WeakStationarity(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WeakStationarity[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the most recent measurement for the specified weather property at the location corresponding to loc.
        /// https://reference.wolfram.com/language/ref/WeatherData.html
        ///</summary>
        corewolf::engine *WeatherData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WeatherData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives all measurements during the specified date.
        /// https://reference.wolfram.com/language/ref/WeatherData.html
        ///</summary>
        corewolf::engine *WeatherData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WeatherData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of dates and measurements for the time interval start to end.
        /// https://reference.wolfram.com/language/ref/WeatherData.html
        ///</summary>
        corewolf::engine *WeatherData(const std::string &arg0, const std::string &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("WeatherData[" + arg0 + ", " + arg1 + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// gives the most recent forecast for all weather forecast properties for the specified location.
        /// https://reference.wolfram.com/language/ref/WeatherForecastData.html
        ///</summary>
        corewolf::engine *WeatherForecastData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WeatherForecastData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the forecast for the property at the specified location.
        /// https://reference.wolfram.com/language/ref/WeatherForecastData.html
        ///</summary>
        corewolf::engine *WeatherForecastData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WeatherForecastData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the forecast at the time or times specified by datespec for the property at the location.
        /// https://reference.wolfram.com/language/ref/WeatherForecastData.html
        ///</summary>
        corewolf::engine *WeatherForecastData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WeatherForecastData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a dataset of the top web audio search results for the specified literal string.
        /// https://reference.wolfram.com/language/ref/WebAudioSearch.html
        ///</summary>
        corewolf::engine *WebAudioSearch(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WebAudioSearch[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the elements of the web audio search specified by format.
        /// https://reference.wolfram.com/language/ref/WebAudioSearch.html
        ///</summary>
        corewolf::engine *WebAudioSearch(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WebAudioSearch[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// returns only audio results that satisfy crit.
        /// https://reference.wolfram.com/language/ref/WebAudioSearch.html
        ///</summary>
        corewolf::engine *WebAudioSearch(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WebAudioSearch[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an HTML column containing the expri.
        /// https://reference.wolfram.com/language/ref/WebColumn.html
        ///</summary>
        corewolf::engine *WebColumn(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WebColumn[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// displays with expr formatted using the specified option settings.
        /// https://reference.wolfram.com/language/ref/WebColumn.html
        ///</summary>
        corewolf::engine *WebColumn(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WebColumn[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an element of an open webpage operated on by WebExecute.
        /// https://reference.wolfram.com/language/ref/WebElementObject.html
        ///</summary>
        corewolf::engine *WebElementObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WebElementObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Weber function .
        /// https://reference.wolfram.com/language/ref/WeberE.html
        ///</summary>
        corewolf::engine *WeberE(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WeberE[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the associated Weber function .
        /// https://reference.wolfram.com/language/ref/WeberE.html
        ///</summary>
        corewolf::engine *WeberE(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WeberE[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// executes the command cmd in a web browser.
        /// https://reference.wolfram.com/language/ref/WebExecute.html
        ///</summary>
        corewolf::engine *WebExecute(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WebExecute[" + arg0 + "]", name);
        }

        ///< summary>
        /// executes a list of commands in sequence.
        /// https://reference.wolfram.com/language/ref/WebExecute.html
        ///</summary>
        corewolf::engine *WebExecute(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WebExecute[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// executes cmds in the specified web session.
        /// https://reference.wolfram.com/language/ref/WebExecute.html
        ///</summary>
        corewolf::engine *WebExecute(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WebExecute[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an image of the webpage specified by url.
        /// https://reference.wolfram.com/language/ref/WebImage.html
        ///</summary>
        corewolf::engine *WebImage(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WebImage[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a list of thumbnails of the top web image search results for the specified literal string.
        /// https://reference.wolfram.com/language/ref/WebImageSearch.html
        ///</summary>
        corewolf::engine *WebImageSearch(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WebImageSearch[" + arg0 + "]", name);
        }

        ///< summary>
        /// picks out the first n top results obtained by doing the web image search specified by form.
        /// https://reference.wolfram.com/language/ref/WebImageSearch.html
        ///</summary>
        corewolf::engine *WebImageSearch(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WebImageSearch[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// picks out the first n elements of the web image search specified by elems.
        /// https://reference.wolfram.com/language/ref/WebImageSearch.html
        ///</summary>
        corewolf::engine *WebImageSearch(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WebImageSearch[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an HTML element containing expr.
        /// https://reference.wolfram.com/language/ref/WebItem.html
        ///</summary>
        corewolf::engine *WebItem(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WebItem[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents an HTML element formatted using the specified option settings.
        /// https://reference.wolfram.com/language/ref/WebItem.html
        ///</summary>
        corewolf::engine *WebItem(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WebItem[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents an HTML column containing the expri.
        /// https://reference.wolfram.com/language/ref/WebRow.html
        ///</summary>
        corewolf::engine *WebRow(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WebRow[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// displays with expr formatted using the specified option settings.
        /// https://reference.wolfram.com/language/ref/WebRow.html
        ///</summary>
        corewolf::engine *WebRow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WebRow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a dataset of the top web search results for the specified literal string.
        /// https://reference.wolfram.com/language/ref/WebSearch.html
        ///</summary>
        corewolf::engine *WebSearch(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WebSearch[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the elements of the web search specified by elems.
        /// https://reference.wolfram.com/language/ref/WebSearch.html
        ///</summary>
        corewolf::engine *WebSearch(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WebSearch[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a web browser session started by StartWebSession for use with WebExecute.
        /// https://reference.wolfram.com/language/ref/WebSessionObject.html
        ///</summary>
        corewolf::engine *WebSessionObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WebSessionObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the list of all active web sessions.
        /// https://reference.wolfram.com/language/ref/WebSessions.html
        ///</summary>
        corewolf::engine *WebSessions(const std::string &name = "")
        {
            return this->execute("WebSessions[]", name);
        }

        ///< summary>
        /// represents an open window or tab in a web browser.
        /// https://reference.wolfram.com/language/ref/WebWindowObject.html
        ///</summary>
        corewolf::engine *WebWindowObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WebWindowObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// displays as x⋀y⋀….
        /// https://reference.wolfram.com/language/ref/Wedge.html
        ///</summary>
        corewolf::engine *Wedge(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Wedge[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Weibull distribution with shape parameter α and scale parameter β.
        /// https://reference.wolfram.com/language/ref/WeibullDistribution.html
        ///</summary>
        corewolf::engine *WeibullDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WeibullDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Weibull distribution with shape parameter α, scale parameter β, and location parameter μ.
        /// https://reference.wolfram.com/language/ref/WeibullDistribution.html
        ///</summary>
        corewolf::engine *WeibullDistribution(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WeibullDistribution[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the value e1 of the Weierstrass elliptic function  at the half-period .
        /// https://reference.wolfram.com/language/ref/WeierstrassE1.html
        ///</summary>
        corewolf::engine *WeierstrassE1(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WeierstrassE1[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value e2 of the Weierstrass elliptic function  at the half-period .
        /// https://reference.wolfram.com/language/ref/WeierstrassE2.html
        ///</summary>
        corewolf::engine *WeierstrassE2(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WeierstrassE2[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value e3 of the Weierstrass elliptic function  at the half-period .
        /// https://reference.wolfram.com/language/ref/WeierstrassE3.html
        ///</summary>
        corewolf::engine *WeierstrassE3(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WeierstrassE3[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value η1 of the Weierstrass zeta function ζ at the half-period .
        /// https://reference.wolfram.com/language/ref/WeierstrassEta1.html
        ///</summary>
        corewolf::engine *WeierstrassEta1(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WeierstrassEta1[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value η2 of the Weierstrass zeta function ζ at the half-period .
        /// https://reference.wolfram.com/language/ref/WeierstrassEta2.html
        ///</summary>
        corewolf::engine *WeierstrassEta2(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WeierstrassEta2[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the value η3 of the Weierstrass zeta function ζ at the half-period .
        /// https://reference.wolfram.com/language/ref/WeierstrassEta3.html
        ///</summary>
        corewolf::engine *WeierstrassEta3(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WeierstrassEta3[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the half‐periods {ω1,ω3} for Weierstrass elliptic functions corresponding to the invariants {g2,g3}.
        /// https://reference.wolfram.com/language/ref/WeierstrassHalfPeriods.html
        ///</summary>
        corewolf::engine *WeierstrassHalfPeriods(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WeierstrassHalfPeriods[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the half-period ω1 for Weierstrass elliptic functions corresponding to the invariants {g2,g3}.
        /// https://reference.wolfram.com/language/ref/WeierstrassHalfPeriodW1.html
        ///</summary>
        corewolf::engine *WeierstrassHalfPeriodW1(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WeierstrassHalfPeriodW1[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the half-period ω2 for the Weierstrass elliptic functions corresponding to the invariants {g2,g3}.
        /// https://reference.wolfram.com/language/ref/WeierstrassHalfPeriodW2.html
        ///</summary>
        corewolf::engine *WeierstrassHalfPeriodW2(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WeierstrassHalfPeriodW2[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the half-period ω3 for the Weierstrass elliptic functions corresponding to the invariants {g2,g3}.
        /// https://reference.wolfram.com/language/ref/WeierstrassHalfPeriodW3.html
        ///</summary>
        corewolf::engine *WeierstrassHalfPeriodW3(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WeierstrassHalfPeriodW3[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the invariant  for the Weierstrass elliptic functions corresponding to the half‐periods {ω,ω′}.
        /// https://reference.wolfram.com/language/ref/WeierstrassInvariantG2.html
        ///</summary>
        corewolf::engine *WeierstrassInvariantG2(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WeierstrassInvariantG2[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the invariant  for the Weierstrass elliptic functions corresponding to the half‐periods {ω,ω′}.
        /// https://reference.wolfram.com/language/ref/WeierstrassInvariantG3.html
        ///</summary>
        corewolf::engine *WeierstrassInvariantG3(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WeierstrassInvariantG3[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the invariants {g2,g3} for Weierstrass elliptic functions corresponding to the half‐periods {ω1,ω3}.
        /// https://reference.wolfram.com/language/ref/WeierstrassInvariants.html
        ///</summary>
        corewolf::engine *WeierstrassInvariants(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WeierstrassInvariants[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Weierstrass elliptic function .
        /// https://reference.wolfram.com/language/ref/WeierstrassP.html
        ///</summary>
        corewolf::engine *WeierstrassP(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("WeierstrassP[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the derivative of the Weierstrass elliptic function .
        /// https://reference.wolfram.com/language/ref/WeierstrassPPrime.html
        ///</summary>
        corewolf::engine *WeierstrassPPrime(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("WeierstrassPPrime[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Weierstrass sigma function .
        /// https://reference.wolfram.com/language/ref/WeierstrassSigma.html
        ///</summary>
        corewolf::engine *WeierstrassSigma(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("WeierstrassSigma[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Weierstrass zeta function .
        /// https://reference.wolfram.com/language/ref/WeierstrassZeta.html
        ///</summary>
        corewolf::engine *WeierstrassZeta(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("WeierstrassZeta[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the graph with weighted adjacency matrix wmat.
        /// https://reference.wolfram.com/language/ref/WeightedAdjacencyGraph.html
        ///</summary>
        corewolf::engine *WeightedAdjacencyGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WeightedAdjacencyGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the graph with vertices vi and weighted adjacency matrix wmat.
        /// https://reference.wolfram.com/language/ref/WeightedAdjacencyGraph.html
        ///</summary>
        corewolf::engine *WeightedAdjacencyGraph(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WeightedAdjacencyGraph[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the adjacency matrix of edge weights of the graph g.
        /// https://reference.wolfram.com/language/ref/WeightedAdjacencyMatrix.html
        ///</summary>
        corewolf::engine *WeightedAdjacencyMatrix(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WeightedAdjacencyMatrix[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses rules vw to specify the graph g.
        /// https://reference.wolfram.com/language/ref/WeightedAdjacencyMatrix.html
        ///</summary>
        corewolf::engine *WeightedAdjacencyMatrix(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WeightedAdjacencyMatrix[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// represents observations xi with weights wi.
        /// https://reference.wolfram.com/language/ref/WeightedData.html
        ///</summary>
        corewolf::engine *WeightedData(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("WeightedData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// represents observations xi with weighting function fn.
        /// https://reference.wolfram.com/language/ref/WeightedData.html
        ///</summary>
        corewolf::engine *WeightedData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WeightedData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// yields True if the graph g is a weighted graph and False otherwise.
        /// https://reference.wolfram.com/language/ref/WeightedGraphQ.html
        ///</summary>
        corewolf::engine *WeightedGraphQ(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WeightedGraphQ[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Welch window function of x.
        /// https://reference.wolfram.com/language/ref/WelchWindow.html
        ///</summary>
        corewolf::engine *WelchWindow(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WelchWindow[" + arg0 + "]", name);
        }

        ///< summary>
        /// uses the parameter α.
        /// https://reference.wolfram.com/language/ref/WelchWindow.html
        ///</summary>
        corewolf::engine *WelchWindow(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WelchWindow[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the wheel graph with n vertices .
        /// https://reference.wolfram.com/language/ref/WheelGraph.html
        ///</summary>
        corewolf::engine *WheelGraph(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WheelGraph[" + arg0 + "]", name);
        }

        ///< summary>
        /// specifies an action that occurs when the event triggers it for equations in NDSolve and related functions.
        /// https://reference.wolfram.com/language/ref/WhenEvent.html
        ///</summary>
        corewolf::engine *WhenEvent(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WhenEvent[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates each of the testi in turn, returning the value of the valuei corresponding to the first one that yields True.
        /// https://reference.wolfram.com/language/ref/Which.html
        ///</summary>
        corewolf::engine *Which(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &arg4, const std::string &name = "")
        {
            return this->execute("Which[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + "]", name);
        }

        ///< summary>
        /// evaluates test, then body, repetitively, until test first fails to give True.
        /// https://reference.wolfram.com/language/ref/While.html
        ///</summary>
        corewolf::engine *While(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("While[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Gaussian white noise process with mean 0 and standard deviation 1.
        /// https://reference.wolfram.com/language/ref/WhiteNoiseProcess.html
        ///</summary>
        corewolf::engine *WhiteNoiseProcess(const std::string &name = "")
        {
            return this->execute("WhiteNoiseProcess[]", name);
        }

        ///< summary>
        /// represents a Gaussian white noise process with mean 0 and standard deviation σ.
        /// https://reference.wolfram.com/language/ref/WhiteNoiseProcess.html
        ///</summary>
        corewolf::engine *WhiteNoiseProcess(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WhiteNoiseProcess[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Whittaker function .
        /// https://reference.wolfram.com/language/ref/WhittakerM.html
        ///</summary>
        corewolf::engine *WhittakerM(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WhittakerM[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Whittaker function .
        /// https://reference.wolfram.com/language/ref/WhittakerW.html
        ///</summary>
        corewolf::engine *WhittakerW(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WhittakerW[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// removes noise from data by applying a range-r Wiener filter.
        /// https://reference.wolfram.com/language/ref/WienerFilter.html
        ///</summary>
        corewolf::engine *WienerFilter(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WienerFilter[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// assumes an additive noise power value ns.
        /// https://reference.wolfram.com/language/ref/WienerFilter.html
        ///</summary>
        corewolf::engine *WienerFilter(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WienerFilter[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// uses radius ri at level i in data.
        /// https://reference.wolfram.com/language/ref/WienerFilter.html
        ///</summary>
        corewolf::engine *WienerFilter(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WienerFilter[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a Wiener process with a drift μ and volatility σ.
        /// https://reference.wolfram.com/language/ref/WienerProcess.html
        ///</summary>
        corewolf::engine *WienerProcess(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WienerProcess[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a standard Wiener process with drift 0 and volatility 1.
        /// https://reference.wolfram.com/language/ref/WienerProcess.html
        ///</summary>
        corewolf::engine *WienerProcess(const std::string &name = "")
        {
            return this->execute("WienerProcess[]", name);
        }

        ///< summary>
        /// gives the Wigner D-function .
        /// https://reference.wolfram.com/language/ref/WignerD.html
        ///</summary>
        corewolf::engine *WignerD(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("WignerD[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the Wigner D-function .
        /// https://reference.wolfram.com/language/ref/WignerD.html
        ///</summary>
        corewolf::engine *WignerD(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WignerD[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Wigner D-function .
        /// https://reference.wolfram.com/language/ref/WignerD.html
        ///</summary>
        corewolf::engine *WignerD(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WignerD[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents a Wigner semicircle distribution with radius r centered at the origin.
        /// https://reference.wolfram.com/language/ref/WignerSemicircleDistribution.html
        ///</summary>
        corewolf::engine *WignerSemicircleDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WignerSemicircleDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Wigner semicircle distribution with radius r centered at a.
        /// https://reference.wolfram.com/language/ref/WignerSemicircleDistribution.html
        ///</summary>
        corewolf::engine *WignerSemicircleDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WignerSemicircleDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the values of the specified property for the given item.
        /// https://reference.wolfram.com/language/ref/WikidataData.html
        ///</summary>
        corewolf::engine *WikidataData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WikidataData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives values for each of the itemi.
        /// https://reference.wolfram.com/language/ref/WikidataData.html
        ///</summary>
        corewolf::engine *WikidataData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WikidataData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives values for each of the propertyi.
        /// https://reference.wolfram.com/language/ref/WikidataData.html
        ///</summary>
        corewolf::engine *WikidataData(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("WikidataData[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// returns a list of Wikidata items whose labels include the given keywords.
        /// https://reference.wolfram.com/language/ref/WikidataSearch.html
        ///</summary>
        corewolf::engine *WikidataSearch(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WikidataSearch[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the plain text of the specified Wikipedia article.
        /// https://reference.wolfram.com/language/ref/WikipediaData.html
        ///</summary>
        corewolf::engine *WikipediaData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WikipediaData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property, modified by optional parameters, for the given Wikipedia article.
        /// https://reference.wolfram.com/language/ref/WikipediaData.html
        ///</summary>
        corewolf::engine *WikipediaData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WikipediaData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns a list of Wikipedia articles whose titles include the given keywords.
        /// https://reference.wolfram.com/language/ref/WikipediaSearch.html
        ///</summary>
        corewolf::engine *WikipediaSearch(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WikipediaSearch[" + arg0 + "]", name);
        }

        ///< summary>
        /// returns a list of Wikipedia articles whose titles include the given keywords.
        /// https://reference.wolfram.com/language/ref/WikipediaSearch.html
        ///</summary>
        corewolf::engine *WikipediaSearch(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WikipediaSearch[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives Wilks's  for the matrices m1 and m2.
        /// https://reference.wolfram.com/language/ref/WilksW.html
        ///</summary>
        corewolf::engine *WilksW(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WilksW[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether the matrices m1 and m2 are independent.
        /// https://reference.wolfram.com/language/ref/WilksWTest.html
        ///</summary>
        corewolf::engine *WilksWTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WilksWTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the most recent measurement for wind direction near the current location.
        /// https://reference.wolfram.com/language/ref/WindDirectionData.html
        ///</summary>
        corewolf::engine *WindDirectionData(const std::string &name = "")
        {
            return this->execute("WindDirectionData[]", name);
        }

        ///< summary>
        /// gives the wind direction value for the specified time near the current location.
        /// https://reference.wolfram.com/language/ref/WindDirectionData.html
        ///</summary>
        corewolf::engine *WindDirectionData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WindDirectionData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value or values for the specified date and location.
        /// https://reference.wolfram.com/language/ref/WindDirectionData.html
        ///</summary>
        corewolf::engine *WindDirectionData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WindDirectionData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives values for all specified locations on the specified dates.
        /// https://reference.wolfram.com/language/ref/WindDirectionData.html
        ///</summary>
        corewolf::engine *WindDirectionData(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("WindDirectionData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the count of the number of times a closed curve winds around a point p.
        /// https://reference.wolfram.com/language/ref/WindingCount.html
        ///</summary>
        corewolf::engine *WindingCount(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WindingCount[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a polygon representing all points for which the closed contour p1,p2,…,pn,p1 winds around at least once.
        /// https://reference.wolfram.com/language/ref/WindingPolygon.html
        ///</summary>
        corewolf::engine *WindingPolygon(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WindingPolygon[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a polygon from the closed contours p11,p12,… and p21,p22,….
        /// https://reference.wolfram.com/language/ref/WindingPolygon.html
        ///</summary>
        corewolf::engine *WindingPolygon(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("WindingPolygon[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// uses the specified winding rule "wrule" to define the polygon.
        /// https://reference.wolfram.com/language/ref/WindingPolygon.html
        ///</summary>
        corewolf::engine *WindingPolygon(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WindingPolygon[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the most recent measurement for wind speed near the current location.
        /// https://reference.wolfram.com/language/ref/WindSpeedData.html
        ///</summary>
        corewolf::engine *WindSpeedData(const std::string &name = "")
        {
            return this->execute("WindSpeedData[]", name);
        }

        ///< summary>
        /// gives the wind speed value for the specified time near the current location.
        /// https://reference.wolfram.com/language/ref/WindSpeedData.html
        ///</summary>
        corewolf::engine *WindSpeedData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WindSpeedData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value or values for the specified date and location.
        /// https://reference.wolfram.com/language/ref/WindSpeedData.html
        ///</summary>
        corewolf::engine *WindSpeedData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WindSpeedData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives values for all specified locations on the specified dates.
        /// https://reference.wolfram.com/language/ref/WindSpeedData.html
        ///</summary>
        corewolf::engine *WindSpeedData(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("WindSpeedData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the most recent weather station measurement for wind vector near the current location.
        /// https://reference.wolfram.com/language/ref/WindVectorData.html
        ///</summary>
        corewolf::engine *WindVectorData(const std::string &name = "")
        {
            return this->execute("WindVectorData[]", name);
        }

        ///< summary>
        /// gives the wind vector value for the specified time near the current location.
        /// https://reference.wolfram.com/language/ref/WindVectorData.html
        ///</summary>
        corewolf::engine *WindVectorData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WindVectorData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the value or values for the specified date and location.
        /// https://reference.wolfram.com/language/ref/WindVectorData.html
        ///</summary>
        corewolf::engine *WindVectorData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WindVectorData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives values for all specified locations on the specified dates.
        /// https://reference.wolfram.com/language/ref/WindVectorData.html
        ///</summary>
        corewolf::engine *WindVectorData(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("WindVectorData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the mean of the elements in list after replacing the fraction f of the smallest and largest elements by the remaining extreme values.
        /// https://reference.wolfram.com/language/ref/WinsorizedMean.html
        ///</summary>
        corewolf::engine *WinsorizedMean(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WinsorizedMean[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the mean when the fraction f1 of the smallest elements and the fraction f2 of the largest elements are replaced by the remaining extreme values.
        /// https://reference.wolfram.com/language/ref/WinsorizedMean.html
        ///</summary>
        corewolf::engine *WinsorizedMean(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("WinsorizedMean[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the 5% winsorized mean WinsorizedMean[list,0.05].
        /// https://reference.wolfram.com/language/ref/WinsorizedMean.html
        ///</summary>
        corewolf::engine *WinsorizedMean(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WinsorizedMean[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the variance of the elements in list after replacing the fraction f of the smallest and largest elements by the remaining extreme values.
        /// https://reference.wolfram.com/language/ref/WinsorizedVariance.html
        ///</summary>
        corewolf::engine *WinsorizedVariance(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WinsorizedVariance[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the variance when the fraction f1 of the smallest elements and the fraction f2 of the largest elements are replaced by the remaining extreme values.
        /// https://reference.wolfram.com/language/ref/WinsorizedVariance.html
        ///</summary>
        corewolf::engine *WinsorizedVariance(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("WinsorizedVariance[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the 5% winsorized variance WinsorizedVariance[list,0.05].
        /// https://reference.wolfram.com/language/ref/WinsorizedVariance.html
        ///</summary>
        corewolf::engine *WinsorizedVariance(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WinsorizedVariance[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Wishart matrix distribution with ν degrees of freedom and covariance matrix Σ.
        /// https://reference.wolfram.com/language/ref/WishartMatrixDistribution.html
        ///</summary>
        corewolf::engine *WishartMatrixDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WishartMatrixDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// specifies that all occurrences of the symbols x, y, … in expr should be replaced by x0, y0, ….
        /// https://reference.wolfram.com/language/ref/With.html
        ///</summary>
        corewolf::engine *With(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("With[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates expr, running cleanup before returning the result, even if an abort, throw, etc. was generated during the evaluation of expr.
        /// https://reference.wolfram.com/language/ref/WithCleanup.html
        ///</summary>
        corewolf::engine *WithCleanup(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WithCleanup[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// evaluates init before evaluating expr, blocking aborts, throws, etc. in both init and cleanup.
        /// https://reference.wolfram.com/language/ref/WithCleanup.html
        ///</summary>
        corewolf::engine *WithCleanup(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WithCleanup[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// locks the file path, evaluates expr, then releases the file.
        /// https://reference.wolfram.com/language/ref/WithLock.html
        ///</summary>
        corewolf::engine *WithLock(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WithLock[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// sends query to Wolfram|Alpha and imports the output.
        /// https://reference.wolfram.com/language/ref/WolframAlpha.html
        ///</summary>
        corewolf::engine *WolframAlpha(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WolframAlpha[" + arg0 + "]", name);
        }

        ///< summary>
        /// imports the output according to the specified format.
        /// https://reference.wolfram.com/language/ref/WolframAlpha.html
        ///</summary>
        corewolf::engine *WolframAlpha(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WolframAlpha[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the Wolfram Language symbol entity.
        /// https://reference.wolfram.com/language/ref/WolframLanguageData.html
        ///</summary>
        corewolf::engine *WolframLanguageData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WolframLanguageData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified Wolfram Language symbol entities.
        /// https://reference.wolfram.com/language/ref/WolframLanguageData.html
        ///</summary>
        corewolf::engine *WolframLanguageData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WolframLanguageData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/WolframLanguageData.html
        ///</summary>
        corewolf::engine *WolframLanguageData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WolframLanguageData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// generates a word cloud graphic in which the si are sized according to their multiplicity in the list.
        /// https://reference.wolfram.com/language/ref/WordCloud.html
        ///</summary>
        corewolf::engine *WordCloud(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WordCloud[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// also generates a word cloud in which the si are sized according to the weights wi.
        /// https://reference.wolfram.com/language/ref/WordCloud.html
        ///</summary>
        corewolf::engine *WordCloud(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WordCloud[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// also generates a word cloud in which the si are sized according to the weights wi.
        /// https://reference.wolfram.com/language/ref/WordCloud.html
        ///</summary>
        corewolf::engine *WordCloud(const std::vector<std::string> &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("WordCloud[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the total number of words in string.
        /// https://reference.wolfram.com/language/ref/WordCount.html
        ///</summary>
        corewolf::engine *WordCount(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WordCount[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an association whose keys are the distinct words identified in string, and whose values give the number of times those words appear in string.
        /// https://reference.wolfram.com/language/ref/WordCounts.html
        ///</summary>
        corewolf::engine *WordCounts(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WordCounts[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives counts of the distinct n-grams consisting of runs of n words in string.
        /// https://reference.wolfram.com/language/ref/WordCounts.html
        ///</summary>
        corewolf::engine *WordCounts(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WordCounts[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified property for the English word "word".
        /// https://reference.wolfram.com/language/ref/WordData.html
        ///</summary>
        corewolf::engine *WordData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WordData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of full word specifications representing possible uses and senses of "word".
        /// https://reference.wolfram.com/language/ref/WordData.html
        ///</summary>
        corewolf::engine *WordData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WordData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the dictionary definitions available for "word".
        /// https://reference.wolfram.com/language/ref/WordDefinition.html
        ///</summary>
        corewolf::engine *WordDefinition(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WordDefinition[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the frequency of word in text.
        /// https://reference.wolfram.com/language/ref/WordFrequency.html
        ///</summary>
        corewolf::engine *WordFrequency(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WordFrequency[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives an association of the frequencies of each of the wordi.
        /// https://reference.wolfram.com/language/ref/WordFrequency.html
        ///</summary>
        corewolf::engine *WordFrequency(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &name = "")
        {
            return this->execute("WordFrequency[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + "]", name);
        }

        ///< summary>
        /// gives the frequency of word in typical published English text.
        /// https://reference.wolfram.com/language/ref/WordFrequencyData.html
        ///</summary>
        corewolf::engine *WordFrequencyData(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WordFrequencyData[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives an association of frequencies of the wordi.
        /// https://reference.wolfram.com/language/ref/WordFrequencyData.html
        ///</summary>
        corewolf::engine *WordFrequencyData(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("WordFrequencyData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives a time series for the frequency of word in typical published English text.
        /// https://reference.wolfram.com/language/ref/WordFrequencyData.html
        ///</summary>
        corewolf::engine *WordFrequencyData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WordFrequencyData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a time series for dates specified by datespec.
        /// https://reference.wolfram.com/language/ref/WordFrequencyData.html
        ///</summary>
        corewolf::engine *WordFrequencyData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("WordFrequencyData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives a list of common words.
        /// https://reference.wolfram.com/language/ref/WordList.html
        ///</summary>
        corewolf::engine *WordList(const std::string &name = "")
        {
            return this->execute("WordList[]", name);
        }

        ///< summary>
        /// gives a list of words of the specified type.
        /// https://reference.wolfram.com/language/ref/WordList.html
        ///</summary>
        corewolf::engine *WordList(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WordList[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives a stemmed form of word, removing plurals, inflections, etc.
        /// https://reference.wolfram.com/language/ref/WordStem.html
        ///</summary>
        corewolf::engine *WordStem(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("WordStem[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives translations for word into the language lang.
        /// https://reference.wolfram.com/language/ref/WordTranslation.html
        ///</summary>
        corewolf::engine *WordTranslation(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WordTranslation[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// writes the expressions expri in sequence, followed by a newline, to the specified output channel.
        /// https://reference.wolfram.com/language/ref/Write.html
        ///</summary>
        corewolf::engine *Write(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("Write[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// writes "string" to a file, followed by a newline.
        /// https://reference.wolfram.com/language/ref/WriteLine.html
        ///</summary>
        corewolf::engine *WriteLine(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WriteLine[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// writes "string" to a file.
        /// https://reference.wolfram.com/language/ref/WriteString.html
        ///</summary>
        corewolf::engine *WriteString(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("WriteString[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// converts the expri to strings, and then writes them in sequence to the specified output channel.
        /// https://reference.wolfram.com/language/ref/WriteString.html
        ///</summary>
        corewolf::engine *WriteString(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("WriteString[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the Wronskian determinant for the functions y1,y2,… depending on x.
        /// https://reference.wolfram.com/language/ref/Wronskian.html
        ///</summary>
        corewolf::engine *Wronskian(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Wronskian[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the Wronskian determinant for the basis of the solutions of the linear differential equation eqn with dependent variable y and independent variable x.
        /// https://reference.wolfram.com/language/ref/Wronskian.html
        ///</summary>
        corewolf::engine *Wronskian(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Wronskian[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the Wronskian determinant for the system of linear differential equations eqns.
        /// https://reference.wolfram.com/language/ref/Wronskian.html
        ///</summary>
        corewolf::engine *Wronskian(const std::string &arg0, const std::vector<std::string> &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Wronskian[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents an element in symbolic XML.
        /// https://reference.wolfram.com/language/ref/XMLElement.html
        ///</summary>
        corewolf::engine *XMLElement(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("XMLElement[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }

        ///< summary>
        /// represents the head of an XML const std::string &in symbolic XML.
        /// https://reference.wolfram.com/language/ref/XMLObject.html
        ///</summary>
        corewolf::engine *XMLObject(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("XMLObject[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields a TemplateObject that represents an XML template to be applied using functions like TemplateApply.
        /// https://reference.wolfram.com/language/ref/XMLTemplate.html
        ///</summary>
        corewolf::engine *XMLTemplate(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("XMLTemplate[" + arg0 + "]", name);
        }

        ///< summary>
        /// yields a TemplateObject with arguments, suitable for cloud deployment or other evaluation.
        /// https://reference.wolfram.com/language/ref/XMLTemplate.html
        ///</summary>
        corewolf::engine *XMLTemplate(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("XMLTemplate[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// is the logical XNOR (not XOR) function. It gives True if an even number of the  are True, and the rest are False. It gives False if an odd number of the  are True, and the rest are False.
        /// https://reference.wolfram.com/language/ref/Xnor.html
        ///</summary>
        corewolf::engine *Xnor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Xnor[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// is the logical XOR (exclusive OR) function. It gives True if an odd number of the  are True, and the rest are False. It gives False if an even number of the  are True, and the rest are False.
        /// https://reference.wolfram.com/language/ref/Xor.html
        ///</summary>
        corewolf::engine *Xor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("Xor[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a color in the XYZ color space with tristimulus values x, y and z.
        /// https://reference.wolfram.com/language/ref/XYZColor.html
        ///</summary>
        corewolf::engine *XYZColor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("XYZColor[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// specifies opacity a.
        /// https://reference.wolfram.com/language/ref/XYZColor.html
        ///</summary>
        corewolf::engine *XYZColor(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("XYZColor[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// returns a color from an HTML color name etc.
        /// https://reference.wolfram.com/language/ref/XYZColor.html
        ///</summary>
        corewolf::engine *XYZColor(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("XYZColor[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the Yule dissimilarity between Boolean vectors u and v.
        /// https://reference.wolfram.com/language/ref/YuleDissimilarity.html
        ///</summary>
        corewolf::engine *YuleDissimilarity(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("YuleDissimilarity[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the radial Zernike polynomial .
        /// https://reference.wolfram.com/language/ref/ZernikeR.html
        ///</summary>
        corewolf::engine *ZernikeR(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ZernikeR[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents the symmetry of a zero tensor in the slots si.
        /// https://reference.wolfram.com/language/ref/ZeroSymmetric.html
        ///</summary>
        corewolf::engine *ZeroSymmetric(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ZeroSymmetric[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// gives the Riemann zeta function .
        /// https://reference.wolfram.com/language/ref/Zeta.html
        ///</summary>
        corewolf::engine *Zeta(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("Zeta[" + arg0 + "]", name);
        }

        ///< summary>
        /// gives the generalized Riemann zeta function .
        /// https://reference.wolfram.com/language/ref/Zeta.html
        ///</summary>
        corewolf::engine *Zeta(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("Zeta[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// represents the k zero of the Riemann zeta function on the critical line.
        /// https://reference.wolfram.com/language/ref/ZetaZero.html
        ///</summary>
        corewolf::engine *ZetaZero(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ZetaZero[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents the k zero with imaginary part greater than .
        /// https://reference.wolfram.com/language/ref/ZetaZero.html
        ///</summary>
        corewolf::engine *ZetaZero(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ZetaZero[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the value of the specified property for the ZIP code entity.
        /// https://reference.wolfram.com/language/ref/ZIPCodeData.html
        ///</summary>
        corewolf::engine *ZIPCodeData(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ZIPCodeData[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives a list of property values for the specified ZIP code entities.
        /// https://reference.wolfram.com/language/ref/ZIPCodeData.html
        ///</summary>
        corewolf::engine *ZIPCodeData(const std::vector<std::string> &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ZIPCodeData[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// gives the specified annotation associated with the given property.
        /// https://reference.wolfram.com/language/ref/ZIPCodeData.html
        ///</summary>
        corewolf::engine *ZIPCodeData(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ZIPCodeData[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// represents a zeta distribution with parameter ρ.
        /// https://reference.wolfram.com/language/ref/ZipfDistribution.html
        ///</summary>
        corewolf::engine *ZipfDistribution(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ZipfDistribution[" + arg0 + "]", name);
        }

        ///< summary>
        /// represents a Zipf distribution with range n.
        /// https://reference.wolfram.com/language/ref/ZipfDistribution.html
        ///</summary>
        corewolf::engine *ZipfDistribution(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ZipfDistribution[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests whether the mean of the data is zero.
        /// https://reference.wolfram.com/language/ref/ZTest.html
        ///</summary>
        corewolf::engine *ZTest(const std::string &arg0, const std::string &name = "")
        {
            return this->execute("ZTest[" + arg0 + "]", name);
        }

        ///< summary>
        /// tests whether the means of data1 and data2 are equal.
        /// https://reference.wolfram.com/language/ref/ZTest.html
        ///</summary>
        corewolf::engine *ZTest(const std::vector<std::string> &arg0, const std::string &name = "")
        {
            return this->execute("ZTest[" + std::to_string('{') + engine::_print_vector(arg0) + "}" + "]", name);
        }

        ///< summary>
        /// tests for zero or equal means assuming a population variance σ2.
        /// https://reference.wolfram.com/language/ref/ZTest.html
        ///</summary>
        corewolf::engine *ZTest(const std::string &arg0, const std::string &arg1, const std::string &name = "")
        {
            return this->execute("ZTest[" + arg0 + ", " + arg1 + "]", name);
        }

        ///< summary>
        /// tests the mean against μ0.
        /// https://reference.wolfram.com/language/ref/ZTest.html
        ///</summary>
        corewolf::engine *ZTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ZTest[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// returns the value of "property".
        /// https://reference.wolfram.com/language/ref/ZTest.html
        ///</summary>
        corewolf::engine *ZTest(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &arg3, const std::string &name = "")
        {
            return this->execute("ZTest[" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + "]", name);
        }

        ///< summary>
        /// gives the Z transform of expr.
        /// https://reference.wolfram.com/language/ref/ZTransform.html
        ///</summary>
        corewolf::engine *ZTransform(const std::string &arg0, const std::string &arg1, const std::string &arg2, const std::string &name = "")
        {
            return this->execute("ZTransform[" + arg0 + ", " + arg1 + ", " + arg2 + "]", name);
        }

        ///< summary>
        /// gives the multidimensional Z transform of expr.
        /// https://reference.wolfram.com/language/ref/ZTransform.html
        ///</summary>
        corewolf::engine *ZTransform(const std::string &arg0, const std::vector<std::string> &arg1, const std::vector<std::string> &arg2, const std::string &name = "")
        {
            return this->execute("ZTransform[" + arg0 + ", " + std::to_string('{') + engine::_print_vector(arg1) + "}" + ", " + std::to_string('{') + engine::_print_vector(arg2) + "}" + "]", name);
        }
    };

    engine *engine::_instance = nullptr;

    std::ostream &operator<<(std::ostream &os, const corewolf::engine en)
    {
        os << en._text;
        return os;
    }

    std::ostream &operator<<(std::ostream &os, const corewolf::engine *en)
    {
        os << en->_text;
        return os;
    }
}